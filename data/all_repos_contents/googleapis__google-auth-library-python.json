{"noxfile.py": "# Copyright 2019 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport os\nimport pathlib\nimport shutil\n\nimport nox\n\nCURRENT_DIRECTORY = pathlib.Path(__file__).parent.absolute()\n\n# https://github.com/psf/black/issues/2964, pin click version to 8.0.4 to\n# avoid incompatiblity with black.\nCLICK_VERSION = \"click==8.0.4\"\nBLACK_VERSION = \"black==19.3b0\"\nBLACK_PATHS = [\n    \"google\",\n    \"tests\",\n    \"tests_async\",\n    \"noxfile.py\",\n    \"setup.py\",\n    \"docs/conf.py\",\n]\n\n\n@nox.session(python=\"3.8\")\ndef lint(session):\n    session.install(\n        \"flake8\", \"flake8-import-order\", \"docutils\", CLICK_VERSION, BLACK_VERSION\n    )\n    session.install(\"-e\", \".\")\n    session.run(\"black\", \"--check\", *BLACK_PATHS)\n    session.run(\n        \"flake8\",\n        \"--import-order-style=google\",\n        \"--application-import-names=google,tests,system_tests\",\n        \"google\",\n        \"tests\",\n        \"tests_async\",\n    )\n    session.run(\n        \"python\", \"setup.py\", \"check\", \"--metadata\", \"--restructuredtext\", \"--strict\"\n    )\n\n\n@nox.session(python=\"3.8\")\ndef blacken(session):\n    \"\"\"Run black.\n    Format code to uniform standard.\n    The Python version should be consistent with what is\n    supplied in the Python Owlbot postprocessor.\n\n    https://github.com/googleapis/synthtool/blob/master/docker/owlbot/python/Dockerfile\n    \"\"\"\n    session.install(CLICK_VERSION, BLACK_VERSION)\n    session.run(\"black\", *BLACK_PATHS)\n\n\n@nox.session(python=\"3.8\")\ndef mypy(session):\n    \"\"\"Verify type hints are mypy compatible.\"\"\"\n    session.install(\"-e\", \".\")\n    session.install(\n        \"mypy\",\n        \"types-cachetools\",\n        \"types-certifi\",\n        \"types-freezegun\",\n        \"types-pyOpenSSL\",\n        \"types-requests\",\n        \"types-setuptools\",\n        \"types-mock\",\n    )\n    session.run(\"mypy\", \"-p\", \"google\", \"-p\", \"tests\", \"-p\", \"tests_async\")\n\n\n@nox.session(python=[\"3.7\", \"3.8\", \"3.9\", \"3.10\", \"3.11\", \"3.12\"])\ndef unit(session):\n    constraints_path = str(\n        CURRENT_DIRECTORY / \"testing\" / f\"constraints-{session.python}.txt\"\n    )\n    session.install(\"-r\", \"testing/requirements.txt\", \"-c\", constraints_path)\n    session.install(\"-e\", \".\", \"-c\", constraints_path)\n    session.run(\n        \"pytest\",\n        f\"--junitxml=unit_{session.python}_sponge_log.xml\",\n        \"--cov=google.auth\",\n        \"--cov=google.oauth2\",\n        \"--cov=tests\",\n        \"--cov-report=term-missing\",\n        \"tests\",\n        \"tests_async\",\n    )\n\n\n@nox.session(python=\"3.8\")\ndef cover(session):\n    session.install(\"-r\", \"testing/requirements.txt\")\n    session.install(\"-e\", \".\")\n    session.run(\n        \"pytest\",\n        \"--cov=google.auth\",\n        \"--cov=google.oauth2\",\n        \"--cov=tests\",\n        \"--cov=tests_async\",\n        \"--cov-report=term-missing\",\n        \"tests\",\n        \"tests_async\",\n    )\n    session.run(\"coverage\", \"report\", \"--show-missing\", \"--fail-under=100\")\n\n\n@nox.session(python=\"3.9\")\ndef docs(session):\n    \"\"\"Build the docs for this library.\"\"\"\n\n    session.install(\"-e\", \".[aiohttp]\")\n    session.install(\"sphinx\", \"alabaster\", \"recommonmark\", \"sphinx-docstring-typing\")\n\n    shutil.rmtree(os.path.join(\"docs\", \"_build\"), ignore_errors=True)\n    session.run(\n        \"sphinx-build\",\n        \"-T\",  # show full traceback on exception\n        \"-W\",  # warnings as errors\n        \"-N\",  # no colors\n        \"-b\",\n        \"html\",\n        \"-d\",\n        os.path.join(\"docs\", \"_build\", \"doctrees\", \"\"),\n        os.path.join(\"docs\", \"\"),\n        os.path.join(\"docs\", \"_build\", \"html\", \"\"),\n    )\n\n\n@nox.session(python=\"pypy\")\ndef pypy(session):\n    session.install(\"-r\", \"testing/requirements.txt\")\n    session.install(\"-e\", \".\")\n    session.run(\n        \"pytest\",\n        f\"--junitxml=unit_{session.python}_sponge_log.xml\",\n        \"--cov=google.auth\",\n        \"--cov=google.oauth2\",\n        \"--cov=tests\",\n        \"tests\",\n        \"tests_async\",\n    )\n", "setup.py": "# Copyright 2014 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport io\nimport os\n\nfrom setuptools import find_namespace_packages\nfrom setuptools import setup\n\n\nDEPENDENCIES = (\n    \"cachetools>=2.0.0,<6.0\",\n    \"pyasn1-modules>=0.2.1\",\n    # rsa==4.5 is the last version to support 2.7\n    # https://github.com/sybrenstuvel/python-rsa/issues/152#issuecomment-643470233\n    \"rsa>=3.1.4,<5\",\n)\n\nextras = {\n    \"aiohttp\": [\"aiohttp >= 3.6.2, < 4.0.0.dev0\", \"requests >= 2.20.0, < 3.0.0.dev0\"],\n    \"pyopenssl\": [\"pyopenssl>=20.0.0\", \"cryptography>=38.0.3\"],\n    \"requests\": \"requests >= 2.20.0, < 3.0.0.dev0\",\n    \"reauth\": \"pyu2f>=0.1.5\",\n    # Enterprise cert only works for OpenSSL 1.1.1. Newer versions of these\n    # dependencies are built with OpenSSL 3.0 so we need to fix the version.\n    \"enterprise_cert\": [\"cryptography==36.0.2\", \"pyopenssl==22.0.0\"],\n}\n\nwith io.open(\"README.rst\", \"r\") as fh:\n    long_description = fh.read()\n\npackage_root = os.path.abspath(os.path.dirname(__file__))\n\nversion = {}\nwith open(os.path.join(package_root, \"google/auth/version.py\")) as fp:\n    exec(fp.read(), version)\nversion = version[\"__version__\"]\n\nsetup(\n    name=\"google-auth\",\n    version=version,\n    author=\"Google Cloud Platform\",\n    author_email=\"googleapis-packages@google.com\",\n    description=\"Google Authentication Library\",\n    long_description=long_description,\n    url=\"https://github.com/googleapis/google-auth-library-python\",\n    packages=find_namespace_packages(\n        exclude=(\"tests*\", \"system_tests*\", \"docs*\", \"samples*\")\n    ),\n    install_requires=DEPENDENCIES,\n    extras_require=extras,\n    python_requires=\">=3.7\",\n    license=\"Apache 2.0\",\n    keywords=\"google auth oauth client\",\n    classifiers=[\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n        \"Programming Language :: Python :: 3.12\",\n        \"Development Status :: 5 - Production/Stable\",\n        \"Intended Audience :: Developers\",\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Operating System :: POSIX\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Operating System :: MacOS :: MacOS X\",\n        \"Operating System :: OS Independent\",\n        \"Topic :: Internet :: WWW/HTTP\",\n    ],\n)\n", "owlbot.py": "import synthtool as s\nfrom synthtool import gcp\n\ncommon = gcp.CommonTemplates()\n\n# ----------------------------------------------------------------------------\n# Add templated files\n# ----------------------------------------------------------------------------\ntemplated_files = common.py_library(unit_cov_level=100, cov_level=100)\n\n\ns.move(\n    templated_files / \".kokoro\",\n    excludes=[\n        \"continuous/common.cfg\",\n        \"presubmit/common.cfg\",\n        \"build.sh\",\n        \"samples/*\",\n    ],\n)  # just move kokoro configs\ns.move(\n    # needed by samples kokoro jobs\n    templated_files / \".trampolinerc\"\n)\ns.move(\n    templated_files / \"renovate.json\",\n)\n\n\nassert 1 == s.replace(\n    \".kokoro/docs/docs-presubmit.cfg\",\n    'value: \"docs docfx\"',\n    'value: \"docs\"',\n)\n\ns.shell.run([\"nox\", \"-s\", \"blacken\"], hide_output=False)\n", "samples/cloud-client/snippets/authenticate_implicit_with_adc.py": "# Copyright 2022 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# [START auth_cloud_implicit_adc]\n\nfrom google.cloud import storage\n\n\ndef authenticate_implicit_with_adc(project_id=\"your-google-cloud-project-id\"):\n    \"\"\"\n    When interacting with Google Cloud Client libraries, the library can auto-detect the\n    credentials to use.\n\n    // TODO(Developer):\n    //  1. Before running this sample,\n    //  set up ADC as described in https://cloud.google.com/docs/authentication/external/set-up-adc\n    //  2. Replace the project variable.\n    //  3. Make sure that the user account or service account that you are using\n    //  has the required permissions. For this sample, you must have \"storage.buckets.list\".\n    Args:\n        project_id: The project id of your Google Cloud project.\n    \"\"\"\n\n    # This snippet demonstrates how to list buckets.\n    # *NOTE*: Replace the client created below with the client required for your application.\n    # Note that the credentials are not specified when constructing the client.\n    # Hence, the client library will look for credentials using ADC.\n    storage_client = storage.Client(project=project_id)\n    buckets = storage_client.list_buckets()\n    print(\"Buckets:\")\n    for bucket in buckets:\n        print(bucket.name)\n    print(\"Listed all storage buckets.\")\n\n# [END auth_cloud_implicit_adc]\n", "samples/cloud-client/snippets/idtoken_from_impersonated_credentials.py": "# Copyright 2022 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# [auth_cloud_idtoken_impersonated_credentials]\n\nimport google\nfrom google.auth import impersonated_credentials\nimport google.auth.transport.requests\n\n\ndef idtoken_from_impersonated_credentials(\n        impersonated_service_account: str, scope: str, target_audience: str):\n    \"\"\"\n      Use a service account (SA1) to impersonate as another service account (SA2) and obtain id token\n      for the impersonated account.\n      To obtain token for SA2, SA1 should have the \"roles/iam.serviceAccountTokenCreator\" permission\n      on SA2.\n\n    Args:\n        impersonated_service_account: The name of the privilege-bearing service account for whom the credential is created.\n            Examples: name@project.service.gserviceaccount.com\n\n        scope: Provide the scopes that you might need to request to access Google APIs,\n            depending on the level of access you need.\n            For this example, we use the cloud-wide scope and use IAM to narrow the permissions.\n            https://cloud.google.com/docs/authentication#authorization_for_services\n            For more information, see: https://developers.google.com/identity/protocols/oauth2/scopes\n\n        target_audience: The service name for which the id token is requested. Service name refers to the\n            logical identifier of an API service, such as \"iap.googleapis.com\".\n            Examples: iap.googleapis.com\n    \"\"\"\n\n    # Construct the GoogleCredentials object which obtains the default configuration from your\n    # working environment.\n    credentials, project_id = google.auth.default()\n\n    # Create the impersonated credential.\n    target_credentials = impersonated_credentials.Credentials(\n        source_credentials=credentials,\n        target_principal=impersonated_service_account,\n        # delegates: The chained list of delegates required to grant the final accessToken.\n        # For more information, see:\n        # https://cloud.google.com/iam/docs/create-short-lived-credentials-direct#sa-credentials-permissions\n        # Delegate is NOT USED here.\n        delegates=[],\n        target_scopes=[scope],\n        lifetime=300)\n\n    # Set the impersonated credential, target audience and token options.\n    id_creds = impersonated_credentials.IDTokenCredentials(\n        target_credentials,\n        target_audience=target_audience,\n        include_email=True)\n\n    # Get the ID token.\n    # Once you've obtained the ID token, use it to make an authenticated call\n    # to the target audience.\n    request = google.auth.transport.requests.Request()\n    id_creds.refresh(request)\n    # token = id_creds.token\n    print(\"Generated ID token.\")\n\n# [auth_cloud_idtoken_impersonated_credentials]\n", "samples/cloud-client/snippets/idtoken_from_metadata_server.py": "# Copyright 2022 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# [START auth_cloud_idtoken_metadata_server]\n\nimport google\nimport google.oauth2.credentials\nfrom google.auth import compute_engine\nimport google.auth.transport.requests\n\n\ndef idtoken_from_metadata_server(url: str):\n    \"\"\"\n    Use the Google Cloud metadata server in the Cloud Run (or AppEngine or Kubernetes etc.,)\n    environment to create an identity token and add it to the HTTP request as part of an\n    Authorization header.\n\n    Args:\n        url: The url or target audience to obtain the ID token for.\n            Examples: http://www.example.com\n    \"\"\"\n\n    request = google.auth.transport.requests.Request()\n    # Set the target audience.\n    # Setting \"use_metadata_identity_endpoint\" to \"True\" will make the request use the default application\n    # credentials. Optionally, you can also specify a specific service account to use by mentioning\n    # the service_account_email.\n    credentials = compute_engine.IDTokenCredentials(\n        request=request, target_audience=url, use_metadata_identity_endpoint=True\n    )\n\n    # Get the ID token.\n    # Once you've obtained the ID token, use it to make an authenticated call\n    # to the target audience.\n    credentials.refresh(request)\n    # print(credentials.token)\n    print(\"Generated ID token.\")\n\n# [END auth_cloud_idtoken_metadata_server]\n", "samples/cloud-client/snippets/snippets_test.py": "# Copyright 2022 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport re\n\nfrom _pytest.capture import CaptureFixture\n\nimport authenticate_explicit_with_adc\nimport authenticate_implicit_with_adc\nimport idtoken_from_metadata_server\nimport idtoken_from_service_account\n# from system_tests.noxfile import SERVICE_ACCOUNT_FILE\nimport verify_google_idtoken\n\nimport google\nfrom google.oauth2 import service_account\nimport google.auth.transport.requests\nimport os\n\nCREDENTIALS, PROJECT = google.auth.default()\nSERVICE_ACCOUNT_FILE = os.getenv(\"GOOGLE_APPLICATION_CREDENTIALS\")\n\n\ndef test_authenticate_explicit_with_adc(capsys: CaptureFixture):\n    authenticate_explicit_with_adc.authenticate_explicit_with_adc()\n    out, err = capsys.readouterr()\n    assert re.search(\"Listed all storage buckets.\", out)\n\n\ndef test_authenticate_implicit_with_adc(capsys: CaptureFixture):\n    authenticate_implicit_with_adc.authenticate_implicit_with_adc(PROJECT)\n    out, err = capsys.readouterr()\n    assert re.search(\"Listed all storage buckets.\", out)\n\n\ndef test_idtoken_from_metadata_server(capsys: CaptureFixture):\n    idtoken_from_metadata_server.idtoken_from_metadata_server(\"https://www.google.com\")\n    out, err = capsys.readouterr()\n    assert re.search(\"Generated ID token.\", out)\n\n\ndef test_idtoken_from_service_account(capsys: CaptureFixture):\n    idtoken_from_service_account.get_idToken_from_serviceaccount(\n        SERVICE_ACCOUNT_FILE,\n        \"iap.googleapis.com\")\n    out, err = capsys.readouterr()\n    assert re.search(\"Generated ID token.\", out)\n\n\ndef test_verify_google_idtoken():\n    idtoken = get_idtoken_from_service_account(SERVICE_ACCOUNT_FILE, \"iap.googleapis.com\")\n\n    verify_google_idtoken.verify_google_idtoken(\n        idtoken,\n        \"iap.googleapis.com\",\n        \"https://www.googleapis.com/oauth2/v3/certs\"\n    )\n\n\ndef get_idtoken_from_service_account(json_credential_path: str, target_audience: str):\n    credentials = service_account.IDTokenCredentials.from_service_account_file(\n        filename=json_credential_path,\n        target_audience=target_audience)\n\n    request = google.auth.transport.requests.Request()\n    credentials.refresh(request)\n    return credentials.token\n", "samples/cloud-client/snippets/noxfile.py": "# Copyright 2019 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport pathlib\n\nimport nox\n\nCURRENT_DIRECTORY = pathlib.Path(__file__).parent.absolute()\n\n# https://github.com/psf/black/issues/2964, pin click version to 8.0.4 to\n# avoid incompatiblity with black.\nCLICK_VERSION = \"click==8.0.4\"\nBLACK_VERSION = \"black==19.3b0\"\nBLACK_PATHS = [\n    \"google\",\n    \"tests\",\n    \"tests_async\",\n    \"noxfile.py\",\n    \"setup.py\",\n    \"docs/conf.py\",\n]\n\n\n# Error if a python version is missing\nnox.options.error_on_missing_interpreters = True\n\n#\n# Style Checks\n#\n\n\n# Linting with flake8.\n#\n# We ignore the following rules:\n#   E203: whitespace before \u2018:\u2019\n#   E266: too many leading \u2018#\u2019 for block comment\n#   E501: line too long\n#   I202: Additional newline in a section of imports\n#\n# We also need to specify the rules which are ignored by default:\n# ['E226', 'W504', 'E126', 'E123', 'W503', 'E24', 'E704', 'E121']\nFLAKE8_COMMON_ARGS = [\n    \"--show-source\",\n    \"--builtin=gettext\",\n    \"--max-complexity=20\",\n    \"--exclude=.nox,.cache,env,lib,generated_pb2,*_pb2.py,*_pb2_grpc.py\",\n    \"--ignore=E121,E123,E126,E203,E226,E24,E266,E501,E704,W503,W504,I202\",\n    \"--max-line-length=88\",\n]\n\n\n@nox.session(python=[\"3.7\", \"3.8\", \"3.9\", \"3.10\", \"3.11\", \"3.12\"])\ndef unit(session):\n    # constraints_path = str(\n    #     CURRENT_DIRECTORY / \"testing\" / f\"constraints-{session.python}.txt\"\n    # )\n    session.install(\"-r\", \"requirements.txt\")\n    # session.install(\"-e\", \".\")\n    session.run(\n        \"pytest\",\n        f\"--junitxml=unit_{session.python}_sponge_log.xml\",\n        \"snippets_test.py\",\n        # \"tests_async\",\n    )\n\n\n@nox.session\ndef lint(session: nox.sessions.Session) -> None:\n    session.install(\"flake8\")\n\n    args = FLAKE8_COMMON_ARGS + [\n        \".\",\n    ]\n    session.run(\"flake8\", *args)\n", "samples/cloud-client/snippets/noxfile_config.py": "# Copyright 2022 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# Default TEST_CONFIG_OVERRIDE for python repos.\n\n# You can copy this file into your directory, then it will be inported from\n# the noxfile.py.\n\n# The source of truth:\n# https://github.com/GoogleCloudPlatform/python-docs-samples/blob/master/noxfile_config.py\n\nTEST_CONFIG_OVERRIDE = {\n    # You can opt out from the test for specific Python versions.\n    \"ignored_versions\": [\"2.7\"],\n    # Old samples are opted out of enforcing Python type hints\n    # All new samples should feature them\n    \"enforce_type_hints\": True,\n    # An envvar key for determining the project id to use. Change it\n    # to 'BUILD_SPECIFIC_GCLOUD_PROJECT' if you want to opt in using a\n    # build specific Cloud project. You can also use your own string\n    # to use your own Cloud project.\n    # \"gcloud_project_env\": \"GOOGLE_CLOUD_PROJECT\",\n    \"gcloud_project_env\": \"GOOGLE_CLOUD_PROJECT\",\n    # A dictionary you want to inject into your test. Don't put any\n    # secrets here. These values will override predefined values.\n    \"envs\": {},\n}\n", "samples/cloud-client/snippets/idtoken_from_service_account.py": "# Copyright 2022 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# [START auth_cloud_idtoken_service_account]\n\nimport google.auth\nimport google.auth.transport.requests\n\nfrom google.oauth2 import service_account\n\n\ndef get_idToken_from_serviceaccount(json_credential_path: str, target_audience: str):\n    \"\"\"\n    TODO(Developer): Replace the below variables before running the code.\n\n    *NOTE*:\n    Using service account keys introduces risk; they are long-lived, and can be used by anyone\n    that obtains the key. Proper rotation and storage reduce this risk but do not eliminate it.\n    For these reasons, you should consider an alternative approach that\n    does not use a service account key. Several alternatives to service account keys\n    are described here:\n    https://cloud.google.com/docs/authentication/external/set-up-adc\n\n    Args:\n        json_credential_path: Path to the service account json credential file.\n        target_audience: The url or target audience to obtain the ID token for.\n                        Examples: http://www.abc.com\n    \"\"\"\n\n    # Obtain the id token by providing the json file path and target audience.\n    credentials = service_account.IDTokenCredentials.from_service_account_file(\n        filename=json_credential_path,\n        target_audience=target_audience)\n\n    request = google.auth.transport.requests.Request()\n    credentials.refresh(request)\n    print(\"Generated ID token.\")\n\n# [END auth_cloud_idtoken_service_account]\n", "samples/cloud-client/snippets/authenticate_explicit_with_adc.py": "# Copyright 2022 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# [START auth_cloud_explicit_adc]\n\nfrom google.cloud import storage\n\nimport google.oauth2.credentials\nimport google.auth\n\n\ndef authenticate_explicit_with_adc():\n    \"\"\"\n    List storage buckets by authenticating with ADC.\n\n    // TODO(Developer):\n    //  1. Before running this sample,\n    //  set up ADC as described in https://cloud.google.com/docs/authentication/external/set-up-adc\n    //  2. Replace the project variable.\n    //  3. Make sure you have the necessary permission to list storage buckets: \"storage.buckets.list\"\n    \"\"\"\n\n    # Construct the Google credentials object which obtains the default configuration from your\n    # working environment.\n    # google.auth.default() will give you ComputeEngineCredentials\n    # if you are on a GCE (or other metadata server supported environments).\n    credentials, project_id = google.auth.default()\n    # If you are authenticating to a Cloud API, you can let the library include the default scope,\n    # https://www.googleapis.com/auth/cloud-platform, because IAM is used to provide fine-grained\n    # permissions for Cloud.\n    # If you need to provide a scope, specify it as follows:\n    # credentials = google.auth.default(scopes=scope)\n    # For more information on scopes to use,\n    # see: https://developers.google.com/identity/protocols/oauth2/scopes\n\n    # Construct the Storage client.\n    storage_client = storage.Client(credentials=credentials, project=project_id)\n    buckets = storage_client.list_buckets()\n    print(\"Buckets:\")\n    for bucket in buckets:\n        print(bucket.name)\n    print(\"Listed all storage buckets.\")\n\n# [END auth_cloud_explicit_adc]\n", "samples/cloud-client/snippets/verify_google_idtoken.py": "# Copyright 2022 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# [START auth_cloud_verify_google_idtoken]\n\nimport google\nimport google.auth.transport.requests\nfrom google.oauth2 import id_token\n\n\ndef verify_google_idtoken(idtoken: str, audience=\"iap.googleapis.com\",\n                          jwk_url=\"https://www.googleapis.com/oauth2/v3/certs\"):\n    \"\"\"\n      Verifies the obtained Google id token. This is done at the receiving end of the OIDC endpoint.\n      The most common use case for verifying the ID token is when you are protecting\n      your own APIs with IAP. Google services already verify credentials as a platform,\n      so verifying ID tokens before making Google API calls is usually unnecessary.\n\n    Args:\n        idtoken: The Google ID token to verify.\n\n        audience: The service name for which the id token is requested. Service name refers to the\n            logical identifier of an API service, such as \"iap.googleapis.com\".\n\n        jwk_url: To verify id tokens, get the Json Web Key endpoint (jwk).\n            OpenID Connect allows the use of a \"Discovery document,\" a JSON document found at a\n            well-known location containing key-value pairs which provide details about the\n            OpenID Connect provider's configuration.\n            For more information on validating the jwt, see:\n            https://developers.google.com/identity/protocols/oauth2/openid-connect#validatinganidtoken\n\n            Here, we validate Google's token using Google's OpenID Connect service (jwkUrl).\n            For more information on jwk,see:\n            https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-key-sets\n    \"\"\"\n\n    request = google.auth.transport.requests.Request()\n    # Set the parameters and verify the token.\n    # Setting \"certs_url\" is optional. When verifying a Google ID token, this is set by default.\n    result = id_token.verify_token(idtoken, request, audience, clock_skew_in_seconds=10)\n\n    # Verify that the token contains subject and email claims.\n    # Get the User id.\n    if not result[\"sub\"] is None:\n        print(f\"User id: {result['sub']}\")\n    # Optionally, if \"INCLUDE_EMAIL\" was set in the token options, check if the\n    # email was verified.\n    if result['email_verified'] == \"True\":\n        print(f\"Email verified {result['email']}\")\n\n# [END auth_cloud_verify_google_idtoken]\n", "system_tests/noxfile.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Noxfile for automating system tests.\n\nThis file handles setting up environments needed by the system tests. This\nseparates the tests from their environment configuration.\n\nSee the `nox docs`_ for details on how this file works:\n\n.. _nox docs: http://nox.readthedocs.io/en/latest/\n\"\"\"\n\nimport os\nimport pathlib\nimport shutil\nimport tempfile\n\nimport nox\n\nHERE = os.path.abspath(os.path.dirname(__file__))\nLIBRARY_DIR = os.path.abspath(os.path.dirname(HERE))\nDATA_DIR = os.path.join(HERE, \"data\")\nSERVICE_ACCOUNT_FILE = os.path.join(DATA_DIR, \"service_account.json\")\nAUTHORIZED_USER_FILE = os.path.join(DATA_DIR, \"authorized_user.json\")\nEXPLICIT_CREDENTIALS_ENV = \"GOOGLE_APPLICATION_CREDENTIALS\"\nEXPLICIT_PROJECT_ENV = \"GOOGLE_CLOUD_PROJECT\"\nEXPECT_PROJECT_ENV = \"EXPECT_PROJECT_ID\"\nALLOW_PLUGGABLE_ENV = \"GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES\"\n\n\n# The download location for the Cloud SDK\nCLOUD_SDK_DIST_FILENAME = \"google-cloud-sdk.tar.gz\"\nCLOUD_SDK_DOWNLOAD_URL = \"https://dl.google.com/dl/cloudsdk/release/{}\".format(\n    CLOUD_SDK_DIST_FILENAME\n)\n\n# This environment variable is recognized by the Cloud SDK and overrides\n# the location of the SDK's configuration files (which is usually at\n# ${HOME}/.config).\nCLOUD_SDK_CONFIG_ENV = \"CLOUDSDK_CONFIG\"\n\n# If set, this is where the environment setup will install the Cloud SDK.\n# If unset, it will download the SDK to a temporary directory.\nCLOUD_SDK_ROOT = os.environ.get(\"CLOUD_SDK_ROOT\")\n\nif CLOUD_SDK_ROOT is not None:\n    CLOUD_SDK_ROOT = pathlib.Path(CLOUD_SDK_ROOT)\n    if not CLOUD_SDK_ROOT.exists() or not CLOUD_SDK_ROOT.is_dir():\n        print(\"{} did not exist! Please set the CLOUD_SDK_ROOT environment variable to a directory that exists\".format(CLOUD_SDK_ROOT))\n        exit(1)\nelse:\n    CLOUD_SDK_ROOT = pathlib.Path(tempfile.mkdtemp())\n\n# The full path the cloud sdk install directory\nCLOUD_SDK_INSTALL_DIR = CLOUD_SDK_ROOT.joinpath(\"google-cloud-sdk\")\n\n# The full path to the gcloud cli executable.\nGCLOUD = str(CLOUD_SDK_INSTALL_DIR.joinpath(\"bin\", \"gcloud\"))\n\n# Cloud SDK helpers\n\n\ndef install_cloud_sdk(session):\n    \"\"\"Downloads and installs the Google Cloud SDK.\"\"\"\n    # Configure environment variables needed by the SDK.\n    # This sets the config root to the tests' config root. This prevents\n    # our tests from clobbering a developer's configuration when running\n    # these tests locally.\n    session.env[CLOUD_SDK_CONFIG_ENV] = str(CLOUD_SDK_ROOT)\n    # This set the $PATH for the subprocesses so they can find the gcloud\n    # executable.\n    session.env[\"PATH\"] = (\n        str(CLOUD_SDK_INSTALL_DIR.joinpath(\"bin\")) + os.pathsep + os.environ[\"PATH\"]\n    )\n\n    # If gcloud cli executable already exists, just update it.\n    if pathlib.Path(GCLOUD).exists():\n        session.run(GCLOUD, \"components\", \"update\", \"-q\")\n        return\n\n    tar_path = CLOUD_SDK_ROOT.joinpath(CLOUD_SDK_DIST_FILENAME)\n\n    # Download the release.\n    session.run(\"wget\", CLOUD_SDK_DOWNLOAD_URL, \"-O\", str(tar_path), silent=True)\n\n    # Extract the release.\n    session.run(\"tar\", \"xzf\", str(tar_path), \"-C\", str(CLOUD_SDK_ROOT))\n    tar_path.unlink()\n\n    # Run the install script.\n    session.run(\n        str(CLOUD_SDK_INSTALL_DIR.joinpath(\"install.sh\")),\n        \"--usage-reporting\",\n        \"false\",\n        \"--path-update\",\n        \"false\",\n        \"--command-completion\",\n        \"false\",\n        silent=True,\n    )\n\n\ndef copy_credentials(credentials_path):\n    \"\"\"Copies credentials into the SDK root as the application default\n    credentials.\"\"\"\n    dest = CLOUD_SDK_ROOT.joinpath(\"application_default_credentials.json\")\n    if dest.exists():\n        dest.unlink()\n    shutil.copyfile(pathlib.Path(credentials_path), dest)\n\n\ndef configure_cloud_sdk(session, application_default_credentials, project=False):\n    \"\"\"Installs and configures the Cloud SDK with the given application default\n    credentials.\n\n    If project is True, then a project will be set in the active config.\n    If it is false, this will ensure no project is set.\n    \"\"\"\n    install_cloud_sdk(session)\n\n    # Setup the service account as the default user account. This is\n    # needed for the project ID detection to work. Note that this doesn't\n    # change the application default credentials file, which is user\n    # credentials instead of service account credentials sometimes.\n    session.run(\n        GCLOUD, \"auth\", \"activate-service-account\", \"--key-file\", SERVICE_ACCOUNT_FILE\n    )\n\n    if project:\n        session.run(GCLOUD, \"config\", \"set\", \"project\", \"example-project\")\n    else:\n        session.run(GCLOUD, \"config\", \"unset\", \"project\")\n\n    # Copy the credentials file to the config root. This is needed because\n    # unfortunately gcloud doesn't provide a clean way to tell it to use\n    # a particular set of credentials. However, this does verify that gcloud\n    # also considers the credentials valid by calling application-default\n    # print-access-token\n    session.run(copy_credentials, application_default_credentials)\n\n    # Calling this forces the Cloud SDK to read the credentials we just wrote\n    # and obtain a new access token with those credentials. This validates\n    # that our credentials matches the format expected by gcloud.\n    # Silent is set to True to prevent leaking secrets in test logs.\n    session.run(\n        GCLOUD, \"auth\", \"application-default\", \"print-access-token\", silent=True\n    )\n\n\n# Test sesssions\n\nTEST_DEPENDENCIES_ASYNC = [\"aiohttp\", \"pytest-asyncio\", \"nest-asyncio\", \"mock\"]\nTEST_DEPENDENCIES_SYNC = [\"pytest\", \"requests\", \"mock\"]\nPYTHON_VERSIONS_ASYNC = [\"3.7\"]\nPYTHON_VERSIONS_SYNC = [\"3.7\"]\n\n\ndef default(session, *test_paths):\n    # replace 'session._runner.friendly_name' with\n    # session.name once nox has released a new version\n    # https://github.com/theacodes/nox/pull/386\n    sponge_log = f\"--junitxml=system_{str(session._runner.friendly_name)}_sponge_log.xml\"\n    session.run(\n        \"pytest\", sponge_log, *test_paths,\n    )\n\n\n@nox.session(python=PYTHON_VERSIONS_SYNC)\ndef service_account_sync(session):\n    session.install(*TEST_DEPENDENCIES_SYNC)\n    session.install(LIBRARY_DIR)\n    default(\n        session,\n        \"system_tests_sync/test_service_account.py\",\n        *session.posargs,\n    )\n\n\n@nox.session(python=PYTHON_VERSIONS_SYNC)\ndef default_explicit_service_account(session):\n    session.env[EXPLICIT_CREDENTIALS_ENV] = SERVICE_ACCOUNT_FILE\n    session.env[EXPECT_PROJECT_ENV] = \"1\"\n    session.install(*TEST_DEPENDENCIES_SYNC)\n    session.install(LIBRARY_DIR)\n    default(\n        session,\n        \"system_tests_sync/test_default.py\",\n        \"system_tests_sync/test_id_token.py\",\n        *session.posargs,\n    )\n\n\n@nox.session(python=PYTHON_VERSIONS_SYNC)\ndef default_explicit_authorized_user(session):\n    session.env[EXPLICIT_CREDENTIALS_ENV] = AUTHORIZED_USER_FILE\n    session.install(*TEST_DEPENDENCIES_SYNC)\n    session.install(LIBRARY_DIR)\n    default(\n        session,\n        \"system_tests_sync/test_default.py\",\n        *session.posargs,\n    )\n\n\n@nox.session(python=PYTHON_VERSIONS_SYNC)\ndef default_explicit_authorized_user_explicit_project(session):\n    session.env[EXPLICIT_CREDENTIALS_ENV] = AUTHORIZED_USER_FILE\n    session.env[EXPLICIT_PROJECT_ENV] = \"example-project\"\n    session.env[EXPECT_PROJECT_ENV] = \"1\"\n    session.install(*TEST_DEPENDENCIES_SYNC)\n    session.install(LIBRARY_DIR)\n    default(\n        session,\n        \"system_tests_sync/test_default.py\",\n        *session.posargs,\n    )\n\n\n@nox.session(python=PYTHON_VERSIONS_SYNC)\ndef default_cloud_sdk_service_account(session):\n    configure_cloud_sdk(session, SERVICE_ACCOUNT_FILE)\n    session.env[EXPECT_PROJECT_ENV] = \"1\"\n    session.install(*TEST_DEPENDENCIES_SYNC)\n    session.install(LIBRARY_DIR)\n    default(\n        session,\n        \"system_tests_sync/test_default.py\",\n        *session.posargs,\n    )\n\n\n@nox.session(python=PYTHON_VERSIONS_SYNC)\ndef default_cloud_sdk_authorized_user(session):\n    configure_cloud_sdk(session, AUTHORIZED_USER_FILE)\n    session.install(*TEST_DEPENDENCIES_SYNC)\n    session.install(LIBRARY_DIR)\n    default(\n        session,\n        \"system_tests_sync/test_default.py\",\n        *session.posargs,\n    )\n\n\n@nox.session(python=PYTHON_VERSIONS_SYNC)\ndef default_cloud_sdk_authorized_user_configured_project(session):\n    configure_cloud_sdk(session, AUTHORIZED_USER_FILE, project=True)\n    session.env[EXPECT_PROJECT_ENV] = \"1\"\n    session.install(*TEST_DEPENDENCIES_SYNC)\n    session.install(LIBRARY_DIR)\n    default(\n        session,\n        \"system_tests_sync/test_default.py\",\n        *session.posargs,\n    )\n\n\n@nox.session(python=PYTHON_VERSIONS_SYNC)\ndef compute_engine(session):\n    session.install(*TEST_DEPENDENCIES_SYNC)\n    # unset Application Default Credentials so\n    # credentials are detected from environment\n    del session.virtualenv.env[\"GOOGLE_APPLICATION_CREDENTIALS\"]\n    session.install(LIBRARY_DIR)\n    default(\n        session,\n        \"system_tests_sync/test_compute_engine.py\",\n        *session.posargs,\n    )\n\n\n@nox.session(python=PYTHON_VERSIONS_SYNC)\ndef grpc(session):\n    session.install(LIBRARY_DIR)\n    session.install(\"six\")\n    session.install(*TEST_DEPENDENCIES_SYNC, \"google-cloud-pubsub==1.7.2\")\n    session.env[EXPLICIT_CREDENTIALS_ENV] = SERVICE_ACCOUNT_FILE\n    default(\n        session,\n        \"system_tests_sync/test_grpc.py\",\n        *session.posargs,\n    )\n\n\n@nox.session(python=PYTHON_VERSIONS_SYNC)\ndef requests(session):\n    session.install(LIBRARY_DIR)\n    session.install(*TEST_DEPENDENCIES_SYNC)\n    session.env[EXPLICIT_CREDENTIALS_ENV] = SERVICE_ACCOUNT_FILE\n    default(\n        session,\n        \"system_tests_sync/test_requests.py\",\n        *session.posargs,\n    )\n\n\n@nox.session(python=PYTHON_VERSIONS_SYNC)\ndef urllib3(session):\n    session.install(LIBRARY_DIR)\n    session.install(*TEST_DEPENDENCIES_SYNC)\n    session.env[EXPLICIT_CREDENTIALS_ENV] = SERVICE_ACCOUNT_FILE\n    default(\n        session,\n        \"system_tests_sync/test_urllib3.py\",\n        *session.posargs,\n    )\n\n\n@nox.session(python=PYTHON_VERSIONS_SYNC)\ndef mtls_http(session):\n    session.install(LIBRARY_DIR)\n    session.install(*TEST_DEPENDENCIES_SYNC, \"pyopenssl\")\n    session.env[EXPLICIT_CREDENTIALS_ENV] = SERVICE_ACCOUNT_FILE\n    default(\n        session,\n        \"system_tests_sync/test_mtls_http.py\",\n        *session.posargs,\n    )\n\n\n@nox.session(python=PYTHON_VERSIONS_ASYNC)\ndef external_accounts(session):\n    session.env[ALLOW_PLUGGABLE_ENV] = \"1\"\n    session.install(\n        *TEST_DEPENDENCIES_ASYNC,\n        LIBRARY_DIR,\n        \"google-api-python-client\",\n    )\n    default(\n        session,\n        \"system_tests_sync/test_external_accounts.py\",\n        *session.posargs,\n    )\n\n\n@nox.session(python=PYTHON_VERSIONS_SYNC)\ndef downscoping(session):\n    session.install(\n        *TEST_DEPENDENCIES_SYNC,\n        LIBRARY_DIR,\n        \"google-cloud-storage\",\n    )\n    default(\n        session,\n        \"system_tests_sync/test_downscoping.py\",\n        *session.posargs,\n    )\n\n\n# ASYNC SYSTEM TESTS\n\n@nox.session(python=PYTHON_VERSIONS_ASYNC)\ndef service_account_async(session):\n    session.install(*(TEST_DEPENDENCIES_SYNC + TEST_DEPENDENCIES_ASYNC))\n    session.install(LIBRARY_DIR)\n    default(\n        session,\n        \"system_tests_async/test_service_account.py\",\n        *session.posargs,\n    )\n\n\n@nox.session(python=PYTHON_VERSIONS_ASYNC)\ndef default_explicit_service_account_async(session):\n    session.env[EXPLICIT_CREDENTIALS_ENV] = SERVICE_ACCOUNT_FILE\n    session.env[EXPECT_PROJECT_ENV] = \"1\"\n    session.install(*(TEST_DEPENDENCIES_SYNC + TEST_DEPENDENCIES_ASYNC))\n    session.install(LIBRARY_DIR)\n    default(\n        session,\n        \"system_tests_async/test_default.py\",\n        \"system_tests_async/test_id_token.py\",\n        *session.posargs,\n    )\n\n\n@nox.session(python=PYTHON_VERSIONS_ASYNC)\ndef default_explicit_authorized_user_async(session):\n    session.env[EXPLICIT_CREDENTIALS_ENV] = AUTHORIZED_USER_FILE\n    session.install(*(TEST_DEPENDENCIES_SYNC + TEST_DEPENDENCIES_ASYNC))\n    session.install(LIBRARY_DIR)\n    default(\n        session,\n        \"system_tests_async/test_default.py\",\n        *session.posargs,\n    )\n\n\n@nox.session(python=PYTHON_VERSIONS_ASYNC)\ndef default_explicit_authorized_user_explicit_project_async(session):\n    session.env[EXPLICIT_CREDENTIALS_ENV] = AUTHORIZED_USER_FILE\n    session.env[EXPLICIT_PROJECT_ENV] = \"example-project\"\n    session.env[EXPECT_PROJECT_ENV] = \"1\"\n    session.install(*(TEST_DEPENDENCIES_SYNC + TEST_DEPENDENCIES_ASYNC))\n    session.install(LIBRARY_DIR)\n    default(\n        session,\n        \"system_tests_async/test_default.py\",\n        *session.posargs,\n    )\n\n\n@nox.session(python=PYTHON_VERSIONS_ASYNC)\ndef default_cloud_sdk_service_account_async(session):\n    configure_cloud_sdk(session, SERVICE_ACCOUNT_FILE)\n    session.env[EXPECT_PROJECT_ENV] = \"1\"\n    session.install(*(TEST_DEPENDENCIES_SYNC + TEST_DEPENDENCIES_ASYNC))\n    session.install(LIBRARY_DIR)\n    default(\n        session,\n        \"system_tests_async/test_default.py\",\n        *session.posargs,\n    )\n\n\n@nox.session(python=PYTHON_VERSIONS_ASYNC)\ndef default_cloud_sdk_authorized_user_async(session):\n    configure_cloud_sdk(session, AUTHORIZED_USER_FILE)\n    session.install(*(TEST_DEPENDENCIES_SYNC + TEST_DEPENDENCIES_ASYNC))\n    session.install(LIBRARY_DIR)\n    default(\n        session,\n        \"system_tests_async/test_default.py\",\n        *session.posargs,\n    )\n\n\n@nox.session(python=PYTHON_VERSIONS_ASYNC)\ndef default_cloud_sdk_authorized_user_configured_project_async(session):\n    configure_cloud_sdk(session, AUTHORIZED_USER_FILE, project=True)\n    session.env[EXPECT_PROJECT_ENV] = \"1\"\n    session.install(*(TEST_DEPENDENCIES_SYNC + TEST_DEPENDENCIES_ASYNC))\n    session.install(LIBRARY_DIR)\n    default(\n        session,\n        \"system_tests_async/test_default.py\",\n        *session.posargs,\n    )\n", "system_tests/__init__.py": "", "system_tests/system_tests_sync/test_default.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport os\n\nimport google.auth\n\nEXPECT_PROJECT_ID = os.environ.get(\"EXPECT_PROJECT_ID\")\n\n\ndef test_application_default_credentials(verify_refresh):\n    credentials, project_id = google.auth.default()\n\n    if EXPECT_PROJECT_ID is not None:\n        assert project_id is not None\n\n    verify_refresh(credentials)\n", "system_tests/system_tests_sync/test_downscoping.py": "# Copyright 2021 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport re\nimport uuid\n\nimport google.auth\n\nfrom google.auth import downscoped\nfrom google.auth.transport import requests\nfrom google.cloud import exceptions\nfrom google.cloud import storage\nfrom google.oauth2 import credentials\n\nimport pytest\n\n # The object prefix used to test access to files beginning with this prefix.\n_OBJECT_PREFIX = \"customer-a\"\n# The object name of the object inaccessible by the downscoped token.\n_ACCESSIBLE_OBJECT_NAME = \"{0}-data.txt\".format(_OBJECT_PREFIX)\n# The content of the object accessible by the downscoped token.\n_ACCESSIBLE_CONTENT = \"hello world\"\n# The content of the object inaccessible by the downscoped token.\n_INACCESSIBLE_CONTENT = \"secret content\"\n# The object name of the object inaccessible by the downscoped token.\n_INACCESSIBLE_OBJECT_NAME = \"other-customer-data.txt\"\n\n\n@pytest.fixture(scope=\"module\")\ndef temp_bucket():\n    \"\"\"Yields a bucket that is deleted after the test completes.\"\"\"\n    bucket = None\n    while bucket is None or bucket.exists():\n        bucket_name = \"auth-python-downscope-test-{}\".format(uuid.uuid4())\n        bucket = storage.Client().bucket(bucket_name)\n    bucket = storage.Client().create_bucket(bucket.name)\n    yield bucket\n    bucket.delete(force=True)\n\n\n@pytest.fixture(scope=\"module\")\ndef temp_blobs(temp_bucket):\n    \"\"\"Yields two blobs that are deleted after the test completes.\"\"\"\n    bucket = temp_bucket\n    # Downscoped tokens will have readonly access to this blob.\n    accessible_blob = bucket.blob(_ACCESSIBLE_OBJECT_NAME)\n    accessible_blob.upload_from_string(_ACCESSIBLE_CONTENT)\n    # Downscoped tokens will have no access to this blob.\n    inaccessible_blob = bucket.blob(_INACCESSIBLE_OBJECT_NAME)\n    inaccessible_blob.upload_from_string(_INACCESSIBLE_CONTENT)\n    yield (accessible_blob, inaccessible_blob)\n    bucket.delete_blobs([accessible_blob, inaccessible_blob])\n\n\ndef get_token_from_broker(bucket_name, object_prefix):\n    \"\"\"Simulates token broker generating downscoped tokens for specified bucket.\n\n    Args:\n        bucket_name (str): The name of the Cloud Storage bucket.\n        object_prefix (str): The prefix string of the object name. This is used\n            to ensure access is restricted to only objects starting with this\n            prefix string.\n\n    Returns:\n        Tuple[str, datetime.datetime]: The downscoped access token and its expiry date.\n    \"\"\"\n    # Initialize the Credential Access Boundary rules.\n    available_resource = \"//storage.googleapis.com/projects/_/buckets/{0}\".format(bucket_name)\n    # Downscoped credentials will have readonly access to the resource.\n    available_permissions = [\"inRole:roles/storage.objectViewer\"]\n    # Only objects starting with the specified prefix string in the object name\n    # will be allowed read access.\n    availability_expression = (\n        \"resource.name.startsWith('projects/_/buckets/{0}/objects/{1}')\".format(bucket_name, object_prefix)\n    )\n    availability_condition = downscoped.AvailabilityCondition(availability_expression)\n    # Define the single access boundary rule using the above properties.\n    rule = downscoped.AccessBoundaryRule(\n        available_resource=available_resource,\n        available_permissions=available_permissions,\n        availability_condition=availability_condition,\n    )\n    # Define the Credential Access Boundary with all the relevant rules.\n    credential_access_boundary = downscoped.CredentialAccessBoundary(rules=[rule])\n\n    # Retrieve the source credentials via ADC.\n    source_credentials, _ = google.auth.default()\n    if source_credentials.requires_scopes:\n        source_credentials = source_credentials.with_scopes(\n            [\"https://www.googleapis.com/auth/cloud-platform\"]\n        )\n\n    # Create the downscoped credentials.\n    downscoped_credentials = downscoped.Credentials(\n        source_credentials=source_credentials,\n        credential_access_boundary=credential_access_boundary,\n    )\n\n    # Refresh the tokens.\n    downscoped_credentials.refresh(requests.Request())\n\n    # These values will need to be passed to the token consumer.\n    access_token = downscoped_credentials.token\n    expiry = downscoped_credentials.expiry\n    return (access_token, expiry)\n\n\ndef test_downscoping(temp_blobs):\n    \"\"\"Tests token consumer access to cloud storage using downscoped tokens.\n\n    Args:\n        temp_blobs (Tuple[google.cloud.storage.blob.Blob, ...]): The temporarily\n            created test cloud storage blobs (one readonly accessible, the other\n            not).\n    \"\"\"\n    accessible_blob, inaccessible_blob = temp_blobs\n    bucket_name = accessible_blob.bucket.name\n    # Create the OAuth credentials from the downscoped token and pass a\n    # refresh handler to handle token expiration. We are passing a\n    # refresh_handler instead of a one-time access token/expiry pair.\n    # This will allow testing this on-demand method for getting access tokens.\n    def refresh_handler(request, scopes=None):\n        # Get readonly access tokens to objects with accessible prefix in\n        # the temporarily created bucket.\n        return get_token_from_broker(bucket_name, _OBJECT_PREFIX)\n\n    creds = credentials.Credentials(\n        None,\n        scopes=[\"https://www.googleapis.com/auth/cloud-platform\"],\n        refresh_handler=refresh_handler,\n    )\n\n    # Initialize a Cloud Storage client with the oauth2 credentials.\n    storage_client = storage.Client(credentials=creds)\n\n    # Test read access succeeds to accessible blob.\n    bucket = storage_client.bucket(bucket_name)\n    blob = bucket.blob(accessible_blob.name)\n    assert blob.download_as_bytes().decode(\"utf-8\") == _ACCESSIBLE_CONTENT\n\n    # Test write access fails.\n    with pytest.raises(exceptions.Forbidden) as excinfo:\n        blob.upload_from_string(\"Write operations are not allowed\")\n\n    assert excinfo.match(r\"does not have storage.objects.create access\")\n\n    # Test read access fails to inaccessible blob.\n    with pytest.raises(exceptions.Forbidden) as excinfo:\n        bucket.blob(inaccessible_blob.name).download_as_bytes()\n\n    assert excinfo.match(r\"does not have storage.objects.get access\")\n", "system_tests/system_tests_sync/test_external_accounts.py": "# Copyright 2021 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# Prerequisites:\n# Make sure to run the setup in scripts/setup_external_accounts.sh\n# and copy the logged constant strings (_AUDIENCE_OIDC, _AUDIENCE_AWS)\n# into this file before running this test suite.\n# Once that is done, this test can be run indefinitely.\n#\n# The only requirement for this test suite to run is to set the environment\n# variable GOOGLE_APPLICATION_CREDENTIALS to point to the expected service\n# account keys whose email is referred to in the setup script.\n#\n# This script follows the following logic.\n# OIDC provider (file-sourced and url-sourced credentials):\n# Use the service account keys to generate a Google ID token using the\n# iamcredentials generateIdToken API, using the default STS audience.\n# This will use the service account client ID as the sub field of the token.\n# This OIDC token will be used as the external subject token to be exchanged\n# for a Google access token via GCP STS endpoint and then to impersonate the\n# original service account key.\n\n\nimport datetime\nimport json\nimport os\nimport socket\nfrom tempfile import NamedTemporaryFile\nimport threading\nimport time\n\nimport sys\nimport google.auth\nfrom google.auth import _helpers\nfrom googleapiclient import discovery\nfrom http.server import BaseHTTPRequestHandler\nfrom http.server import HTTPServer\nfrom google.oauth2 import service_account\nimport pytest\nfrom mock import patch\n\n# Populate values from the output of scripts/setup_external_accounts.sh.\n_AUDIENCE_OIDC = \"//iam.googleapis.com/projects/79992041559/locations/global/workloadIdentityPools/pool-73wslmxn/providers/oidc-73wslmxn\"\n_AUDIENCE_AWS = \"//iam.googleapis.com/projects/79992041559/locations/global/workloadIdentityPools/pool-73wslmxn/providers/aws-73wslmxn\"\n_ROLE_AWS = \"arn:aws:iam::077071391996:role/ci-python-test\"\n\n\ndef dns_access_direct(request, project_id):\n    # First, get the default credentials.\n    credentials, _ = google.auth.default(\n        scopes=[\"https://www.googleapis.com/auth/cloud-platform.read-only\"],\n        request=request,\n    )\n\n    # Apply the default credentials to the headers to make the request.\n    headers = {}\n    credentials.apply(headers)\n    response = request(\n        url=\"https://dns.googleapis.com/dns/v1/projects/{}\".format(project_id),\n        headers=headers,\n    )\n\n    if response.status == 200:\n        return response.data\n\n\ndef dns_access_client_library(_, project_id):\n    service = discovery.build(\"dns\", \"v1\")\n    request = service.projects().get(project=project_id)\n    return request.execute()\n\n\n@pytest.fixture(params=[dns_access_direct, dns_access_client_library])\ndef dns_access(request, http_request, service_account_info):\n    # Fill in the fixtures on the functions,\n    # so that we don't have to fill in the parameters manually.\n    def wrapper():\n        return request.param(http_request, service_account_info[\"project_id\"])\n\n    yield wrapper\n\n\n@pytest.fixture\ndef oidc_credentials(service_account_file, http_request):\n    result = service_account.IDTokenCredentials.from_service_account_file(\n        service_account_file, target_audience=_AUDIENCE_OIDC\n    )\n    result.refresh(http_request)\n    yield result\n\n\n@pytest.fixture\ndef service_account_info(service_account_file):\n    with open(service_account_file) as f:\n        yield json.load(f)\n\n\n@pytest.fixture\ndef aws_oidc_credentials(\n    service_account_file, service_account_info, authenticated_request\n):\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_file, scopes=[\"https://www.googleapis.com/auth/cloud-platform\"]\n    )\n    result = authenticated_request(credentials)(\n        url=\"https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/{}:generateIdToken\".format(\n            service_account_info[\"client_email\"]\n        ),\n        method=\"POST\",\n        body=json.dumps(\n            {\"audience\": service_account_info[\"client_id\"], \"includeEmail\": True}\n        ),\n    )\n    assert result.status == 200\n\n    yield json.loads(result.data)[\"token\"]\n\n\n# Our external accounts tests involve setting up some preconditions, setting a\n# credential file, and then making sure that our client libraries can work with\n# the set credentials.\ndef get_project_dns(dns_access, credential_data):\n    with NamedTemporaryFile() as credfile:\n        credfile.write(json.dumps(credential_data).encode(\"utf-8\"))\n        credfile.flush()\n\n        with patch.dict(os.environ, {\"GOOGLE_APPLICATION_CREDENTIALS\": credfile.name}):\n            # If our setup and credential file are correct,\n            # discovery.build should be able to establish these as the default credentials.\n            return dns_access()\n\n\ndef get_xml_value_by_tagname(data, tagname):\n    startIndex = data.index(\"<{}>\".format(tagname))\n    if startIndex >= 0:\n        endIndex = data.index(\"</{}>\".format(tagname), startIndex)\n        if endIndex > startIndex:\n            return data[startIndex + len(tagname) + 2 : endIndex]\n\n\n# This test makes sure that setting an accesible credential file\n# works to allow access to Google resources.\ndef test_file_based_external_account(oidc_credentials, dns_access):\n    with NamedTemporaryFile() as tmpfile:\n        tmpfile.write(oidc_credentials.token.encode(\"utf-8\"))\n        tmpfile.flush()\n\n        assert get_project_dns(\n            dns_access,\n            {\n                \"type\": \"external_account\",\n                \"audience\": _AUDIENCE_OIDC,\n                \"subject_token_type\": \"urn:ietf:params:oauth:token-type:jwt\",\n                \"token_url\": \"https://sts.googleapis.com/v1/token\",\n                \"service_account_impersonation_url\": \"https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/{}:generateAccessToken\".format(\n                    oidc_credentials.service_account_email\n                ),\n                \"credential_source\": {\n                    \"file\": tmpfile.name,\n                },\n            },\n        )\n\n\n# This test makes sure that setting a token lifetime works\n# for service account impersonation.\ndef test_file_based_external_account_with_configure_token_lifetime(\n    oidc_credentials, dns_access\n):\n    with NamedTemporaryFile() as tmpfile:\n        tmpfile.write(oidc_credentials.token.encode(\"utf-8\"))\n        tmpfile.flush()\n\n        assert get_project_dns(\n            dns_access,\n            {\n                \"type\": \"external_account\",\n                \"audience\": _AUDIENCE_OIDC,\n                \"subject_token_type\": \"urn:ietf:params:oauth:token-type:jwt\",\n                \"token_url\": \"https://sts.googleapis.com/v1/token\",\n                \"service_account_impersonation_url\": \"https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/{}:generateAccessToken\".format(\n                    oidc_credentials.service_account_email\n                ),\n                \"service_account_impersonation\": {\n                    \"token_lifetime_seconds\": 2800,\n                },\n                \"credential_source\": {\n                    \"file\": tmpfile.name,\n                },\n            },\n        )\n\n\ndef test_configurable_token_lifespan(oidc_credentials, http_request):\n    TOKEN_LIFETIME_SECONDS = 2800\n    BUFFER_SECONDS = 5\n\n    def check_impersonation_expiration():\n        # First, get the default credentials.\n        credentials, _ = google.auth.default(\n            scopes=[\"https://www.googleapis.com/auth/cloud-platform.read-only\"],\n            request=http_request,\n        )\n\n        utcmax = _helpers.utcnow() + datetime.timedelta(seconds=TOKEN_LIFETIME_SECONDS)\n        utcmin = utcmax - datetime.timedelta(seconds=BUFFER_SECONDS)\n        assert utcmin < credentials._impersonated_credentials.expiry <= utcmax\n\n        return True\n\n    with NamedTemporaryFile() as tmpfile:\n        tmpfile.write(oidc_credentials.token.encode(\"utf-8\"))\n        tmpfile.flush()\n\n        assert get_project_dns(\n            check_impersonation_expiration,\n            {\n                \"type\": \"external_account\",\n                \"audience\": _AUDIENCE_OIDC,\n                \"subject_token_type\": \"urn:ietf:params:oauth:token-type:jwt\",\n                \"token_url\": \"https://sts.googleapis.com/v1/token\",\n                \"service_account_impersonation_url\": \"https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/{}:generateAccessToken\".format(\n                    oidc_credentials.service_account_email\n                ),\n                \"service_account_impersonation\": {\n                    \"token_lifetime_seconds\": TOKEN_LIFETIME_SECONDS,\n                },\n                \"credential_source\": {\n                    \"file\": tmpfile.name,\n                },\n            },\n        )\n\n\n# This test makes sure that setting up an http server to provide credentials\n# works to allow access to Google resources.\ndef test_url_based_external_account(dns_access, oidc_credentials, service_account_info):\n    class TestResponseHandler(BaseHTTPRequestHandler):\n        def do_GET(self):\n            if self.headers[\"my-header\"] != \"expected-value\":\n                self.send_response(400)\n                self.send_header(\"Content-Type\", \"application/json\")\n                self.end_headers()\n                self.wfile.write(\n                    json.dumps({\"error\": \"missing header\"}).encode(\"utf-8\")\n                )\n            elif self.path != \"/token\":\n                self.send_response(400)\n                self.send_header(\"Content-Type\", \"application/json\")\n                self.end_headers()\n                self.wfile.write(\n                    json.dumps({\"error\": \"incorrect token path\"}).encode(\"utf-8\")\n                )\n            else:\n                self.send_response(200)\n                self.send_header(\"Content-Type\", \"application/json\")\n                self.end_headers()\n                self.wfile.write(\n                    json.dumps({\"access_token\": oidc_credentials.token}).encode(\"utf-8\")\n                )\n\n    class TestHTTPServer(HTTPServer, object):\n        def __init__(self):\n            self.port = self._find_open_port()\n            super(TestHTTPServer, self).__init__((\"\", self.port), TestResponseHandler)\n\n        @staticmethod\n        def _find_open_port():\n            s = socket.socket()\n            s.bind((\"\", 0))\n            return s.getsockname()[1]\n\n        # This makes sure that the server gets shut down when this variable leaves its \"with\" block\n        # The python3 HttpServer has __enter__ and __exit__ methods, but python2 does not.\n        # By redefining the __enter__ and __exit__ methods, we ensure that python2 and python3 act similarly\n        def __exit__(self, *args):\n            self.shutdown()\n\n        def __enter__(self):\n            return self\n\n    with TestHTTPServer() as server:\n        threading.Thread(target=server.serve_forever).start()\n\n        assert get_project_dns(\n            dns_access,\n            {\n                \"type\": \"external_account\",\n                \"audience\": _AUDIENCE_OIDC,\n                \"subject_token_type\": \"urn:ietf:params:oauth:token-type:jwt\",\n                \"token_url\": \"https://sts.googleapis.com/v1/token\",\n                \"service_account_impersonation_url\": \"https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/{}:generateAccessToken\".format(\n                    oidc_credentials.service_account_email\n                ),\n                \"credential_source\": {\n                    \"url\": \"http://localhost:{}/token\".format(server.port),\n                    \"headers\": {\"my-header\": \"expected-value\"},\n                    \"format\": {\n                        \"type\": \"json\",\n                        \"subject_token_field_name\": \"access_token\",\n                    },\n                },\n            },\n        )\n\n\n# AWS provider tests for AWS credentials\n# The test suite will also run tests for AWS credentials. This works as\n# follows. (Note prequisite setup is needed. This is documented in\n# setup_external_accounts.sh).\n# - iamcredentials:generateIdToken is used to generate a Google ID token using\n#   the service account access token. The service account client_id is used as\n#   audience.\n# - AWS STS AssumeRoleWithWebIdentity API is used to exchange this token for\n#   temporary AWS security credentials for a specified AWS ARN role.\n# - AWS_REGION, AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY and AWS_SESSION_TOKEN\n#   environment variables are set using these credentials before the test is\n#   run simulating an AWS VM.\n# - The test can now be run.\ndef test_aws_based_external_account(\n    aws_oidc_credentials, service_account_info, dns_access, http_request\n):\n    # temporarily disable this test as we investigate why it fails\n    # https://github.com/googleapis/google-auth-library-python/issues/1279\n    return\n    response = http_request(\n        url=(\n            \"https://sts.amazonaws.com/\"\n            \"?Action=AssumeRoleWithWebIdentity\"\n            \"&Version=2011-06-15\"\n            \"&DurationSeconds=3600\"\n            \"&RoleSessionName=python-test\"\n            \"&RoleArn={}\"\n            \"&WebIdentityToken={}\"\n        ).format(_ROLE_AWS, aws_oidc_credentials)\n    )\n    assert response.status == 200\n\n    # The returned data is in XML, but loading an XML parser would be overkill.\n    # Searching the return text manually for the start and finish tag.\n    data = response.data.decode(\"utf-8\")\n\n    with patch.dict(\n        os.environ,\n        {\n            \"AWS_REGION\": \"us-east-2\",\n            \"AWS_ACCESS_KEY_ID\": get_xml_value_by_tagname(data, \"AccessKeyId\"),\n            \"AWS_SECRET_ACCESS_KEY\": get_xml_value_by_tagname(data, \"SecretAccessKey\"),\n            \"AWS_SESSION_TOKEN\": get_xml_value_by_tagname(data, \"SessionToken\"),\n        },\n    ):\n        assert get_project_dns(\n            dns_access,\n            {\n                \"type\": \"external_account\",\n                \"audience\": _AUDIENCE_AWS,\n                \"subject_token_type\": \"urn:ietf:params:aws:token-type:aws4_request\",\n                \"token_url\": \"https://sts.googleapis.com/v1/token\",\n                \"service_account_impersonation_url\": \"https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/{}:generateAccessToken\".format(\n                    service_account_info[\"client_email\"]\n                ),\n                \"credential_source\": {\n                    \"environment_id\": \"aws1\",\n                    \"regional_cred_verification_url\": \"https://sts.{region}.amazonaws.com?Action=GetCallerIdentity&Version=2011-06-15\",\n                },\n            },\n        )\n\n\n# This test makes sure that setting up an executable to provide credentials\n# works to allow access to Google resources.\ndef test_pluggable_external_account(oidc_credentials, service_account_info, dns_access):\n    now = datetime.datetime.now()\n    unix_seconds = time.mktime(now.timetuple())\n    expiration_time = (unix_seconds + 1 * 60 * 60) * 1000\n    credential = {\n        \"success\": True,\n        \"version\": 1,\n        \"expiration_time\": expiration_time,\n        \"token_type\": \"urn:ietf:params:oauth:token-type:jwt\",\n        \"id_token\": oidc_credentials.token,\n    }\n\n    tmpfile = NamedTemporaryFile(delete=True)\n    with open(tmpfile.name, \"w\") as f:\n        f.write(\"#!/bin/bash\\n\")\n        f.write('echo \"{}\"\\n'.format(json.dumps(credential).replace('\"', '\\\\\"')))\n    tmpfile.file.close()\n\n    os.chmod(tmpfile.name, 0o777)\n    assert get_project_dns(\n        dns_access,\n        {\n            \"type\": \"external_account\",\n            \"audience\": _AUDIENCE_OIDC,\n            \"subject_token_type\": \"urn:ietf:params:oauth:token-type:jwt\",\n            \"token_url\": \"https://sts.googleapis.com/v1/token\",\n            \"service_account_impersonation_url\": \"https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/{}:generateAccessToken\".format(\n                oidc_credentials.service_account_email\n            ),\n            \"credential_source\": {\n                \"executable\": {\n                    \"command\": tmpfile.name,\n                }\n            },\n        },\n    )\n", "system_tests/system_tests_sync/test_grpc.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport google.auth\nimport google.auth.credentials\nimport google.auth.jwt\nimport google.auth.transport.grpc\nfrom google.oauth2 import service_account\n\nfrom google.cloud import pubsub_v1\n\n\ndef test_grpc_request_with_regular_credentials(http_request):\n    credentials, project_id = google.auth.default()\n    credentials = google.auth.credentials.with_scopes_if_required(\n        credentials, scopes=[\"https://www.googleapis.com/auth/pubsub\"]\n    )\n\n\n    # Create a pub/sub client.\n    client = pubsub_v1.PublisherClient(credentials=credentials)\n\n    # list the topics and drain the iterator to test that an authorized API\n    # call works.\n    list_topics_iter = client.list_topics(project=\"projects/{}\".format(project_id))\n    list(list_topics_iter)\n\n\ndef test_grpc_request_with_regular_credentials_and_self_signed_jwt(http_request):\n    credentials, project_id = google.auth.default()\n\n    # At the time this test is being written, there are no GAPIC libraries\n    # that will trigger the self-signed JWT flow. Manually create the self-signed\n    # jwt on the service account credential to check that the request\n    # succeeds.\n    credentials = credentials.with_scopes(\n        scopes=[], default_scopes=[\"https://www.googleapis.com/auth/pubsub\"]\n    )\n    credentials._create_self_signed_jwt(audience=\"https://pubsub.googleapis.com/\")\n\n    # Create a pub/sub client.\n    client = pubsub_v1.PublisherClient(credentials=credentials)\n\n    # list the topics and drain the iterator to test that an authorized API\n    # call works.\n    list_topics_iter = client.list_topics(project=\"projects/{}\".format(project_id))\n    list(list_topics_iter)\n    \n    # Check that self-signed JWT was created and is being used\n    assert credentials._jwt_credentials is not None\n    assert credentials._jwt_credentials.token == credentials.token\n\n\ndef test_grpc_request_with_jwt_credentials():\n    credentials, project_id = google.auth.default()\n    audience = \"https://pubsub.googleapis.com/google.pubsub.v1.Publisher\"\n    credentials = google.auth.jwt.Credentials.from_signing_credentials(\n        credentials, audience=audience\n    )\n\n    # Create a pub/sub client.\n    client = pubsub_v1.PublisherClient(credentials=credentials)\n\n    # list the topics and drain the iterator to test that an authorized API\n    # call works.\n    list_topics_iter = client.list_topics(project=\"projects/{}\".format(project_id))\n    list(list_topics_iter)\n\n\ndef test_grpc_request_with_on_demand_jwt_credentials():\n    credentials, project_id = google.auth.default()\n    credentials = google.auth.jwt.OnDemandCredentials.from_signing_credentials(\n        credentials\n    )\n\n    # Create a pub/sub client.\n    client = pubsub_v1.PublisherClient(credentials=credentials)\n\n    # list the topics and drain the iterator to test that an authorized API\n    # call works.\n    list_topics_iter = client.list_topics(project=\"projects/{}\".format(project_id))\n    list(list_topics_iter)\n", "system_tests/system_tests_sync/test_requests.py": "# Copyright 2021 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport google.auth\nimport google.auth.credentials\nimport google.auth.transport.requests\nfrom google.oauth2 import service_account\n\n\ndef test_authorized_session_with_service_account_and_self_signed_jwt():\n    credentials, project_id = google.auth.default()\n\n    credentials = credentials.with_scopes(\n        scopes=[],\n        default_scopes=[\"https://www.googleapis.com/auth/pubsub\"],\n    )\n\n    session = google.auth.transport.requests.AuthorizedSession(\n        credentials=credentials, default_host=\"pubsub.googleapis.com\"\n    )\n\n    # List Pub/Sub Topics through the REST API\n    # https://cloud.google.com/pubsub/docs/reference/rest/v1/projects.topics/list\n    url = \"https://pubsub.googleapis.com/v1/projects/{}/topics\".format(project_id)\n    with session:\n        response = session.get(url)\n        response.raise_for_status()\n\n    # Check that self-signed JWT was created and is being used\n    assert credentials._jwt_credentials is not None\n    assert credentials._jwt_credentials.token.decode() == credentials.token\n", "system_tests/system_tests_sync/test_urllib3.py": "# Copyright 2021 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport google.auth\nimport google.auth.credentials\nimport google.auth.transport.requests\nfrom google.oauth2 import service_account\n\n\ndef test_authorized_session_with_service_account_and_self_signed_jwt():\n    credentials, project_id = google.auth.default()\n\n    credentials = credentials.with_scopes(\n        scopes=[],\n        default_scopes=[\"https://www.googleapis.com/auth/pubsub\"],\n    )\n\n    http = google.auth.transport.urllib3.AuthorizedHttp(\n        credentials=credentials, default_host=\"pubsub.googleapis.com\"\n    )\n\n    # List Pub/Sub Topics through the REST API\n    # https://cloud.google.com/pubsub/docs/reference/rest/v1/projects.topics/list\n    response = http.urlopen(\n        method=\"GET\",\n        url=\"https://pubsub.googleapis.com/v1/projects/{}/topics\".format(project_id)\n    )\n\n    assert response.status == 200\n\n    # Check that self-signed JWT was created and is being used\n    assert credentials._jwt_credentials is not None\n    assert credentials._jwt_credentials.token.decode() == credentials.token\n", "system_tests/system_tests_sync/test_service_account.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport pytest\n\nfrom google.auth import _helpers\nfrom google.auth import exceptions\nfrom google.auth import iam\nfrom google.oauth2 import service_account\n\n\n@pytest.fixture\ndef credentials(service_account_file):\n    yield service_account.Credentials.from_service_account_file(service_account_file)\n\n\ndef test_refresh_no_scopes(http_request, credentials):\n    with pytest.raises(exceptions.RefreshError):\n        credentials.refresh(http_request)\n\n\ndef test_refresh_success(http_request, credentials, token_info):\n    credentials = credentials.with_scopes([\"email\", \"profile\"])\n\n    credentials.refresh(http_request)\n\n    assert credentials.token\n\n    info = token_info(credentials.token)\n\n    assert info[\"email\"] == credentials.service_account_email\n    info_scopes = _helpers.string_to_scopes(info[\"scope\"])\n    assert set(info_scopes) == set(\n        [\n            \"https://www.googleapis.com/auth/userinfo.email\",\n            \"https://www.googleapis.com/auth/userinfo.profile\",\n        ]\n    )\n\ndef test_iam_signer(http_request, credentials):\n    credentials = credentials.with_scopes(\n        [\"https://www.googleapis.com/auth/iam\"]\n    )\n\n    # Verify iamcredentials signer.\n    signer = iam.Signer(\n        http_request,\n        credentials,\n        credentials.service_account_email\n    )\n    \n    signed_blob = signer.sign(\"message\")\n\n    assert isinstance(signed_blob, bytes)\n", "system_tests/system_tests_sync/test_compute_engine.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom datetime import datetime\n\nimport pytest\n\nimport google.auth\nfrom google.auth import compute_engine\nfrom google.auth import _helpers\nfrom google.auth import exceptions\nfrom google.auth import jwt\nfrom google.auth.compute_engine import _metadata\nimport google.oauth2.id_token\n\nAUDIENCE = \"https://pubsub.googleapis.com\"\n\n\n@pytest.fixture(autouse=True)\ndef check_gce_environment(http_request):\n    try:\n        _metadata.get_service_account_info(http_request)\n    except exceptions.TransportError:\n        pytest.skip(\"Compute Engine metadata service is not available.\")\n\n\ndef test_refresh(http_request, token_info):\n    credentials = compute_engine.Credentials()\n\n    credentials.refresh(http_request)\n\n    assert credentials.token is not None\n    assert credentials.service_account_email is not None\n\n    info = token_info(credentials.token)\n    info_scopes = _helpers.string_to_scopes(info[\"scope\"])\n    assert set(info_scopes) == set(credentials.scopes)\n\n\ndef test_default(verify_refresh):\n    credentials, project_id = google.auth.default()\n\n    assert project_id is not None\n    assert isinstance(credentials, compute_engine.Credentials)\n    verify_refresh(credentials)\n\n\ndef test_id_token_from_metadata(http_request):\n    credentials = compute_engine.IDTokenCredentials(\n        http_request, AUDIENCE, use_metadata_identity_endpoint=True\n    )\n    credentials.refresh(http_request)\n\n    _, payload, _, _ = jwt._unverified_decode(credentials.token)\n    assert credentials.valid\n    assert payload[\"aud\"] == AUDIENCE\n    assert datetime.fromtimestamp(payload[\"exp\"]) == credentials.expiry\n\n\ndef test_fetch_id_token(http_request):\n    token = google.oauth2.id_token.fetch_id_token(http_request, AUDIENCE)\n\n    _, payload, _, _ = jwt._unverified_decode(token)\n    assert payload[\"aud\"] == AUDIENCE\n", "system_tests/system_tests_sync/conftest.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport json\nimport os\n\nfrom google.auth import _helpers\nimport google.auth.transport.requests\nimport google.auth.transport.urllib3\nimport pytest\nimport requests\nimport urllib3\n\n\nHERE = os.path.dirname(__file__)\nDATA_DIR = os.path.join(HERE, \"../data\")\nIMPERSONATED_SERVICE_ACCOUNT_FILE = os.path.join(\n    DATA_DIR, \"impersonated_service_account.json\"\n)\nSERVICE_ACCOUNT_FILE = os.path.join(DATA_DIR, \"service_account.json\")\nURLLIB3_HTTP = urllib3.PoolManager(retries=False)\nREQUESTS_SESSION = requests.Session()\nREQUESTS_SESSION.verify = False\nTOKEN_INFO_URL = \"https://www.googleapis.com/oauth2/v3/tokeninfo\"\n\n\n@pytest.fixture\ndef service_account_file():\n    \"\"\"The full path to a valid service account key file.\"\"\"\n    yield SERVICE_ACCOUNT_FILE\n\n\n@pytest.fixture\ndef impersonated_service_account_file():\n    \"\"\"The full path to a valid service account key file.\"\"\"\n    yield IMPERSONATED_SERVICE_ACCOUNT_FILE\n\n\n@pytest.fixture\ndef authorized_user_file():\n    \"\"\"The full path to a valid authorized user file.\"\"\"\n    yield AUTHORIZED_USER_FILE\n\n\n@pytest.fixture(params=[\"urllib3\", \"requests\"])\ndef request_type(request):\n    yield request.param\n\n\n@pytest.fixture\ndef http_request(request_type):\n    \"\"\"A transport.request object.\"\"\"\n    if request_type == \"urllib3\":\n        yield google.auth.transport.urllib3.Request(URLLIB3_HTTP)\n    elif request_type == \"requests\":\n        yield google.auth.transport.requests.Request(REQUESTS_SESSION)\n\n\n@pytest.fixture\ndef authenticated_request(request_type):\n    \"\"\"A transport.request object that takes credentials\"\"\"\n    if request_type == \"urllib3\":\n\n        def wrapper(credentials):\n            return google.auth.transport.urllib3.AuthorizedHttp(\n                credentials, http=URLLIB3_HTTP\n            ).request\n\n        yield wrapper\n    elif request_type == \"requests\":\n\n        def wrapper(credentials):\n            session = google.auth.transport.requests.AuthorizedSession(credentials)\n            session.verify = False\n            return google.auth.transport.requests.Request(session)\n\n        yield wrapper\n\n\n@pytest.fixture\ndef token_info(http_request):\n    \"\"\"Returns a function that obtains OAuth2 token info.\"\"\"\n\n    def _token_info(access_token=None, id_token=None):\n        query_params = {}\n\n        if access_token is not None:\n            query_params[\"access_token\"] = access_token\n        elif id_token is not None:\n            query_params[\"id_token\"] = id_token\n        else:\n            raise ValueError(\"No token specified.\")\n\n        url = _helpers.update_query(TOKEN_INFO_URL, query_params)\n\n        response = http_request(url=url, method=\"GET\")\n\n        return json.loads(response.data.decode(\"utf-8\"))\n\n    yield _token_info\n\n\n@pytest.fixture\ndef verify_refresh(http_request):\n    \"\"\"Returns a function that verifies that credentials can be refreshed.\"\"\"\n\n    def _verify_refresh(credentials):\n        if credentials.requires_scopes:\n            credentials = credentials.with_scopes([\"email\", \"profile\"])\n\n        credentials.refresh(http_request)\n\n        assert credentials.token\n        assert credentials.valid\n\n    yield _verify_refresh\n\n\ndef verify_environment():\n    \"\"\"Checks to make sure that requisite data files are available.\"\"\"\n    if not os.path.isdir(DATA_DIR):\n        raise EnvironmentError(\n            \"In order to run system tests, test data must exist in \"\n            \"system_tests/data. See CONTRIBUTING.rst for details.\"\n        )\n\n\ndef pytest_configure(config):\n    \"\"\"Pytest hook that runs before Pytest collects any tests.\"\"\"\n    verify_environment()\n", "system_tests/system_tests_sync/__init__.py": "", "system_tests/system_tests_sync/test_oauth2_credentials.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport json\n\nfrom google.auth import _helpers\nimport google.oauth2.credentials\n\nGOOGLE_OAUTH2_TOKEN_ENDPOINT = \"https://oauth2.googleapis.com/token\"\n\n\ndef test_refresh(authorized_user_file, http_request, token_info):\n    with open(authorized_user_file, \"r\") as fh:\n        info = json.load(fh)\n\n    credentials = google.oauth2.credentials.Credentials(\n        None,  # No access token, must be refreshed.\n        refresh_token=info[\"refresh_token\"],\n        token_uri=GOOGLE_OAUTH2_TOKEN_ENDPOINT,\n        client_id=info[\"client_id\"],\n        client_secret=info[\"client_secret\"],\n    )\n\n    credentials.refresh(http_request)\n\n    assert credentials.token\n\n    info = token_info(credentials.token)\n\n    info_scopes = _helpers.string_to_scopes(info[\"scope\"])\n\n    # Canonical list of scopes at https://cloud.google.com/sdk/gcloud/reference/auth/application-default/login\n    # or do `gcloud auth application-defaut login --help`\n    canonical_scopes = set(\n        [\n            \"https://www.googleapis.com/auth/userinfo.email\",\n            \"https://www.googleapis.com/auth/cloud-platform\",\n            \"openid\",\n        ]\n    )\n    # When running the test locally, we always have an additional \"accounts.reauth\" scope.\n    canonical_scopes_with_reauth = canonical_scopes.copy()\n    canonical_scopes_with_reauth.add(\"https://www.googleapis.com/auth/accounts.reauth\")\n    assert set(info_scopes) == canonical_scopes or set(info_scopes) == canonical_scopes_with_reauth\n", "system_tests/system_tests_sync/test_mtls_http.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport json\nimport mock\nimport os\nimport time\nfrom os import path\n\n\nimport google.auth\nimport google.auth.credentials\nfrom google.auth import environment_vars\nfrom google.auth.transport import mtls\nimport google.auth.transport.requests\nimport google.auth.transport.urllib3\n\nMTLS_ENDPOINT = \"https://pubsub.mtls.googleapis.com/v1/projects/{}/topics\"\nREGULAR_ENDPOINT = \"https://pubsub.googleapis.com/v1/projects/{}/topics\"\n\n\ndef test_requests():\n    credentials, project_id = google.auth.default()\n    credentials = google.auth.credentials.with_scopes_if_required(\n        credentials, [\"https://www.googleapis.com/auth/pubsub\"]\n    )\n\n    authed_session = google.auth.transport.requests.AuthorizedSession(credentials)\n    with mock.patch.dict(os.environ, {environment_vars.GOOGLE_API_USE_CLIENT_CERTIFICATE: \"true\"}):\n        authed_session.configure_mtls_channel()\n\n    # If the devices has default client cert source, then a mutual TLS channel\n    # is supposed to be created.\n    assert authed_session.is_mtls == mtls.has_default_client_cert_source()\n\n    # Sleep 1 second to avoid 503 error.\n    time.sleep(1)\n\n    if authed_session.is_mtls:\n        response = authed_session.get(MTLS_ENDPOINT.format(project_id))\n    else:\n        response = authed_session.get(REGULAR_ENDPOINT.format(project_id))\n\n    assert response.ok\n\n\ndef test_urllib3():\n    credentials, project_id = google.auth.default()\n    credentials = google.auth.credentials.with_scopes_if_required(\n        credentials, [\"https://www.googleapis.com/auth/pubsub\"]\n    )\n\n    authed_http = google.auth.transport.urllib3.AuthorizedHttp(credentials)\n    with mock.patch.dict(os.environ, {environment_vars.GOOGLE_API_USE_CLIENT_CERTIFICATE: \"true\"}):\n        is_mtls = authed_http.configure_mtls_channel()\n\n    # If the devices has default client cert source, then a mutual TLS channel\n    # is supposed to be created.\n    assert is_mtls == mtls.has_default_client_cert_source()\n\n    # Sleep 1 second to avoid 503 error.\n    time.sleep(1)\n\n    if is_mtls:\n        response = authed_http.request(\"GET\", MTLS_ENDPOINT.format(project_id))\n    else:\n        response = authed_http.request(\"GET\", REGULAR_ENDPOINT.format(project_id))\n\n    assert response.status == 200\n\n\ndef test_requests_with_default_client_cert_source():\n    credentials, project_id = google.auth.default()\n    credentials = google.auth.credentials.with_scopes_if_required(\n        credentials, [\"https://www.googleapis.com/auth/pubsub\"]\n    )\n\n    authed_session = google.auth.transport.requests.AuthorizedSession(credentials)\n\n    if mtls.has_default_client_cert_source():\n        with mock.patch.dict(os.environ, {environment_vars.GOOGLE_API_USE_CLIENT_CERTIFICATE: \"true\"}):\n            authed_session.configure_mtls_channel(\n                client_cert_callback=mtls.default_client_cert_source()\n            )\n\n        assert authed_session.is_mtls\n\n        # Sleep 1 second to avoid 503 error.\n        time.sleep(1)\n\n        response = authed_session.get(MTLS_ENDPOINT.format(project_id))\n        assert response.ok\n\n\ndef test_urllib3_with_default_client_cert_source():\n    credentials, project_id = google.auth.default()\n    credentials = google.auth.credentials.with_scopes_if_required(\n        credentials, [\"https://www.googleapis.com/auth/pubsub\"]\n    )\n\n    authed_http = google.auth.transport.urllib3.AuthorizedHttp(credentials)\n\n    if mtls.has_default_client_cert_source():\n        with mock.patch.dict(os.environ, {environment_vars.GOOGLE_API_USE_CLIENT_CERTIFICATE: \"true\"}):\n            assert authed_http.configure_mtls_channel(\n                client_cert_callback=mtls.default_client_cert_source()\n            )\n\n        # Sleep 1 second to avoid 503 error.\n        time.sleep(1)\n\n        response = authed_http.request(\"GET\", MTLS_ENDPOINT.format(project_id))\n        assert response.status == 200\n", "system_tests/system_tests_sync/test_impersonated_credentials.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport json\nimport pytest\n\nimport google.oauth2.credentials\nfrom google.oauth2 import service_account\nimport google.auth.impersonated_credentials\nfrom google.auth import _helpers\n\n\nGOOGLE_OAUTH2_TOKEN_ENDPOINT = \"https://oauth2.googleapis.com/token\"\n\n\n@pytest.fixture\ndef service_account_credentials(service_account_file):\n    yield service_account.Credentials.from_service_account_file(service_account_file)\n\n\n@pytest.fixture\ndef impersonated_service_account_credentials(impersonated_service_account_file):\n    yield service_account.Credentials.from_service_account_file(\n        impersonated_service_account_file\n    )\n\n\ndef test_refresh_with_user_credentials_as_source(\n    authorized_user_file,\n    impersonated_service_account_credentials,\n    http_request,\n    token_info,\n):\n    with open(authorized_user_file, \"r\") as fh:\n        info = json.load(fh)\n\n    source_credentials = google.oauth2.credentials.Credentials(\n        None,\n        refresh_token=info[\"refresh_token\"],\n        token_uri=GOOGLE_OAUTH2_TOKEN_ENDPOINT,\n        client_id=info[\"client_id\"],\n        client_secret=info[\"client_secret\"],\n        # The source credential needs this scope for the generateAccessToken request\n        # The user must also have `Service Account Token Creator` on the project\n        # that owns the impersonated service account.\n        # See https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials\n        scopes=[\"https://www.googleapis.com/auth/cloud-platform\"],\n    )\n\n    source_credentials.refresh(http_request)\n\n    target_scopes = [\n        \"https://www.googleapis.com/auth/devstorage.read_only\",\n        \"https://www.googleapis.com/auth/analytics\",\n    ]\n    target_credentials = google.auth.impersonated_credentials.Credentials(\n        source_credentials=source_credentials,\n        target_principal=impersonated_service_account_credentials.service_account_email,\n        target_scopes=target_scopes,\n        lifetime=100,\n    )\n\n    target_credentials.refresh(http_request)\n    assert target_credentials.token\n\n\ndef test_refresh_with_service_account_credentials_as_source(\n    http_request,\n    service_account_credentials,\n    impersonated_service_account_credentials,\n    token_info,\n):\n    source_credentials = service_account_credentials.with_scopes([\"email\"])\n    source_credentials.refresh(http_request)\n    assert source_credentials.token\n\n    target_scopes = [\n        \"https://www.googleapis.com/auth/devstorage.read_only\",\n        \"https://www.googleapis.com/auth/analytics\",\n    ]\n    target_credentials = google.auth.impersonated_credentials.Credentials(\n        source_credentials=source_credentials,\n        target_principal=impersonated_service_account_credentials.service_account_email,\n        target_scopes=target_scopes,\n    )\n\n    target_credentials.refresh(http_request)\n    assert target_credentials.token\n", "system_tests/system_tests_sync/test_id_token.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport pytest\n\nfrom google.auth import jwt\nimport google.oauth2.id_token\n\n\ndef test_fetch_id_token(http_request):\n    audience = \"https://pubsub.googleapis.com\"\n    token = google.oauth2.id_token.fetch_id_token(http_request, audience)\n\n    _, payload, _, _ = jwt._unverified_decode(token)\n    assert payload[\"aud\"] == audience\n", "system_tests/system_tests_async/test_default.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport os\nimport pytest\n\nfrom google.auth import _default_async\n\nEXPECT_PROJECT_ID = os.environ.get(\"EXPECT_PROJECT_ID\")\n\n@pytest.mark.asyncio\nasync def test_application_default_credentials(verify_refresh):\n    credentials, project_id = _default_async.default_async()\n\n    if EXPECT_PROJECT_ID is not None:\n        assert project_id is not None\n\n    await verify_refresh(credentials)\n", "system_tests/system_tests_async/test_service_account.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport pytest\n\nfrom google.auth import _helpers\nfrom google.auth import exceptions\nfrom google.auth import iam\nfrom google.oauth2 import _service_account_async\n\n\n@pytest.fixture\ndef credentials(service_account_file):\n    yield _service_account_async.Credentials.from_service_account_file(service_account_file)\n\n\n@pytest.mark.asyncio\nasync def test_refresh_no_scopes(http_request, credentials):\n    \"\"\"\n    We expect the http request to refresh credentials\n    without scopes provided to throw an error.\n    \"\"\"\n    with pytest.raises(exceptions.RefreshError):\n        await credentials.refresh(http_request)\n\n@pytest.mark.asyncio\nasync def test_refresh_success(http_request, credentials, token_info):\n    credentials = credentials.with_scopes([\"email\", \"profile\"])\n    await credentials.refresh(http_request)\n\n    assert credentials.token\n\n    info = await token_info(credentials.token)\n\n    assert info[\"email\"] == credentials.service_account_email\n    info_scopes = _helpers.string_to_scopes(info[\"scope\"])\n    assert set(info_scopes) == set(\n        [\n            \"https://www.googleapis.com/auth/userinfo.email\",\n            \"https://www.googleapis.com/auth/userinfo.profile\",\n        ]\n    )\n", "system_tests/system_tests_async/conftest.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport json\nimport os\n\nfrom google.auth import _helpers\nimport google.auth.transport.requests\nimport google.auth.transport.urllib3\nimport pytest\nimport pytest_asyncio\nimport requests\nimport urllib3\n\nimport aiohttp\nfrom google.auth.transport import _aiohttp_requests as aiohttp_requests\nfrom system_tests.system_tests_sync import conftest as sync_conftest\n\n\nTOKEN_INFO_URL = \"https://www.googleapis.com/oauth2/v3/tokeninfo\"\n\n\n@pytest_asyncio.fixture\ndef service_account_file():\n    \"\"\"The full path to a valid service account key file.\"\"\"\n    yield sync_conftest.SERVICE_ACCOUNT_FILE\n\n\n@pytest_asyncio.fixture\ndef impersonated_service_account_file():\n    \"\"\"The full path to a valid service account key file.\"\"\"\n    yield sync_conftest.IMPERSONATED_SERVICE_ACCOUNT_FILE\n\n\n@pytest_asyncio.fixture\ndef authorized_user_file():\n    \"\"\"The full path to a valid authorized user file.\"\"\"\n    yield sync_conftest.AUTHORIZED_USER_FILE\n\n\n@pytest_asyncio.fixture\nasync def aiohttp_session():\n    async with aiohttp.ClientSession(auto_decompress=False) as session:\n        yield session\n\n\n@pytest_asyncio.fixture(params=[\"aiohttp\"])\nasync def http_request(request, aiohttp_session):\n    \"\"\"A transport.request object.\"\"\"\n    yield aiohttp_requests.Request(aiohttp_session)\n\n\n@pytest_asyncio.fixture\nasync def token_info(http_request):\n    \"\"\"Returns a function that obtains OAuth2 token info.\"\"\"\n\n    async def _token_info(access_token=None, id_token=None):\n        query_params = {}\n\n        if access_token is not None:\n            query_params[\"access_token\"] = access_token\n        elif id_token is not None:\n            query_params[\"id_token\"] = id_token\n        else:\n            raise ValueError(\"No token specified.\")\n\n        url = _helpers.update_query(sync_conftest.TOKEN_INFO_URL, query_params)\n\n        response = await http_request(url=url, method=\"GET\")\n\n        data = await response.content()\n\n        return json.loads(data.decode(\"utf-8\"))\n\n    yield _token_info\n\n\n@pytest_asyncio.fixture\nasync def verify_refresh(http_request):\n    \"\"\"Returns a function that verifies that credentials can be refreshed.\"\"\"\n\n    async def _verify_refresh(credentials):\n        if credentials.requires_scopes:\n            credentials = credentials.with_scopes([\"email\", \"profile\"])\n\n        await credentials.refresh(http_request)\n\n        assert credentials.token\n        assert credentials.valid\n\n    yield _verify_refresh\n\n\ndef verify_environment():\n    \"\"\"Checks to make sure that requisite data files are available.\"\"\"\n    if not os.path.isdir(sync_conftest.DATA_DIR):\n        raise EnvironmentError(\n            \"In order to run system tests, test data must exist in \"\n            \"system_tests/data. See CONTRIBUTING.rst for details.\"\n        )\n\n\ndef pytest_configure(config):\n    \"\"\"Pytest hook that runs before Pytest collects any tests.\"\"\"\n    verify_environment()\n", "system_tests/system_tests_async/__init__.py": "", "system_tests/system_tests_async/test_id_token.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport pytest\n\nfrom google.auth import jwt\nimport google.oauth2._id_token_async\n\n@pytest.mark.asyncio\nasync def test_fetch_id_token(http_request):\n    audience = \"https://pubsub.googleapis.com\"\n    token = await google.oauth2._id_token_async.fetch_id_token(http_request, audience)\n\n    _, payload, _, _ = jwt._unverified_decode(token)\n    assert payload[\"aud\"] == audience\n", "tests_async/test_credentials_async.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport datetime\n\nimport pytest  # type: ignore\n\nfrom google.auth import _credentials_async as credentials\nfrom google.auth import _helpers\n\n\nclass CredentialsImpl(credentials.Credentials):\n    def refresh(self, request):\n        self.token = request\n\n    def with_quota_project(self, quota_project_id):\n        raise NotImplementedError()\n\n\ndef test_credentials_constructor():\n    credentials = CredentialsImpl()\n    assert not credentials.token\n    assert not credentials.expiry\n    assert not credentials.expired\n    assert not credentials.valid\n\n\ndef test_expired_and_valid():\n    credentials = CredentialsImpl()\n    credentials.token = \"token\"\n\n    assert credentials.valid\n    assert not credentials.expired\n\n    # Set the expiration to one second more than now plus the clock skew\n    # accomodation. These credentials should be valid.\n    credentials.expiry = (\n        _helpers.utcnow() + _helpers.REFRESH_THRESHOLD + datetime.timedelta(seconds=1)\n    )\n\n    assert credentials.valid\n    assert not credentials.expired\n\n    # Set the credentials expiration to now. Because of the clock skew\n    # accomodation, these credentials should report as expired.\n    credentials.expiry = _helpers.utcnow()\n\n    assert not credentials.valid\n    assert credentials.expired\n\n\n@pytest.mark.asyncio\nasync def test_before_request():\n    credentials = CredentialsImpl()\n    request = \"token\"\n    headers = {}\n\n    # First call should call refresh, setting the token.\n    await credentials.before_request(request, \"http://example.com\", \"GET\", headers)\n    assert credentials.valid\n    assert credentials.token == \"token\"\n    assert headers[\"authorization\"] == \"Bearer token\"\n\n    request = \"token2\"\n    headers = {}\n\n    # Second call shouldn't call refresh.\n    credentials.before_request(request, \"http://example.com\", \"GET\", headers)\n\n    assert credentials.valid\n    assert credentials.token == \"token\"\n\n\ndef test_anonymous_credentials_ctor():\n    anon = credentials.AnonymousCredentials()\n\n    assert anon.token is None\n    assert anon.expiry is None\n    assert not anon.expired\n    assert anon.valid\n\n\ndef test_anonymous_credentials_refresh():\n    anon = credentials.AnonymousCredentials()\n\n    request = object()\n    with pytest.raises(ValueError):\n        anon.refresh(request)\n\n\ndef test_anonymous_credentials_apply_default():\n    anon = credentials.AnonymousCredentials()\n    headers = {}\n    anon.apply(headers)\n    assert headers == {}\n    with pytest.raises(ValueError):\n        anon.apply(headers, token=\"TOKEN\")\n\n\ndef test_anonymous_credentials_before_request():\n    anon = credentials.AnonymousCredentials()\n    request = object()\n    method = \"GET\"\n    url = \"https://example.com/api/endpoint\"\n    headers = {}\n    anon.before_request(request, method, url, headers)\n    assert headers == {}\n\n\nclass ReadOnlyScopedCredentialsImpl(credentials.ReadOnlyScoped, CredentialsImpl):\n    @property\n    def requires_scopes(self):\n        return super(ReadOnlyScopedCredentialsImpl, self).requires_scopes\n\n\ndef test_readonly_scoped_credentials_constructor():\n    credentials = ReadOnlyScopedCredentialsImpl()\n    assert credentials._scopes is None\n\n\ndef test_readonly_scoped_credentials_scopes():\n    credentials = ReadOnlyScopedCredentialsImpl()\n    credentials._scopes = [\"one\", \"two\"]\n    assert credentials.scopes == [\"one\", \"two\"]\n    assert credentials.has_scopes([\"one\"])\n    assert credentials.has_scopes([\"two\"])\n    assert credentials.has_scopes([\"one\", \"two\"])\n    assert not credentials.has_scopes([\"three\"])\n\n\ndef test_readonly_scoped_credentials_requires_scopes():\n    credentials = ReadOnlyScopedCredentialsImpl()\n    assert not credentials.requires_scopes\n\n\nclass RequiresScopedCredentialsImpl(credentials.Scoped, CredentialsImpl):\n    def __init__(self, scopes=None):\n        super(RequiresScopedCredentialsImpl, self).__init__()\n        self._scopes = scopes\n\n    @property\n    def requires_scopes(self):\n        return not self.scopes\n\n    def with_scopes(self, scopes):\n        return RequiresScopedCredentialsImpl(scopes=scopes)\n\n\ndef test_create_scoped_if_required_scoped():\n    unscoped_credentials = RequiresScopedCredentialsImpl()\n    scoped_credentials = credentials.with_scopes_if_required(\n        unscoped_credentials, [\"one\", \"two\"]\n    )\n\n    assert scoped_credentials is not unscoped_credentials\n    assert not scoped_credentials.requires_scopes\n    assert scoped_credentials.has_scopes([\"one\", \"two\"])\n\n\ndef test_create_scoped_if_required_not_scopes():\n    unscoped_credentials = CredentialsImpl()\n    scoped_credentials = credentials.with_scopes_if_required(\n        unscoped_credentials, [\"one\", \"two\"]\n    )\n\n    assert scoped_credentials is unscoped_credentials\n", "tests_async/test_jwt_async.py": "# Copyright 2020 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport datetime\nimport json\n\nimport mock\nimport pytest  # type: ignore\n\nfrom google.auth import _jwt_async as jwt_async\nfrom google.auth import crypt\nfrom google.auth import exceptions\nfrom tests import test_jwt\n\n\n@pytest.fixture\ndef signer():\n    return crypt.RSASigner.from_string(test_jwt.PRIVATE_KEY_BYTES, \"1\")\n\n\nclass TestCredentials(object):\n    SERVICE_ACCOUNT_EMAIL = \"service-account@example.com\"\n    SUBJECT = \"subject\"\n    AUDIENCE = \"audience\"\n    ADDITIONAL_CLAIMS = {\"meta\": \"data\"}\n    credentials = None\n\n    @pytest.fixture(autouse=True)\n    def credentials_fixture(self, signer):\n        self.credentials = jwt_async.Credentials(\n            signer,\n            self.SERVICE_ACCOUNT_EMAIL,\n            self.SERVICE_ACCOUNT_EMAIL,\n            self.AUDIENCE,\n        )\n\n    def test_from_service_account_info(self):\n        with open(test_jwt.SERVICE_ACCOUNT_JSON_FILE, \"r\") as fh:\n            info = json.load(fh)\n\n        credentials = jwt_async.Credentials.from_service_account_info(\n            info, audience=self.AUDIENCE\n        )\n\n        assert credentials._signer.key_id == info[\"private_key_id\"]\n        assert credentials._issuer == info[\"client_email\"]\n        assert credentials._subject == info[\"client_email\"]\n        assert credentials._audience == self.AUDIENCE\n\n    def test_from_service_account_info_args(self):\n        info = test_jwt.SERVICE_ACCOUNT_INFO.copy()\n\n        credentials = jwt_async.Credentials.from_service_account_info(\n            info,\n            subject=self.SUBJECT,\n            audience=self.AUDIENCE,\n            additional_claims=self.ADDITIONAL_CLAIMS,\n        )\n\n        assert credentials._signer.key_id == info[\"private_key_id\"]\n        assert credentials._issuer == info[\"client_email\"]\n        assert credentials._subject == self.SUBJECT\n        assert credentials._audience == self.AUDIENCE\n        assert credentials._additional_claims == self.ADDITIONAL_CLAIMS\n\n    def test_from_service_account_file(self):\n        info = test_jwt.SERVICE_ACCOUNT_INFO.copy()\n\n        credentials = jwt_async.Credentials.from_service_account_file(\n            test_jwt.SERVICE_ACCOUNT_JSON_FILE, audience=self.AUDIENCE\n        )\n\n        assert credentials._signer.key_id == info[\"private_key_id\"]\n        assert credentials._issuer == info[\"client_email\"]\n        assert credentials._subject == info[\"client_email\"]\n        assert credentials._audience == self.AUDIENCE\n\n    def test_from_service_account_file_args(self):\n        info = test_jwt.SERVICE_ACCOUNT_INFO.copy()\n\n        credentials = jwt_async.Credentials.from_service_account_file(\n            test_jwt.SERVICE_ACCOUNT_JSON_FILE,\n            subject=self.SUBJECT,\n            audience=self.AUDIENCE,\n            additional_claims=self.ADDITIONAL_CLAIMS,\n        )\n\n        assert credentials._signer.key_id == info[\"private_key_id\"]\n        assert credentials._issuer == info[\"client_email\"]\n        assert credentials._subject == self.SUBJECT\n        assert credentials._audience == self.AUDIENCE\n        assert credentials._additional_claims == self.ADDITIONAL_CLAIMS\n\n    def test_from_signing_credentials(self):\n        jwt_from_signing = self.credentials.from_signing_credentials(\n            self.credentials, audience=mock.sentinel.new_audience\n        )\n        jwt_from_info = jwt_async.Credentials.from_service_account_info(\n            test_jwt.SERVICE_ACCOUNT_INFO, audience=mock.sentinel.new_audience\n        )\n\n        assert isinstance(jwt_from_signing, jwt_async.Credentials)\n        assert jwt_from_signing._signer.key_id == jwt_from_info._signer.key_id\n        assert jwt_from_signing._issuer == jwt_from_info._issuer\n        assert jwt_from_signing._subject == jwt_from_info._subject\n        assert jwt_from_signing._audience == jwt_from_info._audience\n\n    def test_default_state(self):\n        assert not self.credentials.valid\n        # Expiration hasn't been set yet\n        assert not self.credentials.expired\n\n    def test_with_claims(self):\n        new_audience = \"new_audience\"\n        new_credentials = self.credentials.with_claims(audience=new_audience)\n\n        assert new_credentials._signer == self.credentials._signer\n        assert new_credentials._issuer == self.credentials._issuer\n        assert new_credentials._subject == self.credentials._subject\n        assert new_credentials._audience == new_audience\n        assert new_credentials._additional_claims == self.credentials._additional_claims\n        assert new_credentials._quota_project_id == self.credentials._quota_project_id\n\n    def test_with_quota_project(self):\n        quota_project_id = \"project-foo\"\n\n        new_credentials = self.credentials.with_quota_project(quota_project_id)\n        assert new_credentials._signer == self.credentials._signer\n        assert new_credentials._issuer == self.credentials._issuer\n        assert new_credentials._subject == self.credentials._subject\n        assert new_credentials._audience == self.credentials._audience\n        assert new_credentials._additional_claims == self.credentials._additional_claims\n        assert new_credentials._quota_project_id == quota_project_id\n\n    def test_sign_bytes(self):\n        to_sign = b\"123\"\n        signature = self.credentials.sign_bytes(to_sign)\n        assert crypt.verify_signature(to_sign, signature, test_jwt.PUBLIC_CERT_BYTES)\n\n    def test_signer(self):\n        assert isinstance(self.credentials.signer, crypt.RSASigner)\n\n    def test_signer_email(self):\n        assert (\n            self.credentials.signer_email\n            == test_jwt.SERVICE_ACCOUNT_INFO[\"client_email\"]\n        )\n\n    def _verify_token(self, token):\n        payload = jwt_async.decode(token, test_jwt.PUBLIC_CERT_BYTES)\n        assert payload[\"iss\"] == self.SERVICE_ACCOUNT_EMAIL\n        return payload\n\n    def test_refresh(self):\n        self.credentials.refresh(None)\n        assert self.credentials.valid\n        assert not self.credentials.expired\n\n    def test_expired(self):\n        assert not self.credentials.expired\n\n        self.credentials.refresh(None)\n        assert not self.credentials.expired\n\n        with mock.patch(\"google.auth._helpers.utcnow\") as now:\n            one_day = datetime.timedelta(days=1)\n            now.return_value = self.credentials.expiry + one_day\n            assert self.credentials.expired\n\n    @pytest.mark.asyncio\n    async def test_before_request(self):\n        headers = {}\n\n        self.credentials.refresh(None)\n        await self.credentials.before_request(\n            None, \"GET\", \"http://example.com?a=1#3\", headers\n        )\n\n        header_value = headers[\"authorization\"]\n        _, token = header_value.split(\" \")\n\n        # Since the audience is set, it should use the existing token.\n        assert token.encode(\"utf-8\") == self.credentials.token\n\n        payload = self._verify_token(token)\n        assert payload[\"aud\"] == self.AUDIENCE\n\n    @pytest.mark.asyncio\n    async def test_before_request_refreshes(self):\n        assert not self.credentials.valid\n        await self.credentials.before_request(\n            None, \"GET\", \"http://example.com?a=1#3\", {}\n        )\n        assert self.credentials.valid\n\n\nclass TestOnDemandCredentials(object):\n    SERVICE_ACCOUNT_EMAIL = \"service-account@example.com\"\n    SUBJECT = \"subject\"\n    ADDITIONAL_CLAIMS = {\"meta\": \"data\"}\n    credentials = None\n\n    @pytest.fixture(autouse=True)\n    def credentials_fixture(self, signer):\n        self.credentials = jwt_async.OnDemandCredentials(\n            signer,\n            self.SERVICE_ACCOUNT_EMAIL,\n            self.SERVICE_ACCOUNT_EMAIL,\n            max_cache_size=2,\n        )\n\n    def test_from_service_account_info(self):\n        with open(test_jwt.SERVICE_ACCOUNT_JSON_FILE, \"r\") as fh:\n            info = json.load(fh)\n\n        credentials = jwt_async.OnDemandCredentials.from_service_account_info(info)\n\n        assert credentials._signer.key_id == info[\"private_key_id\"]\n        assert credentials._issuer == info[\"client_email\"]\n        assert credentials._subject == info[\"client_email\"]\n\n    def test_from_service_account_info_args(self):\n        info = test_jwt.SERVICE_ACCOUNT_INFO.copy()\n\n        credentials = jwt_async.OnDemandCredentials.from_service_account_info(\n            info, subject=self.SUBJECT, additional_claims=self.ADDITIONAL_CLAIMS\n        )\n\n        assert credentials._signer.key_id == info[\"private_key_id\"]\n        assert credentials._issuer == info[\"client_email\"]\n        assert credentials._subject == self.SUBJECT\n        assert credentials._additional_claims == self.ADDITIONAL_CLAIMS\n\n    def test_from_service_account_file(self):\n        info = test_jwt.SERVICE_ACCOUNT_INFO.copy()\n\n        credentials = jwt_async.OnDemandCredentials.from_service_account_file(\n            test_jwt.SERVICE_ACCOUNT_JSON_FILE\n        )\n\n        assert credentials._signer.key_id == info[\"private_key_id\"]\n        assert credentials._issuer == info[\"client_email\"]\n        assert credentials._subject == info[\"client_email\"]\n\n    def test_from_service_account_file_args(self):\n        info = test_jwt.SERVICE_ACCOUNT_INFO.copy()\n\n        credentials = jwt_async.OnDemandCredentials.from_service_account_file(\n            test_jwt.SERVICE_ACCOUNT_JSON_FILE,\n            subject=self.SUBJECT,\n            additional_claims=self.ADDITIONAL_CLAIMS,\n        )\n\n        assert credentials._signer.key_id == info[\"private_key_id\"]\n        assert credentials._issuer == info[\"client_email\"]\n        assert credentials._subject == self.SUBJECT\n        assert credentials._additional_claims == self.ADDITIONAL_CLAIMS\n\n    def test_from_signing_credentials(self):\n        jwt_from_signing = self.credentials.from_signing_credentials(self.credentials)\n        jwt_from_info = jwt_async.OnDemandCredentials.from_service_account_info(\n            test_jwt.SERVICE_ACCOUNT_INFO\n        )\n\n        assert isinstance(jwt_from_signing, jwt_async.OnDemandCredentials)\n        assert jwt_from_signing._signer.key_id == jwt_from_info._signer.key_id\n        assert jwt_from_signing._issuer == jwt_from_info._issuer\n        assert jwt_from_signing._subject == jwt_from_info._subject\n\n    def test_default_state(self):\n        # Credentials are *always* valid.\n        assert self.credentials.valid\n        # Credentials *never* expire.\n        assert not self.credentials.expired\n\n    def test_with_claims(self):\n        new_claims = {\"meep\": \"moop\"}\n        new_credentials = self.credentials.with_claims(additional_claims=new_claims)\n\n        assert new_credentials._signer == self.credentials._signer\n        assert new_credentials._issuer == self.credentials._issuer\n        assert new_credentials._subject == self.credentials._subject\n        assert new_credentials._additional_claims == new_claims\n\n    def test_with_quota_project(self):\n        quota_project_id = \"project-foo\"\n        new_credentials = self.credentials.with_quota_project(quota_project_id)\n\n        assert new_credentials._signer == self.credentials._signer\n        assert new_credentials._issuer == self.credentials._issuer\n        assert new_credentials._subject == self.credentials._subject\n        assert new_credentials._additional_claims == self.credentials._additional_claims\n        assert new_credentials._quota_project_id == quota_project_id\n\n    def test_sign_bytes(self):\n        to_sign = b\"123\"\n        signature = self.credentials.sign_bytes(to_sign)\n        assert crypt.verify_signature(to_sign, signature, test_jwt.PUBLIC_CERT_BYTES)\n\n    def test_signer(self):\n        assert isinstance(self.credentials.signer, crypt.RSASigner)\n\n    def test_signer_email(self):\n        assert (\n            self.credentials.signer_email\n            == test_jwt.SERVICE_ACCOUNT_INFO[\"client_email\"]\n        )\n\n    def _verify_token(self, token):\n        payload = jwt_async.decode(token, test_jwt.PUBLIC_CERT_BYTES)\n        assert payload[\"iss\"] == self.SERVICE_ACCOUNT_EMAIL\n        return payload\n\n    def test_refresh(self):\n        with pytest.raises(exceptions.RefreshError):\n            self.credentials.refresh(None)\n\n    def test_before_request(self):\n        headers = {}\n\n        self.credentials.before_request(\n            None, \"GET\", \"http://example.com?a=1#3\", headers\n        )\n\n        _, token = headers[\"authorization\"].split(\" \")\n        payload = self._verify_token(token)\n\n        assert payload[\"aud\"] == \"http://example.com\"\n\n        # Making another request should re-use the same token.\n        self.credentials.before_request(None, \"GET\", \"http://example.com?b=2\", headers)\n\n        _, new_token = headers[\"authorization\"].split(\" \")\n\n        assert new_token == token\n\n    def test_expired_token(self):\n        self.credentials._cache[\"audience\"] = (\n            mock.sentinel.token,\n            datetime.datetime.min,\n        )\n\n        token = self.credentials._get_jwt_for_audience(\"audience\")\n\n        assert token != mock.sentinel.token\n", "tests_async/conftest.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport os\nimport sys\n\nimport mock\nimport pytest  # type: ignore\n\n\ndef pytest_configure():\n    \"\"\"Load public certificate and private key.\"\"\"\n    pytest.data_dir = os.path.join(\n        os.path.abspath(os.path.join(__file__, \"../..\")), \"tests/data\"\n    )\n\n    with open(os.path.join(pytest.data_dir, \"privatekey.pem\"), \"rb\") as fh:\n        pytest.private_key_bytes = fh.read()\n\n    with open(os.path.join(pytest.data_dir, \"public_cert.pem\"), \"rb\") as fh:\n        pytest.public_cert_bytes = fh.read()\n\n\n@pytest.fixture\ndef mock_non_existent_module(monkeypatch):\n    \"\"\"Mocks a non-existing module in sys.modules.\n\n    Additionally mocks any non-existing modules specified in the dotted path.\n    \"\"\"\n\n    def _mock_non_existent_module(path):\n        parts = path.split(\".\")\n        partial = []\n        for part in parts:\n            partial.append(part)\n            current_module = \".\".join(partial)\n            if current_module not in sys.modules:\n                monkeypatch.setitem(sys.modules, current_module, mock.MagicMock())\n\n    return _mock_non_existent_module\n", "tests_async/__init__.py": "", "tests_async/test__default_async.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport json\nimport os\n\nimport mock\nimport pytest  # type: ignore\n\nfrom google.auth import _credentials_async as credentials\nfrom google.auth import _default_async as _default\nfrom google.auth import app_engine\nfrom google.auth import compute_engine\nfrom google.auth import environment_vars\nfrom google.auth import exceptions\nfrom google.oauth2 import _service_account_async as service_account\nimport google.oauth2.credentials\nfrom tests import test__default as test_default\n\nMOCK_CREDENTIALS = mock.Mock(spec=credentials.CredentialsWithQuotaProject)\nMOCK_CREDENTIALS.with_quota_project.return_value = MOCK_CREDENTIALS\n\nLOAD_FILE_PATCH = mock.patch(\n    \"google.auth._default_async.load_credentials_from_file\",\n    return_value=(MOCK_CREDENTIALS, mock.sentinel.project_id),\n    autospec=True,\n)\n\n\ndef test_load_credentials_from_missing_file():\n    with pytest.raises(exceptions.DefaultCredentialsError) as excinfo:\n        _default.load_credentials_from_file(\"\")\n\n    assert excinfo.match(r\"not found\")\n\n\ndef test_load_credentials_from_file_invalid_json(tmpdir):\n    jsonfile = tmpdir.join(\"invalid.json\")\n    jsonfile.write(\"{\")\n\n    with pytest.raises(exceptions.DefaultCredentialsError) as excinfo:\n        _default.load_credentials_from_file(str(jsonfile))\n\n    assert excinfo.match(r\"not a valid json file\")\n\n\ndef test_load_credentials_from_file_invalid_type(tmpdir):\n    jsonfile = tmpdir.join(\"invalid.json\")\n    jsonfile.write(json.dumps({\"type\": \"not-a-real-type\"}))\n\n    with pytest.raises(exceptions.DefaultCredentialsError) as excinfo:\n        _default.load_credentials_from_file(str(jsonfile))\n\n    assert excinfo.match(r\"does not have a valid type\")\n\n\ndef test_load_credentials_from_file_authorized_user():\n    credentials, project_id = _default.load_credentials_from_file(\n        test_default.AUTHORIZED_USER_FILE\n    )\n    assert isinstance(credentials, google.oauth2._credentials_async.Credentials)\n    assert project_id is None\n\n\ndef test_load_credentials_from_file_no_type(tmpdir):\n    # use the client_secrets.json, which is valid json but not a\n    # loadable credentials type\n    with pytest.raises(exceptions.DefaultCredentialsError) as excinfo:\n        _default.load_credentials_from_file(test_default.CLIENT_SECRETS_FILE)\n\n    assert excinfo.match(r\"does not have a valid type\")\n    assert excinfo.match(r\"Type is None\")\n\n\ndef test_load_credentials_from_file_authorized_user_bad_format(tmpdir):\n    filename = tmpdir.join(\"authorized_user_bad.json\")\n    filename.write(json.dumps({\"type\": \"authorized_user\"}))\n\n    with pytest.raises(exceptions.DefaultCredentialsError) as excinfo:\n        _default.load_credentials_from_file(str(filename))\n\n    assert excinfo.match(r\"Failed to load authorized user\")\n    assert excinfo.match(r\"missing fields\")\n\n\ndef test_load_credentials_from_file_authorized_user_cloud_sdk():\n    with pytest.warns(UserWarning, match=\"Cloud SDK\"):\n        credentials, project_id = _default.load_credentials_from_file(\n            test_default.AUTHORIZED_USER_CLOUD_SDK_FILE\n        )\n    assert isinstance(credentials, google.oauth2._credentials_async.Credentials)\n    assert project_id is None\n\n    # No warning if the json file has quota project id.\n    credentials, project_id = _default.load_credentials_from_file(\n        test_default.AUTHORIZED_USER_CLOUD_SDK_WITH_QUOTA_PROJECT_ID_FILE\n    )\n    assert isinstance(credentials, google.oauth2._credentials_async.Credentials)\n    assert project_id is None\n\n\ndef test_load_credentials_from_file_authorized_user_cloud_sdk_with_scopes():\n    with pytest.warns(UserWarning, match=\"Cloud SDK\"):\n        credentials, project_id = _default.load_credentials_from_file(\n            test_default.AUTHORIZED_USER_CLOUD_SDK_FILE,\n            scopes=[\"https://www.google.com/calendar/feeds\"],\n        )\n    assert isinstance(credentials, google.oauth2._credentials_async.Credentials)\n    assert project_id is None\n    assert credentials.scopes == [\"https://www.google.com/calendar/feeds\"]\n\n\ndef test_load_credentials_from_file_authorized_user_cloud_sdk_with_quota_project():\n    credentials, project_id = _default.load_credentials_from_file(\n        test_default.AUTHORIZED_USER_CLOUD_SDK_FILE, quota_project_id=\"project-foo\"\n    )\n\n    assert isinstance(credentials, google.oauth2._credentials_async.Credentials)\n    assert project_id is None\n    assert credentials.quota_project_id == \"project-foo\"\n\n\ndef test_load_credentials_from_file_service_account():\n    credentials, project_id = _default.load_credentials_from_file(\n        test_default.SERVICE_ACCOUNT_FILE\n    )\n    assert isinstance(credentials, service_account.Credentials)\n    assert project_id == test_default.SERVICE_ACCOUNT_FILE_DATA[\"project_id\"]\n\n\ndef test_load_credentials_from_file_service_account_with_scopes():\n    credentials, project_id = _default.load_credentials_from_file(\n        test_default.SERVICE_ACCOUNT_FILE,\n        scopes=[\"https://www.google.com/calendar/feeds\"],\n    )\n    assert isinstance(credentials, service_account.Credentials)\n    assert project_id == test_default.SERVICE_ACCOUNT_FILE_DATA[\"project_id\"]\n    assert credentials.scopes == [\"https://www.google.com/calendar/feeds\"]\n\n\ndef test_load_credentials_from_file_service_account_bad_format(tmpdir):\n    filename = tmpdir.join(\"serivce_account_bad.json\")\n    filename.write(json.dumps({\"type\": \"service_account\"}))\n\n    with pytest.raises(exceptions.DefaultCredentialsError) as excinfo:\n        _default.load_credentials_from_file(str(filename))\n\n    assert excinfo.match(r\"Failed to load service account\")\n    assert excinfo.match(r\"missing fields\")\n\n\n@mock.patch.dict(os.environ, {}, clear=True)\ndef test__get_explicit_environ_credentials_no_env():\n    assert _default._get_explicit_environ_credentials() == (None, None)\n\n\n@pytest.mark.parametrize(\"quota_project_id\", [None, \"project-foo\"])\n@LOAD_FILE_PATCH\ndef test__get_explicit_environ_credentials(load, quota_project_id, monkeypatch):\n    monkeypatch.setenv(environment_vars.CREDENTIALS, \"filename\")\n\n    credentials, project_id = _default._get_explicit_environ_credentials(\n        quota_project_id=quota_project_id\n    )\n\n    assert credentials is MOCK_CREDENTIALS\n    assert project_id is mock.sentinel.project_id\n    load.assert_called_with(\"filename\", quota_project_id=quota_project_id)\n\n\n@LOAD_FILE_PATCH\ndef test__get_explicit_environ_credentials_no_project_id(load, monkeypatch):\n    load.return_value = MOCK_CREDENTIALS, None\n    monkeypatch.setenv(environment_vars.CREDENTIALS, \"filename\")\n\n    credentials, project_id = _default._get_explicit_environ_credentials()\n\n    assert credentials is MOCK_CREDENTIALS\n    assert project_id is None\n\n\n@pytest.mark.parametrize(\"quota_project_id\", [None, \"project-foo\"])\n@mock.patch(\n    \"google.auth._cloud_sdk.get_application_default_credentials_path\", autospec=True\n)\n@mock.patch(\"google.auth._default_async._get_gcloud_sdk_credentials\", autospec=True)\ndef test__get_explicit_environ_credentials_fallback_to_gcloud(\n    get_gcloud_creds, get_adc_path, quota_project_id, monkeypatch\n):\n    # Set explicit credentials path to cloud sdk credentials path.\n    get_adc_path.return_value = \"filename\"\n    monkeypatch.setenv(environment_vars.CREDENTIALS, \"filename\")\n\n    _default._get_explicit_environ_credentials(quota_project_id=quota_project_id)\n\n    # Check we fall back to cloud sdk flow since explicit credentials path is\n    # cloud sdk credentials path\n    get_gcloud_creds.assert_called_with(quota_project_id=quota_project_id)\n\n\n@pytest.mark.parametrize(\"quota_project_id\", [None, \"project-foo\"])\n@LOAD_FILE_PATCH\n@mock.patch(\n    \"google.auth._cloud_sdk.get_application_default_credentials_path\", autospec=True\n)\ndef test__get_gcloud_sdk_credentials(get_adc_path, load, quota_project_id):\n    get_adc_path.return_value = test_default.SERVICE_ACCOUNT_FILE\n\n    credentials, project_id = _default._get_gcloud_sdk_credentials(\n        quota_project_id=quota_project_id\n    )\n\n    assert credentials is MOCK_CREDENTIALS\n    assert project_id is mock.sentinel.project_id\n    load.assert_called_with(\n        test_default.SERVICE_ACCOUNT_FILE, quota_project_id=quota_project_id\n    )\n\n\n@mock.patch(\n    \"google.auth._cloud_sdk.get_application_default_credentials_path\", autospec=True\n)\ndef test__get_gcloud_sdk_credentials_non_existent(get_adc_path, tmpdir):\n    non_existent = tmpdir.join(\"non-existent\")\n    get_adc_path.return_value = str(non_existent)\n\n    credentials, project_id = _default._get_gcloud_sdk_credentials()\n\n    assert credentials is None\n    assert project_id is None\n\n\n@mock.patch(\n    \"google.auth._cloud_sdk.get_project_id\",\n    return_value=mock.sentinel.project_id,\n    autospec=True,\n)\n@mock.patch(\"os.path.isfile\", return_value=True, autospec=True)\n@LOAD_FILE_PATCH\ndef test__get_gcloud_sdk_credentials_project_id(load, unused_isfile, get_project_id):\n    # Don't return a project ID from load file, make the function check\n    # the Cloud SDK project.\n    load.return_value = MOCK_CREDENTIALS, None\n\n    credentials, project_id = _default._get_gcloud_sdk_credentials()\n\n    assert credentials == MOCK_CREDENTIALS\n    assert project_id == mock.sentinel.project_id\n    assert get_project_id.called\n\n\n@mock.patch(\"google.auth._cloud_sdk.get_project_id\", return_value=None, autospec=True)\n@mock.patch(\"os.path.isfile\", return_value=True)\n@LOAD_FILE_PATCH\ndef test__get_gcloud_sdk_credentials_no_project_id(load, unused_isfile, get_project_id):\n    # Don't return a project ID from load file, make the function check\n    # the Cloud SDK project.\n    load.return_value = MOCK_CREDENTIALS, None\n\n    credentials, project_id = _default._get_gcloud_sdk_credentials()\n\n    assert credentials == MOCK_CREDENTIALS\n    assert project_id is None\n    assert get_project_id.called\n\n\nclass _AppIdentityModule(object):\n    \"\"\"The interface of the App Idenity app engine module.\n    See https://cloud.google.com/appengine/docs/standard/python/refdocs\\\n    /google.appengine.api.app_identity.app_identity\n    \"\"\"\n\n    def get_application_id(self):\n        raise NotImplementedError()\n\n\n@pytest.fixture\ndef app_identity(monkeypatch):\n    \"\"\"Mocks the app_identity module for google.auth.app_engine.\"\"\"\n    app_identity_module = mock.create_autospec(_AppIdentityModule, instance=True)\n    monkeypatch.setattr(app_engine, \"app_identity\", app_identity_module)\n    yield app_identity_module\n\n\n@mock.patch.dict(os.environ)\ndef test__get_gae_credentials_gen1(app_identity):\n    os.environ[environment_vars.LEGACY_APPENGINE_RUNTIME] = \"python27\"\n    app_identity.get_application_id.return_value = mock.sentinel.project\n\n    credentials, project_id = _default._get_gae_credentials()\n\n    assert isinstance(credentials, app_engine.Credentials)\n    assert project_id == mock.sentinel.project\n\n\n@mock.patch.dict(os.environ)\ndef test__get_gae_credentials_gen2():\n    os.environ[\"GAE_RUNTIME\"] = \"python37\"\n    credentials, project_id = _default._get_gae_credentials()\n    assert credentials is None\n    assert project_id is None\n\n\n@mock.patch.dict(os.environ)\ndef test__get_gae_credentials_gen2_backwards_compat():\n    # compat helpers may copy GAE_RUNTIME to APPENGINE_RUNTIME\n    # for backwards compatibility with code that relies on it\n    os.environ[environment_vars.LEGACY_APPENGINE_RUNTIME] = \"python37\"\n    os.environ[\"GAE_RUNTIME\"] = \"python37\"\n    credentials, project_id = _default._get_gae_credentials()\n    assert credentials is None\n    assert project_id is None\n\n\ndef test__get_gae_credentials_env_unset():\n    assert environment_vars.LEGACY_APPENGINE_RUNTIME not in os.environ\n    assert \"GAE_RUNTIME\" not in os.environ\n    credentials, project_id = _default._get_gae_credentials()\n    assert credentials is None\n    assert project_id is None\n\n\n@mock.patch.dict(os.environ)\ndef test__get_gae_credentials_no_app_engine():\n    # test both with and without LEGACY_APPENGINE_RUNTIME setting\n    assert environment_vars.LEGACY_APPENGINE_RUNTIME not in os.environ\n\n    import sys\n\n    with mock.patch.dict(sys.modules, {\"google.auth.app_engine\": None}):\n        credentials, project_id = _default._get_gae_credentials()\n        assert credentials is None\n        assert project_id is None\n\n        os.environ[environment_vars.LEGACY_APPENGINE_RUNTIME] = \"python27\"\n        credentials, project_id = _default._get_gae_credentials()\n        assert credentials is None\n        assert project_id is None\n\n\n@mock.patch.dict(os.environ)\n@mock.patch.object(app_engine, \"app_identity\", new=None)\ndef test__get_gae_credentials_no_apis():\n    # test both with and without LEGACY_APPENGINE_RUNTIME setting\n    assert environment_vars.LEGACY_APPENGINE_RUNTIME not in os.environ\n\n    credentials, project_id = _default._get_gae_credentials()\n    assert credentials is None\n    assert project_id is None\n\n    os.environ[environment_vars.LEGACY_APPENGINE_RUNTIME] = \"python27\"\n    credentials, project_id = _default._get_gae_credentials()\n    assert credentials is None\n    assert project_id is None\n\n\n@mock.patch(\n    \"google.auth.compute_engine._metadata.is_on_gce\", return_value=True, autospec=True\n)\n@mock.patch(\n    \"google.auth.compute_engine._metadata.get_project_id\",\n    return_value=\"example-project\",\n    autospec=True,\n)\ndef test__get_gce_credentials(unused_get, unused_ping):\n    credentials, project_id = _default._get_gce_credentials()\n\n    assert isinstance(credentials, compute_engine.Credentials)\n    assert project_id == \"example-project\"\n\n\n@mock.patch(\n    \"google.auth.compute_engine._metadata.is_on_gce\", return_value=False, autospec=True\n)\ndef test__get_gce_credentials_no_ping(unused_ping):\n    credentials, project_id = _default._get_gce_credentials()\n\n    assert credentials is None\n    assert project_id is None\n\n\n@mock.patch(\n    \"google.auth.compute_engine._metadata.is_on_gce\", return_value=True, autospec=True\n)\n@mock.patch(\n    \"google.auth.compute_engine._metadata.get_project_id\",\n    side_effect=exceptions.TransportError(),\n    autospec=True,\n)\ndef test__get_gce_credentials_no_project_id(unused_get, unused_ping):\n    credentials, project_id = _default._get_gce_credentials()\n\n    assert isinstance(credentials, compute_engine.Credentials)\n    assert project_id is None\n\n\ndef test__get_gce_credentials_no_compute_engine():\n    import sys\n\n    with mock.patch.dict(\"sys.modules\"):\n        sys.modules[\"google.auth.compute_engine\"] = None\n        credentials, project_id = _default._get_gce_credentials()\n        assert credentials is None\n        assert project_id is None\n\n\n@mock.patch(\n    \"google.auth.compute_engine._metadata.is_on_gce\", return_value=False, autospec=True\n)\ndef test__get_gce_credentials_explicit_request(ping):\n    _default._get_gce_credentials(mock.sentinel.request)\n    ping.assert_called_with(request=mock.sentinel.request)\n\n\n@mock.patch(\n    \"google.auth._default_async._get_explicit_environ_credentials\",\n    return_value=(MOCK_CREDENTIALS, mock.sentinel.project_id),\n    autospec=True,\n)\ndef test_default_early_out(unused_get):\n    assert _default.default_async() == (MOCK_CREDENTIALS, mock.sentinel.project_id)\n\n\n@mock.patch(\n    \"google.auth._default_async._get_explicit_environ_credentials\",\n    return_value=(MOCK_CREDENTIALS, mock.sentinel.project_id),\n    autospec=True,\n)\ndef test_default_explict_project_id(unused_get, monkeypatch):\n    monkeypatch.setenv(environment_vars.PROJECT, \"explicit-env\")\n    assert _default.default_async() == (MOCK_CREDENTIALS, \"explicit-env\")\n\n\n@mock.patch(\n    \"google.auth._default_async._get_explicit_environ_credentials\",\n    return_value=(MOCK_CREDENTIALS, mock.sentinel.project_id),\n    autospec=True,\n)\ndef test_default_explict_legacy_project_id(unused_get, monkeypatch):\n    monkeypatch.setenv(environment_vars.LEGACY_PROJECT, \"explicit-env\")\n    assert _default.default_async() == (MOCK_CREDENTIALS, \"explicit-env\")\n\n\n@mock.patch(\"logging.Logger.warning\", autospec=True)\n@mock.patch(\n    \"google.auth._default_async._get_explicit_environ_credentials\",\n    return_value=(MOCK_CREDENTIALS, None),\n    autospec=True,\n)\n@mock.patch(\n    \"google.auth._default_async._get_gcloud_sdk_credentials\",\n    return_value=(MOCK_CREDENTIALS, None),\n    autospec=True,\n)\n@mock.patch(\n    \"google.auth._default_async._get_gae_credentials\",\n    return_value=(MOCK_CREDENTIALS, None),\n    autospec=True,\n)\n@mock.patch(\n    \"google.auth._default_async._get_gce_credentials\",\n    return_value=(MOCK_CREDENTIALS, None),\n    autospec=True,\n)\ndef test_default_without_project_id(\n    unused_gce, unused_gae, unused_sdk, unused_explicit, logger_warning\n):\n    assert _default.default_async() == (MOCK_CREDENTIALS, None)\n    logger_warning.assert_called_with(mock.ANY, mock.ANY, mock.ANY)\n\n\n@mock.patch(\n    \"google.auth._default_async._get_explicit_environ_credentials\",\n    return_value=(None, None),\n    autospec=True,\n)\n@mock.patch(\n    \"google.auth._default_async._get_gcloud_sdk_credentials\",\n    return_value=(None, None),\n    autospec=True,\n)\n@mock.patch(\n    \"google.auth._default_async._get_gae_credentials\",\n    return_value=(None, None),\n    autospec=True,\n)\n@mock.patch(\n    \"google.auth._default_async._get_gce_credentials\",\n    return_value=(None, None),\n    autospec=True,\n)\ndef test_default_fail(unused_gce, unused_gae, unused_sdk, unused_explicit):\n    with pytest.raises(exceptions.DefaultCredentialsError):\n        assert _default.default_async()\n\n\n@mock.patch(\n    \"google.auth._default_async._get_explicit_environ_credentials\",\n    return_value=(MOCK_CREDENTIALS, mock.sentinel.project_id),\n    autospec=True,\n)\n@mock.patch(\n    \"google.auth._credentials_async.with_scopes_if_required\",\n    return_value=MOCK_CREDENTIALS,\n    autospec=True,\n)\ndef test_default_scoped(with_scopes, unused_get):\n    scopes = [\"one\", \"two\"]\n\n    credentials, project_id = _default.default_async(scopes=scopes)\n\n    assert credentials == with_scopes.return_value\n    assert project_id == mock.sentinel.project_id\n    with_scopes.assert_called_once_with(MOCK_CREDENTIALS, scopes)\n\n\n@mock.patch(\n    \"google.auth._default_async._get_explicit_environ_credentials\",\n    return_value=(MOCK_CREDENTIALS, mock.sentinel.project_id),\n    autospec=True,\n)\ndef test_default_no_app_engine_compute_engine_module(unused_get):\n    \"\"\"\n    google.auth.compute_engine and google.auth.app_engine are both optional\n    to allow not including them when using this package. This verifies\n    that default fails gracefully if these modules are absent\n    \"\"\"\n    import sys\n\n    with mock.patch.dict(\"sys.modules\"):\n        sys.modules[\"google.auth.compute_engine\"] = None\n        sys.modules[\"google.auth.app_engine\"] = None\n        assert _default.default_async() == (MOCK_CREDENTIALS, mock.sentinel.project_id)\n\n\n@mock.patch(\n    \"google.auth._cloud_sdk.get_application_default_credentials_path\", autospec=True\n)\ndef test_default_warning_without_quota_project_id_for_user_creds(get_adc_path):\n    get_adc_path.return_value = test_default.AUTHORIZED_USER_CLOUD_SDK_FILE\n\n    with pytest.warns(UserWarning, match=\"Cloud SDK\"):\n        credentials, project_id = _default.default_async(quota_project_id=None)\n\n\n@mock.patch(\n    \"google.auth._cloud_sdk.get_application_default_credentials_path\", autospec=True\n)\ndef test_default_no_warning_with_quota_project_id_for_user_creds(get_adc_path):\n    get_adc_path.return_value = test_default.AUTHORIZED_USER_CLOUD_SDK_FILE\n\n    credentials, project_id = _default.default_async(quota_project_id=\"project-foo\")\n", "tests_async/oauth2/test_credentials_async.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport datetime\nimport json\nimport os\nimport pickle\nimport sys\n\nimport mock\nimport pytest  # type: ignore\n\nfrom google.auth import _helpers\nfrom google.auth import exceptions\nfrom google.oauth2 import _credentials_async as _credentials_async\nfrom google.oauth2 import credentials\nfrom tests.oauth2 import test_credentials\n\n\nclass TestCredentials:\n\n    TOKEN_URI = \"https://example.com/oauth2/token\"\n    REFRESH_TOKEN = \"refresh_token\"\n    CLIENT_ID = \"client_id\"\n    CLIENT_SECRET = \"client_secret\"\n\n    @classmethod\n    def make_credentials(cls):\n        return _credentials_async.Credentials(\n            token=None,\n            refresh_token=cls.REFRESH_TOKEN,\n            token_uri=cls.TOKEN_URI,\n            client_id=cls.CLIENT_ID,\n            client_secret=cls.CLIENT_SECRET,\n            enable_reauth_refresh=True,\n        )\n\n    def test_default_state(self):\n        credentials = self.make_credentials()\n        assert not credentials.valid\n        # Expiration hasn't been set yet\n        assert not credentials.expired\n        # Scopes aren't required for these credentials\n        assert not credentials.requires_scopes\n        # Test properties\n        assert credentials.refresh_token == self.REFRESH_TOKEN\n        assert credentials.token_uri == self.TOKEN_URI\n        assert credentials.client_id == self.CLIENT_ID\n        assert credentials.client_secret == self.CLIENT_SECRET\n\n    @mock.patch(\"google.oauth2._reauth_async.refresh_grant\", autospec=True)\n    @mock.patch(\n        \"google.auth._helpers.utcnow\",\n        return_value=datetime.datetime.min + _helpers.REFRESH_THRESHOLD,\n    )\n    @pytest.mark.asyncio\n    async def test_refresh_success(self, unused_utcnow, refresh_grant):\n        token = \"token\"\n        expiry = _helpers.utcnow() + datetime.timedelta(seconds=500)\n        grant_response = {\"id_token\": mock.sentinel.id_token}\n        rapt_token = \"rapt_token\"\n        refresh_grant.return_value = (\n            # Access token\n            token,\n            # New refresh token\n            None,\n            # Expiry,\n            expiry,\n            # Extra data\n            grant_response,\n            # Rapt token\n            rapt_token,\n        )\n\n        request = mock.AsyncMock(spec=[\"transport.Request\"])\n        creds = self.make_credentials()\n\n        # Refresh credentials\n        await creds.refresh(request)\n\n        # Check jwt grant call.\n        refresh_grant.assert_called_with(\n            request,\n            self.TOKEN_URI,\n            self.REFRESH_TOKEN,\n            self.CLIENT_ID,\n            self.CLIENT_SECRET,\n            None,\n            None,\n            True,\n        )\n\n        # Check that the credentials have the token and expiry\n        assert creds.token == token\n        assert creds.expiry == expiry\n        assert creds.id_token == mock.sentinel.id_token\n        assert creds.rapt_token == rapt_token\n\n        # Check that the credentials are valid (have a token and are not\n        # expired)\n        assert creds.valid\n\n    @pytest.mark.asyncio\n    async def test_refresh_no_refresh_token(self):\n        request = mock.AsyncMock(spec=[\"transport.Request\"])\n        credentials_ = _credentials_async.Credentials(token=None, refresh_token=None)\n\n        with pytest.raises(exceptions.RefreshError, match=\"necessary fields\"):\n            await credentials_.refresh(request)\n\n        request.assert_not_called()\n\n    @mock.patch(\"google.oauth2._reauth_async.refresh_grant\", autospec=True)\n    @mock.patch(\n        \"google.auth._helpers.utcnow\",\n        return_value=datetime.datetime.min + _helpers.REFRESH_THRESHOLD,\n    )\n    @pytest.mark.asyncio\n    async def test_credentials_with_scopes_requested_refresh_success(\n        self, unused_utcnow, refresh_grant\n    ):\n        scopes = [\"email\", \"profile\"]\n        token = \"token\"\n        expiry = _helpers.utcnow() + datetime.timedelta(seconds=500)\n        grant_response = {\"id_token\": mock.sentinel.id_token}\n        rapt_token = \"rapt_token\"\n        refresh_grant.return_value = (\n            # Access token\n            token,\n            # New refresh token\n            None,\n            # Expiry,\n            expiry,\n            # Extra data\n            grant_response,\n            # Rapt token\n            rapt_token,\n        )\n\n        request = mock.AsyncMock(spec=[\"transport.Request\"])\n        creds = _credentials_async.Credentials(\n            token=None,\n            refresh_token=self.REFRESH_TOKEN,\n            token_uri=self.TOKEN_URI,\n            client_id=self.CLIENT_ID,\n            client_secret=self.CLIENT_SECRET,\n            scopes=scopes,\n            rapt_token=\"old_rapt_token\",\n        )\n\n        # Refresh credentials\n        await creds.refresh(request)\n\n        # Check jwt grant call.\n        refresh_grant.assert_called_with(\n            request,\n            self.TOKEN_URI,\n            self.REFRESH_TOKEN,\n            self.CLIENT_ID,\n            self.CLIENT_SECRET,\n            scopes,\n            \"old_rapt_token\",\n            False,\n        )\n\n        # Check that the credentials have the token and expiry\n        assert creds.token == token\n        assert creds.expiry == expiry\n        assert creds.id_token == mock.sentinel.id_token\n        assert creds.has_scopes(scopes)\n        assert creds.rapt_token == rapt_token\n\n        # Check that the credentials are valid (have a token and are not\n        # expired.)\n        assert creds.valid\n\n    @mock.patch(\"google.oauth2._reauth_async.refresh_grant\", autospec=True)\n    @mock.patch(\n        \"google.auth._helpers.utcnow\",\n        return_value=datetime.datetime.min + _helpers.REFRESH_THRESHOLD,\n    )\n    @pytest.mark.asyncio\n    async def test_credentials_with_scopes_returned_refresh_success(\n        self, unused_utcnow, refresh_grant\n    ):\n        scopes = [\"email\", \"profile\"]\n        token = \"token\"\n        expiry = _helpers.utcnow() + datetime.timedelta(seconds=500)\n        grant_response = {\"id_token\": mock.sentinel.id_token, \"scope\": \" \".join(scopes)}\n        rapt_token = \"rapt_token\"\n        refresh_grant.return_value = (\n            # Access token\n            token,\n            # New refresh token\n            None,\n            # Expiry,\n            expiry,\n            # Extra data\n            grant_response,\n            # Rapt token\n            rapt_token,\n        )\n\n        request = mock.AsyncMock(spec=[\"transport.Request\"])\n        creds = _credentials_async.Credentials(\n            token=None,\n            refresh_token=self.REFRESH_TOKEN,\n            token_uri=self.TOKEN_URI,\n            client_id=self.CLIENT_ID,\n            client_secret=self.CLIENT_SECRET,\n            scopes=scopes,\n        )\n\n        # Refresh credentials\n        await creds.refresh(request)\n\n        # Check jwt grant call.\n        refresh_grant.assert_called_with(\n            request,\n            self.TOKEN_URI,\n            self.REFRESH_TOKEN,\n            self.CLIENT_ID,\n            self.CLIENT_SECRET,\n            scopes,\n            None,\n            False,\n        )\n\n        # Check that the credentials have the token and expiry\n        assert creds.token == token\n        assert creds.expiry == expiry\n        assert creds.id_token == mock.sentinel.id_token\n        assert creds.has_scopes(scopes)\n        assert creds.rapt_token == rapt_token\n\n        # Check that the credentials are valid (have a token and are not\n        # expired.)\n        assert creds.valid\n\n    @mock.patch(\"google.oauth2._reauth_async.refresh_grant\", autospec=True)\n    @mock.patch(\n        \"google.auth._helpers.utcnow\",\n        return_value=datetime.datetime.min + _helpers.REFRESH_THRESHOLD,\n    )\n    @pytest.mark.asyncio\n    async def test_credentials_with_scopes_refresh_failure_raises_refresh_error(\n        self, unused_utcnow, refresh_grant\n    ):\n        scopes = [\"email\", \"profile\"]\n        scopes_returned = [\"email\"]\n        token = \"token\"\n        expiry = _helpers.utcnow() + datetime.timedelta(seconds=500)\n        grant_response = {\n            \"id_token\": mock.sentinel.id_token,\n            \"scope\": \" \".join(scopes_returned),\n        }\n        rapt_token = \"rapt_token\"\n        refresh_grant.return_value = (\n            # Access token\n            token,\n            # New refresh token\n            None,\n            # Expiry,\n            expiry,\n            # Extra data\n            grant_response,\n            # Rapt token\n            rapt_token,\n        )\n\n        request = mock.AsyncMock(spec=[\"transport.Request\"])\n        creds = _credentials_async.Credentials(\n            token=None,\n            refresh_token=self.REFRESH_TOKEN,\n            token_uri=self.TOKEN_URI,\n            client_id=self.CLIENT_ID,\n            client_secret=self.CLIENT_SECRET,\n            scopes=scopes,\n            rapt_token=None,\n        )\n\n        # Refresh credentials\n        with pytest.raises(\n            exceptions.RefreshError, match=\"Not all requested scopes were granted\"\n        ):\n            await creds.refresh(request)\n\n        # Check jwt grant call.\n        refresh_grant.assert_called_with(\n            request,\n            self.TOKEN_URI,\n            self.REFRESH_TOKEN,\n            self.CLIENT_ID,\n            self.CLIENT_SECRET,\n            scopes,\n            None,\n            False,\n        )\n\n        # Check that the credentials have the token and expiry\n        assert creds.token == token\n        assert creds.expiry == expiry\n        assert creds.id_token == mock.sentinel.id_token\n        assert creds.has_scopes(scopes)\n\n        # Check that the credentials are valid (have a token and are not\n        # expired.)\n        assert creds.valid\n\n    def test_apply_with_quota_project_id(self):\n        creds = _credentials_async.Credentials(\n            token=\"token\",\n            refresh_token=self.REFRESH_TOKEN,\n            token_uri=self.TOKEN_URI,\n            client_id=self.CLIENT_ID,\n            client_secret=self.CLIENT_SECRET,\n            quota_project_id=\"quota-project-123\",\n        )\n\n        headers = {}\n        creds.apply(headers)\n        assert headers[\"x-goog-user-project\"] == \"quota-project-123\"\n\n    def test_apply_with_no_quota_project_id(self):\n        creds = _credentials_async.Credentials(\n            token=\"token\",\n            refresh_token=self.REFRESH_TOKEN,\n            token_uri=self.TOKEN_URI,\n            client_id=self.CLIENT_ID,\n            client_secret=self.CLIENT_SECRET,\n        )\n\n        headers = {}\n        creds.apply(headers)\n        assert \"x-goog-user-project\" not in headers\n\n    def test_with_quota_project(self):\n        creds = _credentials_async.Credentials(\n            token=\"token\",\n            refresh_token=self.REFRESH_TOKEN,\n            token_uri=self.TOKEN_URI,\n            client_id=self.CLIENT_ID,\n            client_secret=self.CLIENT_SECRET,\n            quota_project_id=\"quota-project-123\",\n        )\n\n        new_creds = creds.with_quota_project(\"new-project-456\")\n        assert new_creds.quota_project_id == \"new-project-456\"\n        headers = {}\n        creds.apply(headers)\n        assert \"x-goog-user-project\" in headers\n\n    def test_from_authorized_user_info(self):\n        info = test_credentials.AUTH_USER_INFO.copy()\n\n        creds = _credentials_async.Credentials.from_authorized_user_info(info)\n        assert creds.client_secret == info[\"client_secret\"]\n        assert creds.client_id == info[\"client_id\"]\n        assert creds.refresh_token == info[\"refresh_token\"]\n        assert creds.token_uri == credentials._GOOGLE_OAUTH2_TOKEN_ENDPOINT\n        assert creds.scopes is None\n\n        scopes = [\"email\", \"profile\"]\n        creds = _credentials_async.Credentials.from_authorized_user_info(info, scopes)\n        assert creds.client_secret == info[\"client_secret\"]\n        assert creds.client_id == info[\"client_id\"]\n        assert creds.refresh_token == info[\"refresh_token\"]\n        assert creds.token_uri == credentials._GOOGLE_OAUTH2_TOKEN_ENDPOINT\n        assert creds.scopes == scopes\n\n    def test_from_authorized_user_file(self):\n        info = test_credentials.AUTH_USER_INFO.copy()\n\n        creds = _credentials_async.Credentials.from_authorized_user_file(\n            test_credentials.AUTH_USER_JSON_FILE\n        )\n        assert creds.client_secret == info[\"client_secret\"]\n        assert creds.client_id == info[\"client_id\"]\n        assert creds.refresh_token == info[\"refresh_token\"]\n        assert creds.token_uri == credentials._GOOGLE_OAUTH2_TOKEN_ENDPOINT\n        assert creds.scopes is None\n\n        scopes = [\"email\", \"profile\"]\n        creds = _credentials_async.Credentials.from_authorized_user_file(\n            test_credentials.AUTH_USER_JSON_FILE, scopes\n        )\n        assert creds.client_secret == info[\"client_secret\"]\n        assert creds.client_id == info[\"client_id\"]\n        assert creds.refresh_token == info[\"refresh_token\"]\n        assert creds.token_uri == credentials._GOOGLE_OAUTH2_TOKEN_ENDPOINT\n        assert creds.scopes == scopes\n\n    def test_to_json(self):\n        info = test_credentials.AUTH_USER_INFO.copy()\n        creds = _credentials_async.Credentials.from_authorized_user_info(info)\n\n        # Test with no `strip` arg\n        json_output = creds.to_json()\n        json_asdict = json.loads(json_output)\n        assert json_asdict.get(\"token\") == creds.token\n        assert json_asdict.get(\"refresh_token\") == creds.refresh_token\n        assert json_asdict.get(\"token_uri\") == creds.token_uri\n        assert json_asdict.get(\"client_id\") == creds.client_id\n        assert json_asdict.get(\"scopes\") == creds.scopes\n        assert json_asdict.get(\"client_secret\") == creds.client_secret\n\n        # Test with a `strip` arg\n        json_output = creds.to_json(strip=[\"client_secret\"])\n        json_asdict = json.loads(json_output)\n        assert json_asdict.get(\"token\") == creds.token\n        assert json_asdict.get(\"refresh_token\") == creds.refresh_token\n        assert json_asdict.get(\"token_uri\") == creds.token_uri\n        assert json_asdict.get(\"client_id\") == creds.client_id\n        assert json_asdict.get(\"scopes\") == creds.scopes\n        assert json_asdict.get(\"client_secret\") is None\n\n    def test_pickle_and_unpickle(self):\n        creds = self.make_credentials()\n        unpickled = pickle.loads(pickle.dumps(creds))\n\n        # make sure attributes aren't lost during pickling\n        assert list(creds.__dict__).sort() == list(unpickled.__dict__).sort()\n\n        for attr in list(creds.__dict__):\n            if attr == \"_refresh_worker\":\n                assert getattr(unpickled, attr) is None\n            else:\n                assert getattr(creds, attr) == getattr(unpickled, attr)\n\n    def test_pickle_with_missing_attribute(self):\n        creds = self.make_credentials()\n\n        # remove an optional attribute before pickling\n        # this mimics a pickle created with a previous class definition with\n        # fewer attributes\n        del creds.__dict__[\"_quota_project_id\"]\n\n        unpickled = pickle.loads(pickle.dumps(creds))\n\n        # Attribute should be initialized by `__setstate__`\n        assert unpickled.quota_project_id is None\n\n    # pickles are not compatible across versions\n    @pytest.mark.skipif(\n        sys.version_info < (3, 5),\n        reason=\"pickle file can only be loaded with Python >= 3.5\",\n    )\n    def test_unpickle_old_credentials_pickle(self):\n        # make sure a credentials file pickled with an older\n        # library version (google-auth==1.5.1) can be unpickled\n        with open(\n            os.path.join(test_credentials.DATA_DIR, \"old_oauth_credentials_py3.pickle\"),\n            \"rb\",\n        ) as f:\n            credentials = pickle.load(f)\n            assert credentials.quota_project_id is None\n\n    @mock.patch(\"google.oauth2._credentials_async.Credentials.apply\", autospec=True)\n    @mock.patch(\"google.oauth2._credentials_async.Credentials.refresh\", autospec=True)\n    @pytest.mark.asyncio\n    async def test_before_request(self, refresh, apply):\n        cred = self.make_credentials()\n        assert not cred.valid\n        await cred.before_request(mock.Mock(), \"GET\", \"https://example.com\", {})\n        refresh.assert_called()\n        apply.assert_called()\n\n    @mock.patch(\"google.oauth2._credentials_async.Credentials.apply\", autospec=True)\n    @mock.patch(\"google.oauth2._credentials_async.Credentials.refresh\", autospec=True)\n    @pytest.mark.asyncio\n    async def test_before_request_no_refresh(self, refresh, apply):\n        cred = self.make_credentials()\n        cred.token = refresh\n        cred.expiry = None\n\n        assert cred.valid\n        await cred.before_request(mock.Mock(), \"GET\", \"https://example.com\", {})\n        refresh.assert_not_called()\n        apply.assert_called()\n\n\nclass TestUserAccessTokenCredentials(object):\n    def test_instance(self):\n        cred = _credentials_async.UserAccessTokenCredentials()\n        assert cred._account is None\n\n        cred = cred.with_account(\"account\")\n        assert cred._account == \"account\"\n\n    @mock.patch(\"google.auth._cloud_sdk.get_auth_access_token\", autospec=True)\n    def test_refresh(self, get_auth_access_token):\n        get_auth_access_token.return_value = \"access_token\"\n        cred = _credentials_async.UserAccessTokenCredentials()\n        cred.refresh(None)\n        assert cred.token == \"access_token\"\n\n    def test_with_quota_project(self):\n        cred = _credentials_async.UserAccessTokenCredentials()\n        quota_project_cred = cred.with_quota_project(\"project-foo\")\n\n        assert quota_project_cred._quota_project_id == \"project-foo\"\n        assert quota_project_cred._account == cred._account\n\n    @mock.patch(\n        \"google.oauth2._credentials_async.UserAccessTokenCredentials.apply\",\n        autospec=True,\n    )\n    @mock.patch(\n        \"google.oauth2._credentials_async.UserAccessTokenCredentials.refresh\",\n        autospec=True,\n    )\n    def test_before_request(self, refresh, apply):\n        cred = _credentials_async.UserAccessTokenCredentials()\n        cred.before_request(mock.Mock(), \"GET\", \"https://example.com\", {})\n        refresh.assert_called()\n        apply.assert_called()\n", "tests_async/oauth2/test__client_async.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport datetime\nimport http.client as http_client\nimport json\nimport urllib\n\nimport mock\nimport pytest  # type: ignore\n\nfrom google.auth import _helpers\nfrom google.auth import _jwt_async as jwt\nfrom google.auth import exceptions\nfrom google.oauth2 import _client as sync_client\nfrom google.oauth2 import _client_async as _client\nfrom tests.oauth2 import test__client as test_client\n\n\ndef make_request(response_data, status=http_client.OK, text=False):\n    response = mock.AsyncMock(spec=[\"transport.Response\"])\n    response.status = status\n    data = response_data if text else json.dumps(response_data).encode(\"utf-8\")\n    response.data = mock.AsyncMock(spec=[\"__call__\", \"read\"])\n    response.data.read = mock.AsyncMock(spec=[\"__call__\"], return_value=data)\n    response.content = mock.AsyncMock(spec=[\"__call__\"], return_value=data)\n    request = mock.AsyncMock(spec=[\"transport.Request\"])\n    request.return_value = response\n    return request\n\n\n@pytest.mark.asyncio\nasync def test__token_endpoint_request():\n\n    request = make_request({\"test\": \"response\"})\n\n    result = await _client._token_endpoint_request(\n        request, \"http://example.com\", {\"test\": \"params\"}\n    )\n\n    # Check request call\n    request.assert_called_with(\n        method=\"POST\",\n        url=\"http://example.com\",\n        headers={\"Content-Type\": \"application/x-www-form-urlencoded\"},\n        body=\"test=params\".encode(\"utf-8\"),\n    )\n\n    # Check result\n    assert result == {\"test\": \"response\"}\n\n\n@pytest.mark.asyncio\nasync def test__token_endpoint_request_text():\n\n    request = make_request(\"response\", text=True)\n\n    result = await _client._token_endpoint_request(\n        request, \"http://example.com\", {\"test\": \"params\"}\n    )\n\n    # Check request call\n    request.assert_called_with(\n        method=\"POST\",\n        url=\"http://example.com\",\n        headers={\"Content-Type\": \"application/x-www-form-urlencoded\"},\n        body=\"test=params\".encode(\"utf-8\"),\n    )\n\n    # Check result\n    assert result == \"response\"\n\n\n@pytest.mark.asyncio\nasync def test__token_endpoint_request_json():\n\n    request = make_request({\"test\": \"response\"})\n    access_token = \"access_token\"\n\n    result = await _client._token_endpoint_request(\n        request,\n        \"http://example.com\",\n        {\"test\": \"params\"},\n        access_token=access_token,\n        use_json=True,\n    )\n\n    # Check request call\n    request.assert_called_with(\n        method=\"POST\",\n        url=\"http://example.com\",\n        headers={\n            \"Content-Type\": \"application/json\",\n            \"Authorization\": \"Bearer access_token\",\n        },\n        body=b'{\"test\": \"params\"}',\n    )\n\n    # Check result\n    assert result == {\"test\": \"response\"}\n\n\n@pytest.mark.asyncio\nasync def test__token_endpoint_request_error():\n    request = make_request({}, status=http_client.BAD_REQUEST)\n\n    with pytest.raises(exceptions.RefreshError) as excinfo:\n        await _client._token_endpoint_request(request, \"http://example.com\", {})\n    assert not excinfo.value.retryable\n\n\n@pytest.mark.asyncio\nasync def test__token_endpoint_request_internal_failure_error():\n    request = make_request(\n        {\"error_description\": \"internal_failure\"}, status=http_client.BAD_REQUEST\n    )\n\n    with pytest.raises(exceptions.RefreshError) as excinfo:\n        await _client._token_endpoint_request(\n            request, \"http://example.com\", {\"error_description\": \"internal_failure\"}\n        )\n    assert excinfo.value.retryable\n\n    request = make_request(\n        {\"error\": \"internal_failure\"}, status=http_client.BAD_REQUEST\n    )\n\n    with pytest.raises(exceptions.RefreshError):\n        await _client._token_endpoint_request(\n            request, \"http://example.com\", {\"error\": \"internal_failure\"}\n        )\n    assert excinfo.value.retryable\n\n\n@pytest.mark.asyncio\nasync def test__token_endpoint_request_internal_failure_and_retry_failure_error():\n    retryable_error = mock.AsyncMock(spec=[\"transport.Response\"])\n    retryable_error.status = http_client.BAD_REQUEST\n    data = json.dumps({\"error_description\": \"internal_failure\"}).encode(\"utf-8\")\n    retryable_error.data = mock.AsyncMock(spec=[\"__call__\", \"read\"])\n    retryable_error.data.read = mock.AsyncMock(spec=[\"__call__\"], return_value=data)\n    retryable_error.content = mock.AsyncMock(spec=[\"__call__\"], return_value=data)\n\n    unretryable_error = mock.AsyncMock(spec=[\"transport.Response\"])\n    unretryable_error.status = http_client.BAD_REQUEST\n    data = json.dumps({\"error_description\": \"invalid_scope\"}).encode(\"utf-8\")\n    unretryable_error.data = mock.AsyncMock(spec=[\"__call__\", \"read\"])\n    unretryable_error.data.read = mock.AsyncMock(spec=[\"__call__\"], return_value=data)\n    unretryable_error.content = mock.AsyncMock(spec=[\"__call__\"], return_value=data)\n\n    request = mock.AsyncMock(spec=[\"transport.Request\"])\n    request.side_effect = [retryable_error, retryable_error, unretryable_error]\n\n    with pytest.raises(exceptions.RefreshError):\n        await _client._token_endpoint_request(\n            request, \"http://example.com\", {\"error_description\": \"invalid_scope\"}\n        )\n    # request should be called three times. Two retryable errors and one\n    # unretryable error to break the retry loop.\n    assert request.call_count == 3\n\n\n@pytest.mark.asyncio\nasync def test__token_endpoint_request_internal_failure_and_retry_succeeds():\n    retryable_error = mock.AsyncMock(spec=[\"transport.Response\"])\n    retryable_error.status = http_client.BAD_REQUEST\n    data = json.dumps({\"error_description\": \"internal_failure\"}).encode(\"utf-8\")\n    retryable_error.data = mock.AsyncMock(spec=[\"__call__\", \"read\"])\n    retryable_error.data.read = mock.AsyncMock(spec=[\"__call__\"], return_value=data)\n    retryable_error.content = mock.AsyncMock(spec=[\"__call__\"], return_value=data)\n\n    response = mock.AsyncMock(spec=[\"transport.Response\"])\n    response.status = http_client.OK\n    data = json.dumps({\"hello\": \"world\"}).encode(\"utf-8\")\n    response.data = mock.AsyncMock(spec=[\"__call__\", \"read\"])\n    response.data.read = mock.AsyncMock(spec=[\"__call__\"], return_value=data)\n    response.content = mock.AsyncMock(spec=[\"__call__\"], return_value=data)\n\n    request = mock.AsyncMock(spec=[\"transport.Request\"])\n    request.side_effect = [retryable_error, response]\n\n    _ = await _client._token_endpoint_request(\n        request, \"http://example.com\", {\"test\": \"params\"}\n    )\n\n    assert request.call_count == 2\n\n\ndef verify_request_params(request, params):\n    request_body = request.call_args[1][\"body\"].decode(\"utf-8\")\n    request_params = urllib.parse.parse_qs(request_body)\n\n    for key, value in params.items():\n        assert request_params[key][0] == value\n\n\n@pytest.mark.asyncio\n@mock.patch(\"google.auth._helpers.utcnow\", return_value=datetime.datetime.min)\nasync def test_jwt_grant(utcnow):\n    request = make_request(\n        {\"access_token\": \"token\", \"expires_in\": 500, \"extra\": \"data\"}\n    )\n\n    token, expiry, extra_data = await _client.jwt_grant(\n        request, \"http://example.com\", \"assertion_value\"\n    )\n\n    # Check request call\n    verify_request_params(\n        request,\n        {\"grant_type\": sync_client._JWT_GRANT_TYPE, \"assertion\": \"assertion_value\"},\n    )\n\n    # Check result\n    assert token == \"token\"\n    assert expiry == utcnow() + datetime.timedelta(seconds=500)\n    assert extra_data[\"extra\"] == \"data\"\n\n\n@pytest.mark.asyncio\nasync def test_jwt_grant_no_access_token():\n    request = make_request(\n        {\n            # No access token.\n            \"expires_in\": 500,\n            \"extra\": \"data\",\n        }\n    )\n\n    with pytest.raises(exceptions.RefreshError) as excinfo:\n        await _client.jwt_grant(request, \"http://example.com\", \"assertion_value\")\n    assert not excinfo.value.retryable\n\n\n@pytest.mark.asyncio\nasync def test_id_token_jwt_grant():\n    now = _helpers.utcnow()\n    id_token_expiry = _helpers.datetime_to_secs(now)\n    id_token = jwt.encode(test_client.SIGNER, {\"exp\": id_token_expiry}).decode(\"utf-8\")\n    request = make_request({\"id_token\": id_token, \"extra\": \"data\"})\n\n    token, expiry, extra_data = await _client.id_token_jwt_grant(\n        request, \"http://example.com\", \"assertion_value\"\n    )\n\n    # Check request call\n    verify_request_params(\n        request,\n        {\"grant_type\": sync_client._JWT_GRANT_TYPE, \"assertion\": \"assertion_value\"},\n    )\n\n    # Check result\n    assert token == id_token\n    # JWT does not store microseconds\n    now = now.replace(microsecond=0)\n    assert expiry == now\n    assert extra_data[\"extra\"] == \"data\"\n\n\n@pytest.mark.asyncio\nasync def test_id_token_jwt_grant_no_access_token():\n    request = make_request(\n        {\n            # No access token.\n            \"expires_in\": 500,\n            \"extra\": \"data\",\n        }\n    )\n\n    with pytest.raises(exceptions.RefreshError) as excinfo:\n        await _client.id_token_jwt_grant(\n            request, \"http://example.com\", \"assertion_value\"\n        )\n    assert not excinfo.value.retryable\n\n\n@pytest.mark.asyncio\n@mock.patch(\"google.auth._helpers.utcnow\", return_value=datetime.datetime.min)\nasync def test_refresh_grant(unused_utcnow):\n    request = make_request(\n        {\n            \"access_token\": \"token\",\n            \"refresh_token\": \"new_refresh_token\",\n            \"expires_in\": 500,\n            \"extra\": \"data\",\n        }\n    )\n\n    token, refresh_token, expiry, extra_data = await _client.refresh_grant(\n        request,\n        \"http://example.com\",\n        \"refresh_token\",\n        \"client_id\",\n        \"client_secret\",\n        rapt_token=\"rapt_token\",\n    )\n\n    # Check request call\n    verify_request_params(\n        request,\n        {\n            \"grant_type\": sync_client._REFRESH_GRANT_TYPE,\n            \"refresh_token\": \"refresh_token\",\n            \"client_id\": \"client_id\",\n            \"client_secret\": \"client_secret\",\n            \"rapt\": \"rapt_token\",\n        },\n    )\n\n    # Check result\n    assert token == \"token\"\n    assert refresh_token == \"new_refresh_token\"\n    assert expiry == datetime.datetime.min + datetime.timedelta(seconds=500)\n    assert extra_data[\"extra\"] == \"data\"\n\n\n@pytest.mark.asyncio\n@mock.patch(\"google.auth._helpers.utcnow\", return_value=datetime.datetime.min)\nasync def test_refresh_grant_with_scopes(unused_utcnow):\n    request = make_request(\n        {\n            \"access_token\": \"token\",\n            \"refresh_token\": \"new_refresh_token\",\n            \"expires_in\": 500,\n            \"extra\": \"data\",\n            \"scope\": test_client.SCOPES_AS_STRING,\n        }\n    )\n\n    token, refresh_token, expiry, extra_data = await _client.refresh_grant(\n        request,\n        \"http://example.com\",\n        \"refresh_token\",\n        \"client_id\",\n        \"client_secret\",\n        test_client.SCOPES_AS_LIST,\n    )\n\n    # Check request call.\n    verify_request_params(\n        request,\n        {\n            \"grant_type\": sync_client._REFRESH_GRANT_TYPE,\n            \"refresh_token\": \"refresh_token\",\n            \"client_id\": \"client_id\",\n            \"client_secret\": \"client_secret\",\n            \"scope\": test_client.SCOPES_AS_STRING,\n        },\n    )\n\n    # Check result.\n    assert token == \"token\"\n    assert refresh_token == \"new_refresh_token\"\n    assert expiry == datetime.datetime.min + datetime.timedelta(seconds=500)\n    assert extra_data[\"extra\"] == \"data\"\n\n\n@pytest.mark.asyncio\nasync def test_refresh_grant_no_access_token():\n    request = make_request(\n        {\n            # No access token.\n            \"refresh_token\": \"new_refresh_token\",\n            \"expires_in\": 500,\n            \"extra\": \"data\",\n        }\n    )\n\n    with pytest.raises(exceptions.RefreshError) as excinfo:\n        await _client.refresh_grant(\n            request, \"http://example.com\", \"refresh_token\", \"client_id\", \"client_secret\"\n        )\n    assert not excinfo.value.retryable\n\n\n@pytest.mark.asyncio\n@mock.patch(\"google.oauth2._client._parse_expiry\", return_value=None)\n@mock.patch.object(_client, \"_token_endpoint_request\", autospec=True)\nasync def test_jwt_grant_retry_default(mock_token_endpoint_request, mock_expiry):\n    _ = await _client.jwt_grant(mock.Mock(), mock.Mock(), mock.Mock())\n    mock_token_endpoint_request.assert_called_with(\n        mock.ANY, mock.ANY, mock.ANY, can_retry=True\n    )\n\n\n@pytest.mark.asyncio\n@pytest.mark.parametrize(\"can_retry\", [True, False])\n@mock.patch(\"google.oauth2._client._parse_expiry\", return_value=None)\n@mock.patch.object(_client, \"_token_endpoint_request\", autospec=True)\nasync def test_jwt_grant_retry_with_retry(\n    mock_token_endpoint_request, mock_expiry, can_retry\n):\n    _ = await _client.jwt_grant(\n        mock.AsyncMock(), mock.Mock(), mock.Mock(), can_retry=can_retry\n    )\n    mock_token_endpoint_request.assert_called_with(\n        mock.ANY, mock.ANY, mock.ANY, can_retry=can_retry\n    )\n\n\n@pytest.mark.asyncio\n@mock.patch(\"google.auth.jwt.decode\", return_value={\"exp\": 0})\n@mock.patch.object(_client, \"_token_endpoint_request\", autospec=True)\nasync def test_id_token_jwt_grant_retry_default(\n    mock_token_endpoint_request, mock_jwt_decode\n):\n    _ = await _client.id_token_jwt_grant(mock.Mock(), mock.Mock(), mock.Mock())\n    mock_token_endpoint_request.assert_called_with(\n        mock.ANY, mock.ANY, mock.ANY, can_retry=True\n    )\n\n\n@pytest.mark.asyncio\n@pytest.mark.parametrize(\"can_retry\", [True, False])\n@mock.patch(\"google.auth.jwt.decode\", return_value={\"exp\": 0})\n@mock.patch.object(_client, \"_token_endpoint_request\", autospec=True)\nasync def test_id_token_jwt_grant_retry_with_retry(\n    mock_token_endpoint_request, mock_jwt_decode, can_retry\n):\n    _ = await _client.id_token_jwt_grant(\n        mock.AsyncMock(), mock.AsyncMock(), mock.AsyncMock(), can_retry=can_retry\n    )\n    mock_token_endpoint_request.assert_called_with(\n        mock.ANY, mock.ANY, mock.ANY, can_retry=can_retry\n    )\n\n\n@pytest.mark.asyncio\n@mock.patch(\"google.oauth2._client._parse_expiry\", return_value=None)\n@mock.patch.object(_client, \"_token_endpoint_request\", autospec=True)\nasync def test_refresh_grant_retry_default(\n    mock_token_endpoint_request, mock_parse_expiry\n):\n    _ = await _client.refresh_grant(\n        mock.AsyncMock(),\n        mock.AsyncMock(),\n        mock.AsyncMock(),\n        mock.AsyncMock(),\n        mock.AsyncMock(),\n    )\n    mock_token_endpoint_request.assert_called_with(\n        mock.ANY, mock.ANY, mock.ANY, can_retry=True\n    )\n\n\n@pytest.mark.asyncio\n@pytest.mark.parametrize(\"can_retry\", [True, False])\n@mock.patch(\"google.oauth2._client._parse_expiry\", return_value=None)\n@mock.patch.object(_client, \"_token_endpoint_request\", autospec=True)\nasync def test_refresh_grant_retry_with_retry(\n    mock_token_endpoint_request, mock_parse_expiry, can_retry\n):\n    _ = await _client.refresh_grant(\n        mock.AsyncMock(),\n        mock.AsyncMock(),\n        mock.AsyncMock(),\n        mock.AsyncMock(),\n        mock.AsyncMock(),\n        can_retry=can_retry,\n    )\n    mock_token_endpoint_request.assert_called_with(\n        mock.ANY, mock.ANY, mock.ANY, can_retry=can_retry\n    )\n\n\n@pytest.mark.asyncio\n@pytest.mark.parametrize(\"can_retry\", [True, False])\nasync def test__token_endpoint_request_no_throw_with_retry(can_retry):\n    mock_request = make_request(\n        {\"error\": \"help\", \"error_description\": \"I'm alive\"},\n        http_client.INTERNAL_SERVER_ERROR,\n    )\n\n    _ = await _client._token_endpoint_request_no_throw(\n        mock_request,\n        mock.AsyncMock(),\n        \"body\",\n        mock.AsyncMock(),\n        mock.AsyncMock(),\n        can_retry=can_retry,\n    )\n\n    if can_retry:\n        assert mock_request.call_count == 4\n    else:\n        assert mock_request.call_count == 1\n", "tests_async/oauth2/test_reauth_async.py": "# Copyright 2021 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport copy\n\nimport mock\nimport pytest  # type: ignore\n\nfrom google.auth import exceptions\nfrom google.oauth2 import _reauth_async\nfrom google.oauth2 import reauth\n\n\nMOCK_REQUEST = mock.AsyncMock(spec=[\"transport.Request\"])\nCHALLENGES_RESPONSE_TEMPLATE = {\n    \"status\": \"CHALLENGE_REQUIRED\",\n    \"sessionId\": \"123\",\n    \"challenges\": [\n        {\n            \"status\": \"READY\",\n            \"challengeId\": 1,\n            \"challengeType\": \"PASSWORD\",\n            \"securityKey\": {},\n        }\n    ],\n}\nCHALLENGES_RESPONSE_AUTHENTICATED = {\n    \"status\": \"AUTHENTICATED\",\n    \"sessionId\": \"123\",\n    \"encodedProofOfReauthToken\": \"new_rapt_token\",\n}\n\n\nclass MockChallenge(object):\n    def __init__(self, name, locally_eligible, challenge_input):\n        self.name = name\n        self.is_locally_eligible = locally_eligible\n        self.challenge_input = challenge_input\n\n    def obtain_challenge_input(self, metadata):\n        return self.challenge_input\n\n\n@pytest.mark.asyncio\nasync def test__get_challenges():\n    with mock.patch(\n        \"google.oauth2._client_async._token_endpoint_request\"\n    ) as mock_token_endpoint_request:\n        await _reauth_async._get_challenges(MOCK_REQUEST, [\"SAML\"], \"token\")\n        mock_token_endpoint_request.assert_called_with(\n            MOCK_REQUEST,\n            reauth._REAUTH_API + \":start\",\n            {\"supportedChallengeTypes\": [\"SAML\"]},\n            access_token=\"token\",\n            use_json=True,\n        )\n\n\n@pytest.mark.asyncio\nasync def test__get_challenges_with_scopes():\n    with mock.patch(\n        \"google.oauth2._client_async._token_endpoint_request\"\n    ) as mock_token_endpoint_request:\n        await _reauth_async._get_challenges(\n            MOCK_REQUEST, [\"SAML\"], \"token\", requested_scopes=[\"scope\"]\n        )\n        mock_token_endpoint_request.assert_called_with(\n            MOCK_REQUEST,\n            reauth._REAUTH_API + \":start\",\n            {\n                \"supportedChallengeTypes\": [\"SAML\"],\n                \"oauthScopesForDomainPolicyLookup\": [\"scope\"],\n            },\n            access_token=\"token\",\n            use_json=True,\n        )\n\n\n@pytest.mark.asyncio\nasync def test__send_challenge_result():\n    with mock.patch(\n        \"google.oauth2._client_async._token_endpoint_request\"\n    ) as mock_token_endpoint_request:\n        await _reauth_async._send_challenge_result(\n            MOCK_REQUEST, \"123\", \"1\", {\"credential\": \"password\"}, \"token\"\n        )\n        mock_token_endpoint_request.assert_called_with(\n            MOCK_REQUEST,\n            reauth._REAUTH_API + \"/123:continue\",\n            {\n                \"sessionId\": \"123\",\n                \"challengeId\": \"1\",\n                \"action\": \"RESPOND\",\n                \"proposalResponse\": {\"credential\": \"password\"},\n            },\n            access_token=\"token\",\n            use_json=True,\n        )\n\n\n@pytest.mark.asyncio\nasync def test__run_next_challenge_not_ready():\n    challenges_response = copy.deepcopy(CHALLENGES_RESPONSE_TEMPLATE)\n    challenges_response[\"challenges\"][0][\"status\"] = \"STATUS_UNSPECIFIED\"\n    assert (\n        await _reauth_async._run_next_challenge(\n            challenges_response, MOCK_REQUEST, \"token\"\n        )\n        is None\n    )\n\n\n@pytest.mark.asyncio\nasync def test__run_next_challenge_not_supported():\n    challenges_response = copy.deepcopy(CHALLENGES_RESPONSE_TEMPLATE)\n    challenges_response[\"challenges\"][0][\"challengeType\"] = \"CHALLENGE_TYPE_UNSPECIFIED\"\n    with pytest.raises(exceptions.ReauthFailError) as excinfo:\n        await _reauth_async._run_next_challenge(\n            challenges_response, MOCK_REQUEST, \"token\"\n        )\n    assert excinfo.match(r\"Unsupported challenge type CHALLENGE_TYPE_UNSPECIFIED\")\n\n\n@pytest.mark.asyncio\nasync def test__run_next_challenge_not_locally_eligible():\n    mock_challenge = MockChallenge(\"PASSWORD\", False, \"challenge_input\")\n    with mock.patch(\n        \"google.oauth2.challenges.AVAILABLE_CHALLENGES\", {\"PASSWORD\": mock_challenge}\n    ):\n        with pytest.raises(exceptions.ReauthFailError) as excinfo:\n            await _reauth_async._run_next_challenge(\n                CHALLENGES_RESPONSE_TEMPLATE, MOCK_REQUEST, \"token\"\n            )\n        assert excinfo.match(r\"Challenge PASSWORD is not locally eligible\")\n\n\n@pytest.mark.asyncio\nasync def test__run_next_challenge_no_challenge_input():\n    mock_challenge = MockChallenge(\"PASSWORD\", True, None)\n    with mock.patch(\n        \"google.oauth2.challenges.AVAILABLE_CHALLENGES\", {\"PASSWORD\": mock_challenge}\n    ):\n        assert (\n            await _reauth_async._run_next_challenge(\n                CHALLENGES_RESPONSE_TEMPLATE, MOCK_REQUEST, \"token\"\n            )\n            is None\n        )\n\n\n@pytest.mark.asyncio\nasync def test__run_next_challenge_success():\n    mock_challenge = MockChallenge(\"PASSWORD\", True, {\"credential\": \"password\"})\n    with mock.patch(\n        \"google.oauth2.challenges.AVAILABLE_CHALLENGES\", {\"PASSWORD\": mock_challenge}\n    ):\n        with mock.patch(\n            \"google.oauth2._reauth_async._send_challenge_result\"\n        ) as mock_send_challenge_result:\n            await _reauth_async._run_next_challenge(\n                CHALLENGES_RESPONSE_TEMPLATE, MOCK_REQUEST, \"token\"\n            )\n            mock_send_challenge_result.assert_called_with(\n                MOCK_REQUEST, \"123\", 1, {\"credential\": \"password\"}, \"token\"\n            )\n\n\n@pytest.mark.asyncio\nasync def test__obtain_rapt_authenticated():\n    with mock.patch(\n        \"google.oauth2._reauth_async._get_challenges\",\n        return_value=CHALLENGES_RESPONSE_AUTHENTICATED,\n    ):\n        new_rapt_token = await _reauth_async._obtain_rapt(MOCK_REQUEST, \"token\", None)\n        assert new_rapt_token == \"new_rapt_token\"\n\n\n@pytest.mark.asyncio\nasync def test__obtain_rapt_authenticated_after_run_next_challenge():\n    with mock.patch(\n        \"google.oauth2._reauth_async._get_challenges\",\n        return_value=CHALLENGES_RESPONSE_TEMPLATE,\n    ):\n        with mock.patch(\n            \"google.oauth2._reauth_async._run_next_challenge\",\n            side_effect=[\n                CHALLENGES_RESPONSE_TEMPLATE,\n                CHALLENGES_RESPONSE_AUTHENTICATED,\n            ],\n        ):\n            with mock.patch(\"google.oauth2.reauth.is_interactive\", return_value=True):\n                assert (\n                    await _reauth_async._obtain_rapt(MOCK_REQUEST, \"token\", None)\n                    == \"new_rapt_token\"\n                )\n\n\n@pytest.mark.asyncio\nasync def test__obtain_rapt_unsupported_status():\n    challenges_response = copy.deepcopy(CHALLENGES_RESPONSE_TEMPLATE)\n    challenges_response[\"status\"] = \"STATUS_UNSPECIFIED\"\n    with mock.patch(\n        \"google.oauth2._reauth_async._get_challenges\", return_value=challenges_response\n    ):\n        with pytest.raises(exceptions.ReauthFailError) as excinfo:\n            await _reauth_async._obtain_rapt(MOCK_REQUEST, \"token\", None)\n        assert excinfo.match(r\"API error: STATUS_UNSPECIFIED\")\n\n\n@pytest.mark.asyncio\nasync def test__obtain_rapt_not_interactive():\n    with mock.patch(\n        \"google.oauth2._reauth_async._get_challenges\",\n        return_value=CHALLENGES_RESPONSE_TEMPLATE,\n    ):\n        with mock.patch(\"google.oauth2.reauth.is_interactive\", return_value=False):\n            with pytest.raises(exceptions.ReauthFailError) as excinfo:\n                await _reauth_async._obtain_rapt(MOCK_REQUEST, \"token\", None)\n            assert excinfo.match(r\"not in an interactive session\")\n\n\n@pytest.mark.asyncio\nasync def test__obtain_rapt_not_authenticated():\n    with mock.patch(\n        \"google.oauth2._reauth_async._get_challenges\",\n        return_value=CHALLENGES_RESPONSE_TEMPLATE,\n    ):\n        with mock.patch(\"google.oauth2.reauth.RUN_CHALLENGE_RETRY_LIMIT\", 0):\n            with pytest.raises(exceptions.ReauthFailError) as excinfo:\n                await _reauth_async._obtain_rapt(MOCK_REQUEST, \"token\", None)\n            assert excinfo.match(r\"Reauthentication failed\")\n\n\n@pytest.mark.asyncio\nasync def test_get_rapt_token():\n    with mock.patch(\n        \"google.oauth2._client_async.refresh_grant\",\n        return_value=(\"token\", None, None, None),\n    ) as mock_refresh_grant:\n        with mock.patch(\n            \"google.oauth2._reauth_async._obtain_rapt\", return_value=\"new_rapt_token\"\n        ) as mock_obtain_rapt:\n            assert (\n                await _reauth_async.get_rapt_token(\n                    MOCK_REQUEST,\n                    \"client_id\",\n                    \"client_secret\",\n                    \"refresh_token\",\n                    \"token_uri\",\n                )\n                == \"new_rapt_token\"\n            )\n            mock_refresh_grant.assert_called_with(\n                request=MOCK_REQUEST,\n                client_id=\"client_id\",\n                client_secret=\"client_secret\",\n                refresh_token=\"refresh_token\",\n                token_uri=\"token_uri\",\n                scopes=[reauth._REAUTH_SCOPE],\n            )\n            mock_obtain_rapt.assert_called_with(\n                MOCK_REQUEST, \"token\", requested_scopes=None\n            )\n\n\n@pytest.mark.asyncio\nasync def test_refresh_grant_failed():\n    with mock.patch(\n        \"google.oauth2._client_async._token_endpoint_request_no_throw\"\n    ) as mock_token_request:\n        mock_token_request.return_value = (False, {\"error\": \"Bad request\"}, True)\n        with pytest.raises(exceptions.RefreshError) as excinfo:\n            await _reauth_async.refresh_grant(\n                MOCK_REQUEST,\n                \"token_uri\",\n                \"refresh_token\",\n                \"client_id\",\n                \"client_secret\",\n                scopes=[\"foo\", \"bar\"],\n                rapt_token=\"rapt_token\",\n            )\n        assert excinfo.match(r\"Bad request\")\n        assert excinfo.value.retryable\n        mock_token_request.assert_called_with(\n            MOCK_REQUEST,\n            \"token_uri\",\n            {\n                \"grant_type\": \"refresh_token\",\n                \"client_id\": \"client_id\",\n                \"client_secret\": \"client_secret\",\n                \"refresh_token\": \"refresh_token\",\n                \"scope\": \"foo bar\",\n                \"rapt\": \"rapt_token\",\n            },\n        )\n\n\n@pytest.mark.asyncio\nasync def test_refresh_grant_success():\n    with mock.patch(\n        \"google.oauth2._client_async._token_endpoint_request_no_throw\"\n    ) as mock_token_request:\n        mock_token_request.side_effect = [\n            (False, {\"error\": \"invalid_grant\", \"error_subtype\": \"rapt_required\"}, True),\n            (True, {\"access_token\": \"access_token\"}, None),\n        ]\n        with mock.patch(\n            \"google.oauth2._reauth_async.get_rapt_token\", return_value=\"new_rapt_token\"\n        ):\n            assert await _reauth_async.refresh_grant(\n                MOCK_REQUEST,\n                \"token_uri\",\n                \"refresh_token\",\n                \"client_id\",\n                \"client_secret\",\n                enable_reauth_refresh=True,\n            ) == (\n                \"access_token\",\n                \"refresh_token\",\n                None,\n                {\"access_token\": \"access_token\"},\n                \"new_rapt_token\",\n            )\n\n\n@pytest.mark.asyncio\nasync def test_refresh_grant_reauth_refresh_disabled():\n    with mock.patch(\n        \"google.oauth2._client_async._token_endpoint_request_no_throw\"\n    ) as mock_token_request:\n        mock_token_request.side_effect = [\n            (\n                False,\n                {\"error\": \"invalid_grant\", \"error_subtype\": \"rapt_required\"},\n                False,\n            ),\n            (True, {\"access_token\": \"access_token\"}, None),\n        ]\n        with pytest.raises(exceptions.RefreshError) as excinfo:\n            assert await _reauth_async.refresh_grant(\n                MOCK_REQUEST, \"token_uri\", \"refresh_token\", \"client_id\", \"client_secret\"\n            )\n        assert excinfo.match(r\"Reauthentication is needed\")\n        assert not excinfo.value.retryable\n", "tests_async/oauth2/test_service_account_async.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport datetime\n\nimport mock\nimport pytest  # type: ignore\n\nfrom google.auth import _helpers\nfrom google.auth import crypt\nfrom google.auth import jwt\nfrom google.auth import transport\nfrom google.oauth2 import _service_account_async as service_account\nfrom tests.oauth2 import test_service_account\n\n\nclass TestCredentials(object):\n    SERVICE_ACCOUNT_EMAIL = \"service-account@example.com\"\n    TOKEN_URI = \"https://example.com/oauth2/token\"\n\n    @classmethod\n    def make_credentials(cls):\n        return service_account.Credentials(\n            test_service_account.SIGNER, cls.SERVICE_ACCOUNT_EMAIL, cls.TOKEN_URI\n        )\n\n    def test_from_service_account_info(self):\n        credentials = service_account.Credentials.from_service_account_info(\n            test_service_account.SERVICE_ACCOUNT_INFO\n        )\n\n        assert (\n            credentials._signer.key_id\n            == test_service_account.SERVICE_ACCOUNT_INFO[\"private_key_id\"]\n        )\n        assert (\n            credentials.service_account_email\n            == test_service_account.SERVICE_ACCOUNT_INFO[\"client_email\"]\n        )\n        assert (\n            credentials._token_uri\n            == test_service_account.SERVICE_ACCOUNT_INFO[\"token_uri\"]\n        )\n\n    def test_from_service_account_info_args(self):\n        info = test_service_account.SERVICE_ACCOUNT_INFO.copy()\n        scopes = [\"email\", \"profile\"]\n        subject = \"subject\"\n        additional_claims = {\"meta\": \"data\"}\n\n        credentials = service_account.Credentials.from_service_account_info(\n            info, scopes=scopes, subject=subject, additional_claims=additional_claims\n        )\n\n        assert credentials.service_account_email == info[\"client_email\"]\n        assert credentials.project_id == info[\"project_id\"]\n        assert credentials._signer.key_id == info[\"private_key_id\"]\n        assert credentials._token_uri == info[\"token_uri\"]\n        assert credentials._scopes == scopes\n        assert credentials._subject == subject\n        assert credentials._additional_claims == additional_claims\n\n    def test_from_service_account_file(self):\n        info = test_service_account.SERVICE_ACCOUNT_INFO.copy()\n\n        credentials = service_account.Credentials.from_service_account_file(\n            test_service_account.SERVICE_ACCOUNT_JSON_FILE\n        )\n\n        assert credentials.service_account_email == info[\"client_email\"]\n        assert credentials.project_id == info[\"project_id\"]\n        assert credentials._signer.key_id == info[\"private_key_id\"]\n        assert credentials._token_uri == info[\"token_uri\"]\n\n    def test_from_service_account_file_args(self):\n        info = test_service_account.SERVICE_ACCOUNT_INFO.copy()\n        scopes = [\"email\", \"profile\"]\n        subject = \"subject\"\n        additional_claims = {\"meta\": \"data\"}\n\n        credentials = service_account.Credentials.from_service_account_file(\n            test_service_account.SERVICE_ACCOUNT_JSON_FILE,\n            subject=subject,\n            scopes=scopes,\n            additional_claims=additional_claims,\n        )\n\n        assert credentials.service_account_email == info[\"client_email\"]\n        assert credentials.project_id == info[\"project_id\"]\n        assert credentials._signer.key_id == info[\"private_key_id\"]\n        assert credentials._token_uri == info[\"token_uri\"]\n        assert credentials._scopes == scopes\n        assert credentials._subject == subject\n        assert credentials._additional_claims == additional_claims\n\n    def test_default_state(self):\n        credentials = self.make_credentials()\n        assert not credentials.valid\n        # Expiration hasn't been set yet\n        assert not credentials.expired\n        # Scopes haven't been specified yet\n        assert credentials.requires_scopes\n\n    def test_sign_bytes(self):\n        credentials = self.make_credentials()\n        to_sign = b\"123\"\n        signature = credentials.sign_bytes(to_sign)\n        assert crypt.verify_signature(\n            to_sign, signature, test_service_account.PUBLIC_CERT_BYTES\n        )\n\n    def test_signer(self):\n        credentials = self.make_credentials()\n        assert isinstance(credentials.signer, crypt.Signer)\n\n    def test_signer_email(self):\n        credentials = self.make_credentials()\n        assert credentials.signer_email == self.SERVICE_ACCOUNT_EMAIL\n\n    def test_create_scoped(self):\n        credentials = self.make_credentials()\n        scopes = [\"email\", \"profile\"]\n        credentials = credentials.with_scopes(scopes)\n        assert credentials._scopes == scopes\n\n    def test_with_claims(self):\n        credentials = self.make_credentials()\n        new_credentials = credentials.with_claims({\"meep\": \"moop\"})\n        assert new_credentials._additional_claims == {\"meep\": \"moop\"}\n\n    def test_with_quota_project(self):\n        credentials = self.make_credentials()\n        new_credentials = credentials.with_quota_project(\"new-project-456\")\n        assert new_credentials.quota_project_id == \"new-project-456\"\n        hdrs = {}\n        new_credentials.apply(hdrs, token=\"tok\")\n        assert \"x-goog-user-project\" in hdrs\n\n    def test__make_authorization_grant_assertion(self):\n        credentials = self.make_credentials()\n        token = credentials._make_authorization_grant_assertion()\n        payload = jwt.decode(token, test_service_account.PUBLIC_CERT_BYTES)\n        assert payload[\"iss\"] == self.SERVICE_ACCOUNT_EMAIL\n        assert (\n            payload[\"aud\"]\n            == service_account.service_account._GOOGLE_OAUTH2_TOKEN_ENDPOINT\n        )\n\n    def test__make_authorization_grant_assertion_scoped(self):\n        credentials = self.make_credentials()\n        scopes = [\"email\", \"profile\"]\n        credentials = credentials.with_scopes(scopes)\n        token = credentials._make_authorization_grant_assertion()\n        payload = jwt.decode(token, test_service_account.PUBLIC_CERT_BYTES)\n        assert payload[\"scope\"] == \"email profile\"\n\n    def test__make_authorization_grant_assertion_subject(self):\n        credentials = self.make_credentials()\n        subject = \"user@example.com\"\n        credentials = credentials.with_subject(subject)\n        token = credentials._make_authorization_grant_assertion()\n        payload = jwt.decode(token, test_service_account.PUBLIC_CERT_BYTES)\n        assert payload[\"sub\"] == subject\n\n    @mock.patch(\"google.oauth2._client_async.jwt_grant\", autospec=True)\n    @pytest.mark.asyncio\n    async def test_refresh_success(self, jwt_grant):\n        credentials = self.make_credentials()\n        token = \"token\"\n        jwt_grant.return_value = (\n            token,\n            _helpers.utcnow() + datetime.timedelta(seconds=500),\n            {},\n        )\n        request = mock.create_autospec(transport.Request, instance=True)\n\n        # Refresh credentials\n        await credentials.refresh(request)\n\n        # Check jwt grant call.\n        assert jwt_grant.called\n\n        called_request, token_uri, assertion = jwt_grant.call_args[0]\n        assert called_request == request\n        assert token_uri == credentials._token_uri\n        assert jwt.decode(assertion, test_service_account.PUBLIC_CERT_BYTES)\n        # No further assertion done on the token, as there are separate tests\n        # for checking the authorization grant assertion.\n\n        # Check that the credentials have the token.\n        assert credentials.token == token\n\n        # Check that the credentials are valid (have a token and are not\n        # expired)\n        assert credentials.valid\n\n    @mock.patch(\"google.oauth2._client_async.jwt_grant\", autospec=True)\n    @pytest.mark.asyncio\n    async def test_before_request_refreshes(self, jwt_grant):\n        credentials = self.make_credentials()\n        token = \"token\"\n        jwt_grant.return_value = (\n            token,\n            _helpers.utcnow() + datetime.timedelta(seconds=500),\n            None,\n        )\n        request = mock.create_autospec(transport.Request, instance=True)\n\n        # Credentials should start as invalid\n        assert not credentials.valid\n\n        # before_request should cause a refresh\n        await credentials.before_request(request, \"GET\", \"http://example.com?a=1#3\", {})\n\n        # The refresh endpoint should've been called.\n        assert jwt_grant.called\n\n        # Credentials should now be valid.\n        assert credentials.valid\n\n\nclass TestIDTokenCredentials(object):\n    SERVICE_ACCOUNT_EMAIL = \"service-account@example.com\"\n    TOKEN_URI = \"https://example.com/oauth2/token\"\n    TARGET_AUDIENCE = \"https://example.com\"\n\n    @classmethod\n    def make_credentials(cls):\n        return service_account.IDTokenCredentials(\n            test_service_account.SIGNER,\n            cls.SERVICE_ACCOUNT_EMAIL,\n            cls.TOKEN_URI,\n            cls.TARGET_AUDIENCE,\n        )\n\n    def test_from_service_account_info(self):\n        credentials = service_account.IDTokenCredentials.from_service_account_info(\n            test_service_account.SERVICE_ACCOUNT_INFO,\n            target_audience=self.TARGET_AUDIENCE,\n        )\n\n        assert (\n            credentials._signer.key_id\n            == test_service_account.SERVICE_ACCOUNT_INFO[\"private_key_id\"]\n        )\n        assert (\n            credentials.service_account_email\n            == test_service_account.SERVICE_ACCOUNT_INFO[\"client_email\"]\n        )\n        assert (\n            credentials._token_uri\n            == test_service_account.SERVICE_ACCOUNT_INFO[\"token_uri\"]\n        )\n        assert credentials._target_audience == self.TARGET_AUDIENCE\n\n    def test_from_service_account_file(self):\n        info = test_service_account.SERVICE_ACCOUNT_INFO.copy()\n\n        credentials = service_account.IDTokenCredentials.from_service_account_file(\n            test_service_account.SERVICE_ACCOUNT_JSON_FILE,\n            target_audience=self.TARGET_AUDIENCE,\n        )\n\n        assert credentials.service_account_email == info[\"client_email\"]\n        assert credentials._signer.key_id == info[\"private_key_id\"]\n        assert credentials._token_uri == info[\"token_uri\"]\n        assert credentials._target_audience == self.TARGET_AUDIENCE\n\n    def test_default_state(self):\n        credentials = self.make_credentials()\n        assert not credentials.valid\n        # Expiration hasn't been set yet\n        assert not credentials.expired\n\n    def test_sign_bytes(self):\n        credentials = self.make_credentials()\n        to_sign = b\"123\"\n        signature = credentials.sign_bytes(to_sign)\n        assert crypt.verify_signature(\n            to_sign, signature, test_service_account.PUBLIC_CERT_BYTES\n        )\n\n    def test_signer(self):\n        credentials = self.make_credentials()\n        assert isinstance(credentials.signer, crypt.Signer)\n\n    def test_signer_email(self):\n        credentials = self.make_credentials()\n        assert credentials.signer_email == self.SERVICE_ACCOUNT_EMAIL\n\n    def test_with_target_audience(self):\n        credentials = self.make_credentials()\n        new_credentials = credentials.with_target_audience(\"https://new.example.com\")\n        assert new_credentials._target_audience == \"https://new.example.com\"\n\n    def test_with_quota_project(self):\n        credentials = self.make_credentials()\n        new_credentials = credentials.with_quota_project(\"project-foo\")\n        assert new_credentials._quota_project_id == \"project-foo\"\n\n    def test__make_authorization_grant_assertion(self):\n        credentials = self.make_credentials()\n        token = credentials._make_authorization_grant_assertion()\n        payload = jwt.decode(token, test_service_account.PUBLIC_CERT_BYTES)\n        assert payload[\"iss\"] == self.SERVICE_ACCOUNT_EMAIL\n        assert (\n            payload[\"aud\"]\n            == service_account.service_account._GOOGLE_OAUTH2_TOKEN_ENDPOINT\n        )\n        assert payload[\"target_audience\"] == self.TARGET_AUDIENCE\n\n    @mock.patch(\"google.oauth2._client_async.id_token_jwt_grant\", autospec=True)\n    @pytest.mark.asyncio\n    async def test_refresh_success(self, id_token_jwt_grant):\n        credentials = self.make_credentials()\n        token = \"token\"\n        id_token_jwt_grant.return_value = (\n            token,\n            _helpers.utcnow() + datetime.timedelta(seconds=500),\n            {},\n        )\n\n        request = mock.AsyncMock(spec=[\"transport.Request\"])\n\n        # Refresh credentials\n        await credentials.refresh(request)\n\n        # Check jwt grant call.\n        assert id_token_jwt_grant.called\n\n        called_request, token_uri, assertion = id_token_jwt_grant.call_args[0]\n        assert called_request == request\n        assert token_uri == credentials._token_uri\n        assert jwt.decode(assertion, test_service_account.PUBLIC_CERT_BYTES)\n        # No further assertion done on the token, as there are separate tests\n        # for checking the authorization grant assertion.\n\n        # Check that the credentials have the token.\n        assert credentials.token == token\n\n        # Check that the credentials are valid (have a token and are not\n        # expired)\n        assert credentials.valid\n\n    @mock.patch(\"google.oauth2._client_async.id_token_jwt_grant\", autospec=True)\n    @pytest.mark.asyncio\n    async def test_before_request_refreshes(self, id_token_jwt_grant):\n        credentials = self.make_credentials()\n        token = \"token\"\n        id_token_jwt_grant.return_value = (\n            token,\n            _helpers.utcnow() + datetime.timedelta(seconds=500),\n            None,\n        )\n        request = mock.AsyncMock(spec=[\"transport.Request\"])\n\n        # Credentials should start as invalid\n        assert not credentials.valid\n\n        # before_request should cause a refresh\n        await credentials.before_request(request, \"GET\", \"http://example.com?a=1#3\", {})\n\n        # The refresh endpoint should've been called.\n        assert id_token_jwt_grant.called\n\n        # Credentials should now be valid.\n        assert credentials.valid\n", "tests_async/oauth2/test_id_token.py": "# Copyright 2020 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport json\nimport os\n\nimport mock\nimport pytest  # type: ignore\n\nfrom google.auth import environment_vars\nfrom google.auth import exceptions\nimport google.auth.compute_engine._metadata\nfrom google.oauth2 import _id_token_async as id_token\nfrom google.oauth2 import _service_account_async\nfrom google.oauth2 import id_token as sync_id_token\nfrom tests.oauth2 import test_id_token\n\n\ndef make_request(status, data=None):\n    response = mock.AsyncMock(spec=[\"transport.Response\"])\n    response.status = status\n\n    if data is not None:\n        response.data = mock.AsyncMock(spec=[\"__call__\", \"read\"])\n        response.content = mock.AsyncMock(\n            spec=[\"__call__\"], return_value=json.dumps(data).encode(\"utf-8\")\n        )\n\n    request = mock.AsyncMock(spec=[\"transport.Request\"])\n    request.return_value = response\n    return request\n\n\n@pytest.mark.asyncio\nasync def test__fetch_certs_success():\n    certs = {\"1\": \"cert\"}\n    request = make_request(200, certs)\n\n    returned_certs = await id_token._fetch_certs(request, mock.sentinel.cert_url)\n\n    request.assert_called_once_with(mock.sentinel.cert_url, method=\"GET\")\n    assert returned_certs == certs\n\n\n@pytest.mark.asyncio\nasync def test__fetch_certs_failure():\n    request = make_request(404)\n\n    with pytest.raises(exceptions.TransportError):\n        await id_token._fetch_certs(request, mock.sentinel.cert_url)\n\n    request.assert_called_once_with(mock.sentinel.cert_url, method=\"GET\")\n\n\n@mock.patch(\"google.auth.jwt.decode\", autospec=True)\n@mock.patch(\"google.oauth2._id_token_async._fetch_certs\", autospec=True)\n@pytest.mark.asyncio\nasync def test_verify_token(_fetch_certs, decode):\n    result = await id_token.verify_token(mock.sentinel.token, mock.sentinel.request)\n\n    assert result == decode.return_value\n    _fetch_certs.assert_called_once_with(\n        mock.sentinel.request, sync_id_token._GOOGLE_OAUTH2_CERTS_URL\n    )\n    decode.assert_called_once_with(\n        mock.sentinel.token,\n        certs=_fetch_certs.return_value,\n        audience=None,\n        clock_skew_in_seconds=0,\n    )\n\n\n@mock.patch(\"google.auth.jwt.decode\", autospec=True)\n@mock.patch(\"google.oauth2._id_token_async._fetch_certs\", autospec=True)\n@pytest.mark.asyncio\nasync def test_verify_token_clock_skew(_fetch_certs, decode):\n    result = await id_token.verify_token(\n        mock.sentinel.token, mock.sentinel.request, clock_skew_in_seconds=10\n    )\n\n    assert result == decode.return_value\n    _fetch_certs.assert_called_once_with(\n        mock.sentinel.request, sync_id_token._GOOGLE_OAUTH2_CERTS_URL\n    )\n    decode.assert_called_once_with(\n        mock.sentinel.token,\n        certs=_fetch_certs.return_value,\n        audience=None,\n        clock_skew_in_seconds=10,\n    )\n\n\n@mock.patch(\"google.auth.jwt.decode\", autospec=True)\n@mock.patch(\"google.oauth2._id_token_async._fetch_certs\", autospec=True)\n@pytest.mark.asyncio\nasync def test_verify_token_args(_fetch_certs, decode):\n    result = await id_token.verify_token(\n        mock.sentinel.token,\n        mock.sentinel.request,\n        audience=mock.sentinel.audience,\n        certs_url=mock.sentinel.certs_url,\n    )\n\n    assert result == decode.return_value\n    _fetch_certs.assert_called_once_with(mock.sentinel.request, mock.sentinel.certs_url)\n    decode.assert_called_once_with(\n        mock.sentinel.token,\n        certs=_fetch_certs.return_value,\n        audience=mock.sentinel.audience,\n        clock_skew_in_seconds=0,\n    )\n\n\n@mock.patch(\"google.oauth2._id_token_async.verify_token\", autospec=True)\n@pytest.mark.asyncio\nasync def test_verify_oauth2_token(verify_token):\n    verify_token.return_value = {\"iss\": \"accounts.google.com\"}\n    result = await id_token.verify_oauth2_token(\n        mock.sentinel.token, mock.sentinel.request, audience=mock.sentinel.audience\n    )\n\n    assert result == verify_token.return_value\n    verify_token.assert_called_once_with(\n        mock.sentinel.token,\n        mock.sentinel.request,\n        audience=mock.sentinel.audience,\n        certs_url=sync_id_token._GOOGLE_OAUTH2_CERTS_URL,\n        clock_skew_in_seconds=0,\n    )\n\n\n@mock.patch(\"google.oauth2._id_token_async.verify_token\", autospec=True)\n@pytest.mark.asyncio\nasync def test_verify_oauth2_token_clock_skew(verify_token):\n    verify_token.return_value = {\"iss\": \"accounts.google.com\"}\n    result = await id_token.verify_oauth2_token(\n        mock.sentinel.token,\n        mock.sentinel.request,\n        audience=mock.sentinel.audience,\n        clock_skew_in_seconds=10,\n    )\n\n    assert result == verify_token.return_value\n    verify_token.assert_called_once_with(\n        mock.sentinel.token,\n        mock.sentinel.request,\n        audience=mock.sentinel.audience,\n        certs_url=sync_id_token._GOOGLE_OAUTH2_CERTS_URL,\n        clock_skew_in_seconds=10,\n    )\n\n\n@mock.patch(\"google.oauth2._id_token_async.verify_token\", autospec=True)\n@pytest.mark.asyncio\nasync def test_verify_oauth2_token_invalid_iss(verify_token):\n    verify_token.return_value = {\"iss\": \"invalid_issuer\"}\n\n    with pytest.raises(exceptions.GoogleAuthError):\n        await id_token.verify_oauth2_token(\n            mock.sentinel.token, mock.sentinel.request, audience=mock.sentinel.audience\n        )\n\n\n@mock.patch(\"google.oauth2._id_token_async.verify_token\", autospec=True)\n@pytest.mark.asyncio\nasync def test_verify_firebase_token(verify_token):\n    result = await id_token.verify_firebase_token(\n        mock.sentinel.token, mock.sentinel.request, audience=mock.sentinel.audience\n    )\n\n    assert result == verify_token.return_value\n    verify_token.assert_called_once_with(\n        mock.sentinel.token,\n        mock.sentinel.request,\n        audience=mock.sentinel.audience,\n        certs_url=sync_id_token._GOOGLE_APIS_CERTS_URL,\n        clock_skew_in_seconds=0,\n    )\n\n\n@mock.patch(\"google.oauth2._id_token_async.verify_token\", autospec=True)\n@pytest.mark.asyncio\nasync def test_verify_firebase_token_clock_skew(verify_token):\n    result = await id_token.verify_firebase_token(\n        mock.sentinel.token,\n        mock.sentinel.request,\n        audience=mock.sentinel.audience,\n        clock_skew_in_seconds=10,\n    )\n\n    assert result == verify_token.return_value\n    verify_token.assert_called_once_with(\n        mock.sentinel.token,\n        mock.sentinel.request,\n        audience=mock.sentinel.audience,\n        certs_url=sync_id_token._GOOGLE_APIS_CERTS_URL,\n        clock_skew_in_seconds=10,\n    )\n\n\n@pytest.mark.asyncio\nasync def test_fetch_id_token_from_metadata_server(monkeypatch):\n    monkeypatch.delenv(environment_vars.CREDENTIALS, raising=False)\n\n    def mock_init(self, request, audience, use_metadata_identity_endpoint):\n        assert use_metadata_identity_endpoint\n        self.token = \"id_token\"\n\n    with mock.patch(\"google.auth.compute_engine._metadata.ping\", return_value=True):\n        with mock.patch.multiple(\n            google.auth.compute_engine.IDTokenCredentials,\n            __init__=mock_init,\n            refresh=mock.Mock(),\n        ):\n            request = mock.AsyncMock()\n            token = await id_token.fetch_id_token(\n                request, \"https://pubsub.googleapis.com\"\n            )\n            assert token == \"id_token\"\n\n\n@pytest.mark.asyncio\nasync def test_fetch_id_token_from_explicit_cred_json_file(monkeypatch):\n    monkeypatch.setenv(environment_vars.CREDENTIALS, test_id_token.SERVICE_ACCOUNT_FILE)\n\n    async def mock_refresh(self, request):\n        self.token = \"id_token\"\n\n    with mock.patch.object(\n        _service_account_async.IDTokenCredentials, \"refresh\", mock_refresh\n    ):\n        request = mock.AsyncMock()\n        token = await id_token.fetch_id_token(request, \"https://pubsub.googleapis.com\")\n        assert token == \"id_token\"\n\n\n@pytest.mark.asyncio\nasync def test_fetch_id_token_no_cred_exists(monkeypatch):\n    monkeypatch.delenv(environment_vars.CREDENTIALS, raising=False)\n\n    with mock.patch(\n        \"google.auth.compute_engine._metadata.ping\",\n        side_effect=exceptions.TransportError(),\n    ):\n        with pytest.raises(exceptions.DefaultCredentialsError) as excinfo:\n            request = mock.AsyncMock()\n            await id_token.fetch_id_token(request, \"https://pubsub.googleapis.com\")\n        assert excinfo.match(\n            r\"Neither metadata server or valid service account credentials are found.\"\n        )\n\n    with mock.patch(\"google.auth.compute_engine._metadata.ping\", return_value=False):\n        with pytest.raises(exceptions.DefaultCredentialsError) as excinfo:\n            request = mock.AsyncMock()\n            await id_token.fetch_id_token(request, \"https://pubsub.googleapis.com\")\n        assert excinfo.match(\n            r\"Neither metadata server or valid service account credentials are found.\"\n        )\n\n\n@pytest.mark.asyncio\nasync def test_fetch_id_token_invalid_cred_file(monkeypatch):\n    not_json_file = os.path.join(\n        os.path.dirname(__file__), \"../../tests/data/public_cert.pem\"\n    )\n    monkeypatch.setenv(environment_vars.CREDENTIALS, not_json_file)\n\n    with pytest.raises(exceptions.DefaultCredentialsError) as excinfo:\n        request = mock.AsyncMock()\n        await id_token.fetch_id_token(request, \"https://pubsub.googleapis.com\")\n    assert excinfo.match(\n        r\"GOOGLE_APPLICATION_CREDENTIALS is not valid service account credentials.\"\n    )\n\n\n@pytest.mark.asyncio\nasync def test_fetch_id_token_invalid_cred_type(monkeypatch):\n    user_credentials_file = os.path.join(\n        os.path.dirname(__file__), \"../../tests/data/authorized_user.json\"\n    )\n    monkeypatch.setenv(environment_vars.CREDENTIALS, user_credentials_file)\n\n    with mock.patch(\"google.auth.compute_engine._metadata.ping\", return_value=False):\n        with pytest.raises(exceptions.DefaultCredentialsError) as excinfo:\n            request = mock.AsyncMock()\n            await id_token.fetch_id_token(request, \"https://pubsub.googleapis.com\")\n        assert excinfo.match(\n            r\"Neither metadata server or valid service account credentials are found.\"\n        )\n\n\n@pytest.mark.asyncio\nasync def test_fetch_id_token_invalid_cred_path(monkeypatch):\n    not_json_file = os.path.join(\n        os.path.dirname(__file__), \"../../tests/data/not_exists.json\"\n    )\n    monkeypatch.setenv(environment_vars.CREDENTIALS, not_json_file)\n\n    with pytest.raises(exceptions.DefaultCredentialsError) as excinfo:\n        request = mock.AsyncMock()\n        await id_token.fetch_id_token(request, \"https://pubsub.googleapis.com\")\n    assert excinfo.match(\n        r\"GOOGLE_APPLICATION_CREDENTIALS path is either not found or invalid.\"\n    )\n", "tests_async/transport/async_compliance.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport http.client as http_client\nimport time\n\nimport flask  # type: ignore\nimport pytest  # type: ignore\nfrom pytest_localserver.http import WSGIServer  # type: ignore\n\nfrom google.auth import exceptions\nfrom tests.transport import compliance\n\n\nclass RequestResponseTests(object):\n    @pytest.fixture(scope=\"module\")\n    def server(self):\n        \"\"\"Provides a test HTTP server.\n\n        The test server is automatically created before\n        a test and destroyed at the end. The server is serving a test\n        application that can be used to verify requests.\n        \"\"\"\n        app = flask.Flask(__name__)\n        app.debug = True\n\n        # pylint: disable=unused-variable\n        # (pylint thinks the flask routes are unusued.)\n        @app.route(\"/basic\")\n        def index():\n            header_value = flask.request.headers.get(\"x-test-header\", \"value\")\n            headers = {\"X-Test-Header\": header_value}\n            return \"Basic Content\", http_client.OK, headers\n\n        @app.route(\"/server_error\")\n        def server_error():\n            return \"Error\", http_client.INTERNAL_SERVER_ERROR\n\n        @app.route(\"/wait\")\n        def wait():\n            time.sleep(3)\n            return \"Waited\"\n\n        # pylint: enable=unused-variable\n\n        server = WSGIServer(application=app.wsgi_app)\n        server.start()\n        yield server\n        server.stop()\n\n    @pytest.mark.asyncio\n    async def test_request_basic(self, server):\n        request = self.make_request()\n        response = await request(url=server.url + \"/basic\", method=\"GET\")\n        assert response.status == http_client.OK\n        assert response.headers[\"x-test-header\"] == \"value\"\n\n        # Use 13 as this is the length of the data written into the stream.\n\n        data = await response.data.read(13)\n        assert data == b\"Basic Content\"\n\n    @pytest.mark.asyncio\n    async def test_request_basic_with_http(self, server):\n        request = self.make_with_parameter_request()\n        response = await request(url=server.url + \"/basic\", method=\"GET\")\n        assert response.status == http_client.OK\n        assert response.headers[\"x-test-header\"] == \"value\"\n\n        # Use 13 as this is the length of the data written into the stream.\n\n        data = await response.data.read(13)\n        assert data == b\"Basic Content\"\n\n    @pytest.mark.asyncio\n    async def test_request_with_timeout_success(self, server):\n        request = self.make_request()\n        response = await request(url=server.url + \"/basic\", method=\"GET\", timeout=2)\n\n        assert response.status == http_client.OK\n        assert response.headers[\"x-test-header\"] == \"value\"\n\n        data = await response.data.read(13)\n        assert data == b\"Basic Content\"\n\n    @pytest.mark.asyncio\n    async def test_request_with_timeout_failure(self, server):\n        request = self.make_request()\n\n        with pytest.raises(exceptions.TransportError):\n            await request(url=server.url + \"/wait\", method=\"GET\", timeout=1)\n\n    @pytest.mark.asyncio\n    async def test_request_headers(self, server):\n        request = self.make_request()\n        response = await request(\n            url=server.url + \"/basic\",\n            method=\"GET\",\n            headers={\"x-test-header\": \"hello world\"},\n        )\n\n        assert response.status == http_client.OK\n        assert response.headers[\"x-test-header\"] == \"hello world\"\n\n        data = await response.data.read(13)\n        assert data == b\"Basic Content\"\n\n    @pytest.mark.asyncio\n    async def test_request_error(self, server):\n        request = self.make_request()\n\n        response = await request(url=server.url + \"/server_error\", method=\"GET\")\n        assert response.status == http_client.INTERNAL_SERVER_ERROR\n        data = await response.data.read(5)\n        assert data == b\"Error\"\n\n    @pytest.mark.asyncio\n    async def test_connection_error(self):\n        request = self.make_request()\n\n        with pytest.raises(exceptions.TransportError):\n            await request(url=\"http://{}\".format(compliance.NXDOMAIN), method=\"GET\")\n", "tests_async/transport/test_aiohttp_requests.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport aiohttp  # type: ignore\nfrom aioresponses import aioresponses, core  # type: ignore\nimport mock\nimport pytest  # type: ignore\nfrom tests_async.transport import async_compliance\n\nimport google.auth._credentials_async\nfrom google.auth.transport import _aiohttp_requests as aiohttp_requests\nimport google.auth.transport._mtls_helper\n\n\nclass TestCombinedResponse:\n    @pytest.mark.asyncio\n    async def test__is_compressed(self):\n        response = core.CallbackResult(headers={\"Content-Encoding\": \"gzip\"})\n        combined_response = aiohttp_requests._CombinedResponse(response)\n        compressed = combined_response._is_compressed()\n        assert compressed\n\n    def test__is_compressed_not(self):\n        response = core.CallbackResult(headers={\"Content-Encoding\": \"not\"})\n        combined_response = aiohttp_requests._CombinedResponse(response)\n        compressed = combined_response._is_compressed()\n        assert not compressed\n\n    @pytest.mark.asyncio\n    async def test_raw_content(self):\n\n        mock_response = mock.AsyncMock()\n        mock_response.content.read.return_value = mock.sentinel.read\n        combined_response = aiohttp_requests._CombinedResponse(response=mock_response)\n        raw_content = await combined_response.raw_content()\n        assert raw_content == mock.sentinel.read\n\n        # Second call to validate the preconfigured path.\n        combined_response._raw_content = mock.sentinel.stored_raw\n        raw_content = await combined_response.raw_content()\n        assert raw_content == mock.sentinel.stored_raw\n\n    @pytest.mark.asyncio\n    async def test_content(self):\n        mock_response = mock.AsyncMock()\n        mock_response.content.read.return_value = mock.sentinel.read\n        combined_response = aiohttp_requests._CombinedResponse(response=mock_response)\n        content = await combined_response.content()\n        assert content == mock.sentinel.read\n\n    @mock.patch(\n        \"google.auth.transport._aiohttp_requests.urllib3.response.MultiDecoder.decompress\",\n        return_value=\"decompressed\",\n        autospec=True,\n    )\n    @pytest.mark.asyncio\n    async def test_content_compressed(self, urllib3_mock):\n        rm = core.RequestMatch(\n            \"url\", headers={\"Content-Encoding\": \"gzip\"}, payload=\"compressed\"\n        )\n        response = await rm.build_response(core.URL(\"url\"))\n\n        combined_response = aiohttp_requests._CombinedResponse(response=response)\n        content = await combined_response.content()\n\n        urllib3_mock.assert_called_once()\n        assert content == \"decompressed\"\n\n\nclass TestResponse:\n    def test_ctor(self):\n        response = aiohttp_requests._Response(mock.sentinel.response)\n        assert response._response == mock.sentinel.response\n\n    @pytest.mark.asyncio\n    async def test_headers_prop(self):\n        rm = core.RequestMatch(\"url\", headers={\"Content-Encoding\": \"header prop\"})\n        mock_response = await rm.build_response(core.URL(\"url\"))\n\n        response = aiohttp_requests._Response(mock_response)\n        assert response.headers[\"Content-Encoding\"] == \"header prop\"\n\n    @pytest.mark.asyncio\n    async def test_status_prop(self):\n        rm = core.RequestMatch(\"url\", status=123)\n        mock_response = await rm.build_response(core.URL(\"url\"))\n        response = aiohttp_requests._Response(mock_response)\n        assert response.status == 123\n\n    @pytest.mark.asyncio\n    async def test_data_prop(self):\n        mock_response = mock.AsyncMock()\n        mock_response.content.read.return_value = mock.sentinel.read\n        response = aiohttp_requests._Response(mock_response)\n        data = await response.data.read()\n        assert data == mock.sentinel.read\n\n\nclass TestRequestResponse(async_compliance.RequestResponseTests):\n    def make_request(self):\n        return aiohttp_requests.Request()\n\n    def make_with_parameter_request(self):\n        http = aiohttp.ClientSession(auto_decompress=False)\n        return aiohttp_requests.Request(http)\n\n    def test_unsupported_session(self):\n        http = aiohttp.ClientSession(auto_decompress=True)\n        with pytest.raises(ValueError):\n            aiohttp_requests.Request(http)\n\n    def test_timeout(self):\n        http = mock.create_autospec(\n            aiohttp.ClientSession, instance=True, _auto_decompress=False\n        )\n        request = aiohttp_requests.Request(http)\n        request(url=\"http://example.com\", method=\"GET\", timeout=5)\n\n\nclass CredentialsStub(google.auth._credentials_async.Credentials):\n    def __init__(self, token=\"token\"):\n        super(CredentialsStub, self).__init__()\n        self.token = token\n\n    def apply(self, headers, token=None):\n        headers[\"authorization\"] = self.token\n\n    def refresh(self, request):\n        self.token += \"1\"\n\n\nclass TestAuthorizedSession(object):\n    TEST_URL = \"http://example.com/\"\n    method = \"GET\"\n\n    def test_constructor(self):\n        authed_session = aiohttp_requests.AuthorizedSession(mock.sentinel.credentials)\n        assert authed_session.credentials == mock.sentinel.credentials\n\n    def test_constructor_with_auth_request(self):\n        http = mock.create_autospec(\n            aiohttp.ClientSession, instance=True, _auto_decompress=False\n        )\n        auth_request = aiohttp_requests.Request(http)\n\n        authed_session = aiohttp_requests.AuthorizedSession(\n            mock.sentinel.credentials, auth_request=auth_request\n        )\n\n        assert authed_session._auth_request == auth_request\n\n    @pytest.mark.asyncio\n    async def test_request(self):\n        with aioresponses() as mocked:\n            credentials = mock.Mock(wraps=CredentialsStub())\n\n            mocked.get(self.TEST_URL, status=200, body=\"test\")\n            session = aiohttp_requests.AuthorizedSession(credentials)\n            resp = await session.request(\n                \"GET\",\n                \"http://example.com/\",\n                headers={\"Keep-Alive\": \"timeout=5, max=1000\", \"fake\": b\"bytes\"},\n            )\n\n            assert resp.status == 200\n            assert \"test\" == await resp.text()\n\n            await session.close()\n\n    @pytest.mark.asyncio\n    async def test_ctx(self):\n        with aioresponses() as mocked:\n            credentials = mock.Mock(wraps=CredentialsStub())\n            mocked.get(\"http://test.example.com\", payload=dict(foo=\"bar\"))\n            session = aiohttp_requests.AuthorizedSession(credentials)\n            resp = await session.request(\"GET\", \"http://test.example.com\")\n            data = await resp.json()\n\n            assert dict(foo=\"bar\") == data\n\n            await session.close()\n\n    @pytest.mark.asyncio\n    async def test_http_headers(self):\n        with aioresponses() as mocked:\n            credentials = mock.Mock(wraps=CredentialsStub())\n            mocked.post(\n                \"http://example.com\",\n                payload=dict(),\n                headers=dict(connection=\"keep-alive\"),\n            )\n\n            session = aiohttp_requests.AuthorizedSession(credentials)\n            resp = await session.request(\"POST\", \"http://example.com\")\n\n            assert resp.headers[\"Connection\"] == \"keep-alive\"\n\n            await session.close()\n\n    @pytest.mark.asyncio\n    async def test_regexp_example(self):\n        with aioresponses() as mocked:\n            credentials = mock.Mock(wraps=CredentialsStub())\n            mocked.get(\"http://example.com\", status=500)\n            mocked.get(\"http://example.com\", status=200)\n\n            session1 = aiohttp_requests.AuthorizedSession(credentials)\n\n            resp1 = await session1.request(\"GET\", \"http://example.com\")\n            session2 = aiohttp_requests.AuthorizedSession(credentials)\n            resp2 = await session2.request(\"GET\", \"http://example.com\")\n\n            assert resp1.status == 500\n            assert resp2.status == 200\n\n            await session1.close()\n            await session2.close()\n\n    @pytest.mark.asyncio\n    async def test_request_no_refresh(self):\n        credentials = mock.Mock(wraps=CredentialsStub())\n        with aioresponses() as mocked:\n            mocked.get(\"http://example.com\", status=200)\n            authed_session = aiohttp_requests.AuthorizedSession(credentials)\n            response = await authed_session.request(\"GET\", \"http://example.com\")\n            assert response.status == 200\n            assert credentials.before_request.called\n            assert not credentials.refresh.called\n\n            await authed_session.close()\n\n    @pytest.mark.asyncio\n    async def test_request_refresh(self):\n        credentials = mock.Mock(wraps=CredentialsStub())\n        with aioresponses() as mocked:\n            mocked.get(\"http://example.com\", status=401)\n            mocked.get(\"http://example.com\", status=200)\n            authed_session = aiohttp_requests.AuthorizedSession(credentials)\n            response = await authed_session.request(\"GET\", \"http://example.com\")\n            assert credentials.refresh.called\n            assert response.status == 200\n\n            await authed_session.close()\n", "tests_async/transport/__init__.py": "", "docs/conf.py": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n#\n# google-auth documentation build configuration file, created by\n# sphinx-quickstart on Thu Sep 22 12:50:15 2016.\n#\n# This file is execfile()d with the current directory set to its\n# containing dir.\n#\n# Note that not all possible configuration values are present in this\n# autogenerated file.\n#\n# All configuration values have a default; values that are commented out\n# serve to show the default.\n\nimport google.auth\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n#\n# import os\n# import sys\n# sys.path.insert(0, os.path.abspath('.'))\n\n# -- General configuration ------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\n#\n# needs_sphinx = '1.0'\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom\n# ones.\nextensions = [\n    \"sphinx.ext.autodoc\",\n    \"sphinx.ext.intersphinx\",\n    \"sphinx.ext.viewcode\",\n    \"sphinx.ext.napoleon\",\n    \"sphinx_docstring_typing\",\n]\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\"_templates\"]\n\n# The suffix(es) of source filenames.\n# You can specify multiple suffix as a list of string:\n#\n# source_suffix = ['.rst', '.md']\nsource_suffix = \".rst\"\n\n# The encoding of source files.\n#\n# source_encoding = 'utf-8-sig'\n\n# The root toctree document.\nroot_doc = \"index\"\n\n# General information about the project.\nproject = \"google-auth\"\ncopyright = \"2016, Google, Inc.\"\nauthor = \"Google, Inc.\"\n\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = google.auth.__version__\n# The full version, including alpha/beta/rc tags.\nrelease = version\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#\n# This is also used if you do content translation via gettext catalogs.\n# Usually you set \"language\" from the command line for these cases.\nlanguage = \"en\"\n\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n#\n# today = ''\n#\n# Else, today_fmt is used as the format for a strftime call.\n#\n# today_fmt = '%B %d, %Y'\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# This patterns also effect to html_static_path and html_extra_path\nexclude_patterns = [\"_build\", \"Thumbs.db\", \".DS_Store\"]\n\n# The reST default role (used for this markup: `text`) to use for all\n# documents.\n#\n# default_role = None\n\n# If true, '()' will be appended to :func: etc. cross-reference text.\n#\n# add_function_parentheses = True\n\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n#\nadd_module_names = False\n\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\n#\n# show_authors = False\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = \"sphinx\"\n\n# A list of ignored prefixes for module index sorting.\n# modindex_common_prefix = []\n\n# If true, keep warnings as \"system message\" paragraphs in the built documents.\n# keep_warnings = False\n\n# If true, `todo` and `todoList` produce output, else they produce nothing.\ntodo_include_todos = False\n\n\n# -- Options for HTML output ----------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#\nhtml_theme = \"alabaster\"\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#\nhtml_theme_options = {\n    \"description\": \"Google Auth Library for Python\",\n    \"github_user\": \"GoogleCloudPlatform\",\n    \"github_repo\": \"google-auth-library-python\",\n    \"github_banner\": True,\n    \"travis_button\": True,\n    \"font_family\": \"'Roboto', Georgia, sans\",\n    \"head_font_family\": \"'Roboto', Georgia, serif\",\n    \"code_font_family\": \"'Roboto Mono', 'Consolas', monospace\",\n}\n\n# Add any paths that contain custom themes here, relative to this directory.\n# html_theme_path = []\n\n# The name for this set of Sphinx documents.\n# \"<project> v<release> documentation\" by default.\n#\n# html_title = 'google-auth v0.0.1a'\n\n# A shorter title for the navigation bar.  Default is the same as html_title.\n#\n# html_short_title = None\n\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n#\n# html_logo = None\n\n# The name of an image file (relative to this directory) to use as a favicon of\n# the docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\n#\n# html_favicon = None\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\nhtml_static_path = [\"_static\"]\n\n# Add any extra paths that contain custom files (such as robots.txt or\n# .htaccess) here, relative to this directory. These files are copied\n# directly to the root of the documentation.\n#\n# html_extra_path = []\n\n# If not None, a 'Last updated on:' timestamp is inserted at every page\n# bottom, using the given strftime format.\n# The empty string is equivalent to '%b %d, %Y'.\n#\n# html_last_updated_fmt = None\n\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n#\n# html_use_smartypants = True\n\n# Custom sidebar templates, maps document names to template names.\n#\n\nhtml_sidebars = {\n    \"**\": [\"about.html\", \"navigation.html\", \"relations.html\", \"searchbox.html\"]\n}\n\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n#\n# html_additional_pages = {}\n\n# If false, no module index is generated.\n#\n# html_domain_indices = True\n\n# If false, no index is generated.\n#\n# html_use_index = True\n\n# If true, the index is split into individual pages for each letter.\n#\n# html_split_index = False\n\n# If true, links to the reST sources are added to the pages.\n#\n# html_show_sourcelink = True\n\n# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.\n#\n# html_show_sphinx = True\n\n# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.\n#\n# html_show_copyright = True\n\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n#\n# html_use_opensearch = ''\n\n# This is the file name suffix for HTML files (e.g. \".xhtml\").\n# html_file_suffix = None\n\n# Language to be used for generating the HTML full-text search index.\n# Sphinx supports the following languages:\n#   'da', 'de', 'en', 'es', 'fi', 'fr', 'h', 'it', 'ja'\n#   'nl', 'no', 'pt', 'ro', 'r', 'sv', 'tr', 'zh'\n#\n# html_search_language = 'en'\n\n# A dictionary with options for the search language support, empty by default.\n# 'ja' uses this config value.\n# 'zh' user can custom change `jieba` dictionary path.\n#\n# html_search_options = {'type': 'default'}\n\n# The name of a javascript file (relative to the configuration directory) that\n# implements a search results scorer. If empty, the default will be used.\n#\n# html_search_scorer = 'scorer.js'\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = \"google-authdoc\"\n\n# -- Options for LaTeX output ---------------------------------------------\n\nlatex_elements = {\n    # The paper size ('letterpaper' or 'a4paper').\n    #\n    # 'papersize': 'letterpaper',\n    # The font size ('10pt', '11pt' or '12pt').\n    #\n    # 'pointsize': '10pt',\n    # Additional stuff for the LaTeX preamble.\n    #\n    # 'preamble': '',\n    # Latex figure (float) alignment\n    #\n    # 'figure_align': 'htbp',\n}\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title,\n#  author, documentclass [howto, manual, or own class]).\nlatex_documents = [\n    (root_doc, \"google-auth.tex\", \"google-auth Documentation\", \"Google, Inc.\", \"manual\")\n]\n\n# The name of an image file (relative to this directory) to place at the top of\n# the title page.\n#\n# latex_logo = None\n\n# For \"manual\" documents, if this is true, then toplevel headings are parts,\n# not chapters.\n#\n# latex_use_parts = False\n\n# If true, show page references after internal links.\n#\n# latex_show_pagerefs = False\n\n# If true, show URL addresses after external links.\n#\n# latex_show_urls = False\n\n# Documents to append as an appendix to all manuals.\n#\n# latex_appendices = []\n\n# It false, will not define \\strong, \\code, \titleref, \\crossref ... but only\n# \\sphinxstrong, ..., \\sphinxtitleref, ... To help avoid clash with user added\n# packages.\n#\n# latex_keep_old_macro_names = True\n\n# If false, no module index is generated.\n#\n# latex_domain_indices = True\n\n\n# -- Options for manual page output ---------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [(root_doc, \"google-auth\", \"google-auth Documentation\", [author], 1)]\n\n# If true, show URL addresses after external links.\n#\n# man_show_urls = False\n\n\n# -- Options for Texinfo output -------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n    (\n        root_doc,\n        \"google-auth\",\n        \"google-auth Documentation\",\n        author,\n        \"google-auth\",\n        \"One line description of project.\",\n        \"Miscellaneous\",\n    )\n]\n\n# Documents to append as an appendix to all manuals.\n#\n# texinfo_appendices = []\n\n# If false, no module index is generated.\n#\n# texinfo_domain_indices = True\n\n# How to display URL addresses: 'footnote', 'no', or 'inline'.\n#\n# texinfo_show_urls = 'footnote'\n\n# If true, do not generate a @detailmenu in the \"Top\" node's menu.\n#\n# texinfo_no_detailmenu = False\n\n\n# Example configuration for intersphinx: refer to the Python standard library.\nintersphinx_mapping = {\n    \"python\": (\"https://docs.python.org/3.5\", None),\n    \"urllib3\": (\"https://urllib3.readthedocs.io/en/stable\", None),\n    \"requests\": (\"https://requests.kennethreitz.org/en/master/\", None),\n    \"requests-oauthlib\": (\n        \"https://requests-oauthlib.readthedocs.io/en/v1.3.0-docs/\",\n        None,\n    ),\n}\n\n# Autodoc config\nautoclass_content = \"both\"\nautodoc_member_order = \"bysource\"\nautodoc_mock_imports = [\"grpc\"]\n", "tests/test_aws.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport datetime\nimport http.client as http_client\nimport json\nimport os\nimport urllib.parse\n\nimport mock\nimport pytest  # type: ignore\n\nfrom google.auth import _helpers, external_account\nfrom google.auth import aws\nfrom google.auth import environment_vars\nfrom google.auth import exceptions\nfrom google.auth import transport\nfrom google.auth.credentials import DEFAULT_UNIVERSE_DOMAIN\n\nIMPERSONATE_ACCESS_TOKEN_REQUEST_METRICS_HEADER_VALUE = (\n    \"gl-python/3.7 auth/1.1 auth-request-type/at cred-type/imp\"\n)\n\nLANG_LIBRARY_METRICS_HEADER_VALUE = \"gl-python/3.7 auth/1.1\"\n\nCLIENT_ID = \"username\"\nCLIENT_SECRET = \"password\"\n# Base64 encoding of \"username:password\".\nBASIC_AUTH_ENCODING = \"dXNlcm5hbWU6cGFzc3dvcmQ=\"\nSERVICE_ACCOUNT_EMAIL = \"service-1234@service-name.iam.gserviceaccount.com\"\nSERVICE_ACCOUNT_IMPERSONATION_URL_BASE = (\n    \"https://us-east1-iamcredentials.googleapis.com\"\n)\nSERVICE_ACCOUNT_IMPERSONATION_URL_ROUTE = \"/v1/projects/-/serviceAccounts/{}:generateAccessToken\".format(\n    SERVICE_ACCOUNT_EMAIL\n)\nSERVICE_ACCOUNT_IMPERSONATION_URL = (\n    SERVICE_ACCOUNT_IMPERSONATION_URL_BASE + SERVICE_ACCOUNT_IMPERSONATION_URL_ROUTE\n)\nQUOTA_PROJECT_ID = \"QUOTA_PROJECT_ID\"\nSCOPES = [\"scope1\", \"scope2\"]\nTOKEN_URL = \"https://sts.googleapis.com/v1/token\"\nTOKEN_INFO_URL = \"https://sts.googleapis.com/v1/introspect\"\nSUBJECT_TOKEN_TYPE = \"urn:ietf:params:aws:token-type:aws4_request\"\nAUDIENCE = \"//iam.googleapis.com/projects/123456/locations/global/workloadIdentityPools/POOL_ID/providers/PROVIDER_ID\"\nREGION_URL = \"http://169.254.169.254/latest/meta-data/placement/availability-zone\"\nIMDSV2_SESSION_TOKEN_URL = \"http://169.254.169.254/latest/api/token\"\nSECURITY_CREDS_URL = \"http://169.254.169.254/latest/meta-data/iam/security-credentials\"\nREGION_URL_IPV6 = \"http://[fd00:ec2::254]/latest/meta-data/placement/availability-zone\"\nIMDSV2_SESSION_TOKEN_URL_IPV6 = \"http://[fd00:ec2::254]/latest/api/token\"\nSECURITY_CREDS_URL_IPV6 = (\n    \"http://[fd00:ec2::254]/latest/meta-data/iam/security-credentials\"\n)\nCRED_VERIFICATION_URL = (\n    \"https://sts.{region}.amazonaws.com?Action=GetCallerIdentity&Version=2011-06-15\"\n)\n# Sample fictitious AWS security credentials to be used with tests that require a session token.\nACCESS_KEY_ID = \"AKIAIOSFODNN7EXAMPLE\"\nSECRET_ACCESS_KEY = \"wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY\"\nTOKEN = \"AQoEXAMPLEH4aoAH0gNCAPyJxz4BlCFFxWNE1OPTgk5TthT+FvwqnKwRcOIfrRh3c/LTo6UDdyJwOOvEVPvLXCrrrUtdnniCEXAMPLE/IvU1dYUg2RVAJBanLiHb4IgRmpRV3zrkuWJOgQs8IZZaIv2BXIa2R4OlgkBN9bkUDNCJiBeb/AXlzBBko7b15fjrBs2+cTQtpZ3CYWFXG8C5zqx37wnOE49mRl/+OtkIKGO7fAE\"\n# To avoid json.dumps() differing behavior from one version to other,\n# the JSON payload is hardcoded.\nREQUEST_PARAMS = '{\"KeySchema\":[{\"KeyType\":\"HASH\",\"AttributeName\":\"Id\"}],\"TableName\":\"TestTable\",\"AttributeDefinitions\":[{\"AttributeName\":\"Id\",\"AttributeType\":\"S\"}],\"ProvisionedThroughput\":{\"WriteCapacityUnits\":5,\"ReadCapacityUnits\":5}}'\n# Each tuple contains the following entries:\n# region, time, credentials, original_request, signed_request\n\nVALID_TOKEN_URLS = [\n    \"https://sts.googleapis.com\",\n    \"https://us-east-1.sts.googleapis.com\",\n    \"https://US-EAST-1.sts.googleapis.com\",\n    \"https://sts.us-east-1.googleapis.com\",\n    \"https://sts.US-WEST-1.googleapis.com\",\n    \"https://us-east-1-sts.googleapis.com\",\n    \"https://US-WEST-1-sts.googleapis.com\",\n    \"https://us-west-1-sts.googleapis.com/path?query\",\n    \"https://sts-us-east-1.p.googleapis.com\",\n]\nINVALID_TOKEN_URLS = [\n    \"https://iamcredentials.googleapis.com\",\n    \"sts.googleapis.com\",\n    \"https://\",\n    \"http://sts.googleapis.com\",\n    \"https://st.s.googleapis.com\",\n    \"https://us-eas\\t-1.sts.googleapis.com\",\n    \"https:/us-east-1.sts.googleapis.com\",\n    \"https://US-WE/ST-1-sts.googleapis.com\",\n    \"https://sts-us-east-1.googleapis.com\",\n    \"https://sts-US-WEST-1.googleapis.com\",\n    \"testhttps://us-east-1.sts.googleapis.com\",\n    \"https://us-east-1.sts.googleapis.comevil.com\",\n    \"https://us-east-1.us-east-1.sts.googleapis.com\",\n    \"https://us-ea.s.t.sts.googleapis.com\",\n    \"https://sts.googleapis.comevil.com\",\n    \"hhttps://us-east-1.sts.googleapis.com\",\n    \"https://us- -1.sts.googleapis.com\",\n    \"https://-sts.googleapis.com\",\n    \"https://us-east-1.sts.googleapis.com.evil.com\",\n    \"https://sts.pgoogleapis.com\",\n    \"https://p.googleapis.com\",\n    \"https://sts.p.com\",\n    \"http://sts.p.googleapis.com\",\n    \"https://xyz-sts.p.googleapis.com\",\n    \"https://sts-xyz.123.p.googleapis.com\",\n    \"https://sts-xyz.p1.googleapis.com\",\n    \"https://sts-xyz.p.foo.com\",\n    \"https://sts-xyz.p.foo.googleapis.com\",\n]\nVALID_SERVICE_ACCOUNT_IMPERSONATION_URLS = [\n    \"https://iamcredentials.googleapis.com\",\n    \"https://us-east-1.iamcredentials.googleapis.com\",\n    \"https://US-EAST-1.iamcredentials.googleapis.com\",\n    \"https://iamcredentials.us-east-1.googleapis.com\",\n    \"https://iamcredentials.US-WEST-1.googleapis.com\",\n    \"https://us-east-1-iamcredentials.googleapis.com\",\n    \"https://US-WEST-1-iamcredentials.googleapis.com\",\n    \"https://us-west-1-iamcredentials.googleapis.com/path?query\",\n    \"https://iamcredentials-us-east-1.p.googleapis.com\",\n]\nINVALID_SERVICE_ACCOUNT_IMPERSONATION_URLS = [\n    \"https://sts.googleapis.com\",\n    \"iamcredentials.googleapis.com\",\n    \"https://\",\n    \"http://iamcredentials.googleapis.com\",\n    \"https://iamcre.dentials.googleapis.com\",\n    \"https://us-eas\\t-1.iamcredentials.googleapis.com\",\n    \"https:/us-east-1.iamcredentials.googleapis.com\",\n    \"https://US-WE/ST-1-iamcredentials.googleapis.com\",\n    \"https://iamcredentials-us-east-1.googleapis.com\",\n    \"https://iamcredentials-US-WEST-1.googleapis.com\",\n    \"testhttps://us-east-1.iamcredentials.googleapis.com\",\n    \"https://us-east-1.iamcredentials.googleapis.comevil.com\",\n    \"https://us-east-1.us-east-1.iamcredentials.googleapis.com\",\n    \"https://us-ea.s.t.iamcredentials.googleapis.com\",\n    \"https://iamcredentials.googleapis.comevil.com\",\n    \"hhttps://us-east-1.iamcredentials.googleapis.com\",\n    \"https://us- -1.iamcredentials.googleapis.com\",\n    \"https://-iamcredentials.googleapis.com\",\n    \"https://us-east-1.iamcredentials.googleapis.com.evil.com\",\n    \"https://iamcredentials.pgoogleapis.com\",\n    \"https://p.googleapis.com\",\n    \"https://iamcredentials.p.com\",\n    \"http://iamcredentials.p.googleapis.com\",\n    \"https://xyz-iamcredentials.p.googleapis.com\",\n    \"https://iamcredentials-xyz.123.p.googleapis.com\",\n    \"https://iamcredentials-xyz.p1.googleapis.com\",\n    \"https://iamcredentials-xyz.p.foo.com\",\n    \"https://iamcredentials-xyz.p.foo.googleapis.com\",\n]\nTEST_FIXTURES = [\n    # GET request (AWS botocore tests).\n    # https://github.com/boto/botocore/blob/879f8440a4e9ace5d3cf145ce8b3d5e5ffb892ef/tests/unit/auth/aws4_testsuite/get-vanilla.req\n    # https://github.com/boto/botocore/blob/879f8440a4e9ace5d3cf145ce8b3d5e5ffb892ef/tests/unit/auth/aws4_testsuite/get-vanilla.sreq\n    (\n        \"us-east-1\",\n        \"2011-09-09T23:36:00Z\",\n        {\n            \"access_key_id\": \"AKIDEXAMPLE\",\n            \"secret_access_key\": \"wJalrXUtnFEMI/K7MDENG+bPxRfiCYEXAMPLEKEY\",\n        },\n        {\n            \"method\": \"GET\",\n            \"url\": \"https://host.foo.com\",\n            \"headers\": {\"date\": \"Mon, 09 Sep 2011 23:36:00 GMT\"},\n        },\n        {\n            \"url\": \"https://host.foo.com\",\n            \"method\": \"GET\",\n            \"headers\": {\n                \"Authorization\": \"AWS4-HMAC-SHA256 Credential=AKIDEXAMPLE/20110909/us-east-1/host/aws4_request, SignedHeaders=date;host, Signature=b27ccfbfa7df52a200ff74193ca6e32d4b48b8856fab7ebf1c595d0670a7e470\",\n                \"host\": \"host.foo.com\",\n                \"date\": \"Mon, 09 Sep 2011 23:36:00 GMT\",\n            },\n        },\n    ),\n    # GET request with relative path (AWS botocore tests).\n    # https://github.com/boto/botocore/blob/879f8440a4e9ace5d3cf145ce8b3d5e5ffb892ef/tests/unit/auth/aws4_testsuite/get-relative-relative.req\n    # https://github.com/boto/botocore/blob/879f8440a4e9ace5d3cf145ce8b3d5e5ffb892ef/tests/unit/auth/aws4_testsuite/get-relative-relative.sreq\n    (\n        \"us-east-1\",\n        \"2011-09-09T23:36:00Z\",\n        {\n            \"access_key_id\": \"AKIDEXAMPLE\",\n            \"secret_access_key\": \"wJalrXUtnFEMI/K7MDENG+bPxRfiCYEXAMPLEKEY\",\n        },\n        {\n            \"method\": \"GET\",\n            \"url\": \"https://host.foo.com/foo/bar/../..\",\n            \"headers\": {\"date\": \"Mon, 09 Sep 2011 23:36:00 GMT\"},\n        },\n        {\n            \"url\": \"https://host.foo.com/foo/bar/../..\",\n            \"method\": \"GET\",\n            \"headers\": {\n                \"Authorization\": \"AWS4-HMAC-SHA256 Credential=AKIDEXAMPLE/20110909/us-east-1/host/aws4_request, SignedHeaders=date;host, Signature=b27ccfbfa7df52a200ff74193ca6e32d4b48b8856fab7ebf1c595d0670a7e470\",\n                \"host\": \"host.foo.com\",\n                \"date\": \"Mon, 09 Sep 2011 23:36:00 GMT\",\n            },\n        },\n    ),\n    # GET request with /./ path (AWS botocore tests).\n    # https://github.com/boto/botocore/blob/879f8440a4e9ace5d3cf145ce8b3d5e5ffb892ef/tests/unit/auth/aws4_testsuite/get-slash-dot-slash.req\n    # https://github.com/boto/botocore/blob/879f8440a4e9ace5d3cf145ce8b3d5e5ffb892ef/tests/unit/auth/aws4_testsuite/get-slash-dot-slash.sreq\n    (\n        \"us-east-1\",\n        \"2011-09-09T23:36:00Z\",\n        {\n            \"access_key_id\": \"AKIDEXAMPLE\",\n            \"secret_access_key\": \"wJalrXUtnFEMI/K7MDENG+bPxRfiCYEXAMPLEKEY\",\n        },\n        {\n            \"method\": \"GET\",\n            \"url\": \"https://host.foo.com/./\",\n            \"headers\": {\"date\": \"Mon, 09 Sep 2011 23:36:00 GMT\"},\n        },\n        {\n            \"url\": \"https://host.foo.com/./\",\n            \"method\": \"GET\",\n            \"headers\": {\n                \"Authorization\": \"AWS4-HMAC-SHA256 Credential=AKIDEXAMPLE/20110909/us-east-1/host/aws4_request, SignedHeaders=date;host, Signature=b27ccfbfa7df52a200ff74193ca6e32d4b48b8856fab7ebf1c595d0670a7e470\",\n                \"host\": \"host.foo.com\",\n                \"date\": \"Mon, 09 Sep 2011 23:36:00 GMT\",\n            },\n        },\n    ),\n    # GET request with pointless dot path (AWS botocore tests).\n    # https://github.com/boto/botocore/blob/879f8440a4e9ace5d3cf145ce8b3d5e5ffb892ef/tests/unit/auth/aws4_testsuite/get-slash-pointless-dot.req\n    # https://github.com/boto/botocore/blob/879f8440a4e9ace5d3cf145ce8b3d5e5ffb892ef/tests/unit/auth/aws4_testsuite/get-slash-pointless-dot.sreq\n    (\n        \"us-east-1\",\n        \"2011-09-09T23:36:00Z\",\n        {\n            \"access_key_id\": \"AKIDEXAMPLE\",\n            \"secret_access_key\": \"wJalrXUtnFEMI/K7MDENG+bPxRfiCYEXAMPLEKEY\",\n        },\n        {\n            \"method\": \"GET\",\n            \"url\": \"https://host.foo.com/./foo\",\n            \"headers\": {\"date\": \"Mon, 09 Sep 2011 23:36:00 GMT\"},\n        },\n        {\n            \"url\": \"https://host.foo.com/./foo\",\n            \"method\": \"GET\",\n            \"headers\": {\n                \"Authorization\": \"AWS4-HMAC-SHA256 Credential=AKIDEXAMPLE/20110909/us-east-1/host/aws4_request, SignedHeaders=date;host, Signature=910e4d6c9abafaf87898e1eb4c929135782ea25bb0279703146455745391e63a\",\n                \"host\": \"host.foo.com\",\n                \"date\": \"Mon, 09 Sep 2011 23:36:00 GMT\",\n            },\n        },\n    ),\n    # GET request with utf8 path (AWS botocore tests).\n    # https://github.com/boto/botocore/blob/879f8440a4e9ace5d3cf145ce8b3d5e5ffb892ef/tests/unit/auth/aws4_testsuite/get-utf8.req\n    # https://github.com/boto/botocore/blob/879f8440a4e9ace5d3cf145ce8b3d5e5ffb892ef/tests/unit/auth/aws4_testsuite/get-utf8.sreq\n    (\n        \"us-east-1\",\n        \"2011-09-09T23:36:00Z\",\n        {\n            \"access_key_id\": \"AKIDEXAMPLE\",\n            \"secret_access_key\": \"wJalrXUtnFEMI/K7MDENG+bPxRfiCYEXAMPLEKEY\",\n        },\n        {\n            \"method\": \"GET\",\n            \"url\": \"https://host.foo.com/%E1%88%B4\",\n            \"headers\": {\"date\": \"Mon, 09 Sep 2011 23:36:00 GMT\"},\n        },\n        {\n            \"url\": \"https://host.foo.com/%E1%88%B4\",\n            \"method\": \"GET\",\n            \"headers\": {\n                \"Authorization\": \"AWS4-HMAC-SHA256 Credential=AKIDEXAMPLE/20110909/us-east-1/host/aws4_request, SignedHeaders=date;host, Signature=8d6634c189aa8c75c2e51e106b6b5121bed103fdb351f7d7d4381c738823af74\",\n                \"host\": \"host.foo.com\",\n                \"date\": \"Mon, 09 Sep 2011 23:36:00 GMT\",\n            },\n        },\n    ),\n    # GET request with duplicate query key (AWS botocore tests).\n    # https://github.com/boto/botocore/blob/879f8440a4e9ace5d3cf145ce8b3d5e5ffb892ef/tests/unit/auth/aws4_testsuite/get-vanilla-query-order-key-case.req\n    # https://github.com/boto/botocore/blob/879f8440a4e9ace5d3cf145ce8b3d5e5ffb892ef/tests/unit/auth/aws4_testsuite/get-vanilla-query-order-key-case.sreq\n    (\n        \"us-east-1\",\n        \"2011-09-09T23:36:00Z\",\n        {\n            \"access_key_id\": \"AKIDEXAMPLE\",\n            \"secret_access_key\": \"wJalrXUtnFEMI/K7MDENG+bPxRfiCYEXAMPLEKEY\",\n        },\n        {\n            \"method\": \"GET\",\n            \"url\": \"https://host.foo.com/?foo=Zoo&foo=aha\",\n            \"headers\": {\"date\": \"Mon, 09 Sep 2011 23:36:00 GMT\"},\n        },\n        {\n            \"url\": \"https://host.foo.com/?foo=Zoo&foo=aha\",\n            \"method\": \"GET\",\n            \"headers\": {\n                \"Authorization\": \"AWS4-HMAC-SHA256 Credential=AKIDEXAMPLE/20110909/us-east-1/host/aws4_request, SignedHeaders=date;host, Signature=be7148d34ebccdc6423b19085378aa0bee970bdc61d144bd1a8c48c33079ab09\",\n                \"host\": \"host.foo.com\",\n                \"date\": \"Mon, 09 Sep 2011 23:36:00 GMT\",\n            },\n        },\n    ),\n    # GET request with duplicate out of order query key (AWS botocore tests).\n    # https://github.com/boto/botocore/blob/879f8440a4e9ace5d3cf145ce8b3d5e5ffb892ef/tests/unit/auth/aws4_testsuite/get-vanilla-query-order-value.req\n    # https://github.com/boto/botocore/blob/879f8440a4e9ace5d3cf145ce8b3d5e5ffb892ef/tests/unit/auth/aws4_testsuite/get-vanilla-query-order-value.sreq\n    (\n        \"us-east-1\",\n        \"2011-09-09T23:36:00Z\",\n        {\n            \"access_key_id\": \"AKIDEXAMPLE\",\n            \"secret_access_key\": \"wJalrXUtnFEMI/K7MDENG+bPxRfiCYEXAMPLEKEY\",\n        },\n        {\n            \"method\": \"GET\",\n            \"url\": \"https://host.foo.com/?foo=b&foo=a\",\n            \"headers\": {\"date\": \"Mon, 09 Sep 2011 23:36:00 GMT\"},\n        },\n        {\n            \"url\": \"https://host.foo.com/?foo=b&foo=a\",\n            \"method\": \"GET\",\n            \"headers\": {\n                \"Authorization\": \"AWS4-HMAC-SHA256 Credential=AKIDEXAMPLE/20110909/us-east-1/host/aws4_request, SignedHeaders=date;host, Signature=feb926e49e382bec75c9d7dcb2a1b6dc8aa50ca43c25d2bc51143768c0875acc\",\n                \"host\": \"host.foo.com\",\n                \"date\": \"Mon, 09 Sep 2011 23:36:00 GMT\",\n            },\n        },\n    ),\n    # GET request with utf8 query (AWS botocore tests).\n    # https://github.com/boto/botocore/blob/879f8440a4e9ace5d3cf145ce8b3d5e5ffb892ef/tests/unit/auth/aws4_testsuite/get-vanilla-ut8-query.req\n    # https://github.com/boto/botocore/blob/879f8440a4e9ace5d3cf145ce8b3d5e5ffb892ef/tests/unit/auth/aws4_testsuite/get-vanilla-ut8-query.sreq\n    (\n        \"us-east-1\",\n        \"2011-09-09T23:36:00Z\",\n        {\n            \"access_key_id\": \"AKIDEXAMPLE\",\n            \"secret_access_key\": \"wJalrXUtnFEMI/K7MDENG+bPxRfiCYEXAMPLEKEY\",\n        },\n        {\n            \"method\": \"GET\",\n            \"url\": \"https://host.foo.com/?{}=bar\".format(\n                urllib.parse.unquote(\"%E1%88%B4\")\n            ),\n            \"headers\": {\"date\": \"Mon, 09 Sep 2011 23:36:00 GMT\"},\n        },\n        {\n            \"url\": \"https://host.foo.com/?{}=bar\".format(\n                urllib.parse.unquote(\"%E1%88%B4\")\n            ),\n            \"method\": \"GET\",\n            \"headers\": {\n                \"Authorization\": \"AWS4-HMAC-SHA256 Credential=AKIDEXAMPLE/20110909/us-east-1/host/aws4_request, SignedHeaders=date;host, Signature=6fb359e9a05394cc7074e0feb42573a2601abc0c869a953e8c5c12e4e01f1a8c\",\n                \"host\": \"host.foo.com\",\n                \"date\": \"Mon, 09 Sep 2011 23:36:00 GMT\",\n            },\n        },\n    ),\n    # POST request with sorted headers (AWS botocore tests).\n    # https://github.com/boto/botocore/blob/879f8440a4e9ace5d3cf145ce8b3d5e5ffb892ef/tests/unit/auth/aws4_testsuite/post-header-key-sort.req\n    # https://github.com/boto/botocore/blob/879f8440a4e9ace5d3cf145ce8b3d5e5ffb892ef/tests/unit/auth/aws4_testsuite/post-header-key-sort.sreq\n    (\n        \"us-east-1\",\n        \"2011-09-09T23:36:00Z\",\n        {\n            \"access_key_id\": \"AKIDEXAMPLE\",\n            \"secret_access_key\": \"wJalrXUtnFEMI/K7MDENG+bPxRfiCYEXAMPLEKEY\",\n        },\n        {\n            \"method\": \"POST\",\n            \"url\": \"https://host.foo.com/\",\n            \"headers\": {\"date\": \"Mon, 09 Sep 2011 23:36:00 GMT\", \"ZOO\": \"zoobar\"},\n        },\n        {\n            \"url\": \"https://host.foo.com/\",\n            \"method\": \"POST\",\n            \"headers\": {\n                \"Authorization\": \"AWS4-HMAC-SHA256 Credential=AKIDEXAMPLE/20110909/us-east-1/host/aws4_request, SignedHeaders=date;host;zoo, Signature=b7a95a52518abbca0964a999a880429ab734f35ebbf1235bd79a5de87756dc4a\",\n                \"host\": \"host.foo.com\",\n                \"date\": \"Mon, 09 Sep 2011 23:36:00 GMT\",\n                \"ZOO\": \"zoobar\",\n            },\n        },\n    ),\n    # POST request with upper case header value from AWS Python test harness.\n    # https://github.com/boto/botocore/blob/879f8440a4e9ace5d3cf145ce8b3d5e5ffb892ef/tests/unit/auth/aws4_testsuite/post-header-value-case.req\n    # https://github.com/boto/botocore/blob/879f8440a4e9ace5d3cf145ce8b3d5e5ffb892ef/tests/unit/auth/aws4_testsuite/post-header-value-case.sreq\n    (\n        \"us-east-1\",\n        \"2011-09-09T23:36:00Z\",\n        {\n            \"access_key_id\": \"AKIDEXAMPLE\",\n            \"secret_access_key\": \"wJalrXUtnFEMI/K7MDENG+bPxRfiCYEXAMPLEKEY\",\n        },\n        {\n            \"method\": \"POST\",\n            \"url\": \"https://host.foo.com/\",\n            \"headers\": {\"date\": \"Mon, 09 Sep 2011 23:36:00 GMT\", \"zoo\": \"ZOOBAR\"},\n        },\n        {\n            \"url\": \"https://host.foo.com/\",\n            \"method\": \"POST\",\n            \"headers\": {\n                \"Authorization\": \"AWS4-HMAC-SHA256 Credential=AKIDEXAMPLE/20110909/us-east-1/host/aws4_request, SignedHeaders=date;host;zoo, Signature=273313af9d0c265c531e11db70bbd653f3ba074c1009239e8559d3987039cad7\",\n                \"host\": \"host.foo.com\",\n                \"date\": \"Mon, 09 Sep 2011 23:36:00 GMT\",\n                \"zoo\": \"ZOOBAR\",\n            },\n        },\n    ),\n    # POST request with header and no body (AWS botocore tests).\n    # https://github.com/boto/botocore/blob/879f8440a4e9ace5d3cf145ce8b3d5e5ffb892ef/tests/unit/auth/aws4_testsuite/get-header-value-trim.req\n    # https://github.com/boto/botocore/blob/879f8440a4e9ace5d3cf145ce8b3d5e5ffb892ef/tests/unit/auth/aws4_testsuite/get-header-value-trim.sreq\n    (\n        \"us-east-1\",\n        \"2011-09-09T23:36:00Z\",\n        {\n            \"access_key_id\": \"AKIDEXAMPLE\",\n            \"secret_access_key\": \"wJalrXUtnFEMI/K7MDENG+bPxRfiCYEXAMPLEKEY\",\n        },\n        {\n            \"method\": \"POST\",\n            \"url\": \"https://host.foo.com/\",\n            \"headers\": {\"date\": \"Mon, 09 Sep 2011 23:36:00 GMT\", \"p\": \"phfft\"},\n        },\n        {\n            \"url\": \"https://host.foo.com/\",\n            \"method\": \"POST\",\n            \"headers\": {\n                \"Authorization\": \"AWS4-HMAC-SHA256 Credential=AKIDEXAMPLE/20110909/us-east-1/host/aws4_request, SignedHeaders=date;host;p, Signature=debf546796015d6f6ded8626f5ce98597c33b47b9164cf6b17b4642036fcb592\",\n                \"host\": \"host.foo.com\",\n                \"date\": \"Mon, 09 Sep 2011 23:36:00 GMT\",\n                \"p\": \"phfft\",\n            },\n        },\n    ),\n    # POST request with body and no header (AWS botocore tests).\n    # https://github.com/boto/botocore/blob/879f8440a4e9ace5d3cf145ce8b3d5e5ffb892ef/tests/unit/auth/aws4_testsuite/post-x-www-form-urlencoded.req\n    # https://github.com/boto/botocore/blob/879f8440a4e9ace5d3cf145ce8b3d5e5ffb892ef/tests/unit/auth/aws4_testsuite/post-x-www-form-urlencoded.sreq\n    (\n        \"us-east-1\",\n        \"2011-09-09T23:36:00Z\",\n        {\n            \"access_key_id\": \"AKIDEXAMPLE\",\n            \"secret_access_key\": \"wJalrXUtnFEMI/K7MDENG+bPxRfiCYEXAMPLEKEY\",\n        },\n        {\n            \"method\": \"POST\",\n            \"url\": \"https://host.foo.com/\",\n            \"headers\": {\n                \"Content-Type\": \"application/x-www-form-urlencoded\",\n                \"date\": \"Mon, 09 Sep 2011 23:36:00 GMT\",\n            },\n            \"data\": \"foo=bar\",\n        },\n        {\n            \"url\": \"https://host.foo.com/\",\n            \"method\": \"POST\",\n            \"headers\": {\n                \"Authorization\": \"AWS4-HMAC-SHA256 Credential=AKIDEXAMPLE/20110909/us-east-1/host/aws4_request, SignedHeaders=content-type;date;host, Signature=5a15b22cf462f047318703b92e6f4f38884e4a7ab7b1d6426ca46a8bd1c26cbc\",\n                \"host\": \"host.foo.com\",\n                \"Content-Type\": \"application/x-www-form-urlencoded\",\n                \"date\": \"Mon, 09 Sep 2011 23:36:00 GMT\",\n            },\n            \"data\": \"foo=bar\",\n        },\n    ),\n    # POST request with querystring (AWS botocore tests).\n    # https://github.com/boto/botocore/blob/879f8440a4e9ace5d3cf145ce8b3d5e5ffb892ef/tests/unit/auth/aws4_testsuite/post-vanilla-query.req\n    # https://github.com/boto/botocore/blob/879f8440a4e9ace5d3cf145ce8b3d5e5ffb892ef/tests/unit/auth/aws4_testsuite/post-vanilla-query.sreq\n    (\n        \"us-east-1\",\n        \"2011-09-09T23:36:00Z\",\n        {\n            \"access_key_id\": \"AKIDEXAMPLE\",\n            \"secret_access_key\": \"wJalrXUtnFEMI/K7MDENG+bPxRfiCYEXAMPLEKEY\",\n        },\n        {\n            \"method\": \"POST\",\n            \"url\": \"https://host.foo.com/?foo=bar\",\n            \"headers\": {\"date\": \"Mon, 09 Sep 2011 23:36:00 GMT\"},\n        },\n        {\n            \"url\": \"https://host.foo.com/?foo=bar\",\n            \"method\": \"POST\",\n            \"headers\": {\n                \"Authorization\": \"AWS4-HMAC-SHA256 Credential=AKIDEXAMPLE/20110909/us-east-1/host/aws4_request, SignedHeaders=date;host, Signature=b6e3b79003ce0743a491606ba1035a804593b0efb1e20a11cba83f8c25a57a92\",\n                \"host\": \"host.foo.com\",\n                \"date\": \"Mon, 09 Sep 2011 23:36:00 GMT\",\n            },\n        },\n    ),\n    # GET request with session token credentials.\n    (\n        \"us-east-2\",\n        \"2020-08-11T06:55:22Z\",\n        {\n            \"access_key_id\": ACCESS_KEY_ID,\n            \"secret_access_key\": SECRET_ACCESS_KEY,\n            \"security_token\": TOKEN,\n        },\n        {\n            \"method\": \"GET\",\n            \"url\": \"https://ec2.us-east-2.amazonaws.com?Action=DescribeRegions&Version=2013-10-15\",\n        },\n        {\n            \"url\": \"https://ec2.us-east-2.amazonaws.com?Action=DescribeRegions&Version=2013-10-15\",\n            \"method\": \"GET\",\n            \"headers\": {\n                \"Authorization\": \"AWS4-HMAC-SHA256 Credential=\"\n                + ACCESS_KEY_ID\n                + \"/20200811/us-east-2/ec2/aws4_request, SignedHeaders=host;x-amz-date;x-amz-security-token, Signature=41e226f997bf917ec6c9b2b14218df0874225f13bb153236c247881e614fafc9\",\n                \"host\": \"ec2.us-east-2.amazonaws.com\",\n                \"x-amz-date\": \"20200811T065522Z\",\n                \"x-amz-security-token\": TOKEN,\n            },\n        },\n    ),\n    # POST request with session token credentials.\n    (\n        \"us-east-2\",\n        \"2020-08-11T06:55:22Z\",\n        {\n            \"access_key_id\": ACCESS_KEY_ID,\n            \"secret_access_key\": SECRET_ACCESS_KEY,\n            \"security_token\": TOKEN,\n        },\n        {\n            \"method\": \"POST\",\n            \"url\": \"https://sts.us-east-2.amazonaws.com?Action=GetCallerIdentity&Version=2011-06-15\",\n        },\n        {\n            \"url\": \"https://sts.us-east-2.amazonaws.com?Action=GetCallerIdentity&Version=2011-06-15\",\n            \"method\": \"POST\",\n            \"headers\": {\n                \"Authorization\": \"AWS4-HMAC-SHA256 Credential=\"\n                + ACCESS_KEY_ID\n                + \"/20200811/us-east-2/sts/aws4_request, SignedHeaders=host;x-amz-date;x-amz-security-token, Signature=596aa990b792d763465d73703e684ca273c45536c6d322c31be01a41d02e5b60\",\n                \"host\": \"sts.us-east-2.amazonaws.com\",\n                \"x-amz-date\": \"20200811T065522Z\",\n                \"x-amz-security-token\": TOKEN,\n            },\n        },\n    ),\n    # POST request with computed x-amz-date and no data.\n    (\n        \"us-east-2\",\n        \"2020-08-11T06:55:22Z\",\n        {\"access_key_id\": ACCESS_KEY_ID, \"secret_access_key\": SECRET_ACCESS_KEY},\n        {\n            \"method\": \"POST\",\n            \"url\": \"https://sts.us-east-2.amazonaws.com?Action=GetCallerIdentity&Version=2011-06-15\",\n        },\n        {\n            \"url\": \"https://sts.us-east-2.amazonaws.com?Action=GetCallerIdentity&Version=2011-06-15\",\n            \"method\": \"POST\",\n            \"headers\": {\n                \"Authorization\": \"AWS4-HMAC-SHA256 Credential=\"\n                + ACCESS_KEY_ID\n                + \"/20200811/us-east-2/sts/aws4_request, SignedHeaders=host;x-amz-date, Signature=9e722e5b7bfa163447e2a14df118b45ebd283c5aea72019bdf921d6e7dc01a9a\",\n                \"host\": \"sts.us-east-2.amazonaws.com\",\n                \"x-amz-date\": \"20200811T065522Z\",\n            },\n        },\n    ),\n    # POST request with session token and additional headers/data.\n    (\n        \"us-east-2\",\n        \"2020-08-11T06:55:22Z\",\n        {\n            \"access_key_id\": ACCESS_KEY_ID,\n            \"secret_access_key\": SECRET_ACCESS_KEY,\n            \"security_token\": TOKEN,\n        },\n        {\n            \"method\": \"POST\",\n            \"url\": \"https://dynamodb.us-east-2.amazonaws.com/\",\n            \"headers\": {\n                \"Content-Type\": \"application/x-amz-json-1.0\",\n                \"x-amz-target\": \"DynamoDB_20120810.CreateTable\",\n            },\n            \"data\": REQUEST_PARAMS,\n        },\n        {\n            \"url\": \"https://dynamodb.us-east-2.amazonaws.com/\",\n            \"method\": \"POST\",\n            \"headers\": {\n                \"Authorization\": \"AWS4-HMAC-SHA256 Credential=\"\n                + ACCESS_KEY_ID\n                + \"/20200811/us-east-2/dynamodb/aws4_request, SignedHeaders=content-type;host;x-amz-date;x-amz-security-token;x-amz-target, Signature=eb8bce0e63654bba672d4a8acb07e72d69210c1797d56ce024dbbc31beb2a2c7\",\n                \"host\": \"dynamodb.us-east-2.amazonaws.com\",\n                \"x-amz-date\": \"20200811T065522Z\",\n                \"Content-Type\": \"application/x-amz-json-1.0\",\n                \"x-amz-target\": \"DynamoDB_20120810.CreateTable\",\n                \"x-amz-security-token\": TOKEN,\n            },\n            \"data\": REQUEST_PARAMS,\n        },\n    ),\n]\n\n\nclass TestRequestSigner(object):\n    @pytest.mark.parametrize(\n        \"region, time, credentials, original_request, signed_request\", TEST_FIXTURES\n    )\n    @mock.patch(\"google.auth._helpers.utcnow\")\n    def test_get_request_options(\n        self, utcnow, region, time, credentials, original_request, signed_request\n    ):\n        utcnow.return_value = datetime.datetime.strptime(time, \"%Y-%m-%dT%H:%M:%SZ\")\n        request_signer = aws.RequestSigner(region)\n        credentials_object = aws.AwsSecurityCredentials(\n            credentials.get(\"access_key_id\"),\n            credentials.get(\"secret_access_key\"),\n            credentials.get(\"security_token\"),\n        )\n        actual_signed_request = request_signer.get_request_options(\n            credentials_object,\n            original_request.get(\"url\"),\n            original_request.get(\"method\"),\n            original_request.get(\"data\"),\n            original_request.get(\"headers\"),\n        )\n\n        assert actual_signed_request == signed_request\n\n    def test_get_request_options_with_missing_scheme_url(self):\n        request_signer = aws.RequestSigner(\"us-east-2\")\n\n        with pytest.raises(ValueError) as excinfo:\n            request_signer.get_request_options(\n                aws.AwsSecurityCredentials(ACCESS_KEY_ID, SECRET_ACCESS_KEY),\n                \"invalid\",\n                \"POST\",\n            )\n\n        assert excinfo.match(r\"Invalid AWS service URL\")\n\n    def test_get_request_options_with_invalid_scheme_url(self):\n        request_signer = aws.RequestSigner(\"us-east-2\")\n\n        with pytest.raises(ValueError) as excinfo:\n            request_signer.get_request_options(\n                aws.AwsSecurityCredentials(ACCESS_KEY_ID, SECRET_ACCESS_KEY),\n                \"http://invalid\",\n                \"POST\",\n            )\n\n        assert excinfo.match(r\"Invalid AWS service URL\")\n\n    def test_get_request_options_with_missing_hostname_url(self):\n        request_signer = aws.RequestSigner(\"us-east-2\")\n\n        with pytest.raises(ValueError) as excinfo:\n            request_signer.get_request_options(\n                aws.AwsSecurityCredentials(ACCESS_KEY_ID, SECRET_ACCESS_KEY),\n                \"https://\",\n                \"POST\",\n            )\n\n        assert excinfo.match(r\"Invalid AWS service URL\")\n\n\nclass TestAwsSecurityCredentialsSupplier(aws.AwsSecurityCredentialsSupplier):\n    def __init__(\n        self,\n        security_credentials=None,\n        region=None,\n        credentials_exception=None,\n        region_exception=None,\n        expected_context=None,\n    ):\n        self._security_credentials = security_credentials\n        self._region = region\n        self._credentials_exception = credentials_exception\n        self._region_exception = region_exception\n        self._expected_context = expected_context\n\n    def get_aws_security_credentials(self, context, request):\n        if self._expected_context is not None:\n            assert self._expected_context == context\n        if self._credentials_exception is not None:\n            raise self._credentials_exception\n        return self._security_credentials\n\n    def get_aws_region(self, context, request):\n        if self._expected_context is not None:\n            assert self._expected_context == context\n        if self._region_exception is not None:\n            raise self._region_exception\n        return self._region\n\n\nclass TestCredentials(object):\n    AWS_REGION = \"us-east-2\"\n    AWS_ROLE = \"gcp-aws-role\"\n    AWS_SECURITY_CREDENTIALS_RESPONSE = {\n        \"AccessKeyId\": ACCESS_KEY_ID,\n        \"SecretAccessKey\": SECRET_ACCESS_KEY,\n        \"Token\": TOKEN,\n    }\n    AWS_IMDSV2_SESSION_TOKEN = \"awsimdsv2sessiontoken\"\n    AWS_SIGNATURE_TIME = \"2020-08-11T06:55:22Z\"\n    CREDENTIAL_SOURCE = {\n        \"environment_id\": \"aws1\",\n        \"region_url\": REGION_URL,\n        \"url\": SECURITY_CREDS_URL,\n        \"regional_cred_verification_url\": CRED_VERIFICATION_URL,\n    }\n    CREDENTIAL_SOURCE_IPV6 = {\n        \"environment_id\": \"aws1\",\n        \"region_url\": REGION_URL_IPV6,\n        \"url\": SECURITY_CREDS_URL_IPV6,\n        \"regional_cred_verification_url\": CRED_VERIFICATION_URL,\n        \"imdsv2_session_token_url\": IMDSV2_SESSION_TOKEN_URL_IPV6,\n    }\n    SUCCESS_RESPONSE = {\n        \"access_token\": \"ACCESS_TOKEN\",\n        \"issued_token_type\": \"urn:ietf:params:oauth:token-type:access_token\",\n        \"token_type\": \"Bearer\",\n        \"expires_in\": 3600,\n        \"scope\": \" \".join(SCOPES),\n    }\n\n    @classmethod\n    def make_serialized_aws_signed_request(\n        cls,\n        aws_security_credentials,\n        region_name=\"us-east-2\",\n        url=\"https://sts.us-east-2.amazonaws.com?Action=GetCallerIdentity&Version=2011-06-15\",\n    ):\n        \"\"\"Utility to generate serialize AWS signed requests.\n        This makes it easy to assert generated subject tokens based on the\n        provided AWS security credentials, regions and AWS STS endpoint.\n        \"\"\"\n        request_signer = aws.RequestSigner(region_name)\n        signed_request = request_signer.get_request_options(\n            aws_security_credentials, url, \"POST\"\n        )\n        reformatted_signed_request = {\n            \"url\": signed_request.get(\"url\"),\n            \"method\": signed_request.get(\"method\"),\n            \"headers\": [\n                {\n                    \"key\": \"Authorization\",\n                    \"value\": signed_request.get(\"headers\").get(\"Authorization\"),\n                },\n                {\"key\": \"host\", \"value\": signed_request.get(\"headers\").get(\"host\")},\n                {\n                    \"key\": \"x-amz-date\",\n                    \"value\": signed_request.get(\"headers\").get(\"x-amz-date\"),\n                },\n            ],\n        }\n        # Include security token if available.\n        if aws_security_credentials.session_token is not None:\n            reformatted_signed_request.get(\"headers\").append(\n                {\n                    \"key\": \"x-amz-security-token\",\n                    \"value\": signed_request.get(\"headers\").get(\"x-amz-security-token\"),\n                }\n            )\n        # Append x-goog-cloud-target-resource header.\n        reformatted_signed_request.get(\"headers\").append(\n            {\"key\": \"x-goog-cloud-target-resource\", \"value\": AUDIENCE}\n        ),\n        return urllib.parse.quote(\n            json.dumps(\n                reformatted_signed_request, separators=(\",\", \":\"), sort_keys=True\n            )\n        )\n\n    @classmethod\n    def make_mock_request(\n        cls,\n        region_status=None,\n        region_name=None,\n        role_status=None,\n        role_name=None,\n        security_credentials_status=None,\n        security_credentials_data=None,\n        token_status=None,\n        token_data=None,\n        impersonation_status=None,\n        impersonation_data=None,\n        imdsv2_session_token_status=None,\n        imdsv2_session_token_data=None,\n    ):\n        \"\"\"Utility function to generate a mock HTTP request object.\n        This will facilitate testing various edge cases by specify how the\n        various endpoints will respond while generating a Google Access token\n        in an AWS environment.\n        \"\"\"\n        responses = []\n\n        if region_status:\n            if imdsv2_session_token_status:\n                # AWS session token request\n                imdsv2_session_response = mock.create_autospec(\n                    transport.Response, instance=True\n                )\n                imdsv2_session_response.status = imdsv2_session_token_status\n                imdsv2_session_response.data = imdsv2_session_token_data\n                responses.append(imdsv2_session_response)\n\n            # AWS region request.\n            region_response = mock.create_autospec(transport.Response, instance=True)\n            region_response.status = region_status\n            if region_name:\n                region_response.data = \"{}b\".format(region_name).encode(\"utf-8\")\n            responses.append(region_response)\n\n        if imdsv2_session_token_status:\n            # AWS session token request\n            imdsv2_session_response = mock.create_autospec(\n                transport.Response, instance=True\n            )\n            imdsv2_session_response.status = imdsv2_session_token_status\n            imdsv2_session_response.data = imdsv2_session_token_data\n            responses.append(imdsv2_session_response)\n\n        if role_status:\n            # AWS role name request.\n            role_response = mock.create_autospec(transport.Response, instance=True)\n            role_response.status = role_status\n            if role_name:\n                role_response.data = role_name.encode(\"utf-8\")\n            responses.append(role_response)\n\n        if security_credentials_status:\n            # AWS security credentials request.\n            security_credentials_response = mock.create_autospec(\n                transport.Response, instance=True\n            )\n            security_credentials_response.status = security_credentials_status\n            if security_credentials_data:\n                security_credentials_response.data = json.dumps(\n                    security_credentials_data\n                ).encode(\"utf-8\")\n            responses.append(security_credentials_response)\n\n        if token_status:\n            # GCP token exchange request.\n            token_response = mock.create_autospec(transport.Response, instance=True)\n            token_response.status = token_status\n            token_response.data = json.dumps(token_data).encode(\"utf-8\")\n            responses.append(token_response)\n\n        if impersonation_status:\n            # Service account impersonation request.\n            impersonation_response = mock.create_autospec(\n                transport.Response, instance=True\n            )\n            impersonation_response.status = impersonation_status\n            impersonation_response.data = json.dumps(impersonation_data).encode(\"utf-8\")\n            responses.append(impersonation_response)\n\n        request = mock.create_autospec(transport.Request)\n        request.side_effect = responses\n\n        return request\n\n    @classmethod\n    def make_credentials(\n        cls,\n        credential_source=None,\n        aws_security_credentials_supplier=None,\n        token_url=TOKEN_URL,\n        token_info_url=TOKEN_INFO_URL,\n        client_id=None,\n        client_secret=None,\n        quota_project_id=None,\n        scopes=None,\n        default_scopes=None,\n        service_account_impersonation_url=None,\n    ):\n        return aws.Credentials(\n            audience=AUDIENCE,\n            subject_token_type=SUBJECT_TOKEN_TYPE,\n            token_url=token_url,\n            token_info_url=token_info_url,\n            service_account_impersonation_url=service_account_impersonation_url,\n            credential_source=credential_source,\n            aws_security_credentials_supplier=aws_security_credentials_supplier,\n            client_id=client_id,\n            client_secret=client_secret,\n            quota_project_id=quota_project_id,\n            scopes=scopes,\n            default_scopes=default_scopes,\n        )\n\n    @classmethod\n    def assert_aws_metadata_request_kwargs(\n        cls, request_kwargs, url, headers=None, method=\"GET\"\n    ):\n        assert request_kwargs[\"url\"] == url\n        # All used AWS metadata server endpoints use GET HTTP method.\n        assert request_kwargs[\"method\"] == method\n        if headers:\n            assert request_kwargs[\"headers\"] == headers\n        else:\n            assert \"headers\" not in request_kwargs or request_kwargs[\"headers\"] is None\n        # None of the endpoints used require any data in request.\n        assert \"body\" not in request_kwargs\n\n    @classmethod\n    def assert_token_request_kwargs(\n        cls, request_kwargs, headers, request_data, token_url=TOKEN_URL\n    ):\n        assert request_kwargs[\"url\"] == token_url\n        assert request_kwargs[\"method\"] == \"POST\"\n        assert request_kwargs[\"headers\"] == headers\n        assert request_kwargs[\"body\"] is not None\n        body_tuples = urllib.parse.parse_qsl(request_kwargs[\"body\"])\n        assert len(body_tuples) == len(request_data.keys())\n        for (k, v) in body_tuples:\n            assert v.decode(\"utf-8\") == request_data[k.decode(\"utf-8\")]\n\n    @classmethod\n    def assert_impersonation_request_kwargs(\n        cls,\n        request_kwargs,\n        headers,\n        request_data,\n        service_account_impersonation_url=SERVICE_ACCOUNT_IMPERSONATION_URL,\n    ):\n        assert request_kwargs[\"url\"] == service_account_impersonation_url\n        assert request_kwargs[\"method\"] == \"POST\"\n        assert request_kwargs[\"headers\"] == headers\n        assert request_kwargs[\"body\"] is not None\n        body_json = json.loads(request_kwargs[\"body\"].decode(\"utf-8\"))\n        assert body_json == request_data\n\n    @mock.patch.object(aws.Credentials, \"__init__\", return_value=None)\n    def test_from_info_full_options(self, mock_init):\n        credentials = aws.Credentials.from_info(\n            {\n                \"audience\": AUDIENCE,\n                \"subject_token_type\": SUBJECT_TOKEN_TYPE,\n                \"token_url\": TOKEN_URL,\n                \"token_info_url\": TOKEN_INFO_URL,\n                \"service_account_impersonation_url\": SERVICE_ACCOUNT_IMPERSONATION_URL,\n                \"service_account_impersonation\": {\"token_lifetime_seconds\": 2800},\n                \"client_id\": CLIENT_ID,\n                \"client_secret\": CLIENT_SECRET,\n                \"quota_project_id\": QUOTA_PROJECT_ID,\n                \"credential_source\": self.CREDENTIAL_SOURCE,\n            }\n        )\n\n        # Confirm aws.Credentials instance initialized with the expected parameters.\n        assert isinstance(credentials, aws.Credentials)\n        mock_init.assert_called_once_with(\n            audience=AUDIENCE,\n            subject_token_type=SUBJECT_TOKEN_TYPE,\n            token_url=TOKEN_URL,\n            token_info_url=TOKEN_INFO_URL,\n            service_account_impersonation_url=SERVICE_ACCOUNT_IMPERSONATION_URL,\n            service_account_impersonation_options={\"token_lifetime_seconds\": 2800},\n            client_id=CLIENT_ID,\n            client_secret=CLIENT_SECRET,\n            credential_source=self.CREDENTIAL_SOURCE,\n            aws_security_credentials_supplier=None,\n            quota_project_id=QUOTA_PROJECT_ID,\n            workforce_pool_user_project=None,\n            universe_domain=DEFAULT_UNIVERSE_DOMAIN,\n        )\n\n    @mock.patch.object(aws.Credentials, \"__init__\", return_value=None)\n    def test_from_info_required_options_only(self, mock_init):\n        credentials = aws.Credentials.from_info(\n            {\n                \"audience\": AUDIENCE,\n                \"subject_token_type\": SUBJECT_TOKEN_TYPE,\n                \"token_url\": TOKEN_URL,\n                \"credential_source\": self.CREDENTIAL_SOURCE,\n            }\n        )\n\n        # Confirm aws.Credentials instance initialized with the expected parameters.\n        assert isinstance(credentials, aws.Credentials)\n        mock_init.assert_called_once_with(\n            audience=AUDIENCE,\n            subject_token_type=SUBJECT_TOKEN_TYPE,\n            token_url=TOKEN_URL,\n            token_info_url=None,\n            service_account_impersonation_url=None,\n            service_account_impersonation_options={},\n            client_id=None,\n            client_secret=None,\n            credential_source=self.CREDENTIAL_SOURCE,\n            aws_security_credentials_supplier=None,\n            quota_project_id=None,\n            workforce_pool_user_project=None,\n            universe_domain=DEFAULT_UNIVERSE_DOMAIN,\n        )\n\n    @mock.patch.object(aws.Credentials, \"__init__\", return_value=None)\n    def test_from_info_supplier(self, mock_init):\n        supplier = TestAwsSecurityCredentialsSupplier()\n\n        credentials = aws.Credentials.from_info(\n            {\n                \"audience\": AUDIENCE,\n                \"subject_token_type\": SUBJECT_TOKEN_TYPE,\n                \"token_url\": TOKEN_URL,\n                \"aws_security_credentials_supplier\": supplier,\n            }\n        )\n\n        # Confirm aws.Credentials instance initialized with the expected parameters.\n        assert isinstance(credentials, aws.Credentials)\n        mock_init.assert_called_once_with(\n            audience=AUDIENCE,\n            subject_token_type=SUBJECT_TOKEN_TYPE,\n            token_url=TOKEN_URL,\n            token_info_url=None,\n            service_account_impersonation_url=None,\n            service_account_impersonation_options={},\n            client_id=None,\n            client_secret=None,\n            credential_source=None,\n            aws_security_credentials_supplier=supplier,\n            quota_project_id=None,\n            workforce_pool_user_project=None,\n            universe_domain=DEFAULT_UNIVERSE_DOMAIN,\n        )\n\n    @mock.patch.object(aws.Credentials, \"__init__\", return_value=None)\n    def test_from_file_full_options(self, mock_init, tmpdir):\n        info = {\n            \"audience\": AUDIENCE,\n            \"subject_token_type\": SUBJECT_TOKEN_TYPE,\n            \"token_url\": TOKEN_URL,\n            \"token_info_url\": TOKEN_INFO_URL,\n            \"service_account_impersonation_url\": SERVICE_ACCOUNT_IMPERSONATION_URL,\n            \"service_account_impersonation\": {\"token_lifetime_seconds\": 2800},\n            \"client_id\": CLIENT_ID,\n            \"client_secret\": CLIENT_SECRET,\n            \"quota_project_id\": QUOTA_PROJECT_ID,\n            \"credential_source\": self.CREDENTIAL_SOURCE,\n            \"universe_domain\": DEFAULT_UNIVERSE_DOMAIN,\n        }\n        config_file = tmpdir.join(\"config.json\")\n        config_file.write(json.dumps(info))\n        credentials = aws.Credentials.from_file(str(config_file))\n\n        # Confirm aws.Credentials instance initialized with the expected parameters.\n        assert isinstance(credentials, aws.Credentials)\n        mock_init.assert_called_once_with(\n            audience=AUDIENCE,\n            subject_token_type=SUBJECT_TOKEN_TYPE,\n            token_url=TOKEN_URL,\n            token_info_url=TOKEN_INFO_URL,\n            service_account_impersonation_url=SERVICE_ACCOUNT_IMPERSONATION_URL,\n            service_account_impersonation_options={\"token_lifetime_seconds\": 2800},\n            client_id=CLIENT_ID,\n            client_secret=CLIENT_SECRET,\n            credential_source=self.CREDENTIAL_SOURCE,\n            aws_security_credentials_supplier=None,\n            quota_project_id=QUOTA_PROJECT_ID,\n            workforce_pool_user_project=None,\n            universe_domain=DEFAULT_UNIVERSE_DOMAIN,\n        )\n\n    @mock.patch.object(aws.Credentials, \"__init__\", return_value=None)\n    def test_from_file_required_options_only(self, mock_init, tmpdir):\n        info = {\n            \"audience\": AUDIENCE,\n            \"subject_token_type\": SUBJECT_TOKEN_TYPE,\n            \"token_url\": TOKEN_URL,\n            \"credential_source\": self.CREDENTIAL_SOURCE,\n        }\n        config_file = tmpdir.join(\"config.json\")\n        config_file.write(json.dumps(info))\n        credentials = aws.Credentials.from_file(str(config_file))\n\n        # Confirm aws.Credentials instance initialized with the expected parameters.\n        assert isinstance(credentials, aws.Credentials)\n        mock_init.assert_called_once_with(\n            audience=AUDIENCE,\n            subject_token_type=SUBJECT_TOKEN_TYPE,\n            token_url=TOKEN_URL,\n            token_info_url=None,\n            service_account_impersonation_url=None,\n            service_account_impersonation_options={},\n            client_id=None,\n            client_secret=None,\n            credential_source=self.CREDENTIAL_SOURCE,\n            aws_security_credentials_supplier=None,\n            quota_project_id=None,\n            workforce_pool_user_project=None,\n            universe_domain=DEFAULT_UNIVERSE_DOMAIN,\n        )\n\n    def test_constructor_invalid_credential_source(self):\n        # Provide invalid credential source.\n        credential_source = {\"unsupported\": \"value\"}\n\n        with pytest.raises(ValueError) as excinfo:\n            self.make_credentials(credential_source=credential_source)\n\n        assert excinfo.match(r\"No valid AWS 'credential_source' provided\")\n\n    def test_constructor_invalid_credential_source_and_supplier(self):\n        # Provide both a credential source and supplier.\n        with pytest.raises(ValueError) as excinfo:\n            self.make_credentials(\n                credential_source=self.CREDENTIAL_SOURCE,\n                aws_security_credentials_supplier=\"test\",\n            )\n\n        assert excinfo.match(\n            r\"AWS credential cannot have both a credential source and an AWS security credentials supplier.\"\n        )\n\n    def test_constructor_invalid_no_credential_source_or_supplier(self):\n        # Provide no credential source or supplier.\n        with pytest.raises(ValueError) as excinfo:\n            self.make_credentials()\n\n        assert excinfo.match(\n            r\"A valid credential source or AWS security credentials supplier must be provided.\"\n        )\n\n    def test_constructor_invalid_environment_id(self):\n        # Provide invalid environment_id.\n        credential_source = self.CREDENTIAL_SOURCE.copy()\n        credential_source[\"environment_id\"] = \"azure1\"\n\n        with pytest.raises(ValueError) as excinfo:\n            self.make_credentials(credential_source=credential_source)\n\n        assert excinfo.match(r\"No valid AWS 'credential_source' provided\")\n\n    def test_constructor_missing_cred_verification_url(self):\n        # regional_cred_verification_url is a required field.\n        credential_source = self.CREDENTIAL_SOURCE.copy()\n        credential_source.pop(\"regional_cred_verification_url\")\n\n        with pytest.raises(ValueError) as excinfo:\n            self.make_credentials(credential_source=credential_source)\n\n        assert excinfo.match(r\"No valid AWS 'credential_source' provided\")\n\n    def test_constructor_invalid_environment_id_version(self):\n        # Provide an unsupported version.\n        credential_source = self.CREDENTIAL_SOURCE.copy()\n        credential_source[\"environment_id\"] = \"aws3\"\n\n        with pytest.raises(ValueError) as excinfo:\n            self.make_credentials(credential_source=credential_source)\n\n        assert excinfo.match(r\"aws version '3' is not supported in the current build.\")\n\n    def test_info(self):\n        credentials = self.make_credentials(\n            credential_source=self.CREDENTIAL_SOURCE.copy()\n        )\n\n        assert credentials.info == {\n            \"type\": \"external_account\",\n            \"audience\": AUDIENCE,\n            \"subject_token_type\": SUBJECT_TOKEN_TYPE,\n            \"token_url\": TOKEN_URL,\n            \"token_info_url\": TOKEN_INFO_URL,\n            \"credential_source\": self.CREDENTIAL_SOURCE,\n            \"universe_domain\": DEFAULT_UNIVERSE_DOMAIN,\n        }\n\n    def test_token_info_url(self):\n        credentials = self.make_credentials(\n            credential_source=self.CREDENTIAL_SOURCE.copy()\n        )\n\n        assert credentials.token_info_url == TOKEN_INFO_URL\n\n    def test_token_info_url_custom(self):\n        for url in VALID_TOKEN_URLS:\n            credentials = self.make_credentials(\n                credential_source=self.CREDENTIAL_SOURCE.copy(),\n                token_info_url=(url + \"/introspect\"),\n            )\n\n            assert credentials.token_info_url == (url + \"/introspect\")\n\n    def test_token_info_url_negative(self):\n        credentials = self.make_credentials(\n            credential_source=self.CREDENTIAL_SOURCE.copy(), token_info_url=None\n        )\n\n        assert not credentials.token_info_url\n\n    def test_token_url_custom(self):\n        for url in VALID_TOKEN_URLS:\n            credentials = self.make_credentials(\n                credential_source=self.CREDENTIAL_SOURCE.copy(),\n                token_url=(url + \"/token\"),\n            )\n\n            assert credentials._token_url == (url + \"/token\")\n\n    def test_service_account_impersonation_url_custom(self):\n        for url in VALID_SERVICE_ACCOUNT_IMPERSONATION_URLS:\n            credentials = self.make_credentials(\n                credential_source=self.CREDENTIAL_SOURCE.copy(),\n                service_account_impersonation_url=(\n                    url + SERVICE_ACCOUNT_IMPERSONATION_URL_ROUTE\n                ),\n            )\n\n            assert credentials._service_account_impersonation_url == (\n                url + SERVICE_ACCOUNT_IMPERSONATION_URL_ROUTE\n            )\n\n    def test_info_with_default_token_url(self):\n        credentials = aws.Credentials(\n            audience=AUDIENCE,\n            subject_token_type=SUBJECT_TOKEN_TYPE,\n            credential_source=self.CREDENTIAL_SOURCE.copy(),\n        )\n\n        assert credentials.info == {\n            \"type\": \"external_account\",\n            \"audience\": AUDIENCE,\n            \"subject_token_type\": SUBJECT_TOKEN_TYPE,\n            \"token_url\": TOKEN_URL,\n            \"credential_source\": self.CREDENTIAL_SOURCE.copy(),\n            \"universe_domain\": DEFAULT_UNIVERSE_DOMAIN,\n        }\n\n    def test_info_with_default_token_url_with_universe_domain(self):\n        credentials = aws.Credentials(\n            audience=AUDIENCE,\n            subject_token_type=SUBJECT_TOKEN_TYPE,\n            credential_source=self.CREDENTIAL_SOURCE.copy(),\n            universe_domain=\"testdomain.org\",\n        )\n\n        assert credentials.info == {\n            \"type\": \"external_account\",\n            \"audience\": AUDIENCE,\n            \"subject_token_type\": SUBJECT_TOKEN_TYPE,\n            \"token_url\": \"https://sts.testdomain.org/v1/token\",\n            \"credential_source\": self.CREDENTIAL_SOURCE.copy(),\n            \"universe_domain\": \"testdomain.org\",\n        }\n\n    def test_retrieve_subject_token_missing_region_url(self):\n        # When AWS_REGION envvar is not available, region_url is required for\n        # determining the current AWS region.\n        credential_source = self.CREDENTIAL_SOURCE.copy()\n        credential_source.pop(\"region_url\")\n        credentials = self.make_credentials(credential_source=credential_source)\n\n        with pytest.raises(exceptions.RefreshError) as excinfo:\n            credentials.retrieve_subject_token(None)\n\n        assert excinfo.match(r\"Unable to determine AWS region\")\n\n    @mock.patch(\"google.auth._helpers.utcnow\")\n    def test_retrieve_subject_token_success_temp_creds_no_environment_vars(\n        self, utcnow\n    ):\n        utcnow.return_value = datetime.datetime.strptime(\n            self.AWS_SIGNATURE_TIME, \"%Y-%m-%dT%H:%M:%SZ\"\n        )\n        request = self.make_mock_request(\n            region_status=http_client.OK,\n            region_name=self.AWS_REGION,\n            role_status=http_client.OK,\n            role_name=self.AWS_ROLE,\n            security_credentials_status=http_client.OK,\n            security_credentials_data=self.AWS_SECURITY_CREDENTIALS_RESPONSE,\n        )\n        credentials = self.make_credentials(credential_source=self.CREDENTIAL_SOURCE)\n\n        subject_token = credentials.retrieve_subject_token(request)\n\n        assert subject_token == self.make_serialized_aws_signed_request(\n            aws.AwsSecurityCredentials(ACCESS_KEY_ID, SECRET_ACCESS_KEY, TOKEN)\n        )\n        # Assert region request.\n        self.assert_aws_metadata_request_kwargs(\n            request.call_args_list[0][1], REGION_URL\n        )\n        # Assert role request.\n        self.assert_aws_metadata_request_kwargs(\n            request.call_args_list[1][1], SECURITY_CREDS_URL\n        )\n        # Assert security credentials request.\n        self.assert_aws_metadata_request_kwargs(\n            request.call_args_list[2][1],\n            \"{}/{}\".format(SECURITY_CREDS_URL, self.AWS_ROLE),\n            {\"Content-Type\": \"application/json\"},\n        )\n\n        # Retrieve subject_token again. Region should not be queried again.\n        new_request = self.make_mock_request(\n            role_status=http_client.OK,\n            role_name=self.AWS_ROLE,\n            security_credentials_status=http_client.OK,\n            security_credentials_data=self.AWS_SECURITY_CREDENTIALS_RESPONSE,\n        )\n\n        credentials.retrieve_subject_token(new_request)\n\n        # Only 3 requests should be sent as the region is cached.\n        assert len(new_request.call_args_list) == 2\n        # Assert role request.\n        self.assert_aws_metadata_request_kwargs(\n            new_request.call_args_list[0][1], SECURITY_CREDS_URL\n        )\n        # Assert security credentials request.\n        self.assert_aws_metadata_request_kwargs(\n            new_request.call_args_list[1][1],\n            \"{}/{}\".format(SECURITY_CREDS_URL, self.AWS_ROLE),\n            {\"Content-Type\": \"application/json\"},\n        )\n\n    @mock.patch(\"google.auth._helpers.utcnow\")\n    @mock.patch.dict(os.environ, {})\n    def test_retrieve_subject_token_success_temp_creds_no_environment_vars_idmsv2(\n        self, utcnow\n    ):\n        utcnow.return_value = datetime.datetime.strptime(\n            self.AWS_SIGNATURE_TIME, \"%Y-%m-%dT%H:%M:%SZ\"\n        )\n        request = self.make_mock_request(\n            region_status=http_client.OK,\n            region_name=self.AWS_REGION,\n            role_status=http_client.OK,\n            role_name=self.AWS_ROLE,\n            security_credentials_status=http_client.OK,\n            security_credentials_data=self.AWS_SECURITY_CREDENTIALS_RESPONSE,\n            imdsv2_session_token_status=http_client.OK,\n            imdsv2_session_token_data=self.AWS_IMDSV2_SESSION_TOKEN,\n        )\n        credential_source_token_url = self.CREDENTIAL_SOURCE.copy()\n        credential_source_token_url[\n            \"imdsv2_session_token_url\"\n        ] = IMDSV2_SESSION_TOKEN_URL\n        credentials = self.make_credentials(\n            credential_source=credential_source_token_url\n        )\n\n        subject_token = credentials.retrieve_subject_token(request)\n\n        assert subject_token == self.make_serialized_aws_signed_request(\n            aws.AwsSecurityCredentials(ACCESS_KEY_ID, SECRET_ACCESS_KEY, TOKEN)\n        )\n        # Assert session token request\n        self.assert_aws_metadata_request_kwargs(\n            request.call_args_list[0][1],\n            IMDSV2_SESSION_TOKEN_URL,\n            {\"X-aws-ec2-metadata-token-ttl-seconds\": \"300\"},\n            \"PUT\",\n        )\n        # Assert region request.\n        self.assert_aws_metadata_request_kwargs(\n            request.call_args_list[1][1],\n            REGION_URL,\n            {\"X-aws-ec2-metadata-token\": self.AWS_IMDSV2_SESSION_TOKEN},\n        )\n        # Assert session token request\n        self.assert_aws_metadata_request_kwargs(\n            request.call_args_list[2][1],\n            IMDSV2_SESSION_TOKEN_URL,\n            {\"X-aws-ec2-metadata-token-ttl-seconds\": \"300\"},\n            \"PUT\",\n        )\n        # Assert role request.\n        self.assert_aws_metadata_request_kwargs(\n            request.call_args_list[3][1],\n            SECURITY_CREDS_URL,\n            {\"X-aws-ec2-metadata-token\": self.AWS_IMDSV2_SESSION_TOKEN},\n        )\n        # Assert security credentials request.\n        self.assert_aws_metadata_request_kwargs(\n            request.call_args_list[4][1],\n            \"{}/{}\".format(SECURITY_CREDS_URL, self.AWS_ROLE),\n            {\n                \"Content-Type\": \"application/json\",\n                \"X-aws-ec2-metadata-token\": self.AWS_IMDSV2_SESSION_TOKEN,\n            },\n        )\n\n        # Retrieve subject_token again. Region should not be queried again.\n        new_request = self.make_mock_request(\n            role_status=http_client.OK,\n            role_name=self.AWS_ROLE,\n            security_credentials_status=http_client.OK,\n            security_credentials_data=self.AWS_SECURITY_CREDENTIALS_RESPONSE,\n            imdsv2_session_token_status=http_client.OK,\n            imdsv2_session_token_data=self.AWS_IMDSV2_SESSION_TOKEN,\n        )\n\n        credentials.retrieve_subject_token(new_request)\n\n        # Only 3 requests should be sent as the region is cached.\n        assert len(new_request.call_args_list) == 3\n        # Assert session token request.\n        self.assert_aws_metadata_request_kwargs(\n            request.call_args_list[0][1],\n            IMDSV2_SESSION_TOKEN_URL,\n            {\"X-aws-ec2-metadata-token-ttl-seconds\": \"300\"},\n            \"PUT\",\n        )\n        # Assert role request.\n        self.assert_aws_metadata_request_kwargs(\n            new_request.call_args_list[1][1],\n            SECURITY_CREDS_URL,\n            {\"X-aws-ec2-metadata-token\": self.AWS_IMDSV2_SESSION_TOKEN},\n        )\n        # Assert security credentials request.\n        self.assert_aws_metadata_request_kwargs(\n            new_request.call_args_list[2][1],\n            \"{}/{}\".format(SECURITY_CREDS_URL, self.AWS_ROLE),\n            {\n                \"Content-Type\": \"application/json\",\n                \"X-aws-ec2-metadata-token\": self.AWS_IMDSV2_SESSION_TOKEN,\n            },\n        )\n\n    @mock.patch(\"google.auth._helpers.utcnow\")\n    @mock.patch.dict(\n        os.environ,\n        {\n            environment_vars.AWS_REGION: AWS_REGION,\n            environment_vars.AWS_ACCESS_KEY_ID: ACCESS_KEY_ID,\n        },\n    )\n    def test_retrieve_subject_token_success_temp_creds_environment_vars_missing_secret_access_key_idmsv2(\n        self, utcnow\n    ):\n        utcnow.return_value = datetime.datetime.strptime(\n            self.AWS_SIGNATURE_TIME, \"%Y-%m-%dT%H:%M:%SZ\"\n        )\n        request = self.make_mock_request(\n            role_status=http_client.OK,\n            role_name=self.AWS_ROLE,\n            security_credentials_status=http_client.OK,\n            security_credentials_data=self.AWS_SECURITY_CREDENTIALS_RESPONSE,\n            imdsv2_session_token_status=http_client.OK,\n            imdsv2_session_token_data=self.AWS_IMDSV2_SESSION_TOKEN,\n        )\n        credential_source_token_url = self.CREDENTIAL_SOURCE.copy()\n        credential_source_token_url[\n            \"imdsv2_session_token_url\"\n        ] = IMDSV2_SESSION_TOKEN_URL\n        credentials = self.make_credentials(\n            credential_source=credential_source_token_url\n        )\n\n        subject_token = credentials.retrieve_subject_token(request)\n        assert subject_token == self.make_serialized_aws_signed_request(\n            aws.AwsSecurityCredentials(ACCESS_KEY_ID, SECRET_ACCESS_KEY, TOKEN)\n        )\n        # Assert session token request.\n        self.assert_aws_metadata_request_kwargs(\n            request.call_args_list[0][1],\n            IMDSV2_SESSION_TOKEN_URL,\n            {\"X-aws-ec2-metadata-token-ttl-seconds\": \"300\"},\n            \"PUT\",\n        )\n        # Assert role request.\n        self.assert_aws_metadata_request_kwargs(\n            request.call_args_list[1][1],\n            SECURITY_CREDS_URL,\n            {\"X-aws-ec2-metadata-token\": self.AWS_IMDSV2_SESSION_TOKEN},\n        )\n        # Assert security credentials request.\n        self.assert_aws_metadata_request_kwargs(\n            request.call_args_list[2][1],\n            \"{}/{}\".format(SECURITY_CREDS_URL, self.AWS_ROLE),\n            {\n                \"Content-Type\": \"application/json\",\n                \"X-aws-ec2-metadata-token\": self.AWS_IMDSV2_SESSION_TOKEN,\n            },\n        )\n\n    @mock.patch(\"google.auth._helpers.utcnow\")\n    @mock.patch.dict(\n        os.environ,\n        {\n            environment_vars.AWS_REGION: AWS_REGION,\n            environment_vars.AWS_SECRET_ACCESS_KEY: SECRET_ACCESS_KEY,\n        },\n    )\n    def test_retrieve_subject_token_success_temp_creds_environment_vars_missing_access_key_id_idmsv2(\n        self, utcnow\n    ):\n        utcnow.return_value = datetime.datetime.strptime(\n            self.AWS_SIGNATURE_TIME, \"%Y-%m-%dT%H:%M:%SZ\"\n        )\n        request = self.make_mock_request(\n            role_status=http_client.OK,\n            role_name=self.AWS_ROLE,\n            security_credentials_status=http_client.OK,\n            security_credentials_data=self.AWS_SECURITY_CREDENTIALS_RESPONSE,\n            imdsv2_session_token_status=http_client.OK,\n            imdsv2_session_token_data=self.AWS_IMDSV2_SESSION_TOKEN,\n        )\n        credential_source_token_url = self.CREDENTIAL_SOURCE.copy()\n        credential_source_token_url[\n            \"imdsv2_session_token_url\"\n        ] = IMDSV2_SESSION_TOKEN_URL\n        credentials = self.make_credentials(\n            credential_source=credential_source_token_url\n        )\n\n        subject_token = credentials.retrieve_subject_token(request)\n        assert subject_token == self.make_serialized_aws_signed_request(\n            aws.AwsSecurityCredentials(ACCESS_KEY_ID, SECRET_ACCESS_KEY, TOKEN)\n        )\n        # Assert session token request.\n        self.assert_aws_metadata_request_kwargs(\n            request.call_args_list[0][1],\n            IMDSV2_SESSION_TOKEN_URL,\n            {\"X-aws-ec2-metadata-token-ttl-seconds\": \"300\"},\n            \"PUT\",\n        )\n        # Assert role request.\n        self.assert_aws_metadata_request_kwargs(\n            request.call_args_list[1][1],\n            SECURITY_CREDS_URL,\n            {\"X-aws-ec2-metadata-token\": self.AWS_IMDSV2_SESSION_TOKEN},\n        )\n        # Assert security credentials request.\n        self.assert_aws_metadata_request_kwargs(\n            request.call_args_list[2][1],\n            \"{}/{}\".format(SECURITY_CREDS_URL, self.AWS_ROLE),\n            {\n                \"Content-Type\": \"application/json\",\n                \"X-aws-ec2-metadata-token\": self.AWS_IMDSV2_SESSION_TOKEN,\n            },\n        )\n\n    @mock.patch(\"google.auth._helpers.utcnow\")\n    @mock.patch.dict(os.environ, {environment_vars.AWS_REGION: AWS_REGION})\n    def test_retrieve_subject_token_success_temp_creds_environment_vars_missing_creds_idmsv2(\n        self, utcnow\n    ):\n        utcnow.return_value = datetime.datetime.strptime(\n            self.AWS_SIGNATURE_TIME, \"%Y-%m-%dT%H:%M:%SZ\"\n        )\n        request = self.make_mock_request(\n            role_status=http_client.OK,\n            role_name=self.AWS_ROLE,\n            security_credentials_status=http_client.OK,\n            security_credentials_data=self.AWS_SECURITY_CREDENTIALS_RESPONSE,\n            imdsv2_session_token_status=http_client.OK,\n            imdsv2_session_token_data=self.AWS_IMDSV2_SESSION_TOKEN,\n        )\n        credential_source_token_url = self.CREDENTIAL_SOURCE.copy()\n        credential_source_token_url[\n            \"imdsv2_session_token_url\"\n        ] = IMDSV2_SESSION_TOKEN_URL\n        credentials = self.make_credentials(\n            credential_source=credential_source_token_url\n        )\n\n        subject_token = credentials.retrieve_subject_token(request)\n        assert subject_token == self.make_serialized_aws_signed_request(\n            aws.AwsSecurityCredentials(ACCESS_KEY_ID, SECRET_ACCESS_KEY, TOKEN)\n        )\n        # Assert session token request.\n        self.assert_aws_metadata_request_kwargs(\n            request.call_args_list[0][1],\n            IMDSV2_SESSION_TOKEN_URL,\n            {\"X-aws-ec2-metadata-token-ttl-seconds\": \"300\"},\n            \"PUT\",\n        )\n        # Assert role request.\n        self.assert_aws_metadata_request_kwargs(\n            request.call_args_list[1][1],\n            SECURITY_CREDS_URL,\n            {\"X-aws-ec2-metadata-token\": self.AWS_IMDSV2_SESSION_TOKEN},\n        )\n        # Assert security credentials request.\n        self.assert_aws_metadata_request_kwargs(\n            request.call_args_list[2][1],\n            \"{}/{}\".format(SECURITY_CREDS_URL, self.AWS_ROLE),\n            {\n                \"Content-Type\": \"application/json\",\n                \"X-aws-ec2-metadata-token\": self.AWS_IMDSV2_SESSION_TOKEN,\n            },\n        )\n\n    @mock.patch(\"google.auth._helpers.utcnow\")\n    @mock.patch.dict(\n        os.environ,\n        {\n            environment_vars.AWS_REGION: AWS_REGION,\n            environment_vars.AWS_ACCESS_KEY_ID: ACCESS_KEY_ID,\n            environment_vars.AWS_SECRET_ACCESS_KEY: SECRET_ACCESS_KEY,\n        },\n    )\n    def test_retrieve_subject_token_success_temp_creds_idmsv2(self, utcnow):\n        utcnow.return_value = datetime.datetime.strptime(\n            self.AWS_SIGNATURE_TIME, \"%Y-%m-%dT%H:%M:%SZ\"\n        )\n        request = self.make_mock_request(\n            role_status=http_client.OK, role_name=self.AWS_ROLE\n        )\n        credential_source_token_url = self.CREDENTIAL_SOURCE.copy()\n        credential_source_token_url[\n            \"imdsv2_session_token_url\"\n        ] = IMDSV2_SESSION_TOKEN_URL\n        credentials = self.make_credentials(\n            credential_source=credential_source_token_url\n        )\n\n        credentials.retrieve_subject_token(request)\n        assert not request.called\n\n    @mock.patch(\"google.auth._helpers.utcnow\")\n    def test_retrieve_subject_token_success_ipv6(self, utcnow):\n        utcnow.return_value = datetime.datetime.strptime(\n            self.AWS_SIGNATURE_TIME, \"%Y-%m-%dT%H:%M:%SZ\"\n        )\n        request = self.make_mock_request(\n            region_status=http_client.OK,\n            region_name=self.AWS_REGION,\n            role_status=http_client.OK,\n            role_name=self.AWS_ROLE,\n            security_credentials_status=http_client.OK,\n            security_credentials_data=self.AWS_SECURITY_CREDENTIALS_RESPONSE,\n            imdsv2_session_token_status=http_client.OK,\n            imdsv2_session_token_data=self.AWS_IMDSV2_SESSION_TOKEN,\n        )\n        credential_source_token_url = self.CREDENTIAL_SOURCE_IPV6.copy()\n        credentials = self.make_credentials(\n            credential_source=credential_source_token_url\n        )\n\n        subject_token = credentials.retrieve_subject_token(request)\n\n        assert subject_token == self.make_serialized_aws_signed_request(\n            aws.AwsSecurityCredentials(ACCESS_KEY_ID, SECRET_ACCESS_KEY, TOKEN)\n        )\n        # Assert session token request.\n        self.assert_aws_metadata_request_kwargs(\n            request.call_args_list[0][1],\n            IMDSV2_SESSION_TOKEN_URL_IPV6,\n            {\"X-aws-ec2-metadata-token-ttl-seconds\": \"300\"},\n            \"PUT\",\n        )\n        # Assert region request.\n        self.assert_aws_metadata_request_kwargs(\n            request.call_args_list[1][1],\n            REGION_URL_IPV6,\n            {\"X-aws-ec2-metadata-token\": self.AWS_IMDSV2_SESSION_TOKEN},\n        )\n        # Assert session token request.\n        self.assert_aws_metadata_request_kwargs(\n            request.call_args_list[2][1],\n            IMDSV2_SESSION_TOKEN_URL_IPV6,\n            {\"X-aws-ec2-metadata-token-ttl-seconds\": \"300\"},\n            \"PUT\",\n        )\n        # Assert role request.\n        self.assert_aws_metadata_request_kwargs(\n            request.call_args_list[3][1],\n            SECURITY_CREDS_URL_IPV6,\n            {\"X-aws-ec2-metadata-token\": self.AWS_IMDSV2_SESSION_TOKEN},\n        )\n        # Assert security credentials request.\n        self.assert_aws_metadata_request_kwargs(\n            request.call_args_list[4][1],\n            \"{}/{}\".format(SECURITY_CREDS_URL_IPV6, self.AWS_ROLE),\n            {\n                \"Content-Type\": \"application/json\",\n                \"X-aws-ec2-metadata-token\": self.AWS_IMDSV2_SESSION_TOKEN,\n            },\n        )\n\n    @mock.patch(\"google.auth._helpers.utcnow\")\n    def test_retrieve_subject_token_session_error_idmsv2(self, utcnow):\n        utcnow.return_value = datetime.datetime.strptime(\n            self.AWS_SIGNATURE_TIME, \"%Y-%m-%dT%H:%M:%SZ\"\n        )\n        request = self.make_mock_request(\n            imdsv2_session_token_status=http_client.UNAUTHORIZED,\n            imdsv2_session_token_data=\"unauthorized\",\n        )\n        credential_source_token_url = self.CREDENTIAL_SOURCE.copy()\n        credential_source_token_url[\n            \"imdsv2_session_token_url\"\n        ] = IMDSV2_SESSION_TOKEN_URL\n        credentials = self.make_credentials(\n            credential_source=credential_source_token_url\n        )\n\n        with pytest.raises(exceptions.RefreshError) as excinfo:\n            credentials.retrieve_subject_token(request)\n\n        assert excinfo.match(r\"Unable to retrieve AWS Session Token\")\n\n        # Assert session token request\n        self.assert_aws_metadata_request_kwargs(\n            request.call_args_list[0][1],\n            IMDSV2_SESSION_TOKEN_URL,\n            {\"X-aws-ec2-metadata-token-ttl-seconds\": \"300\"},\n            \"PUT\",\n        )\n\n    @mock.patch(\"google.auth._helpers.utcnow\")\n    def test_retrieve_subject_token_success_permanent_creds_no_environment_vars(\n        self, utcnow\n    ):\n        # Simualte a permanent credential without a session token is\n        # returned by the security-credentials endpoint.\n        security_creds_response = self.AWS_SECURITY_CREDENTIALS_RESPONSE.copy()\n        security_creds_response.pop(\"Token\")\n        utcnow.return_value = datetime.datetime.strptime(\n            self.AWS_SIGNATURE_TIME, \"%Y-%m-%dT%H:%M:%SZ\"\n        )\n        request = self.make_mock_request(\n            region_status=http_client.OK,\n            region_name=self.AWS_REGION,\n            role_status=http_client.OK,\n            role_name=self.AWS_ROLE,\n            security_credentials_status=http_client.OK,\n            security_credentials_data=security_creds_response,\n        )\n        credentials = self.make_credentials(credential_source=self.CREDENTIAL_SOURCE)\n\n        subject_token = credentials.retrieve_subject_token(request)\n\n        assert subject_token == self.make_serialized_aws_signed_request(\n            aws.AwsSecurityCredentials(ACCESS_KEY_ID, SECRET_ACCESS_KEY)\n        )\n\n    @mock.patch(\"google.auth._helpers.utcnow\")\n    def test_retrieve_subject_token_success_environment_vars(self, utcnow, monkeypatch):\n        monkeypatch.setenv(environment_vars.AWS_ACCESS_KEY_ID, ACCESS_KEY_ID)\n        monkeypatch.setenv(environment_vars.AWS_SECRET_ACCESS_KEY, SECRET_ACCESS_KEY)\n        monkeypatch.setenv(environment_vars.AWS_SESSION_TOKEN, TOKEN)\n        monkeypatch.setenv(environment_vars.AWS_REGION, self.AWS_REGION)\n        utcnow.return_value = datetime.datetime.strptime(\n            self.AWS_SIGNATURE_TIME, \"%Y-%m-%dT%H:%M:%SZ\"\n        )\n        credentials = self.make_credentials(credential_source=self.CREDENTIAL_SOURCE)\n\n        subject_token = credentials.retrieve_subject_token(None)\n\n        assert subject_token == self.make_serialized_aws_signed_request(\n            aws.AwsSecurityCredentials(ACCESS_KEY_ID, SECRET_ACCESS_KEY, TOKEN)\n        )\n\n    @mock.patch(\"google.auth._helpers.utcnow\")\n    def test_retrieve_subject_token_success_environment_vars_with_default_region(\n        self, utcnow, monkeypatch\n    ):\n        monkeypatch.setenv(environment_vars.AWS_ACCESS_KEY_ID, ACCESS_KEY_ID)\n        monkeypatch.setenv(environment_vars.AWS_SECRET_ACCESS_KEY, SECRET_ACCESS_KEY)\n        monkeypatch.setenv(environment_vars.AWS_SESSION_TOKEN, TOKEN)\n        monkeypatch.setenv(environment_vars.AWS_DEFAULT_REGION, self.AWS_REGION)\n        utcnow.return_value = datetime.datetime.strptime(\n            self.AWS_SIGNATURE_TIME, \"%Y-%m-%dT%H:%M:%SZ\"\n        )\n        credentials = self.make_credentials(credential_source=self.CREDENTIAL_SOURCE)\n\n        subject_token = credentials.retrieve_subject_token(None)\n\n        assert subject_token == self.make_serialized_aws_signed_request(\n            aws.AwsSecurityCredentials(ACCESS_KEY_ID, SECRET_ACCESS_KEY, TOKEN)\n        )\n\n    @mock.patch(\"google.auth._helpers.utcnow\")\n    def test_retrieve_subject_token_success_environment_vars_with_both_regions_set(\n        self, utcnow, monkeypatch\n    ):\n        monkeypatch.setenv(environment_vars.AWS_ACCESS_KEY_ID, ACCESS_KEY_ID)\n        monkeypatch.setenv(environment_vars.AWS_SECRET_ACCESS_KEY, SECRET_ACCESS_KEY)\n        monkeypatch.setenv(environment_vars.AWS_SESSION_TOKEN, TOKEN)\n        monkeypatch.setenv(environment_vars.AWS_DEFAULT_REGION, \"Malformed AWS Region\")\n        # This test makes sure that the AWS_REGION gets used over AWS_DEFAULT_REGION,\n        # So, AWS_DEFAULT_REGION is set to something that would cause the test to fail,\n        # And AWS_REGION is set to the a valid value, and it should succeed\n        monkeypatch.setenv(environment_vars.AWS_REGION, self.AWS_REGION)\n        utcnow.return_value = datetime.datetime.strptime(\n            self.AWS_SIGNATURE_TIME, \"%Y-%m-%dT%H:%M:%SZ\"\n        )\n        credentials = self.make_credentials(credential_source=self.CREDENTIAL_SOURCE)\n\n        subject_token = credentials.retrieve_subject_token(None)\n\n        assert subject_token == self.make_serialized_aws_signed_request(\n            aws.AwsSecurityCredentials(ACCESS_KEY_ID, SECRET_ACCESS_KEY, TOKEN)\n        )\n\n    @mock.patch(\"google.auth._helpers.utcnow\")\n    def test_retrieve_subject_token_success_environment_vars_no_session_token(\n        self, utcnow, monkeypatch\n    ):\n        monkeypatch.setenv(environment_vars.AWS_ACCESS_KEY_ID, ACCESS_KEY_ID)\n        monkeypatch.setenv(environment_vars.AWS_SECRET_ACCESS_KEY, SECRET_ACCESS_KEY)\n        monkeypatch.setenv(environment_vars.AWS_REGION, self.AWS_REGION)\n        utcnow.return_value = datetime.datetime.strptime(\n            self.AWS_SIGNATURE_TIME, \"%Y-%m-%dT%H:%M:%SZ\"\n        )\n        credentials = self.make_credentials(credential_source=self.CREDENTIAL_SOURCE)\n\n        subject_token = credentials.retrieve_subject_token(None)\n\n        assert subject_token == self.make_serialized_aws_signed_request(\n            aws.AwsSecurityCredentials(ACCESS_KEY_ID, SECRET_ACCESS_KEY)\n        )\n\n    @mock.patch(\"google.auth._helpers.utcnow\")\n    def test_retrieve_subject_token_success_environment_vars_except_region(\n        self, utcnow, monkeypatch\n    ):\n        monkeypatch.setenv(environment_vars.AWS_ACCESS_KEY_ID, ACCESS_KEY_ID)\n        monkeypatch.setenv(environment_vars.AWS_SECRET_ACCESS_KEY, SECRET_ACCESS_KEY)\n        monkeypatch.setenv(environment_vars.AWS_SESSION_TOKEN, TOKEN)\n        utcnow.return_value = datetime.datetime.strptime(\n            self.AWS_SIGNATURE_TIME, \"%Y-%m-%dT%H:%M:%SZ\"\n        )\n        # Region will be queried since it is not found in envvars.\n        request = self.make_mock_request(\n            region_status=http_client.OK, region_name=self.AWS_REGION\n        )\n        credentials = self.make_credentials(credential_source=self.CREDENTIAL_SOURCE)\n\n        subject_token = credentials.retrieve_subject_token(request)\n\n        assert subject_token == self.make_serialized_aws_signed_request(\n            aws.AwsSecurityCredentials(ACCESS_KEY_ID, SECRET_ACCESS_KEY, TOKEN)\n        )\n\n    def test_retrieve_subject_token_error_determining_aws_region(self):\n        # Simulate error in retrieving the AWS region.\n        request = self.make_mock_request(region_status=http_client.BAD_REQUEST)\n        credentials = self.make_credentials(credential_source=self.CREDENTIAL_SOURCE)\n\n        with pytest.raises(exceptions.RefreshError) as excinfo:\n            credentials.retrieve_subject_token(request)\n\n        assert excinfo.match(r\"Unable to retrieve AWS region\")\n\n    def test_retrieve_subject_token_error_determining_aws_role(self):\n        # Simulate error in retrieving the AWS role name.\n        request = self.make_mock_request(\n            region_status=http_client.OK,\n            region_name=self.AWS_REGION,\n            role_status=http_client.BAD_REQUEST,\n        )\n        credentials = self.make_credentials(credential_source=self.CREDENTIAL_SOURCE)\n\n        with pytest.raises(exceptions.RefreshError) as excinfo:\n            credentials.retrieve_subject_token(request)\n\n        assert excinfo.match(r\"Unable to retrieve AWS role name\")\n\n    def test_retrieve_subject_token_error_determining_security_creds_url(self):\n        # Simulate the security-credentials url is missing. This is needed for\n        # determining the AWS security credentials when not found in envvars.\n        credential_source = self.CREDENTIAL_SOURCE.copy()\n        credential_source.pop(\"url\")\n        request = self.make_mock_request(\n            region_status=http_client.OK, region_name=self.AWS_REGION\n        )\n        credentials = self.make_credentials(credential_source=credential_source)\n\n        with pytest.raises(exceptions.RefreshError) as excinfo:\n            credentials.retrieve_subject_token(request)\n\n        assert excinfo.match(\n            r\"Unable to determine the AWS metadata server security credentials endpoint\"\n        )\n\n    def test_retrieve_subject_token_error_determining_aws_security_creds(self):\n        # Simulate error in retrieving the AWS security credentials.\n        request = self.make_mock_request(\n            region_status=http_client.OK,\n            region_name=self.AWS_REGION,\n            role_status=http_client.OK,\n            role_name=self.AWS_ROLE,\n            security_credentials_status=http_client.BAD_REQUEST,\n        )\n        credentials = self.make_credentials(credential_source=self.CREDENTIAL_SOURCE)\n\n        with pytest.raises(exceptions.RefreshError) as excinfo:\n            credentials.retrieve_subject_token(request)\n\n        assert excinfo.match(r\"Unable to retrieve AWS security credentials\")\n\n    @mock.patch(\n        \"google.auth.metrics.python_and_auth_lib_version\",\n        return_value=LANG_LIBRARY_METRICS_HEADER_VALUE,\n    )\n    @mock.patch(\"google.auth._helpers.utcnow\")\n    def test_refresh_success_without_impersonation_ignore_default_scopes(\n        self, utcnow, mock_auth_lib_value\n    ):\n        utcnow.return_value = datetime.datetime.strptime(\n            self.AWS_SIGNATURE_TIME, \"%Y-%m-%dT%H:%M:%SZ\"\n        )\n        expected_subject_token = self.make_serialized_aws_signed_request(\n            aws.AwsSecurityCredentials(ACCESS_KEY_ID, SECRET_ACCESS_KEY, TOKEN)\n        )\n        token_headers = {\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n            \"Authorization\": \"Basic \" + BASIC_AUTH_ENCODING,\n            \"x-goog-api-client\": \"gl-python/3.7 auth/1.1 google-byoid-sdk sa-impersonation/false config-lifetime/false source/aws\",\n        }\n        token_request_data = {\n            \"grant_type\": \"urn:ietf:params:oauth:grant-type:token-exchange\",\n            \"audience\": AUDIENCE,\n            \"requested_token_type\": \"urn:ietf:params:oauth:token-type:access_token\",\n            \"scope\": \" \".join(SCOPES),\n            \"subject_token\": expected_subject_token,\n            \"subject_token_type\": SUBJECT_TOKEN_TYPE,\n        }\n        request = self.make_mock_request(\n            region_status=http_client.OK,\n            region_name=self.AWS_REGION,\n            role_status=http_client.OK,\n            role_name=self.AWS_ROLE,\n            security_credentials_status=http_client.OK,\n            security_credentials_data=self.AWS_SECURITY_CREDENTIALS_RESPONSE,\n            token_status=http_client.OK,\n            token_data=self.SUCCESS_RESPONSE,\n        )\n        credentials = self.make_credentials(\n            client_id=CLIENT_ID,\n            client_secret=CLIENT_SECRET,\n            credential_source=self.CREDENTIAL_SOURCE,\n            quota_project_id=QUOTA_PROJECT_ID,\n            scopes=SCOPES,\n            # Default scopes should be ignored.\n            default_scopes=[\"ignored\"],\n        )\n\n        credentials.refresh(request)\n\n        assert len(request.call_args_list) == 4\n        # Fourth request should be sent to GCP STS endpoint.\n        self.assert_token_request_kwargs(\n            request.call_args_list[3][1], token_headers, token_request_data\n        )\n        assert credentials.token == self.SUCCESS_RESPONSE[\"access_token\"]\n        assert credentials.quota_project_id == QUOTA_PROJECT_ID\n        assert credentials.scopes == SCOPES\n        assert credentials.default_scopes == [\"ignored\"]\n\n    @mock.patch(\n        \"google.auth.metrics.python_and_auth_lib_version\",\n        return_value=LANG_LIBRARY_METRICS_HEADER_VALUE,\n    )\n    @mock.patch(\"google.auth._helpers.utcnow\")\n    def test_refresh_success_without_impersonation_use_default_scopes(\n        self, utcnow, mock_auth_lib_value\n    ):\n        utcnow.return_value = datetime.datetime.strptime(\n            self.AWS_SIGNATURE_TIME, \"%Y-%m-%dT%H:%M:%SZ\"\n        )\n        expected_subject_token = self.make_serialized_aws_signed_request(\n            aws.AwsSecurityCredentials(ACCESS_KEY_ID, SECRET_ACCESS_KEY, TOKEN)\n        )\n        token_headers = {\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n            \"Authorization\": \"Basic \" + BASIC_AUTH_ENCODING,\n            \"x-goog-api-client\": \"gl-python/3.7 auth/1.1 google-byoid-sdk sa-impersonation/false config-lifetime/false source/aws\",\n        }\n        token_request_data = {\n            \"grant_type\": \"urn:ietf:params:oauth:grant-type:token-exchange\",\n            \"audience\": AUDIENCE,\n            \"requested_token_type\": \"urn:ietf:params:oauth:token-type:access_token\",\n            \"scope\": \" \".join(SCOPES),\n            \"subject_token\": expected_subject_token,\n            \"subject_token_type\": SUBJECT_TOKEN_TYPE,\n        }\n        request = self.make_mock_request(\n            region_status=http_client.OK,\n            region_name=self.AWS_REGION,\n            role_status=http_client.OK,\n            role_name=self.AWS_ROLE,\n            security_credentials_status=http_client.OK,\n            security_credentials_data=self.AWS_SECURITY_CREDENTIALS_RESPONSE,\n            token_status=http_client.OK,\n            token_data=self.SUCCESS_RESPONSE,\n        )\n        credentials = self.make_credentials(\n            client_id=CLIENT_ID,\n            client_secret=CLIENT_SECRET,\n            credential_source=self.CREDENTIAL_SOURCE,\n            quota_project_id=QUOTA_PROJECT_ID,\n            scopes=None,\n            # Default scopes should be used since user specified scopes are none.\n            default_scopes=SCOPES,\n        )\n\n        credentials.refresh(request)\n\n        assert len(request.call_args_list) == 4\n        # Fourth request should be sent to GCP STS endpoint.\n        self.assert_token_request_kwargs(\n            request.call_args_list[3][1], token_headers, token_request_data\n        )\n        assert credentials.token == self.SUCCESS_RESPONSE[\"access_token\"]\n        assert credentials.quota_project_id == QUOTA_PROJECT_ID\n        assert credentials.scopes is None\n        assert credentials.default_scopes == SCOPES\n\n    @mock.patch(\n        \"google.auth.metrics.token_request_access_token_impersonate\",\n        return_value=IMPERSONATE_ACCESS_TOKEN_REQUEST_METRICS_HEADER_VALUE,\n    )\n    @mock.patch(\n        \"google.auth.metrics.python_and_auth_lib_version\",\n        return_value=LANG_LIBRARY_METRICS_HEADER_VALUE,\n    )\n    @mock.patch(\"google.auth._helpers.utcnow\")\n    def test_refresh_success_with_impersonation_ignore_default_scopes(\n        self, utcnow, mock_metrics_header_value, mock_auth_lib_value\n    ):\n        utcnow.return_value = datetime.datetime.strptime(\n            self.AWS_SIGNATURE_TIME, \"%Y-%m-%dT%H:%M:%SZ\"\n        )\n        expire_time = (\n            _helpers.utcnow().replace(microsecond=0) + datetime.timedelta(seconds=3600)\n        ).isoformat(\"T\") + \"Z\"\n        expected_subject_token = self.make_serialized_aws_signed_request(\n            aws.AwsSecurityCredentials(ACCESS_KEY_ID, SECRET_ACCESS_KEY, TOKEN)\n        )\n        token_headers = {\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n            \"Authorization\": \"Basic \" + BASIC_AUTH_ENCODING,\n            \"x-goog-api-client\": \"gl-python/3.7 auth/1.1 google-byoid-sdk sa-impersonation/true config-lifetime/false source/aws\",\n        }\n        token_request_data = {\n            \"grant_type\": \"urn:ietf:params:oauth:grant-type:token-exchange\",\n            \"audience\": AUDIENCE,\n            \"requested_token_type\": \"urn:ietf:params:oauth:token-type:access_token\",\n            \"scope\": \"https://www.googleapis.com/auth/iam\",\n            \"subject_token\": expected_subject_token,\n            \"subject_token_type\": SUBJECT_TOKEN_TYPE,\n        }\n        # Service account impersonation request/response.\n        impersonation_response = {\n            \"accessToken\": \"SA_ACCESS_TOKEN\",\n            \"expireTime\": expire_time,\n        }\n        impersonation_headers = {\n            \"Content-Type\": \"application/json\",\n            \"authorization\": \"Bearer {}\".format(self.SUCCESS_RESPONSE[\"access_token\"]),\n            \"x-goog-user-project\": QUOTA_PROJECT_ID,\n            \"x-goog-api-client\": IMPERSONATE_ACCESS_TOKEN_REQUEST_METRICS_HEADER_VALUE,\n            \"x-allowed-locations\": \"0x0\",\n        }\n        impersonation_request_data = {\n            \"delegates\": None,\n            \"scope\": SCOPES,\n            \"lifetime\": \"3600s\",\n        }\n        request = self.make_mock_request(\n            region_status=http_client.OK,\n            region_name=self.AWS_REGION,\n            role_status=http_client.OK,\n            role_name=self.AWS_ROLE,\n            security_credentials_status=http_client.OK,\n            security_credentials_data=self.AWS_SECURITY_CREDENTIALS_RESPONSE,\n            token_status=http_client.OK,\n            token_data=self.SUCCESS_RESPONSE,\n            impersonation_status=http_client.OK,\n            impersonation_data=impersonation_response,\n        )\n        credentials = self.make_credentials(\n            client_id=CLIENT_ID,\n            client_secret=CLIENT_SECRET,\n            credential_source=self.CREDENTIAL_SOURCE,\n            service_account_impersonation_url=SERVICE_ACCOUNT_IMPERSONATION_URL,\n            quota_project_id=QUOTA_PROJECT_ID,\n            scopes=SCOPES,\n            # Default scopes should be ignored.\n            default_scopes=[\"ignored\"],\n        )\n\n        credentials.refresh(request)\n\n        assert len(request.call_args_list) == 5\n        # Fourth request should be sent to GCP STS endpoint.\n        self.assert_token_request_kwargs(\n            request.call_args_list[3][1], token_headers, token_request_data\n        )\n        # Fifth request should be sent to iamcredentials endpoint for service\n        # account impersonation.\n        self.assert_impersonation_request_kwargs(\n            request.call_args_list[4][1],\n            impersonation_headers,\n            impersonation_request_data,\n        )\n        assert credentials.token == impersonation_response[\"accessToken\"]\n        assert credentials.quota_project_id == QUOTA_PROJECT_ID\n        assert credentials.scopes == SCOPES\n        assert credentials.default_scopes == [\"ignored\"]\n\n    @mock.patch(\n        \"google.auth.metrics.token_request_access_token_impersonate\",\n        return_value=IMPERSONATE_ACCESS_TOKEN_REQUEST_METRICS_HEADER_VALUE,\n    )\n    @mock.patch(\n        \"google.auth.metrics.python_and_auth_lib_version\",\n        return_value=LANG_LIBRARY_METRICS_HEADER_VALUE,\n    )\n    @mock.patch(\"google.auth._helpers.utcnow\")\n    def test_refresh_success_with_impersonation_use_default_scopes(\n        self, utcnow, mock_metrics_header_value, mock_auth_lib_value\n    ):\n        utcnow.return_value = datetime.datetime.strptime(\n            self.AWS_SIGNATURE_TIME, \"%Y-%m-%dT%H:%M:%SZ\"\n        )\n        expire_time = (\n            _helpers.utcnow().replace(microsecond=0) + datetime.timedelta(seconds=3600)\n        ).isoformat(\"T\") + \"Z\"\n        expected_subject_token = self.make_serialized_aws_signed_request(\n            aws.AwsSecurityCredentials(ACCESS_KEY_ID, SECRET_ACCESS_KEY, TOKEN)\n        )\n        token_headers = {\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n            \"Authorization\": \"Basic \" + BASIC_AUTH_ENCODING,\n            \"x-goog-api-client\": \"gl-python/3.7 auth/1.1 google-byoid-sdk sa-impersonation/true config-lifetime/false source/aws\",\n        }\n        token_request_data = {\n            \"grant_type\": \"urn:ietf:params:oauth:grant-type:token-exchange\",\n            \"audience\": AUDIENCE,\n            \"requested_token_type\": \"urn:ietf:params:oauth:token-type:access_token\",\n            \"scope\": \"https://www.googleapis.com/auth/iam\",\n            \"subject_token\": expected_subject_token,\n            \"subject_token_type\": SUBJECT_TOKEN_TYPE,\n        }\n        # Service account impersonation request/response.\n        impersonation_response = {\n            \"accessToken\": \"SA_ACCESS_TOKEN\",\n            \"expireTime\": expire_time,\n        }\n        impersonation_headers = {\n            \"Content-Type\": \"application/json\",\n            \"authorization\": \"Bearer {}\".format(self.SUCCESS_RESPONSE[\"access_token\"]),\n            \"x-goog-user-project\": QUOTA_PROJECT_ID,\n            \"x-goog-api-client\": IMPERSONATE_ACCESS_TOKEN_REQUEST_METRICS_HEADER_VALUE,\n            \"x-allowed-locations\": \"0x0\",\n        }\n        impersonation_request_data = {\n            \"delegates\": None,\n            \"scope\": SCOPES,\n            \"lifetime\": \"3600s\",\n        }\n        request = self.make_mock_request(\n            region_status=http_client.OK,\n            region_name=self.AWS_REGION,\n            role_status=http_client.OK,\n            role_name=self.AWS_ROLE,\n            security_credentials_status=http_client.OK,\n            security_credentials_data=self.AWS_SECURITY_CREDENTIALS_RESPONSE,\n            token_status=http_client.OK,\n            token_data=self.SUCCESS_RESPONSE,\n            impersonation_status=http_client.OK,\n            impersonation_data=impersonation_response,\n        )\n        credentials = self.make_credentials(\n            client_id=CLIENT_ID,\n            client_secret=CLIENT_SECRET,\n            credential_source=self.CREDENTIAL_SOURCE,\n            service_account_impersonation_url=SERVICE_ACCOUNT_IMPERSONATION_URL,\n            quota_project_id=QUOTA_PROJECT_ID,\n            scopes=None,\n            # Default scopes should be used since user specified scopes are none.\n            default_scopes=SCOPES,\n        )\n\n        credentials.refresh(request)\n\n        assert len(request.call_args_list) == 5\n        # Fourth request should be sent to GCP STS endpoint.\n        self.assert_token_request_kwargs(\n            request.call_args_list[3][1], token_headers, token_request_data\n        )\n        # Fifth request should be sent to iamcredentials endpoint for service\n        # account impersonation.\n        self.assert_impersonation_request_kwargs(\n            request.call_args_list[4][1],\n            impersonation_headers,\n            impersonation_request_data,\n        )\n        assert credentials.token == impersonation_response[\"accessToken\"]\n        assert credentials.quota_project_id == QUOTA_PROJECT_ID\n        assert credentials.scopes is None\n        assert credentials.default_scopes == SCOPES\n\n    def test_refresh_with_retrieve_subject_token_error(self):\n        request = self.make_mock_request(region_status=http_client.BAD_REQUEST)\n        credentials = self.make_credentials(credential_source=self.CREDENTIAL_SOURCE)\n\n        with pytest.raises(exceptions.RefreshError) as excinfo:\n            credentials.refresh(request)\n\n        assert excinfo.match(r\"Unable to retrieve AWS region\")\n\n    @mock.patch(\"google.auth._helpers.utcnow\")\n    def test_retrieve_subject_token_success_with_supplier(self, utcnow):\n        utcnow.return_value = datetime.datetime.strptime(\n            self.AWS_SIGNATURE_TIME, \"%Y-%m-%dT%H:%M:%SZ\"\n        )\n        request = self.make_mock_request()\n\n        security_credentials = aws.AwsSecurityCredentials(\n            ACCESS_KEY_ID, SECRET_ACCESS_KEY\n        )\n        supplier = TestAwsSecurityCredentialsSupplier(\n            security_credentials=security_credentials, region=self.AWS_REGION\n        )\n\n        credentials = self.make_credentials(aws_security_credentials_supplier=supplier)\n\n        subject_token = credentials.retrieve_subject_token(request)\n        assert subject_token == self.make_serialized_aws_signed_request(\n            aws.AwsSecurityCredentials(ACCESS_KEY_ID, SECRET_ACCESS_KEY)\n        )\n\n    @mock.patch(\"google.auth._helpers.utcnow\")\n    def test_retrieve_subject_token_success_with_supplier_session_token(self, utcnow):\n        utcnow.return_value = datetime.datetime.strptime(\n            self.AWS_SIGNATURE_TIME, \"%Y-%m-%dT%H:%M:%SZ\"\n        )\n        request = self.make_mock_request()\n\n        security_credentials = aws.AwsSecurityCredentials(\n            ACCESS_KEY_ID, SECRET_ACCESS_KEY, TOKEN\n        )\n        supplier = TestAwsSecurityCredentialsSupplier(\n            security_credentials=security_credentials, region=self.AWS_REGION\n        )\n\n        credentials = self.make_credentials(aws_security_credentials_supplier=supplier)\n\n        subject_token = credentials.retrieve_subject_token(request)\n        assert subject_token == self.make_serialized_aws_signed_request(\n            aws.AwsSecurityCredentials(ACCESS_KEY_ID, SECRET_ACCESS_KEY, TOKEN)\n        )\n\n    @mock.patch(\"google.auth._helpers.utcnow\")\n    def test_retrieve_subject_token_success_with_supplier_correct_context(self, utcnow):\n        utcnow.return_value = datetime.datetime.strptime(\n            self.AWS_SIGNATURE_TIME, \"%Y-%m-%dT%H:%M:%SZ\"\n        )\n        request = self.make_mock_request()\n        expected_context = external_account.SupplierContext(\n            SUBJECT_TOKEN_TYPE, AUDIENCE\n        )\n\n        security_credentials = aws.AwsSecurityCredentials(\n            ACCESS_KEY_ID, SECRET_ACCESS_KEY\n        )\n        supplier = TestAwsSecurityCredentialsSupplier(\n            security_credentials=security_credentials,\n            region=self.AWS_REGION,\n            expected_context=expected_context,\n        )\n\n        credentials = self.make_credentials(aws_security_credentials_supplier=supplier)\n\n        credentials.retrieve_subject_token(request)\n\n    def test_retrieve_subject_token_error_with_supplier(self):\n        request = self.make_mock_request()\n        expected_exception = exceptions.RefreshError(\"Test error\")\n        supplier = TestAwsSecurityCredentialsSupplier(\n            region=self.AWS_REGION, credentials_exception=expected_exception\n        )\n\n        credentials = self.make_credentials(aws_security_credentials_supplier=supplier)\n\n        with pytest.raises(exceptions.RefreshError) as excinfo:\n            credentials.refresh(request)\n\n        assert excinfo.match(r\"Test error\")\n\n    def test_retrieve_subject_token_error_with_supplier_region(self):\n        request = self.make_mock_request()\n        expected_exception = exceptions.RefreshError(\"Test error\")\n        security_credentials = aws.AwsSecurityCredentials(\n            ACCESS_KEY_ID, SECRET_ACCESS_KEY\n        )\n        supplier = TestAwsSecurityCredentialsSupplier(\n            security_credentials=security_credentials,\n            region_exception=expected_exception,\n        )\n\n        credentials = self.make_credentials(aws_security_credentials_supplier=supplier)\n\n        with pytest.raises(exceptions.RefreshError) as excinfo:\n            credentials.refresh(request)\n\n        assert excinfo.match(r\"Test error\")\n\n    @mock.patch(\n        \"google.auth.metrics.python_and_auth_lib_version\",\n        return_value=LANG_LIBRARY_METRICS_HEADER_VALUE,\n    )\n    @mock.patch(\"google.auth._helpers.utcnow\")\n    def test_refresh_success_with_supplier_with_impersonation(\n        self, utcnow, mock_auth_lib_value\n    ):\n        utcnow.return_value = datetime.datetime.strptime(\n            self.AWS_SIGNATURE_TIME, \"%Y-%m-%dT%H:%M:%SZ\"\n        )\n        expire_time = (\n            _helpers.utcnow().replace(microsecond=0) + datetime.timedelta(seconds=3600)\n        ).isoformat(\"T\") + \"Z\"\n        expected_subject_token = self.make_serialized_aws_signed_request(\n            aws.AwsSecurityCredentials(ACCESS_KEY_ID, SECRET_ACCESS_KEY, TOKEN)\n        )\n        token_headers = {\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n            \"Authorization\": \"Basic \" + BASIC_AUTH_ENCODING,\n            \"x-goog-api-client\": \"gl-python/3.7 auth/1.1 google-byoid-sdk sa-impersonation/true config-lifetime/false source/programmatic\",\n        }\n        token_request_data = {\n            \"grant_type\": \"urn:ietf:params:oauth:grant-type:token-exchange\",\n            \"audience\": AUDIENCE,\n            \"requested_token_type\": \"urn:ietf:params:oauth:token-type:access_token\",\n            \"scope\": \"https://www.googleapis.com/auth/iam\",\n            \"subject_token\": expected_subject_token,\n            \"subject_token_type\": SUBJECT_TOKEN_TYPE,\n        }\n        # Service account impersonation request/response.\n        impersonation_response = {\n            \"accessToken\": \"SA_ACCESS_TOKEN\",\n            \"expireTime\": expire_time,\n        }\n        impersonation_headers = {\n            \"Content-Type\": \"application/json\",\n            \"authorization\": \"Bearer {}\".format(self.SUCCESS_RESPONSE[\"access_token\"]),\n            \"x-goog-user-project\": QUOTA_PROJECT_ID,\n            \"x-goog-api-client\": IMPERSONATE_ACCESS_TOKEN_REQUEST_METRICS_HEADER_VALUE,\n            \"x-allowed-locations\": \"0x0\",\n        }\n        impersonation_request_data = {\n            \"delegates\": None,\n            \"scope\": SCOPES,\n            \"lifetime\": \"3600s\",\n        }\n        request = self.make_mock_request(\n            token_status=http_client.OK,\n            token_data=self.SUCCESS_RESPONSE,\n            impersonation_status=http_client.OK,\n            impersonation_data=impersonation_response,\n        )\n\n        supplier = TestAwsSecurityCredentialsSupplier(\n            security_credentials=aws.AwsSecurityCredentials(\n                ACCESS_KEY_ID, SECRET_ACCESS_KEY, TOKEN\n            ),\n            region=self.AWS_REGION,\n        )\n\n        credentials = self.make_credentials(\n            client_id=CLIENT_ID,\n            client_secret=CLIENT_SECRET,\n            aws_security_credentials_supplier=supplier,\n            service_account_impersonation_url=SERVICE_ACCOUNT_IMPERSONATION_URL,\n            quota_project_id=QUOTA_PROJECT_ID,\n            scopes=SCOPES,\n            # Default scopes should be ignored.\n            default_scopes=[\"ignored\"],\n        )\n\n        credentials.refresh(request)\n\n        assert len(request.call_args_list) == 2\n        # First request should be sent to GCP STS endpoint.\n        self.assert_token_request_kwargs(\n            request.call_args_list[0][1], token_headers, token_request_data\n        )\n        # Second request should be sent to iamcredentials endpoint for service\n        # account impersonation.\n        self.assert_impersonation_request_kwargs(\n            request.call_args_list[1][1],\n            impersonation_headers,\n            impersonation_request_data,\n        )\n        assert credentials.token == impersonation_response[\"accessToken\"]\n        assert credentials.quota_project_id == QUOTA_PROJECT_ID\n        assert credentials.scopes == SCOPES\n        assert credentials.default_scopes == [\"ignored\"]\n\n    @mock.patch(\n        \"google.auth.metrics.python_and_auth_lib_version\",\n        return_value=LANG_LIBRARY_METRICS_HEADER_VALUE,\n    )\n    @mock.patch(\"google.auth._helpers.utcnow\")\n    def test_refresh_success_with_supplier(self, utcnow, mock_auth_lib_value):\n        utcnow.return_value = datetime.datetime.strptime(\n            self.AWS_SIGNATURE_TIME, \"%Y-%m-%dT%H:%M:%SZ\"\n        )\n        expected_subject_token = self.make_serialized_aws_signed_request(\n            aws.AwsSecurityCredentials(ACCESS_KEY_ID, SECRET_ACCESS_KEY, TOKEN)\n        )\n        token_headers = {\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n            \"Authorization\": \"Basic \" + BASIC_AUTH_ENCODING,\n            \"x-goog-api-client\": \"gl-python/3.7 auth/1.1 google-byoid-sdk sa-impersonation/false config-lifetime/false source/programmatic\",\n        }\n        token_request_data = {\n            \"grant_type\": \"urn:ietf:params:oauth:grant-type:token-exchange\",\n            \"audience\": AUDIENCE,\n            \"requested_token_type\": \"urn:ietf:params:oauth:token-type:access_token\",\n            \"scope\": \" \".join(SCOPES),\n            \"subject_token\": expected_subject_token,\n            \"subject_token_type\": SUBJECT_TOKEN_TYPE,\n        }\n        request = self.make_mock_request(\n            token_status=http_client.OK, token_data=self.SUCCESS_RESPONSE\n        )\n\n        supplier = TestAwsSecurityCredentialsSupplier(\n            security_credentials=aws.AwsSecurityCredentials(\n                ACCESS_KEY_ID, SECRET_ACCESS_KEY, TOKEN\n            ),\n            region=self.AWS_REGION,\n        )\n\n        credentials = self.make_credentials(\n            client_id=CLIENT_ID,\n            client_secret=CLIENT_SECRET,\n            aws_security_credentials_supplier=supplier,\n            quota_project_id=QUOTA_PROJECT_ID,\n            scopes=SCOPES,\n            # Default scopes should be ignored.\n            default_scopes=[\"ignored\"],\n        )\n\n        credentials.refresh(request)\n\n        assert len(request.call_args_list) == 1\n        # First request should be sent to GCP STS endpoint.\n        self.assert_token_request_kwargs(\n            request.call_args_list[0][1], token_headers, token_request_data\n        )\n        assert credentials.token == self.SUCCESS_RESPONSE[\"access_token\"]\n        assert credentials.quota_project_id == QUOTA_PROJECT_ID\n        assert credentials.scopes == SCOPES\n        assert credentials.default_scopes == [\"ignored\"]\n", "tests/test_api_key.py": "# Copyright 2022 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport pytest  # type: ignore\n\nfrom google.auth import api_key\n\n\ndef test_credentials_constructor():\n    with pytest.raises(ValueError) as excinfo:\n        api_key.Credentials(\"\")\n\n    assert excinfo.match(r\"Token must be a non-empty API key string\")\n\n\ndef test_expired_and_valid():\n    credentials = api_key.Credentials(\"api-key\")\n\n    assert credentials.valid\n    assert credentials.token == \"api-key\"\n    assert not credentials.expired\n\n    credentials.refresh(None)\n    assert credentials.valid\n    assert credentials.token == \"api-key\"\n    assert not credentials.expired\n\n\ndef test_before_request():\n    credentials = api_key.Credentials(\"api-key\")\n    headers = {}\n\n    credentials.before_request(None, \"http://example.com\", \"GET\", headers)\n    assert headers[\"x-goog-api-key\"] == \"api-key\"\n", "tests/test__refresh_worker.py": "# Copyright 2023 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport pickle\nimport random\nimport threading\nimport time\n\nimport mock\nimport pytest  # type: ignore\n\nfrom google.auth import _refresh_worker, credentials, exceptions\n\nMAIN_THREAD_SLEEP_MS = 100 / 1000\n\n\nclass MockCredentialsImpl(credentials.Credentials):\n    def __init__(self, sleep_seconds=None):\n        self.refresh_count = 0\n        self.token = None\n        self.sleep_seconds = sleep_seconds if sleep_seconds else None\n\n    def refresh(self, request):\n        if self.sleep_seconds:\n            time.sleep(self.sleep_seconds)\n        self.token = request\n        self.refresh_count += 1\n\n\n@pytest.fixture\ndef test_thread_count():\n    return 25\n\n\ndef _cred_spinlock(cred):\n    while cred.token is None:  # pragma: NO COVER\n        time.sleep(MAIN_THREAD_SLEEP_MS)\n\n\ndef test_invalid_start_refresh():\n    w = _refresh_worker.RefreshThreadManager()\n    with pytest.raises(exceptions.InvalidValue):\n        w.start_refresh(None, None)\n\n\ndef test_start_refresh():\n    w = _refresh_worker.RefreshThreadManager()\n    cred = MockCredentialsImpl()\n    request = mock.MagicMock()\n    assert w.start_refresh(cred, request)\n\n    assert w._worker is not None\n\n    _cred_spinlock(cred)\n\n    assert cred.token == request\n    assert cred.refresh_count == 1\n\n\ndef test_nonblocking_start_refresh():\n    w = _refresh_worker.RefreshThreadManager()\n    cred = MockCredentialsImpl(sleep_seconds=1)\n    request = mock.MagicMock()\n    assert w.start_refresh(cred, request)\n\n    assert w._worker is not None\n    assert not cred.token\n    assert cred.refresh_count == 0\n\n\ndef test_multiple_refreshes_multiple_workers(test_thread_count):\n    w = _refresh_worker.RefreshThreadManager()\n    cred = MockCredentialsImpl()\n    request = mock.MagicMock()\n\n    def _thread_refresh():\n        time.sleep(random.randrange(0, 5))\n        assert w.start_refresh(cred, request)\n\n    threads = [\n        threading.Thread(target=_thread_refresh) for _ in range(test_thread_count)\n    ]\n    for t in threads:\n        t.start()\n\n    _cred_spinlock(cred)\n\n    assert cred.token == request\n    # There is a chance only one thread has enough time to perform a refresh.\n    # Generally multiple threads will have time to perform a refresh\n    assert cred.refresh_count > 0\n\n\ndef test_refresh_error():\n    w = _refresh_worker.RefreshThreadManager()\n    cred = mock.MagicMock()\n    request = mock.MagicMock()\n\n    cred.refresh.side_effect = exceptions.RefreshError(\"Failed to refresh\")\n\n    assert w.start_refresh(cred, request)\n\n    while w._worker._error_info is None:  # pragma: NO COVER\n        time.sleep(MAIN_THREAD_SLEEP_MS)\n\n    assert w._worker is not None\n    assert isinstance(w._worker._error_info, exceptions.RefreshError)\n\n\ndef test_refresh_error_call_refresh_again():\n    w = _refresh_worker.RefreshThreadManager()\n    cred = mock.MagicMock()\n    request = mock.MagicMock()\n\n    cred.refresh.side_effect = exceptions.RefreshError(\"Failed to refresh\")\n\n    assert w.start_refresh(cred, request)\n\n    while w._worker._error_info is None:  # pragma: NO COVER\n        time.sleep(MAIN_THREAD_SLEEP_MS)\n\n    assert not w.start_refresh(cred, request)\n\n\ndef test_refresh_dead_worker():\n    cred = MockCredentialsImpl()\n    request = mock.MagicMock()\n\n    w = _refresh_worker.RefreshThreadManager()\n    w._worker = None\n\n    w.start_refresh(cred, request)\n\n    _cred_spinlock(cred)\n\n    assert cred.token == request\n    assert cred.refresh_count == 1\n\n\ndef test_pickle():\n    w = _refresh_worker.RefreshThreadManager()\n    # For some reason isinstance cannot interpret threading.Lock as a type.\n    assert w._lock is not None\n\n    pickled_manager = pickle.dumps(w)\n    manager = pickle.loads(pickled_manager)\n    assert isinstance(manager, _refresh_worker.RefreshThreadManager)\n    assert manager._lock is not None\n", "tests/test__cloud_sdk.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport io\nimport json\nimport os\nimport subprocess\nimport sys\n\nimport mock\nimport pytest  # type: ignore\n\nfrom google.auth import _cloud_sdk\nfrom google.auth import environment_vars\nfrom google.auth import exceptions\n\n\nDATA_DIR = os.path.join(os.path.dirname(__file__), \"data\")\nAUTHORIZED_USER_FILE = os.path.join(DATA_DIR, \"authorized_user.json\")\n\nwith io.open(AUTHORIZED_USER_FILE, \"rb\") as fh:\n    AUTHORIZED_USER_FILE_DATA = json.load(fh)\n\nSERVICE_ACCOUNT_FILE = os.path.join(DATA_DIR, \"service_account.json\")\n\nwith io.open(SERVICE_ACCOUNT_FILE, \"rb\") as fh:\n    SERVICE_ACCOUNT_FILE_DATA = json.load(fh)\n\n\n@pytest.mark.parametrize(\n    \"data, expected_project_id\",\n    [(b\"example-project\\n\", \"example-project\"), (b\"\", None)],\n)\ndef test_get_project_id(data, expected_project_id):\n    check_output_patch = mock.patch(\n        \"subprocess.check_output\", autospec=True, return_value=data\n    )\n\n    with check_output_patch as check_output:\n        project_id = _cloud_sdk.get_project_id()\n\n    assert project_id == expected_project_id\n    assert check_output.called\n\n\n@mock.patch(\n    \"subprocess.check_output\",\n    autospec=True,\n    side_effect=subprocess.CalledProcessError(-1, \"testing\"),\n)\ndef test_get_project_id_call_error(check_output):\n    project_id = _cloud_sdk.get_project_id()\n    assert project_id is None\n    assert check_output.called\n\n\ndef test__run_subprocess_ignore_stderr():\n    command = [\n        sys.executable,\n        \"-c\",\n        \"from __future__ import print_function;\"\n        + \"import sys;\"\n        + \"print('error', file=sys.stderr);\"\n        + \"print('output', file=sys.stdout)\",\n    ]\n\n    # If we ignore stderr, then the output only has stdout\n    output = _cloud_sdk._run_subprocess_ignore_stderr(command)\n    assert output == b\"output\\n\"\n\n    # If we pipe stderr to stdout, then the output is mixed with stdout and stderr.\n    output = subprocess.check_output(command, stderr=subprocess.STDOUT)\n    assert output == b\"output\\nerror\\n\" or output == b\"error\\noutput\\n\"\n\n\n@mock.patch(\"os.name\", new=\"nt\")\ndef test_get_project_id_windows():\n    check_output_patch = mock.patch(\n        \"subprocess.check_output\", autospec=True, return_value=b\"example-project\\n\"\n    )\n\n    with check_output_patch as check_output:\n        project_id = _cloud_sdk.get_project_id()\n\n    assert project_id == \"example-project\"\n    assert check_output.called\n    # Make sure the executable is `gcloud.cmd`.\n    args = check_output.call_args[0]\n    command = args[0]\n    executable = command[0]\n    assert executable == \"gcloud.cmd\"\n\n\n@mock.patch(\"google.auth._cloud_sdk.get_config_path\", autospec=True)\ndef test_get_application_default_credentials_path(get_config_dir):\n    config_path = \"config_path\"\n    get_config_dir.return_value = config_path\n    credentials_path = _cloud_sdk.get_application_default_credentials_path()\n    assert credentials_path == os.path.join(\n        config_path, _cloud_sdk._CREDENTIALS_FILENAME\n    )\n\n\ndef test_get_config_path_env_var(monkeypatch):\n    config_path_sentinel = \"config_path\"\n    monkeypatch.setenv(environment_vars.CLOUD_SDK_CONFIG_DIR, config_path_sentinel)\n    config_path = _cloud_sdk.get_config_path()\n    assert config_path == config_path_sentinel\n\n\n@mock.patch(\"os.path.expanduser\")\ndef test_get_config_path_unix(expanduser):\n    expanduser.side_effect = lambda path: path\n\n    config_path = _cloud_sdk.get_config_path()\n\n    assert os.path.split(config_path) == (\"~/.config\", _cloud_sdk._CONFIG_DIRECTORY)\n\n\n@mock.patch(\"os.name\", new=\"nt\")\ndef test_get_config_path_windows(monkeypatch):\n    appdata = \"appdata\"\n    monkeypatch.setenv(_cloud_sdk._WINDOWS_CONFIG_ROOT_ENV_VAR, appdata)\n\n    config_path = _cloud_sdk.get_config_path()\n\n    assert os.path.split(config_path) == (appdata, _cloud_sdk._CONFIG_DIRECTORY)\n\n\n@mock.patch(\"os.name\", new=\"nt\")\ndef test_get_config_path_no_appdata(monkeypatch):\n    monkeypatch.delenv(_cloud_sdk._WINDOWS_CONFIG_ROOT_ENV_VAR, raising=False)\n    monkeypatch.setenv(\"SystemDrive\", \"G:\")\n\n    config_path = _cloud_sdk.get_config_path()\n\n    assert os.path.split(config_path) == (\"G:/\\\\\", _cloud_sdk._CONFIG_DIRECTORY)\n\n\n@mock.patch(\"os.name\", new=\"nt\")\n@mock.patch(\"subprocess.check_output\", autospec=True)\ndef test_get_auth_access_token_windows(check_output):\n    check_output.return_value = b\"access_token\\n\"\n\n    token = _cloud_sdk.get_auth_access_token()\n    assert token == \"access_token\"\n    check_output.assert_called_with(\n        (\"gcloud.cmd\", \"auth\", \"print-access-token\"), stderr=subprocess.STDOUT\n    )\n\n\n@mock.patch(\"subprocess.check_output\", autospec=True)\ndef test_get_auth_access_token_with_account(check_output):\n    check_output.return_value = b\"access_token\\n\"\n\n    token = _cloud_sdk.get_auth_access_token(account=\"account\")\n    assert token == \"access_token\"\n    check_output.assert_called_with(\n        (\"gcloud\", \"auth\", \"print-access-token\", \"--account=account\"),\n        stderr=subprocess.STDOUT,\n    )\n\n\n@mock.patch(\"subprocess.check_output\", autospec=True)\ndef test_get_auth_access_token_with_exception(check_output):\n    check_output.side_effect = OSError()\n\n    with pytest.raises(exceptions.UserAccessTokenError):\n        _cloud_sdk.get_auth_access_token(account=\"account\")\n", "tests/test__service_account_info.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport json\nimport os\n\nimport pytest  # type: ignore\n\nfrom google.auth import _service_account_info\nfrom google.auth import crypt\n\n\nDATA_DIR = os.path.join(os.path.dirname(__file__), \"data\")\nSERVICE_ACCOUNT_JSON_FILE = os.path.join(DATA_DIR, \"service_account.json\")\nGDCH_SERVICE_ACCOUNT_JSON_FILE = os.path.join(DATA_DIR, \"gdch_service_account.json\")\n\nwith open(SERVICE_ACCOUNT_JSON_FILE, \"r\") as fh:\n    SERVICE_ACCOUNT_INFO = json.load(fh)\n\nwith open(GDCH_SERVICE_ACCOUNT_JSON_FILE, \"r\") as fh:\n    GDCH_SERVICE_ACCOUNT_INFO = json.load(fh)\n\n\ndef test_from_dict():\n    signer = _service_account_info.from_dict(SERVICE_ACCOUNT_INFO)\n    assert isinstance(signer, crypt.RSASigner)\n    assert signer.key_id == SERVICE_ACCOUNT_INFO[\"private_key_id\"]\n\n\ndef test_from_dict_es256_signer():\n    signer = _service_account_info.from_dict(\n        GDCH_SERVICE_ACCOUNT_INFO, use_rsa_signer=False\n    )\n    assert isinstance(signer, crypt.ES256Signer)\n    assert signer.key_id == GDCH_SERVICE_ACCOUNT_INFO[\"private_key_id\"]\n\n\ndef test_from_dict_bad_private_key():\n    info = SERVICE_ACCOUNT_INFO.copy()\n    info[\"private_key\"] = \"garbage\"\n\n    with pytest.raises(ValueError) as excinfo:\n        _service_account_info.from_dict(info)\n\n    assert excinfo.match(r\"key\")\n\n\ndef test_from_dict_bad_format():\n    with pytest.raises(ValueError) as excinfo:\n        _service_account_info.from_dict({}, require=(\"meep\",))\n\n    assert excinfo.match(r\"missing fields\")\n\n\ndef test_from_filename():\n    info, signer = _service_account_info.from_filename(SERVICE_ACCOUNT_JSON_FILE)\n\n    for key, value in SERVICE_ACCOUNT_INFO.items():\n        assert info[key] == value\n\n    assert isinstance(signer, crypt.RSASigner)\n    assert signer.key_id == SERVICE_ACCOUNT_INFO[\"private_key_id\"]\n\n\ndef test_from_filename_es256_signer():\n    _, signer = _service_account_info.from_filename(\n        GDCH_SERVICE_ACCOUNT_JSON_FILE, use_rsa_signer=False\n    )\n\n    assert isinstance(signer, crypt.ES256Signer)\n    assert signer.key_id == GDCH_SERVICE_ACCOUNT_INFO[\"private_key_id\"]\n", "tests/test_app_engine.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport datetime\n\nimport mock\nimport pytest  # type: ignore\n\nfrom google.auth import app_engine\n\n\nclass _AppIdentityModule(object):\n    \"\"\"The interface of the App Idenity app engine module.\n    See https://cloud.google.com/appengine/docs/standard/python/refdocs\n    /google.appengine.api.app_identity.app_identity\n    \"\"\"\n\n    def get_application_id(self):\n        raise NotImplementedError()\n\n    def sign_blob(self, bytes_to_sign, deadline=None):\n        raise NotImplementedError()\n\n    def get_service_account_name(self, deadline=None):\n        raise NotImplementedError()\n\n    def get_access_token(self, scopes, service_account_id=None):\n        raise NotImplementedError()\n\n\n@pytest.fixture\ndef app_identity(monkeypatch):\n    \"\"\"Mocks the app_identity module for google.auth.app_engine.\"\"\"\n    app_identity_module = mock.create_autospec(_AppIdentityModule, instance=True)\n    monkeypatch.setattr(app_engine, \"app_identity\", app_identity_module)\n    yield app_identity_module\n\n\ndef test_get_project_id(app_identity):\n    app_identity.get_application_id.return_value = mock.sentinel.project\n    assert app_engine.get_project_id() == mock.sentinel.project\n\n\n@mock.patch.object(app_engine, \"app_identity\", new=None)\ndef test_get_project_id_missing_apis():\n    with pytest.raises(EnvironmentError) as excinfo:\n        assert app_engine.get_project_id()\n\n    assert excinfo.match(r\"App Engine APIs are not available\")\n\n\nclass TestSigner(object):\n    def test_key_id(self, app_identity):\n        app_identity.sign_blob.return_value = (\n            mock.sentinel.key_id,\n            mock.sentinel.signature,\n        )\n\n        signer = app_engine.Signer()\n\n        assert signer.key_id is None\n\n    def test_sign(self, app_identity):\n        app_identity.sign_blob.return_value = (\n            mock.sentinel.key_id,\n            mock.sentinel.signature,\n        )\n\n        signer = app_engine.Signer()\n        to_sign = b\"123\"\n\n        signature = signer.sign(to_sign)\n\n        assert signature == mock.sentinel.signature\n        app_identity.sign_blob.assert_called_with(to_sign)\n\n\nclass TestCredentials(object):\n    @mock.patch.object(app_engine, \"app_identity\", new=None)\n    def test_missing_apis(self):\n        with pytest.raises(EnvironmentError) as excinfo:\n            app_engine.Credentials()\n\n        assert excinfo.match(r\"App Engine APIs are not available\")\n\n    def test_default_state(self, app_identity):\n        credentials = app_engine.Credentials()\n\n        # Not token acquired yet\n        assert not credentials.valid\n        # Expiration hasn't been set yet\n        assert not credentials.expired\n        # Scopes are required\n        assert not credentials.scopes\n        assert not credentials.default_scopes\n        assert credentials.requires_scopes\n        assert not credentials.quota_project_id\n\n    def test_with_scopes(self, app_identity):\n        credentials = app_engine.Credentials()\n\n        assert not credentials.scopes\n        assert credentials.requires_scopes\n\n        scoped_credentials = credentials.with_scopes([\"email\"])\n\n        assert scoped_credentials.has_scopes([\"email\"])\n        assert not scoped_credentials.requires_scopes\n\n    def test_with_default_scopes(self, app_identity):\n        credentials = app_engine.Credentials()\n\n        assert not credentials.scopes\n        assert not credentials.default_scopes\n        assert credentials.requires_scopes\n\n        scoped_credentials = credentials.with_scopes(\n            scopes=None, default_scopes=[\"email\"]\n        )\n\n        assert scoped_credentials.has_scopes([\"email\"])\n        assert not scoped_credentials.requires_scopes\n\n    def test_with_quota_project(self, app_identity):\n        credentials = app_engine.Credentials()\n\n        assert not credentials.scopes\n        assert not credentials.quota_project_id\n\n        quota_project_creds = credentials.with_quota_project(\"project-foo\")\n\n        assert quota_project_creds.quota_project_id == \"project-foo\"\n\n    def test_service_account_email_implicit(self, app_identity):\n        app_identity.get_service_account_name.return_value = (\n            mock.sentinel.service_account_email\n        )\n        credentials = app_engine.Credentials()\n\n        assert credentials.service_account_email == mock.sentinel.service_account_email\n        assert app_identity.get_service_account_name.called\n\n    def test_service_account_email_explicit(self, app_identity):\n        credentials = app_engine.Credentials(\n            service_account_id=mock.sentinel.service_account_email\n        )\n\n        assert credentials.service_account_email == mock.sentinel.service_account_email\n        assert not app_identity.get_service_account_name.called\n\n    @mock.patch(\"google.auth._helpers.utcnow\", return_value=datetime.datetime.min)\n    def test_refresh(self, utcnow, app_identity):\n        token = \"token\"\n        ttl = 643942923\n        app_identity.get_access_token.return_value = token, ttl\n        credentials = app_engine.Credentials(\n            scopes=[\"email\"], default_scopes=[\"profile\"]\n        )\n\n        credentials.refresh(None)\n\n        app_identity.get_access_token.assert_called_with(\n            credentials.scopes, credentials._service_account_id\n        )\n        assert credentials.token == token\n        assert credentials.expiry == datetime.datetime(1990, 5, 29, 1, 2, 3)\n        assert credentials.valid\n        assert not credentials.expired\n\n    @mock.patch(\"google.auth._helpers.utcnow\", return_value=datetime.datetime.min)\n    def test_refresh_with_default_scopes(self, utcnow, app_identity):\n        token = \"token\"\n        ttl = 643942923\n        app_identity.get_access_token.return_value = token, ttl\n        credentials = app_engine.Credentials(default_scopes=[\"email\"])\n\n        credentials.refresh(None)\n\n        app_identity.get_access_token.assert_called_with(\n            credentials.default_scopes, credentials._service_account_id\n        )\n        assert credentials.token == token\n        assert credentials.expiry == datetime.datetime(1990, 5, 29, 1, 2, 3)\n        assert credentials.valid\n        assert not credentials.expired\n\n    def test_sign_bytes(self, app_identity):\n        app_identity.sign_blob.return_value = (\n            mock.sentinel.key_id,\n            mock.sentinel.signature,\n        )\n        credentials = app_engine.Credentials()\n        to_sign = b\"123\"\n\n        signature = credentials.sign_bytes(to_sign)\n\n        assert signature == mock.sentinel.signature\n        app_identity.sign_blob.assert_called_with(to_sign)\n\n    def test_signer(self, app_identity):\n        credentials = app_engine.Credentials()\n        assert isinstance(credentials.signer, app_engine.Signer)\n\n    def test_signer_email(self, app_identity):\n        credentials = app_engine.Credentials()\n        assert credentials.signer_email == credentials.service_account_email\n", "tests/test_metrics.py": "# Copyright 2014 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport platform\n\nimport mock\n\nfrom google.auth import metrics\nfrom google.auth import version\n\n\ndef test_add_metric_header():\n    headers = {}\n    metrics.add_metric_header(headers, None)\n    assert headers == {}\n\n    headers = {\"x-goog-api-client\": \"foo\"}\n    metrics.add_metric_header(headers, \"bar\")\n    assert headers == {\"x-goog-api-client\": \"foo bar\"}\n\n    headers = {}\n    metrics.add_metric_header(headers, \"bar\")\n    assert headers == {\"x-goog-api-client\": \"bar\"}\n\n\n@mock.patch.object(platform, \"python_version\", return_value=\"3.7\")\ndef test_versions(mock_python_version):\n    version_save = version.__version__\n    version.__version__ = \"1.1\"\n    assert metrics.python_and_auth_lib_version() == \"gl-python/3.7 auth/1.1\"\n    version.__version__ = version_save\n\n\n@mock.patch(\n    \"google.auth.metrics.python_and_auth_lib_version\",\n    return_value=\"gl-python/3.7 auth/1.1\",\n)\ndef test_metric_values(mock_python_and_auth_lib_version):\n    assert (\n        metrics.token_request_access_token_mds()\n        == \"gl-python/3.7 auth/1.1 auth-request-type/at cred-type/mds\"\n    )\n    assert (\n        metrics.token_request_id_token_mds()\n        == \"gl-python/3.7 auth/1.1 auth-request-type/it cred-type/mds\"\n    )\n    assert (\n        metrics.token_request_access_token_impersonate()\n        == \"gl-python/3.7 auth/1.1 auth-request-type/at cred-type/imp\"\n    )\n    assert (\n        metrics.token_request_id_token_impersonate()\n        == \"gl-python/3.7 auth/1.1 auth-request-type/it cred-type/imp\"\n    )\n    assert (\n        metrics.token_request_access_token_sa_assertion()\n        == \"gl-python/3.7 auth/1.1 auth-request-type/at cred-type/sa\"\n    )\n    assert (\n        metrics.token_request_id_token_sa_assertion()\n        == \"gl-python/3.7 auth/1.1 auth-request-type/it cred-type/sa\"\n    )\n    assert metrics.token_request_user() == \"gl-python/3.7 auth/1.1 cred-type/u\"\n    assert metrics.mds_ping() == \"gl-python/3.7 auth/1.1 auth-request-type/mds\"\n    assert metrics.reauth_start() == \"gl-python/3.7 auth/1.1 auth-request-type/re-start\"\n    assert (\n        metrics.reauth_continue() == \"gl-python/3.7 auth/1.1 auth-request-type/re-cont\"\n    )\n\n\n@mock.patch(\n    \"google.auth.metrics.python_and_auth_lib_version\",\n    return_value=\"gl-python/3.7 auth/1.1\",\n)\ndef test_byoid_metric_header(mock_python_and_auth_lib_version):\n    metrics_options = {}\n    assert (\n        metrics.byoid_metrics_header(metrics_options)\n        == \"gl-python/3.7 auth/1.1 google-byoid-sdk\"\n    )\n    metrics_options[\"testKey\"] = \"testValue\"\n    assert (\n        metrics.byoid_metrics_header(metrics_options)\n        == \"gl-python/3.7 auth/1.1 google-byoid-sdk testKey/testValue\"\n    )\n", "tests/test_external_account.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport datetime\nimport http.client as http_client\nimport json\nimport urllib\n\nimport mock\nimport pytest  # type: ignore\n\nfrom google.auth import _helpers\nfrom google.auth import exceptions\nfrom google.auth import external_account\nfrom google.auth import transport\nfrom google.auth.credentials import DEFAULT_UNIVERSE_DOMAIN\nfrom google.auth.credentials import TokenState\n\nIMPERSONATE_ACCESS_TOKEN_REQUEST_METRICS_HEADER_VALUE = (\n    \"gl-python/3.7 auth/1.1 auth-request-type/at cred-type/imp\"\n)\nLANG_LIBRARY_METRICS_HEADER_VALUE = \"gl-python/3.7 auth/1.1\"\n\nCLIENT_ID = \"username\"\nCLIENT_SECRET = \"password\"\n# Base64 encoding of \"username:password\"\nBASIC_AUTH_ENCODING = \"dXNlcm5hbWU6cGFzc3dvcmQ=\"\nSERVICE_ACCOUNT_EMAIL = \"service-1234@service-name.iam.gserviceaccount.com\"\n# List of valid workforce pool audiences.\nTEST_USER_AUDIENCES = [\n    \"//iam.googleapis.com/locations/global/workforcePools/pool-id/providers/provider-id\",\n    \"//iam.googleapis.com/locations/eu/workforcePools/pool-id/providers/provider-id\",\n    \"//iam.googleapis.com/locations/eu/workforcePools/workloadIdentityPools/providers/provider-id\",\n]\n# Workload identity pool audiences or invalid workforce pool audiences.\nTEST_NON_USER_AUDIENCES = [\n    # Legacy K8s audience format.\n    \"identitynamespace:1f12345:my_provider\",\n    (\n        \"//iam.googleapis.com/projects/123456/locations/\"\n        \"global/workloadIdentityPools/pool-id/providers/\"\n        \"provider-id\"\n    ),\n    (\n        \"//iam.googleapis.com/projects/123456/locations/\"\n        \"eu/workloadIdentityPools/pool-id/providers/\"\n        \"provider-id\"\n    ),\n    # Pool ID with workforcePools string.\n    (\n        \"//iam.googleapis.com/projects/123456/locations/\"\n        \"global/workloadIdentityPools/workforcePools/providers/\"\n        \"provider-id\"\n    ),\n    # Unrealistic / incorrect workforce pool audiences.\n    \"//iamgoogleapis.com/locations/eu/workforcePools/pool-id/providers/provider-id\",\n    \"//iam.googleapiscom/locations/eu/workforcePools/pool-id/providers/provider-id\",\n    \"//iam.googleapis.com/locations/workforcePools/pool-id/providers/provider-id\",\n    \"//iam.googleapis.com/locations/eu/workforcePool/pool-id/providers/provider-id\",\n    \"//iam.googleapis.com/locations//workforcePool/pool-id/providers/provider-id\",\n]\n\n\nclass CredentialsImpl(external_account.Credentials):\n    def __init__(self, **kwargs):\n        super(CredentialsImpl, self).__init__(**kwargs)\n        self._counter = 0\n\n    def retrieve_subject_token(self, request):\n        counter = self._counter\n        self._counter += 1\n        return \"subject_token_{}\".format(counter)\n\n\nclass TestCredentials(object):\n    TOKEN_URL = \"https://sts.googleapis.com/v1/token\"\n    TOKEN_INFO_URL = \"https://sts.googleapis.com/v1/introspect\"\n    PROJECT_NUMBER = \"123456\"\n    POOL_ID = \"POOL_ID\"\n    PROVIDER_ID = \"PROVIDER_ID\"\n    AUDIENCE = (\n        \"//iam.googleapis.com/projects/{}\"\n        \"/locations/global/workloadIdentityPools/{}\"\n        \"/providers/{}\"\n    ).format(PROJECT_NUMBER, POOL_ID, PROVIDER_ID)\n    WORKFORCE_AUDIENCE = (\n        \"//iam.googleapis.com/locations/global/workforcePools/{}/providers/{}\"\n    ).format(POOL_ID, PROVIDER_ID)\n    WORKFORCE_POOL_USER_PROJECT = \"WORKFORCE_POOL_USER_PROJECT_NUMBER\"\n    SUBJECT_TOKEN_TYPE = \"urn:ietf:params:oauth:token-type:jwt\"\n    WORKFORCE_SUBJECT_TOKEN_TYPE = \"urn:ietf:params:oauth:token-type:id_token\"\n    CREDENTIAL_SOURCE = {\"file\": \"/var/run/secrets/goog.id/token\"}\n    SUCCESS_RESPONSE = {\n        \"access_token\": \"ACCESS_TOKEN\",\n        \"issued_token_type\": \"urn:ietf:params:oauth:token-type:access_token\",\n        \"token_type\": \"Bearer\",\n        \"expires_in\": 3600,\n        \"scope\": \"scope1 scope2\",\n    }\n    ERROR_RESPONSE = {\n        \"error\": \"invalid_request\",\n        \"error_description\": \"Invalid subject token\",\n        \"error_uri\": \"https://tools.ietf.org/html/rfc6749\",\n    }\n    QUOTA_PROJECT_ID = \"QUOTA_PROJECT_ID\"\n    SERVICE_ACCOUNT_IMPERSONATION_URL = (\n        \"https://us-east1-iamcredentials.googleapis.com/v1/projects/-\"\n        + \"/serviceAccounts/{}:generateAccessToken\".format(SERVICE_ACCOUNT_EMAIL)\n    )\n    SCOPES = [\"scope1\", \"scope2\"]\n    IMPERSONATION_ERROR_RESPONSE = {\n        \"error\": {\n            \"code\": 400,\n            \"message\": \"Request contains an invalid argument\",\n            \"status\": \"INVALID_ARGUMENT\",\n        }\n    }\n    PROJECT_ID = \"my-proj-id\"\n    CLOUD_RESOURCE_MANAGER_URL = (\n        \"https://cloudresourcemanager.googleapis.com/v1/projects/\"\n    )\n    CLOUD_RESOURCE_MANAGER_SUCCESS_RESPONSE = {\n        \"projectNumber\": PROJECT_NUMBER,\n        \"projectId\": PROJECT_ID,\n        \"lifecycleState\": \"ACTIVE\",\n        \"name\": \"project-name\",\n        \"createTime\": \"2018-11-06T04:42:54.109Z\",\n        \"parent\": {\"type\": \"folder\", \"id\": \"12345678901\"},\n    }\n\n    @classmethod\n    def make_credentials(\n        cls,\n        client_id=None,\n        client_secret=None,\n        quota_project_id=None,\n        token_info_url=None,\n        scopes=None,\n        default_scopes=None,\n        service_account_impersonation_url=None,\n        service_account_impersonation_options={},\n        universe_domain=DEFAULT_UNIVERSE_DOMAIN,\n    ):\n        return CredentialsImpl(\n            audience=cls.AUDIENCE,\n            subject_token_type=cls.SUBJECT_TOKEN_TYPE,\n            token_url=cls.TOKEN_URL,\n            token_info_url=token_info_url,\n            service_account_impersonation_url=service_account_impersonation_url,\n            service_account_impersonation_options=service_account_impersonation_options,\n            credential_source=cls.CREDENTIAL_SOURCE,\n            client_id=client_id,\n            client_secret=client_secret,\n            quota_project_id=quota_project_id,\n            scopes=scopes,\n            default_scopes=default_scopes,\n            universe_domain=universe_domain,\n        )\n\n    @classmethod\n    def make_workforce_pool_credentials(\n        cls,\n        client_id=None,\n        client_secret=None,\n        quota_project_id=None,\n        scopes=None,\n        default_scopes=None,\n        service_account_impersonation_url=None,\n        workforce_pool_user_project=None,\n    ):\n        return CredentialsImpl(\n            audience=cls.WORKFORCE_AUDIENCE,\n            subject_token_type=cls.WORKFORCE_SUBJECT_TOKEN_TYPE,\n            token_url=cls.TOKEN_URL,\n            service_account_impersonation_url=service_account_impersonation_url,\n            credential_source=cls.CREDENTIAL_SOURCE,\n            client_id=client_id,\n            client_secret=client_secret,\n            quota_project_id=quota_project_id,\n            scopes=scopes,\n            default_scopes=default_scopes,\n            workforce_pool_user_project=workforce_pool_user_project,\n        )\n\n    @classmethod\n    def make_mock_request(\n        cls,\n        status=http_client.OK,\n        data=None,\n        impersonation_status=None,\n        impersonation_data=None,\n        cloud_resource_manager_status=None,\n        cloud_resource_manager_data=None,\n    ):\n        # STS token exchange request.\n        token_response = mock.create_autospec(transport.Response, instance=True)\n        token_response.status = status\n        token_response.data = json.dumps(data).encode(\"utf-8\")\n        responses = [token_response]\n\n        # If service account impersonation is requested, mock the expected response.\n        if impersonation_status:\n            impersonation_response = mock.create_autospec(\n                transport.Response, instance=True\n            )\n            impersonation_response.status = impersonation_status\n            impersonation_response.data = json.dumps(impersonation_data).encode(\"utf-8\")\n            responses.append(impersonation_response)\n\n        # If cloud resource manager is requested, mock the expected response.\n        if cloud_resource_manager_status:\n            cloud_resource_manager_response = mock.create_autospec(\n                transport.Response, instance=True\n            )\n            cloud_resource_manager_response.status = cloud_resource_manager_status\n            cloud_resource_manager_response.data = json.dumps(\n                cloud_resource_manager_data\n            ).encode(\"utf-8\")\n            responses.append(cloud_resource_manager_response)\n\n        request = mock.create_autospec(transport.Request)\n        request.side_effect = responses\n\n        return request\n\n    @classmethod\n    def assert_token_request_kwargs(cls, request_kwargs, headers, request_data):\n        assert request_kwargs[\"url\"] == cls.TOKEN_URL\n        assert request_kwargs[\"method\"] == \"POST\"\n        assert request_kwargs[\"headers\"] == headers\n        assert request_kwargs[\"body\"] is not None\n        body_tuples = urllib.parse.parse_qsl(request_kwargs[\"body\"])\n        for (k, v) in body_tuples:\n            assert v.decode(\"utf-8\") == request_data[k.decode(\"utf-8\")]\n        assert len(body_tuples) == len(request_data.keys())\n\n    @classmethod\n    def assert_impersonation_request_kwargs(cls, request_kwargs, headers, request_data):\n        assert request_kwargs[\"url\"] == cls.SERVICE_ACCOUNT_IMPERSONATION_URL\n        assert request_kwargs[\"method\"] == \"POST\"\n        assert request_kwargs[\"headers\"] == headers\n        assert request_kwargs[\"body\"] is not None\n        body_json = json.loads(request_kwargs[\"body\"].decode(\"utf-8\"))\n        assert body_json == request_data\n\n    @classmethod\n    def assert_resource_manager_request_kwargs(\n        cls, request_kwargs, project_number, headers\n    ):\n        assert request_kwargs[\"url\"] == cls.CLOUD_RESOURCE_MANAGER_URL + project_number\n        assert request_kwargs[\"method\"] == \"GET\"\n        assert request_kwargs[\"headers\"] == headers\n        assert \"body\" not in request_kwargs\n\n    def test_default_state(self):\n        credentials = self.make_credentials(\n            service_account_impersonation_url=self.SERVICE_ACCOUNT_IMPERSONATION_URL\n        )\n\n        # Token url and service account impersonation url should be set\n        assert credentials._token_url\n        assert credentials._service_account_impersonation_url\n        # Not token acquired yet\n        assert not credentials.token\n        assert not credentials.valid\n        # Expiration hasn't been set yet\n        assert not credentials.expiry\n        assert not credentials.expired\n        # Scopes are required\n        assert not credentials.scopes\n        assert credentials.requires_scopes\n        assert not credentials.quota_project_id\n        # Token info url not set yet\n        assert not credentials.token_info_url\n\n    def test_nonworkforce_with_workforce_pool_user_project(self):\n        with pytest.raises(ValueError) as excinfo:\n            CredentialsImpl(\n                audience=self.AUDIENCE,\n                subject_token_type=self.SUBJECT_TOKEN_TYPE,\n                token_url=self.TOKEN_URL,\n                credential_source=self.CREDENTIAL_SOURCE,\n                workforce_pool_user_project=self.WORKFORCE_POOL_USER_PROJECT,\n            )\n\n        assert excinfo.match(\n            \"workforce_pool_user_project should not be set for non-workforce \"\n            \"pool credentials\"\n        )\n\n    def test_with_scopes(self):\n        credentials = self.make_credentials()\n\n        assert not credentials.scopes\n        assert credentials.requires_scopes\n\n        scoped_credentials = credentials.with_scopes([\"email\"])\n\n        assert scoped_credentials.has_scopes([\"email\"])\n        assert not scoped_credentials.requires_scopes\n\n    def test_with_scopes_workforce_pool(self):\n        credentials = self.make_workforce_pool_credentials(\n            workforce_pool_user_project=self.WORKFORCE_POOL_USER_PROJECT\n        )\n\n        assert not credentials.scopes\n        assert credentials.requires_scopes\n\n        scoped_credentials = credentials.with_scopes([\"email\"])\n\n        assert scoped_credentials.has_scopes([\"email\"])\n        assert not scoped_credentials.requires_scopes\n        assert (\n            scoped_credentials.info.get(\"workforce_pool_user_project\")\n            == self.WORKFORCE_POOL_USER_PROJECT\n        )\n\n    def test_with_scopes_using_user_and_default_scopes(self):\n        credentials = self.make_credentials()\n\n        assert not credentials.scopes\n        assert credentials.requires_scopes\n\n        scoped_credentials = credentials.with_scopes(\n            [\"email\"], default_scopes=[\"profile\"]\n        )\n\n        assert scoped_credentials.has_scopes([\"email\"])\n        assert not scoped_credentials.has_scopes([\"profile\"])\n        assert not scoped_credentials.requires_scopes\n        assert scoped_credentials.scopes == [\"email\"]\n        assert scoped_credentials.default_scopes == [\"profile\"]\n\n    def test_with_scopes_using_default_scopes_only(self):\n        credentials = self.make_credentials()\n\n        assert not credentials.scopes\n        assert credentials.requires_scopes\n\n        scoped_credentials = credentials.with_scopes(None, default_scopes=[\"profile\"])\n\n        assert scoped_credentials.has_scopes([\"profile\"])\n        assert not scoped_credentials.requires_scopes\n\n    def test_with_scopes_full_options_propagated(self):\n        credentials = self.make_credentials(\n            client_id=CLIENT_ID,\n            client_secret=CLIENT_SECRET,\n            quota_project_id=self.QUOTA_PROJECT_ID,\n            scopes=self.SCOPES,\n            token_info_url=self.TOKEN_INFO_URL,\n            default_scopes=[\"default1\"],\n            service_account_impersonation_url=self.SERVICE_ACCOUNT_IMPERSONATION_URL,\n            service_account_impersonation_options={\"token_lifetime_seconds\": 2800},\n        )\n\n        with mock.patch.object(\n            external_account.Credentials, \"__init__\", return_value=None\n        ) as mock_init:\n            credentials.with_scopes([\"email\"], [\"default2\"])\n\n        # Confirm with_scopes initialized the credential with the expected\n        # parameters and scopes.\n        mock_init.assert_called_once_with(\n            audience=self.AUDIENCE,\n            subject_token_type=self.SUBJECT_TOKEN_TYPE,\n            token_url=self.TOKEN_URL,\n            token_info_url=self.TOKEN_INFO_URL,\n            credential_source=self.CREDENTIAL_SOURCE,\n            service_account_impersonation_url=self.SERVICE_ACCOUNT_IMPERSONATION_URL,\n            service_account_impersonation_options={\"token_lifetime_seconds\": 2800},\n            client_id=CLIENT_ID,\n            client_secret=CLIENT_SECRET,\n            quota_project_id=self.QUOTA_PROJECT_ID,\n            scopes=[\"email\"],\n            default_scopes=[\"default2\"],\n            universe_domain=DEFAULT_UNIVERSE_DOMAIN,\n        )\n\n    def test_with_token_uri(self):\n        credentials = self.make_credentials()\n        new_token_uri = \"https://eu-sts.googleapis.com/v1/token\"\n\n        assert credentials._token_url == self.TOKEN_URL\n\n        creds_with_new_token_uri = credentials.with_token_uri(new_token_uri)\n\n        assert creds_with_new_token_uri._token_url == new_token_uri\n\n    def test_with_token_uri_workforce_pool(self):\n        credentials = self.make_workforce_pool_credentials(\n            workforce_pool_user_project=self.WORKFORCE_POOL_USER_PROJECT\n        )\n\n        new_token_uri = \"https://eu-sts.googleapis.com/v1/token\"\n\n        assert credentials._token_url == self.TOKEN_URL\n\n        creds_with_new_token_uri = credentials.with_token_uri(new_token_uri)\n\n        assert creds_with_new_token_uri._token_url == new_token_uri\n        assert (\n            creds_with_new_token_uri.info.get(\"workforce_pool_user_project\")\n            == self.WORKFORCE_POOL_USER_PROJECT\n        )\n\n    def test_with_quota_project(self):\n        credentials = self.make_credentials()\n\n        assert not credentials.scopes\n        assert not credentials.quota_project_id\n\n        quota_project_creds = credentials.with_quota_project(\"project-foo\")\n\n        assert quota_project_creds.quota_project_id == \"project-foo\"\n\n    def test_with_quota_project_workforce_pool(self):\n        credentials = self.make_workforce_pool_credentials(\n            workforce_pool_user_project=self.WORKFORCE_POOL_USER_PROJECT\n        )\n\n        assert not credentials.scopes\n        assert not credentials.quota_project_id\n\n        quota_project_creds = credentials.with_quota_project(\"project-foo\")\n\n        assert quota_project_creds.quota_project_id == \"project-foo\"\n        assert (\n            quota_project_creds.info.get(\"workforce_pool_user_project\")\n            == self.WORKFORCE_POOL_USER_PROJECT\n        )\n\n    def test_with_quota_project_full_options_propagated(self):\n        credentials = self.make_credentials(\n            client_id=CLIENT_ID,\n            client_secret=CLIENT_SECRET,\n            token_info_url=self.TOKEN_INFO_URL,\n            quota_project_id=self.QUOTA_PROJECT_ID,\n            scopes=self.SCOPES,\n            default_scopes=[\"default1\"],\n            service_account_impersonation_url=self.SERVICE_ACCOUNT_IMPERSONATION_URL,\n            service_account_impersonation_options={\"token_lifetime_seconds\": 2800},\n        )\n\n        with mock.patch.object(\n            external_account.Credentials, \"__init__\", return_value=None\n        ) as mock_init:\n            credentials.with_quota_project(\"project-foo\")\n\n        # Confirm with_quota_project initialized the credential with the\n        # expected parameters and quota project ID.\n        mock_init.assert_called_once_with(\n            audience=self.AUDIENCE,\n            subject_token_type=self.SUBJECT_TOKEN_TYPE,\n            token_url=self.TOKEN_URL,\n            token_info_url=self.TOKEN_INFO_URL,\n            credential_source=self.CREDENTIAL_SOURCE,\n            service_account_impersonation_url=self.SERVICE_ACCOUNT_IMPERSONATION_URL,\n            service_account_impersonation_options={\"token_lifetime_seconds\": 2800},\n            client_id=CLIENT_ID,\n            client_secret=CLIENT_SECRET,\n            quota_project_id=\"project-foo\",\n            scopes=self.SCOPES,\n            default_scopes=[\"default1\"],\n            universe_domain=DEFAULT_UNIVERSE_DOMAIN,\n        )\n\n    def test_info(self):\n        credentials = self.make_credentials(universe_domain=\"dummy_universe.com\")\n\n        assert credentials.info == {\n            \"type\": \"external_account\",\n            \"audience\": self.AUDIENCE,\n            \"subject_token_type\": self.SUBJECT_TOKEN_TYPE,\n            \"token_url\": self.TOKEN_URL,\n            \"credential_source\": self.CREDENTIAL_SOURCE.copy(),\n            \"universe_domain\": \"dummy_universe.com\",\n        }\n\n    def test_universe_domain(self):\n        credentials = self.make_credentials(universe_domain=\"dummy_universe.com\")\n        assert credentials.universe_domain == \"dummy_universe.com\"\n\n        credentials = self.make_credentials()\n        assert credentials.universe_domain == DEFAULT_UNIVERSE_DOMAIN\n\n    def test_with_universe_domain(self):\n        credentials = self.make_credentials()\n        new_credentials = credentials.with_universe_domain(\"dummy_universe.com\")\n        assert new_credentials.universe_domain == \"dummy_universe.com\"\n\n    def test_info_workforce_pool(self):\n        credentials = self.make_workforce_pool_credentials(\n            workforce_pool_user_project=self.WORKFORCE_POOL_USER_PROJECT\n        )\n\n        assert credentials.info == {\n            \"type\": \"external_account\",\n            \"audience\": self.WORKFORCE_AUDIENCE,\n            \"subject_token_type\": self.WORKFORCE_SUBJECT_TOKEN_TYPE,\n            \"token_url\": self.TOKEN_URL,\n            \"credential_source\": self.CREDENTIAL_SOURCE.copy(),\n            \"workforce_pool_user_project\": self.WORKFORCE_POOL_USER_PROJECT,\n            \"universe_domain\": DEFAULT_UNIVERSE_DOMAIN,\n        }\n\n    def test_info_with_full_options(self):\n        credentials = self.make_credentials(\n            client_id=CLIENT_ID,\n            client_secret=CLIENT_SECRET,\n            quota_project_id=self.QUOTA_PROJECT_ID,\n            token_info_url=self.TOKEN_INFO_URL,\n            service_account_impersonation_url=self.SERVICE_ACCOUNT_IMPERSONATION_URL,\n            service_account_impersonation_options={\"token_lifetime_seconds\": 2800},\n        )\n\n        assert credentials.info == {\n            \"type\": \"external_account\",\n            \"audience\": self.AUDIENCE,\n            \"subject_token_type\": self.SUBJECT_TOKEN_TYPE,\n            \"token_url\": self.TOKEN_URL,\n            \"token_info_url\": self.TOKEN_INFO_URL,\n            \"service_account_impersonation_url\": self.SERVICE_ACCOUNT_IMPERSONATION_URL,\n            \"service_account_impersonation\": {\"token_lifetime_seconds\": 2800},\n            \"credential_source\": self.CREDENTIAL_SOURCE.copy(),\n            \"quota_project_id\": self.QUOTA_PROJECT_ID,\n            \"client_id\": CLIENT_ID,\n            \"client_secret\": CLIENT_SECRET,\n            \"universe_domain\": DEFAULT_UNIVERSE_DOMAIN,\n        }\n\n    def test_service_account_email_without_impersonation(self):\n        credentials = self.make_credentials()\n\n        assert credentials.service_account_email is None\n\n    def test_service_account_email_with_impersonation(self):\n        credentials = self.make_credentials(\n            service_account_impersonation_url=self.SERVICE_ACCOUNT_IMPERSONATION_URL\n        )\n\n        assert credentials.service_account_email == SERVICE_ACCOUNT_EMAIL\n\n    @pytest.mark.parametrize(\"audience\", TEST_NON_USER_AUDIENCES)\n    def test_is_user_with_non_users(self, audience):\n        credentials = CredentialsImpl(\n            audience=audience,\n            subject_token_type=self.SUBJECT_TOKEN_TYPE,\n            token_url=self.TOKEN_URL,\n            credential_source=self.CREDENTIAL_SOURCE,\n        )\n\n        assert credentials.is_user is False\n\n    @pytest.mark.parametrize(\"audience\", TEST_USER_AUDIENCES)\n    def test_is_user_with_users(self, audience):\n        credentials = CredentialsImpl(\n            audience=audience,\n            subject_token_type=self.SUBJECT_TOKEN_TYPE,\n            token_url=self.TOKEN_URL,\n            credential_source=self.CREDENTIAL_SOURCE,\n        )\n\n        assert credentials.is_user is True\n\n    @pytest.mark.parametrize(\"audience\", TEST_USER_AUDIENCES)\n    def test_is_user_with_users_and_impersonation(self, audience):\n        # Initialize the credentials with service account impersonation.\n        credentials = CredentialsImpl(\n            audience=audience,\n            subject_token_type=self.SUBJECT_TOKEN_TYPE,\n            token_url=self.TOKEN_URL,\n            credential_source=self.CREDENTIAL_SOURCE,\n            service_account_impersonation_url=self.SERVICE_ACCOUNT_IMPERSONATION_URL,\n        )\n\n        # Even though the audience is for a workforce pool, since service account\n        # impersonation is used, the credentials will represent a service account and\n        # not a user.\n        assert credentials.is_user is False\n\n    @pytest.mark.parametrize(\"audience\", TEST_NON_USER_AUDIENCES)\n    def test_is_workforce_pool_with_non_users(self, audience):\n        credentials = CredentialsImpl(\n            audience=audience,\n            subject_token_type=self.SUBJECT_TOKEN_TYPE,\n            token_url=self.TOKEN_URL,\n            credential_source=self.CREDENTIAL_SOURCE,\n        )\n\n        assert credentials.is_workforce_pool is False\n\n    @pytest.mark.parametrize(\"audience\", TEST_USER_AUDIENCES)\n    def test_is_workforce_pool_with_users(self, audience):\n        credentials = CredentialsImpl(\n            audience=audience,\n            subject_token_type=self.SUBJECT_TOKEN_TYPE,\n            token_url=self.TOKEN_URL,\n            credential_source=self.CREDENTIAL_SOURCE,\n        )\n\n        assert credentials.is_workforce_pool is True\n\n    @pytest.mark.parametrize(\"audience\", TEST_USER_AUDIENCES)\n    def test_is_workforce_pool_with_users_and_impersonation(self, audience):\n        # Initialize the credentials with workforce audience and service account\n        # impersonation.\n        credentials = CredentialsImpl(\n            audience=audience,\n            subject_token_type=self.SUBJECT_TOKEN_TYPE,\n            token_url=self.TOKEN_URL,\n            credential_source=self.CREDENTIAL_SOURCE,\n            service_account_impersonation_url=self.SERVICE_ACCOUNT_IMPERSONATION_URL,\n        )\n\n        # Even though impersonation is used, is_workforce_pool should still return True.\n        assert credentials.is_workforce_pool is True\n\n    @pytest.mark.parametrize(\"mock_expires_in\", [2800, \"2800\"])\n    @mock.patch(\n        \"google.auth.metrics.python_and_auth_lib_version\",\n        return_value=LANG_LIBRARY_METRICS_HEADER_VALUE,\n    )\n    @mock.patch(\"google.auth._helpers.utcnow\", return_value=datetime.datetime.min)\n    def test_refresh_without_client_auth_success(\n        self, unused_utcnow, mock_auth_lib_value, mock_expires_in\n    ):\n        response = self.SUCCESS_RESPONSE.copy()\n        # Test custom expiration to confirm expiry is set correctly.\n        response[\"expires_in\"] = mock_expires_in\n        expected_expiry = datetime.datetime.min + datetime.timedelta(\n            seconds=int(mock_expires_in)\n        )\n        headers = {\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n            \"x-goog-api-client\": \"gl-python/3.7 auth/1.1 google-byoid-sdk sa-impersonation/false config-lifetime/false\",\n        }\n        request_data = {\n            \"grant_type\": \"urn:ietf:params:oauth:grant-type:token-exchange\",\n            \"audience\": self.AUDIENCE,\n            \"requested_token_type\": \"urn:ietf:params:oauth:token-type:access_token\",\n            \"subject_token\": \"subject_token_0\",\n            \"subject_token_type\": self.SUBJECT_TOKEN_TYPE,\n        }\n        request = self.make_mock_request(status=http_client.OK, data=response)\n        credentials = self.make_credentials()\n\n        credentials.refresh(request)\n\n        self.assert_token_request_kwargs(request.call_args[1], headers, request_data)\n        assert credentials.valid\n        assert credentials.expiry == expected_expiry\n        assert not credentials.expired\n        assert credentials.token == response[\"access_token\"]\n\n    @mock.patch(\n        \"google.auth.metrics.python_and_auth_lib_version\",\n        return_value=LANG_LIBRARY_METRICS_HEADER_VALUE,\n    )\n    @mock.patch(\"google.auth._helpers.utcnow\", return_value=datetime.datetime.min)\n    def test_refresh_workforce_without_client_auth_success(\n        self, unused_utcnow, test_auth_lib_value\n    ):\n        response = self.SUCCESS_RESPONSE.copy()\n        # Test custom expiration to confirm expiry is set correctly.\n        response[\"expires_in\"] = 2800\n        expected_expiry = datetime.datetime.min + datetime.timedelta(\n            seconds=response[\"expires_in\"]\n        )\n        headers = {\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n            \"x-goog-api-client\": \"gl-python/3.7 auth/1.1 google-byoid-sdk sa-impersonation/false config-lifetime/false\",\n        }\n        request_data = {\n            \"grant_type\": \"urn:ietf:params:oauth:grant-type:token-exchange\",\n            \"audience\": self.WORKFORCE_AUDIENCE,\n            \"requested_token_type\": \"urn:ietf:params:oauth:token-type:access_token\",\n            \"subject_token\": \"subject_token_0\",\n            \"subject_token_type\": self.WORKFORCE_SUBJECT_TOKEN_TYPE,\n            \"options\": urllib.parse.quote(\n                json.dumps({\"userProject\": self.WORKFORCE_POOL_USER_PROJECT})\n            ),\n        }\n        request = self.make_mock_request(status=http_client.OK, data=response)\n        credentials = self.make_workforce_pool_credentials(\n            workforce_pool_user_project=self.WORKFORCE_POOL_USER_PROJECT\n        )\n\n        credentials.refresh(request)\n\n        self.assert_token_request_kwargs(request.call_args[1], headers, request_data)\n        assert credentials.valid\n        assert credentials.expiry == expected_expiry\n        assert not credentials.expired\n        assert credentials.token == response[\"access_token\"]\n\n    @mock.patch(\n        \"google.auth.metrics.python_and_auth_lib_version\",\n        return_value=LANG_LIBRARY_METRICS_HEADER_VALUE,\n    )\n    @mock.patch(\"google.auth._helpers.utcnow\", return_value=datetime.datetime.min)\n    def test_refresh_workforce_with_client_auth_success(\n        self, unused_utcnow, mock_auth_lib_value\n    ):\n        response = self.SUCCESS_RESPONSE.copy()\n        # Test custom expiration to confirm expiry is set correctly.\n        response[\"expires_in\"] = 2800\n        expected_expiry = datetime.datetime.min + datetime.timedelta(\n            seconds=response[\"expires_in\"]\n        )\n        headers = {\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n            \"Authorization\": \"Basic {}\".format(BASIC_AUTH_ENCODING),\n            \"x-goog-api-client\": \"gl-python/3.7 auth/1.1 google-byoid-sdk sa-impersonation/false config-lifetime/false\",\n        }\n        request_data = {\n            \"grant_type\": \"urn:ietf:params:oauth:grant-type:token-exchange\",\n            \"audience\": self.WORKFORCE_AUDIENCE,\n            \"requested_token_type\": \"urn:ietf:params:oauth:token-type:access_token\",\n            \"subject_token\": \"subject_token_0\",\n            \"subject_token_type\": self.WORKFORCE_SUBJECT_TOKEN_TYPE,\n        }\n        request = self.make_mock_request(status=http_client.OK, data=response)\n        # Client Auth will have higher priority over workforce_pool_user_project.\n        credentials = self.make_workforce_pool_credentials(\n            client_id=CLIENT_ID,\n            client_secret=CLIENT_SECRET,\n            workforce_pool_user_project=self.WORKFORCE_POOL_USER_PROJECT,\n        )\n\n        credentials.refresh(request)\n\n        self.assert_token_request_kwargs(request.call_args[1], headers, request_data)\n        assert credentials.valid\n        assert credentials.expiry == expected_expiry\n        assert not credentials.expired\n        assert credentials.token == response[\"access_token\"]\n\n    @mock.patch(\n        \"google.auth.metrics.python_and_auth_lib_version\",\n        return_value=LANG_LIBRARY_METRICS_HEADER_VALUE,\n    )\n    @mock.patch(\"google.auth._helpers.utcnow\", return_value=datetime.datetime.min)\n    def test_refresh_workforce_with_client_auth_and_no_workforce_project_success(\n        self, unused_utcnow, mock_lib_version_value\n    ):\n        response = self.SUCCESS_RESPONSE.copy()\n        # Test custom expiration to confirm expiry is set correctly.\n        response[\"expires_in\"] = 2800\n        expected_expiry = datetime.datetime.min + datetime.timedelta(\n            seconds=response[\"expires_in\"]\n        )\n        headers = {\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n            \"Authorization\": \"Basic {}\".format(BASIC_AUTH_ENCODING),\n            \"x-goog-api-client\": \"gl-python/3.7 auth/1.1 google-byoid-sdk sa-impersonation/false config-lifetime/false\",\n        }\n        request_data = {\n            \"grant_type\": \"urn:ietf:params:oauth:grant-type:token-exchange\",\n            \"audience\": self.WORKFORCE_AUDIENCE,\n            \"requested_token_type\": \"urn:ietf:params:oauth:token-type:access_token\",\n            \"subject_token\": \"subject_token_0\",\n            \"subject_token_type\": self.WORKFORCE_SUBJECT_TOKEN_TYPE,\n        }\n        request = self.make_mock_request(status=http_client.OK, data=response)\n        # Client Auth will be sufficient for user project determination.\n        credentials = self.make_workforce_pool_credentials(\n            client_id=CLIENT_ID,\n            client_secret=CLIENT_SECRET,\n            workforce_pool_user_project=None,\n        )\n\n        credentials.refresh(request)\n\n        self.assert_token_request_kwargs(request.call_args[1], headers, request_data)\n        assert credentials.valid\n        assert credentials.expiry == expected_expiry\n        assert not credentials.expired\n        assert credentials.token == response[\"access_token\"]\n\n    @mock.patch(\n        \"google.auth.metrics.token_request_access_token_impersonate\",\n        return_value=IMPERSONATE_ACCESS_TOKEN_REQUEST_METRICS_HEADER_VALUE,\n    )\n    @mock.patch(\n        \"google.auth.metrics.python_and_auth_lib_version\",\n        return_value=LANG_LIBRARY_METRICS_HEADER_VALUE,\n    )\n    def test_refresh_impersonation_without_client_auth_success(\n        self, mock_metrics_header_value, mock_auth_lib_value\n    ):\n        # Simulate service account access token expires in 2800 seconds.\n        expire_time = (\n            _helpers.utcnow().replace(microsecond=0) + datetime.timedelta(seconds=2800)\n        ).isoformat(\"T\") + \"Z\"\n        expected_expiry = datetime.datetime.strptime(expire_time, \"%Y-%m-%dT%H:%M:%SZ\")\n        # STS token exchange request/response.\n        token_response = self.SUCCESS_RESPONSE.copy()\n        token_headers = {\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n            \"x-goog-api-client\": \"gl-python/3.7 auth/1.1 google-byoid-sdk sa-impersonation/true config-lifetime/false\",\n        }\n        token_request_data = {\n            \"grant_type\": \"urn:ietf:params:oauth:grant-type:token-exchange\",\n            \"audience\": self.AUDIENCE,\n            \"requested_token_type\": \"urn:ietf:params:oauth:token-type:access_token\",\n            \"subject_token\": \"subject_token_0\",\n            \"subject_token_type\": self.SUBJECT_TOKEN_TYPE,\n            \"scope\": \"https://www.googleapis.com/auth/iam\",\n        }\n        # Service account impersonation request/response.\n        impersonation_response = {\n            \"accessToken\": \"SA_ACCESS_TOKEN\",\n            \"expireTime\": expire_time,\n        }\n        impersonation_headers = {\n            \"Content-Type\": \"application/json\",\n            \"authorization\": \"Bearer {}\".format(token_response[\"access_token\"]),\n            \"x-goog-api-client\": IMPERSONATE_ACCESS_TOKEN_REQUEST_METRICS_HEADER_VALUE,\n            \"x-allowed-locations\": \"0x0\",\n        }\n        impersonation_request_data = {\n            \"delegates\": None,\n            \"scope\": self.SCOPES,\n            \"lifetime\": \"3600s\",\n        }\n        # Initialize mock request to handle token exchange and service account\n        # impersonation request.\n        request = self.make_mock_request(\n            status=http_client.OK,\n            data=token_response,\n            impersonation_status=http_client.OK,\n            impersonation_data=impersonation_response,\n        )\n        # Initialize credentials with service account impersonation.\n        credentials = self.make_credentials(\n            service_account_impersonation_url=self.SERVICE_ACCOUNT_IMPERSONATION_URL,\n            scopes=self.SCOPES,\n        )\n\n        credentials.refresh(request)\n\n        # Only 2 requests should be processed.\n        assert len(request.call_args_list) == 2\n        # Verify token exchange request parameters.\n        self.assert_token_request_kwargs(\n            request.call_args_list[0][1], token_headers, token_request_data\n        )\n        # Verify service account impersonation request parameters.\n        self.assert_impersonation_request_kwargs(\n            request.call_args_list[1][1],\n            impersonation_headers,\n            impersonation_request_data,\n        )\n        assert credentials.valid\n        assert credentials.expiry == expected_expiry\n        assert not credentials.expired\n        assert credentials.token == impersonation_response[\"accessToken\"]\n\n    @mock.patch(\n        \"google.auth.metrics.token_request_access_token_impersonate\",\n        return_value=IMPERSONATE_ACCESS_TOKEN_REQUEST_METRICS_HEADER_VALUE,\n    )\n    @mock.patch(\n        \"google.auth.metrics.python_and_auth_lib_version\",\n        return_value=LANG_LIBRARY_METRICS_HEADER_VALUE,\n    )\n    def test_refresh_workforce_impersonation_without_client_auth_success(\n        self, mock_metrics_header_value, mock_auth_lib_value\n    ):\n        # Simulate service account access token expires in 2800 seconds.\n        expire_time = (\n            _helpers.utcnow().replace(microsecond=0) + datetime.timedelta(seconds=2800)\n        ).isoformat(\"T\") + \"Z\"\n        expected_expiry = datetime.datetime.strptime(expire_time, \"%Y-%m-%dT%H:%M:%SZ\")\n        # STS token exchange request/response.\n        token_response = self.SUCCESS_RESPONSE.copy()\n        token_headers = {\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n            \"x-goog-api-client\": \"gl-python/3.7 auth/1.1 google-byoid-sdk sa-impersonation/true config-lifetime/false\",\n        }\n        token_request_data = {\n            \"grant_type\": \"urn:ietf:params:oauth:grant-type:token-exchange\",\n            \"audience\": self.WORKFORCE_AUDIENCE,\n            \"requested_token_type\": \"urn:ietf:params:oauth:token-type:access_token\",\n            \"subject_token\": \"subject_token_0\",\n            \"subject_token_type\": self.WORKFORCE_SUBJECT_TOKEN_TYPE,\n            \"scope\": \"https://www.googleapis.com/auth/iam\",\n            \"options\": urllib.parse.quote(\n                json.dumps({\"userProject\": self.WORKFORCE_POOL_USER_PROJECT})\n            ),\n        }\n        # Service account impersonation request/response.\n        impersonation_response = {\n            \"accessToken\": \"SA_ACCESS_TOKEN\",\n            \"expireTime\": expire_time,\n        }\n        impersonation_headers = {\n            \"Content-Type\": \"application/json\",\n            \"authorization\": \"Bearer {}\".format(token_response[\"access_token\"]),\n            \"x-goog-api-client\": IMPERSONATE_ACCESS_TOKEN_REQUEST_METRICS_HEADER_VALUE,\n            \"x-allowed-locations\": \"0x0\",\n        }\n        impersonation_request_data = {\n            \"delegates\": None,\n            \"scope\": self.SCOPES,\n            \"lifetime\": \"3600s\",\n        }\n        # Initialize mock request to handle token exchange and service account\n        # impersonation request.\n        request = self.make_mock_request(\n            status=http_client.OK,\n            data=token_response,\n            impersonation_status=http_client.OK,\n            impersonation_data=impersonation_response,\n        )\n        # Initialize credentials with service account impersonation.\n        credentials = self.make_workforce_pool_credentials(\n            service_account_impersonation_url=self.SERVICE_ACCOUNT_IMPERSONATION_URL,\n            scopes=self.SCOPES,\n            workforce_pool_user_project=self.WORKFORCE_POOL_USER_PROJECT,\n        )\n\n        credentials.refresh(request)\n\n        # Only 2 requests should be processed.\n        assert len(request.call_args_list) == 2\n        # Verify token exchange request parameters.\n        self.assert_token_request_kwargs(\n            request.call_args_list[0][1], token_headers, token_request_data\n        )\n        # Verify service account impersonation request parameters.\n        self.assert_impersonation_request_kwargs(\n            request.call_args_list[1][1],\n            impersonation_headers,\n            impersonation_request_data,\n        )\n        assert credentials.valid\n        assert credentials.expiry == expected_expiry\n        assert not credentials.expired\n        assert credentials.token == impersonation_response[\"accessToken\"]\n\n    @mock.patch(\n        \"google.auth.metrics.python_and_auth_lib_version\",\n        return_value=LANG_LIBRARY_METRICS_HEADER_VALUE,\n    )\n    def test_refresh_without_client_auth_success_explicit_user_scopes_ignore_default_scopes(\n        self, mock_auth_lib_value\n    ):\n        headers = {\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n            \"x-goog-api-client\": \"gl-python/3.7 auth/1.1 google-byoid-sdk sa-impersonation/false config-lifetime/false\",\n        }\n        request_data = {\n            \"grant_type\": \"urn:ietf:params:oauth:grant-type:token-exchange\",\n            \"audience\": self.AUDIENCE,\n            \"requested_token_type\": \"urn:ietf:params:oauth:token-type:access_token\",\n            \"scope\": \"scope1 scope2\",\n            \"subject_token\": \"subject_token_0\",\n            \"subject_token_type\": self.SUBJECT_TOKEN_TYPE,\n        }\n        request = self.make_mock_request(\n            status=http_client.OK, data=self.SUCCESS_RESPONSE\n        )\n        credentials = self.make_credentials(\n            scopes=[\"scope1\", \"scope2\"],\n            # Default scopes will be ignored in favor of user scopes.\n            default_scopes=[\"ignored\"],\n        )\n\n        credentials.refresh(request)\n\n        self.assert_token_request_kwargs(request.call_args[1], headers, request_data)\n        assert credentials.valid\n        assert not credentials.expired\n        assert credentials.token == self.SUCCESS_RESPONSE[\"access_token\"]\n        assert credentials.has_scopes([\"scope1\", \"scope2\"])\n        assert not credentials.has_scopes([\"ignored\"])\n\n    @mock.patch(\n        \"google.auth.metrics.python_and_auth_lib_version\",\n        return_value=LANG_LIBRARY_METRICS_HEADER_VALUE,\n    )\n    def test_refresh_without_client_auth_success_explicit_default_scopes_only(\n        self, mock_auth_lib_value\n    ):\n        headers = {\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n            \"x-goog-api-client\": \"gl-python/3.7 auth/1.1 google-byoid-sdk sa-impersonation/false config-lifetime/false\",\n        }\n        request_data = {\n            \"grant_type\": \"urn:ietf:params:oauth:grant-type:token-exchange\",\n            \"audience\": self.AUDIENCE,\n            \"requested_token_type\": \"urn:ietf:params:oauth:token-type:access_token\",\n            \"scope\": \"scope1 scope2\",\n            \"subject_token\": \"subject_token_0\",\n            \"subject_token_type\": self.SUBJECT_TOKEN_TYPE,\n        }\n        request = self.make_mock_request(\n            status=http_client.OK, data=self.SUCCESS_RESPONSE\n        )\n        credentials = self.make_credentials(\n            scopes=None,\n            # Default scopes will be used since user scopes are none.\n            default_scopes=[\"scope1\", \"scope2\"],\n        )\n\n        credentials.refresh(request)\n\n        self.assert_token_request_kwargs(request.call_args[1], headers, request_data)\n        assert credentials.valid\n        assert not credentials.expired\n        assert credentials.token == self.SUCCESS_RESPONSE[\"access_token\"]\n        assert credentials.has_scopes([\"scope1\", \"scope2\"])\n\n    def test_refresh_without_client_auth_error(self):\n        request = self.make_mock_request(\n            status=http_client.BAD_REQUEST, data=self.ERROR_RESPONSE\n        )\n        credentials = self.make_credentials()\n\n        with pytest.raises(exceptions.OAuthError) as excinfo:\n            credentials.refresh(request)\n\n        assert excinfo.match(\n            r\"Error code invalid_request: Invalid subject token - https://tools.ietf.org/html/rfc6749\"\n        )\n        assert not credentials.expired\n        assert credentials.token is None\n\n    def test_refresh_impersonation_without_client_auth_error(self):\n        request = self.make_mock_request(\n            status=http_client.OK,\n            data=self.SUCCESS_RESPONSE,\n            impersonation_status=http_client.BAD_REQUEST,\n            impersonation_data=self.IMPERSONATION_ERROR_RESPONSE,\n        )\n        credentials = self.make_credentials(\n            service_account_impersonation_url=self.SERVICE_ACCOUNT_IMPERSONATION_URL,\n            scopes=self.SCOPES,\n        )\n\n        with pytest.raises(exceptions.RefreshError) as excinfo:\n            credentials.refresh(request)\n\n        assert excinfo.match(r\"Unable to acquire impersonated credentials\")\n        assert not credentials.expired\n        assert credentials.token is None\n\n    def test_refresh_impersonation_invalid_impersonated_url_error(self):\n        credentials = self.make_credentials(\n            service_account_impersonation_url=\"https://iamcredentials.googleapis.com/v1/invalid\",\n            scopes=self.SCOPES,\n        )\n\n        with pytest.raises(exceptions.RefreshError) as excinfo:\n            credentials.refresh(None)\n\n        assert excinfo.match(\n            r\"Unable to determine target principal from service account impersonation URL.\"\n        )\n        assert not credentials.expired\n        assert credentials.token is None\n\n    @mock.patch(\n        \"google.auth.metrics.python_and_auth_lib_version\",\n        return_value=LANG_LIBRARY_METRICS_HEADER_VALUE,\n    )\n    def test_refresh_with_client_auth_success(self, mock_auth_lib_value):\n        headers = {\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n            \"Authorization\": \"Basic {}\".format(BASIC_AUTH_ENCODING),\n            \"x-goog-api-client\": \"gl-python/3.7 auth/1.1 google-byoid-sdk sa-impersonation/false config-lifetime/false\",\n        }\n        request_data = {\n            \"grant_type\": \"urn:ietf:params:oauth:grant-type:token-exchange\",\n            \"audience\": self.AUDIENCE,\n            \"requested_token_type\": \"urn:ietf:params:oauth:token-type:access_token\",\n            \"subject_token\": \"subject_token_0\",\n            \"subject_token_type\": self.SUBJECT_TOKEN_TYPE,\n        }\n        request = self.make_mock_request(\n            status=http_client.OK, data=self.SUCCESS_RESPONSE\n        )\n        credentials = self.make_credentials(\n            client_id=CLIENT_ID, client_secret=CLIENT_SECRET\n        )\n\n        credentials.refresh(request)\n\n        self.assert_token_request_kwargs(request.call_args[1], headers, request_data)\n        assert credentials.valid\n        assert not credentials.expired\n        assert credentials.token == self.SUCCESS_RESPONSE[\"access_token\"]\n\n    @mock.patch(\n        \"google.auth.metrics.token_request_access_token_impersonate\",\n        return_value=IMPERSONATE_ACCESS_TOKEN_REQUEST_METRICS_HEADER_VALUE,\n    )\n    @mock.patch(\n        \"google.auth.metrics.python_and_auth_lib_version\",\n        return_value=LANG_LIBRARY_METRICS_HEADER_VALUE,\n    )\n    def test_refresh_impersonation_with_client_auth_success_ignore_default_scopes(\n        self, mock_metrics_header_value, mock_auth_lib_value\n    ):\n        # Simulate service account access token expires in 2800 seconds.\n        expire_time = (\n            _helpers.utcnow().replace(microsecond=0) + datetime.timedelta(seconds=2800)\n        ).isoformat(\"T\") + \"Z\"\n        expected_expiry = datetime.datetime.strptime(expire_time, \"%Y-%m-%dT%H:%M:%SZ\")\n        # STS token exchange request/response.\n        token_response = self.SUCCESS_RESPONSE.copy()\n        token_headers = {\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n            \"Authorization\": \"Basic {}\".format(BASIC_AUTH_ENCODING),\n            \"x-goog-api-client\": \"gl-python/3.7 auth/1.1 google-byoid-sdk sa-impersonation/true config-lifetime/false\",\n        }\n        token_request_data = {\n            \"grant_type\": \"urn:ietf:params:oauth:grant-type:token-exchange\",\n            \"audience\": self.AUDIENCE,\n            \"requested_token_type\": \"urn:ietf:params:oauth:token-type:access_token\",\n            \"subject_token\": \"subject_token_0\",\n            \"subject_token_type\": self.SUBJECT_TOKEN_TYPE,\n            \"scope\": \"https://www.googleapis.com/auth/iam\",\n        }\n        # Service account impersonation request/response.\n        impersonation_response = {\n            \"accessToken\": \"SA_ACCESS_TOKEN\",\n            \"expireTime\": expire_time,\n        }\n        impersonation_headers = {\n            \"Content-Type\": \"application/json\",\n            \"authorization\": \"Bearer {}\".format(token_response[\"access_token\"]),\n            \"x-goog-api-client\": IMPERSONATE_ACCESS_TOKEN_REQUEST_METRICS_HEADER_VALUE,\n            \"x-allowed-locations\": \"0x0\",\n        }\n        impersonation_request_data = {\n            \"delegates\": None,\n            \"scope\": self.SCOPES,\n            \"lifetime\": \"3600s\",\n        }\n        # Initialize mock request to handle token exchange and service account\n        # impersonation request.\n        request = self.make_mock_request(\n            status=http_client.OK,\n            data=token_response,\n            impersonation_status=http_client.OK,\n            impersonation_data=impersonation_response,\n        )\n        # Initialize credentials with service account impersonation and basic auth.\n        credentials = self.make_credentials(\n            client_id=CLIENT_ID,\n            client_secret=CLIENT_SECRET,\n            service_account_impersonation_url=self.SERVICE_ACCOUNT_IMPERSONATION_URL,\n            scopes=self.SCOPES,\n            # Default scopes will be ignored since user scopes are specified.\n            default_scopes=[\"ignored\"],\n        )\n\n        credentials.refresh(request)\n\n        # Only 2 requests should be processed.\n        assert len(request.call_args_list) == 2\n        # Verify token exchange request parameters.\n        self.assert_token_request_kwargs(\n            request.call_args_list[0][1], token_headers, token_request_data\n        )\n        # Verify service account impersonation request parameters.\n        self.assert_impersonation_request_kwargs(\n            request.call_args_list[1][1],\n            impersonation_headers,\n            impersonation_request_data,\n        )\n        assert credentials.valid\n        assert credentials.expiry == expected_expiry\n        assert not credentials.expired\n        assert credentials.token == impersonation_response[\"accessToken\"]\n\n    @mock.patch(\n        \"google.auth.metrics.token_request_access_token_impersonate\",\n        return_value=IMPERSONATE_ACCESS_TOKEN_REQUEST_METRICS_HEADER_VALUE,\n    )\n    @mock.patch(\n        \"google.auth.metrics.python_and_auth_lib_version\",\n        return_value=LANG_LIBRARY_METRICS_HEADER_VALUE,\n    )\n    def test_refresh_impersonation_with_client_auth_success_use_default_scopes(\n        self, mock_metrics_header_value, mock_auth_lib_value\n    ):\n        # Simulate service account access token expires in 2800 seconds.\n        expire_time = (\n            _helpers.utcnow().replace(microsecond=0) + datetime.timedelta(seconds=2800)\n        ).isoformat(\"T\") + \"Z\"\n        expected_expiry = datetime.datetime.strptime(expire_time, \"%Y-%m-%dT%H:%M:%SZ\")\n        # STS token exchange request/response.\n        token_response = self.SUCCESS_RESPONSE.copy()\n        token_headers = {\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n            \"Authorization\": \"Basic {}\".format(BASIC_AUTH_ENCODING),\n            \"x-goog-api-client\": \"gl-python/3.7 auth/1.1 google-byoid-sdk sa-impersonation/true config-lifetime/false\",\n        }\n        token_request_data = {\n            \"grant_type\": \"urn:ietf:params:oauth:grant-type:token-exchange\",\n            \"audience\": self.AUDIENCE,\n            \"requested_token_type\": \"urn:ietf:params:oauth:token-type:access_token\",\n            \"subject_token\": \"subject_token_0\",\n            \"subject_token_type\": self.SUBJECT_TOKEN_TYPE,\n            \"scope\": \"https://www.googleapis.com/auth/iam\",\n        }\n        # Service account impersonation request/response.\n        impersonation_response = {\n            \"accessToken\": \"SA_ACCESS_TOKEN\",\n            \"expireTime\": expire_time,\n        }\n        impersonation_headers = {\n            \"Content-Type\": \"application/json\",\n            \"authorization\": \"Bearer {}\".format(token_response[\"access_token\"]),\n            \"x-goog-api-client\": IMPERSONATE_ACCESS_TOKEN_REQUEST_METRICS_HEADER_VALUE,\n            \"x-allowed-locations\": \"0x0\",\n        }\n        impersonation_request_data = {\n            \"delegates\": None,\n            \"scope\": self.SCOPES,\n            \"lifetime\": \"3600s\",\n        }\n        # Initialize mock request to handle token exchange and service account\n        # impersonation request.\n        request = self.make_mock_request(\n            status=http_client.OK,\n            data=token_response,\n            impersonation_status=http_client.OK,\n            impersonation_data=impersonation_response,\n        )\n        # Initialize credentials with service account impersonation and basic auth.\n        credentials = self.make_credentials(\n            client_id=CLIENT_ID,\n            client_secret=CLIENT_SECRET,\n            service_account_impersonation_url=self.SERVICE_ACCOUNT_IMPERSONATION_URL,\n            scopes=None,\n            # Default scopes will be used since user specified scopes are none.\n            default_scopes=self.SCOPES,\n        )\n\n        credentials.refresh(request)\n\n        # Only 2 requests should be processed.\n        assert len(request.call_args_list) == 2\n        # Verify token exchange request parameters.\n        self.assert_token_request_kwargs(\n            request.call_args_list[0][1], token_headers, token_request_data\n        )\n        # Verify service account impersonation request parameters.\n        self.assert_impersonation_request_kwargs(\n            request.call_args_list[1][1],\n            impersonation_headers,\n            impersonation_request_data,\n        )\n        assert credentials.valid\n        assert credentials.expiry == expected_expiry\n        assert not credentials.expired\n        assert credentials.token == impersonation_response[\"accessToken\"]\n\n    def test_apply_without_quota_project_id(self):\n        headers = {}\n        request = self.make_mock_request(\n            status=http_client.OK, data=self.SUCCESS_RESPONSE\n        )\n        credentials = self.make_credentials()\n\n        credentials.refresh(request)\n        credentials.apply(headers)\n\n        assert headers == {\n            \"authorization\": \"Bearer {}\".format(self.SUCCESS_RESPONSE[\"access_token\"]),\n            \"x-allowed-locations\": \"0x0\",\n        }\n\n    def test_apply_workforce_without_quota_project_id(self):\n        headers = {}\n        request = self.make_mock_request(\n            status=http_client.OK, data=self.SUCCESS_RESPONSE\n        )\n        credentials = self.make_workforce_pool_credentials(\n            workforce_pool_user_project=self.WORKFORCE_POOL_USER_PROJECT\n        )\n\n        credentials.refresh(request)\n        credentials.apply(headers)\n\n        assert headers == {\n            \"authorization\": \"Bearer {}\".format(self.SUCCESS_RESPONSE[\"access_token\"]),\n            \"x-allowed-locations\": \"0x0\",\n        }\n\n    def test_apply_impersonation_without_quota_project_id(self):\n        expire_time = (\n            _helpers.utcnow().replace(microsecond=0) + datetime.timedelta(seconds=3600)\n        ).isoformat(\"T\") + \"Z\"\n        # Service account impersonation response.\n        impersonation_response = {\n            \"accessToken\": \"SA_ACCESS_TOKEN\",\n            \"expireTime\": expire_time,\n        }\n        # Initialize mock request to handle token exchange and service account\n        # impersonation request.\n        request = self.make_mock_request(\n            status=http_client.OK,\n            data=self.SUCCESS_RESPONSE.copy(),\n            impersonation_status=http_client.OK,\n            impersonation_data=impersonation_response,\n        )\n        # Initialize credentials with service account impersonation.\n        credentials = self.make_credentials(\n            service_account_impersonation_url=self.SERVICE_ACCOUNT_IMPERSONATION_URL,\n            scopes=self.SCOPES,\n        )\n        headers = {}\n\n        credentials.refresh(request)\n        credentials.apply(headers)\n\n        assert headers == {\n            \"authorization\": \"Bearer {}\".format(impersonation_response[\"accessToken\"]),\n            \"x-allowed-locations\": \"0x0\",\n        }\n\n    def test_apply_with_quota_project_id(self):\n        headers = {\"other\": \"header-value\"}\n        request = self.make_mock_request(\n            status=http_client.OK, data=self.SUCCESS_RESPONSE\n        )\n        credentials = self.make_credentials(quota_project_id=self.QUOTA_PROJECT_ID)\n\n        credentials.refresh(request)\n        credentials.apply(headers)\n\n        assert headers == {\n            \"other\": \"header-value\",\n            \"authorization\": \"Bearer {}\".format(self.SUCCESS_RESPONSE[\"access_token\"]),\n            \"x-goog-user-project\": self.QUOTA_PROJECT_ID,\n            \"x-allowed-locations\": \"0x0\",\n        }\n\n    def test_apply_impersonation_with_quota_project_id(self):\n        expire_time = (\n            _helpers.utcnow().replace(microsecond=0) + datetime.timedelta(seconds=3600)\n        ).isoformat(\"T\") + \"Z\"\n        # Service account impersonation response.\n        impersonation_response = {\n            \"accessToken\": \"SA_ACCESS_TOKEN\",\n            \"expireTime\": expire_time,\n        }\n        # Initialize mock request to handle token exchange and service account\n        # impersonation request.\n        request = self.make_mock_request(\n            status=http_client.OK,\n            data=self.SUCCESS_RESPONSE.copy(),\n            impersonation_status=http_client.OK,\n            impersonation_data=impersonation_response,\n        )\n        # Initialize credentials with service account impersonation.\n        credentials = self.make_credentials(\n            service_account_impersonation_url=self.SERVICE_ACCOUNT_IMPERSONATION_URL,\n            scopes=self.SCOPES,\n            quota_project_id=self.QUOTA_PROJECT_ID,\n        )\n        headers = {\"other\": \"header-value\"}\n\n        credentials.refresh(request)\n        credentials.apply(headers)\n\n        assert headers == {\n            \"other\": \"header-value\",\n            \"authorization\": \"Bearer {}\".format(impersonation_response[\"accessToken\"]),\n            \"x-goog-user-project\": self.QUOTA_PROJECT_ID,\n            \"x-allowed-locations\": \"0x0\",\n        }\n\n    def test_before_request(self):\n        headers = {\"other\": \"header-value\"}\n        request = self.make_mock_request(\n            status=http_client.OK, data=self.SUCCESS_RESPONSE\n        )\n        credentials = self.make_credentials()\n\n        # First call should call refresh, setting the token.\n        credentials.before_request(request, \"POST\", \"https://example.com/api\", headers)\n\n        assert headers == {\n            \"other\": \"header-value\",\n            \"authorization\": \"Bearer {}\".format(self.SUCCESS_RESPONSE[\"access_token\"]),\n            \"x-allowed-locations\": \"0x0\",\n        }\n\n        # Second call shouldn't call refresh.\n        credentials.before_request(request, \"POST\", \"https://example.com/api\", headers)\n\n        assert headers == {\n            \"other\": \"header-value\",\n            \"authorization\": \"Bearer {}\".format(self.SUCCESS_RESPONSE[\"access_token\"]),\n            \"x-allowed-locations\": \"0x0\",\n        }\n\n    def test_before_request_workforce(self):\n        headers = {\"other\": \"header-value\"}\n        request = self.make_mock_request(\n            status=http_client.OK, data=self.SUCCESS_RESPONSE\n        )\n        credentials = self.make_workforce_pool_credentials(\n            workforce_pool_user_project=self.WORKFORCE_POOL_USER_PROJECT\n        )\n\n        # First call should call refresh, setting the token.\n        credentials.before_request(request, \"POST\", \"https://example.com/api\", headers)\n\n        assert headers == {\n            \"other\": \"header-value\",\n            \"authorization\": \"Bearer {}\".format(self.SUCCESS_RESPONSE[\"access_token\"]),\n            \"x-allowed-locations\": \"0x0\",\n        }\n\n        # Second call shouldn't call refresh.\n        credentials.before_request(request, \"POST\", \"https://example.com/api\", headers)\n\n        assert headers == {\n            \"other\": \"header-value\",\n            \"authorization\": \"Bearer {}\".format(self.SUCCESS_RESPONSE[\"access_token\"]),\n            \"x-allowed-locations\": \"0x0\",\n        }\n\n    def test_before_request_impersonation(self):\n        expire_time = (\n            _helpers.utcnow().replace(microsecond=0) + datetime.timedelta(seconds=3600)\n        ).isoformat(\"T\") + \"Z\"\n        # Service account impersonation response.\n        impersonation_response = {\n            \"accessToken\": \"SA_ACCESS_TOKEN\",\n            \"expireTime\": expire_time,\n        }\n        # Initialize mock request to handle token exchange and service account\n        # impersonation request.\n        request = self.make_mock_request(\n            status=http_client.OK,\n            data=self.SUCCESS_RESPONSE.copy(),\n            impersonation_status=http_client.OK,\n            impersonation_data=impersonation_response,\n        )\n        headers = {\"other\": \"header-value\"}\n        credentials = self.make_credentials(\n            service_account_impersonation_url=self.SERVICE_ACCOUNT_IMPERSONATION_URL\n        )\n\n        # First call should call refresh, setting the token.\n        credentials.before_request(request, \"POST\", \"https://example.com/api\", headers)\n\n        assert headers == {\n            \"other\": \"header-value\",\n            \"authorization\": \"Bearer {}\".format(impersonation_response[\"accessToken\"]),\n            \"x-allowed-locations\": \"0x0\",\n        }\n\n        # Second call shouldn't call refresh.\n        credentials.before_request(request, \"POST\", \"https://example.com/api\", headers)\n\n        assert headers == {\n            \"other\": \"header-value\",\n            \"authorization\": \"Bearer {}\".format(impersonation_response[\"accessToken\"]),\n            \"x-allowed-locations\": \"0x0\",\n        }\n\n    @mock.patch(\"google.auth._helpers.utcnow\")\n    def test_before_request_expired(self, utcnow):\n        headers = {}\n        request = self.make_mock_request(\n            status=http_client.OK, data=self.SUCCESS_RESPONSE\n        )\n        credentials = self.make_credentials()\n        credentials.token = \"token\"\n        utcnow.return_value = datetime.datetime.min\n        # Set the expiration to one second more than now plus the clock skew\n        # accomodation. These credentials should be valid.\n        credentials.expiry = (\n            datetime.datetime.min\n            + _helpers.REFRESH_THRESHOLD\n            + datetime.timedelta(seconds=1)\n        )\n\n        assert credentials.valid\n        assert not credentials.expired\n        assert credentials.token_state == TokenState.FRESH\n\n        credentials.before_request(request, \"POST\", \"https://example.com/api\", headers)\n\n        # Cached token should be used.\n        assert headers == {\n            \"authorization\": \"Bearer token\",\n            \"x-allowed-locations\": \"0x0\",\n        }\n\n        # Next call should simulate 1 second passed.\n        utcnow.return_value = datetime.datetime.min + datetime.timedelta(seconds=1)\n\n        assert not credentials.valid\n        assert credentials.expired\n        assert credentials.token_state == TokenState.STALE\n\n        credentials.before_request(request, \"POST\", \"https://example.com/api\", headers)\n        assert credentials.token_state == TokenState.FRESH\n\n        # New token should be retrieved.\n        assert headers == {\n            \"authorization\": \"Bearer {}\".format(self.SUCCESS_RESPONSE[\"access_token\"]),\n            \"x-allowed-locations\": \"0x0\",\n        }\n\n    @mock.patch(\"google.auth._helpers.utcnow\")\n    def test_before_request_impersonation_expired(self, utcnow):\n        headers = {}\n        expire_time = (\n            datetime.datetime.min + datetime.timedelta(seconds=3601)\n        ).isoformat(\"T\") + \"Z\"\n        # Service account impersonation response.\n        impersonation_response = {\n            \"accessToken\": \"SA_ACCESS_TOKEN\",\n            \"expireTime\": expire_time,\n        }\n        # Initialize mock request to handle token exchange and service account\n        # impersonation request.\n        request = self.make_mock_request(\n            status=http_client.OK,\n            data=self.SUCCESS_RESPONSE.copy(),\n            impersonation_status=http_client.OK,\n            impersonation_data=impersonation_response,\n        )\n        credentials = self.make_credentials(\n            service_account_impersonation_url=self.SERVICE_ACCOUNT_IMPERSONATION_URL\n        )\n        credentials.token = \"token\"\n        utcnow.return_value = datetime.datetime.min\n        # Set the expiration to one second more than now plus the clock skew\n        # accomodation. These credentials should be valid.\n        credentials.expiry = (\n            datetime.datetime.min\n            + _helpers.REFRESH_THRESHOLD\n            + datetime.timedelta(seconds=1)\n        )\n\n        assert credentials.valid\n        assert not credentials.expired\n        assert credentials.token_state == TokenState.FRESH\n\n        credentials.before_request(request, \"POST\", \"https://example.com/api\", headers)\n        assert credentials.token_state == TokenState.FRESH\n\n        # Cached token should be used.\n        assert headers == {\n            \"authorization\": \"Bearer token\",\n            \"x-allowed-locations\": \"0x0\",\n        }\n\n        # Next call should simulate 1 second passed. This will trigger the expiration\n        # threshold.\n        utcnow.return_value = datetime.datetime.min + datetime.timedelta(seconds=1)\n\n        assert not credentials.valid\n        assert credentials.expired\n        assert credentials.token_state == TokenState.STALE\n\n        credentials.before_request(request, \"POST\", \"https://example.com/api\", headers)\n        assert credentials.token_state == TokenState.FRESH\n\n        credentials.before_request(request, \"POST\", \"https://example.com/api\", headers)\n\n        # New token should be retrieved.\n        assert headers == {\n            \"authorization\": \"Bearer {}\".format(impersonation_response[\"accessToken\"]),\n            \"x-allowed-locations\": \"0x0\",\n        }\n\n    @pytest.mark.parametrize(\n        \"audience\",\n        [\n            # Legacy K8s audience format.\n            \"identitynamespace:1f12345:my_provider\",\n            # Unrealistic audiences.\n            \"//iam.googleapis.com/projects\",\n            \"//iam.googleapis.com/projects/\",\n            \"//iam.googleapis.com/project/123456\",\n            \"//iam.googleapis.com/projects//123456\",\n            \"//iam.googleapis.com/prefix_projects/123456\",\n            \"//iam.googleapis.com/projects_suffix/123456\",\n        ],\n    )\n    def test_project_number_indeterminable(self, audience):\n        credentials = CredentialsImpl(\n            audience=audience,\n            subject_token_type=self.SUBJECT_TOKEN_TYPE,\n            token_url=self.TOKEN_URL,\n            credential_source=self.CREDENTIAL_SOURCE,\n        )\n\n        assert credentials.project_number is None\n        assert credentials.get_project_id(None) is None\n\n    def test_project_number_determinable(self):\n        credentials = CredentialsImpl(\n            audience=self.AUDIENCE,\n            subject_token_type=self.SUBJECT_TOKEN_TYPE,\n            token_url=self.TOKEN_URL,\n            credential_source=self.CREDENTIAL_SOURCE,\n        )\n\n        assert credentials.project_number == self.PROJECT_NUMBER\n\n    def test_project_number_workforce(self):\n        credentials = CredentialsImpl(\n            audience=self.WORKFORCE_AUDIENCE,\n            subject_token_type=self.WORKFORCE_SUBJECT_TOKEN_TYPE,\n            token_url=self.TOKEN_URL,\n            credential_source=self.CREDENTIAL_SOURCE,\n            workforce_pool_user_project=self.WORKFORCE_POOL_USER_PROJECT,\n        )\n\n        assert credentials.project_number is None\n\n    def test_project_id_without_scopes(self):\n        # Initialize credentials with no scopes.\n        credentials = CredentialsImpl(\n            audience=self.AUDIENCE,\n            subject_token_type=self.SUBJECT_TOKEN_TYPE,\n            token_url=self.TOKEN_URL,\n            credential_source=self.CREDENTIAL_SOURCE,\n        )\n\n        assert credentials.get_project_id(None) is None\n\n    @mock.patch(\n        \"google.auth.metrics.token_request_access_token_impersonate\",\n        return_value=IMPERSONATE_ACCESS_TOKEN_REQUEST_METRICS_HEADER_VALUE,\n    )\n    @mock.patch(\n        \"google.auth.metrics.python_and_auth_lib_version\",\n        return_value=LANG_LIBRARY_METRICS_HEADER_VALUE,\n    )\n    def test_get_project_id_cloud_resource_manager_success(\n        self, mock_metrics_header_value, mock_auth_lib_value\n    ):\n        # STS token exchange request/response.\n        token_response = self.SUCCESS_RESPONSE.copy()\n        token_headers = {\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n            \"x-goog-api-client\": \"gl-python/3.7 auth/1.1 google-byoid-sdk sa-impersonation/true config-lifetime/false\",\n        }\n        token_request_data = {\n            \"grant_type\": \"urn:ietf:params:oauth:grant-type:token-exchange\",\n            \"audience\": self.AUDIENCE,\n            \"requested_token_type\": \"urn:ietf:params:oauth:token-type:access_token\",\n            \"subject_token\": \"subject_token_0\",\n            \"subject_token_type\": self.SUBJECT_TOKEN_TYPE,\n            \"scope\": \"https://www.googleapis.com/auth/iam\",\n        }\n        # Service account impersonation request/response.\n        expire_time = (\n            _helpers.utcnow().replace(microsecond=0) + datetime.timedelta(seconds=3600)\n        ).isoformat(\"T\") + \"Z\"\n        expected_expiry = datetime.datetime.strptime(expire_time, \"%Y-%m-%dT%H:%M:%SZ\")\n        impersonation_response = {\n            \"accessToken\": \"SA_ACCESS_TOKEN\",\n            \"expireTime\": expire_time,\n        }\n        impersonation_headers = {\n            \"Content-Type\": \"application/json\",\n            \"x-goog-user-project\": self.QUOTA_PROJECT_ID,\n            \"authorization\": \"Bearer {}\".format(token_response[\"access_token\"]),\n            \"x-goog-api-client\": IMPERSONATE_ACCESS_TOKEN_REQUEST_METRICS_HEADER_VALUE,\n            \"x-allowed-locations\": \"0x0\",\n        }\n        impersonation_request_data = {\n            \"delegates\": None,\n            \"scope\": self.SCOPES,\n            \"lifetime\": \"3600s\",\n        }\n        # Initialize mock request to handle token exchange, service account\n        # impersonation and cloud resource manager request.\n        request = self.make_mock_request(\n            status=http_client.OK,\n            data=self.SUCCESS_RESPONSE.copy(),\n            impersonation_status=http_client.OK,\n            impersonation_data=impersonation_response,\n            cloud_resource_manager_status=http_client.OK,\n            cloud_resource_manager_data=self.CLOUD_RESOURCE_MANAGER_SUCCESS_RESPONSE,\n        )\n        credentials = self.make_credentials(\n            service_account_impersonation_url=self.SERVICE_ACCOUNT_IMPERSONATION_URL,\n            scopes=self.SCOPES,\n            quota_project_id=self.QUOTA_PROJECT_ID,\n        )\n\n        # Expected project ID from cloud resource manager response should be returned.\n        project_id = credentials.get_project_id(request)\n\n        assert project_id == self.PROJECT_ID\n        # 3 requests should be processed.\n        assert len(request.call_args_list) == 3\n        # Verify token exchange request parameters.\n        self.assert_token_request_kwargs(\n            request.call_args_list[0][1], token_headers, token_request_data\n        )\n        # Verify service account impersonation request parameters.\n        self.assert_impersonation_request_kwargs(\n            request.call_args_list[1][1],\n            impersonation_headers,\n            impersonation_request_data,\n        )\n        # In the process of getting project ID, an access token should be\n        # retrieved.\n        assert credentials.valid\n        assert credentials.expiry == expected_expiry\n        assert not credentials.expired\n        assert credentials.token == impersonation_response[\"accessToken\"]\n        # Verify cloud resource manager request parameters.\n        self.assert_resource_manager_request_kwargs(\n            request.call_args_list[2][1],\n            self.PROJECT_NUMBER,\n            {\n                \"x-goog-user-project\": self.QUOTA_PROJECT_ID,\n                \"authorization\": \"Bearer {}\".format(\n                    impersonation_response[\"accessToken\"]\n                ),\n                \"x-allowed-locations\": \"0x0\",\n            },\n        )\n\n        # Calling get_project_id again should return the cached project_id.\n        project_id = credentials.get_project_id(request)\n\n        assert project_id == self.PROJECT_ID\n        # No additional requests.\n        assert len(request.call_args_list) == 3\n\n    @mock.patch(\n        \"google.auth.metrics.python_and_auth_lib_version\",\n        return_value=LANG_LIBRARY_METRICS_HEADER_VALUE,\n    )\n    def test_workforce_pool_get_project_id_cloud_resource_manager_success(\n        self, mock_auth_lib_value\n    ):\n        # STS token exchange request/response.\n        token_headers = {\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n            \"x-goog-api-client\": \"gl-python/3.7 auth/1.1 google-byoid-sdk sa-impersonation/false config-lifetime/false\",\n        }\n        token_request_data = {\n            \"grant_type\": \"urn:ietf:params:oauth:grant-type:token-exchange\",\n            \"audience\": self.WORKFORCE_AUDIENCE,\n            \"requested_token_type\": \"urn:ietf:params:oauth:token-type:access_token\",\n            \"subject_token\": \"subject_token_0\",\n            \"subject_token_type\": self.WORKFORCE_SUBJECT_TOKEN_TYPE,\n            \"scope\": \"scope1 scope2\",\n            \"options\": urllib.parse.quote(\n                json.dumps({\"userProject\": self.WORKFORCE_POOL_USER_PROJECT})\n            ),\n        }\n        # Initialize mock request to handle token exchange and cloud resource\n        # manager request.\n        request = self.make_mock_request(\n            status=http_client.OK,\n            data=self.SUCCESS_RESPONSE.copy(),\n            cloud_resource_manager_status=http_client.OK,\n            cloud_resource_manager_data=self.CLOUD_RESOURCE_MANAGER_SUCCESS_RESPONSE,\n        )\n        credentials = self.make_workforce_pool_credentials(\n            scopes=self.SCOPES,\n            quota_project_id=self.QUOTA_PROJECT_ID,\n            workforce_pool_user_project=self.WORKFORCE_POOL_USER_PROJECT,\n        )\n\n        # Expected project ID from cloud resource manager response should be returned.\n        project_id = credentials.get_project_id(request)\n\n        assert project_id == self.PROJECT_ID\n        # 2 requests should be processed.\n        assert len(request.call_args_list) == 2\n        # Verify token exchange request parameters.\n        self.assert_token_request_kwargs(\n            request.call_args_list[0][1], token_headers, token_request_data\n        )\n        # In the process of getting project ID, an access token should be\n        # retrieved.\n        assert credentials.valid\n        assert not credentials.expired\n        assert credentials.token == self.SUCCESS_RESPONSE[\"access_token\"]\n        # Verify cloud resource manager request parameters.\n        self.assert_resource_manager_request_kwargs(\n            request.call_args_list[1][1],\n            self.WORKFORCE_POOL_USER_PROJECT,\n            {\n                \"x-goog-user-project\": self.QUOTA_PROJECT_ID,\n                \"authorization\": \"Bearer {}\".format(\n                    self.SUCCESS_RESPONSE[\"access_token\"]\n                ),\n                \"x-allowed-locations\": \"0x0\",\n            },\n        )\n\n        # Calling get_project_id again should return the cached project_id.\n        project_id = credentials.get_project_id(request)\n\n        assert project_id == self.PROJECT_ID\n        # No additional requests.\n        assert len(request.call_args_list) == 2\n\n    @mock.patch(\n        \"google.auth.metrics.token_request_access_token_impersonate\",\n        return_value=IMPERSONATE_ACCESS_TOKEN_REQUEST_METRICS_HEADER_VALUE,\n    )\n    @mock.patch(\n        \"google.auth.metrics.python_and_auth_lib_version\",\n        return_value=LANG_LIBRARY_METRICS_HEADER_VALUE,\n    )\n    def test_refresh_impersonation_with_lifetime(\n        self, mock_metrics_header_value, mock_auth_lib_value\n    ):\n        # Simulate service account access token expires in 2800 seconds.\n        expire_time = (\n            _helpers.utcnow().replace(microsecond=0) + datetime.timedelta(seconds=2800)\n        ).isoformat(\"T\") + \"Z\"\n        expected_expiry = datetime.datetime.strptime(expire_time, \"%Y-%m-%dT%H:%M:%SZ\")\n        # STS token exchange request/response.\n        token_response = self.SUCCESS_RESPONSE.copy()\n        token_headers = {\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n            \"x-goog-api-client\": \"gl-python/3.7 auth/1.1 google-byoid-sdk sa-impersonation/true config-lifetime/true\",\n        }\n        token_request_data = {\n            \"grant_type\": \"urn:ietf:params:oauth:grant-type:token-exchange\",\n            \"audience\": self.AUDIENCE,\n            \"requested_token_type\": \"urn:ietf:params:oauth:token-type:access_token\",\n            \"subject_token\": \"subject_token_0\",\n            \"subject_token_type\": self.SUBJECT_TOKEN_TYPE,\n            \"scope\": \"https://www.googleapis.com/auth/iam\",\n        }\n        # Service account impersonation request/response.\n        impersonation_response = {\n            \"accessToken\": \"SA_ACCESS_TOKEN\",\n            \"expireTime\": expire_time,\n        }\n        impersonation_headers = {\n            \"Content-Type\": \"application/json\",\n            \"authorization\": \"Bearer {}\".format(token_response[\"access_token\"]),\n            \"x-goog-api-client\": IMPERSONATE_ACCESS_TOKEN_REQUEST_METRICS_HEADER_VALUE,\n            \"x-allowed-locations\": \"0x0\",\n        }\n        impersonation_request_data = {\n            \"delegates\": None,\n            \"scope\": self.SCOPES,\n            \"lifetime\": \"2800s\",\n        }\n        # Initialize mock request to handle token exchange and service account\n        # impersonation request.\n        request = self.make_mock_request(\n            status=http_client.OK,\n            data=token_response,\n            impersonation_status=http_client.OK,\n            impersonation_data=impersonation_response,\n        )\n        # Initialize credentials with service account impersonation.\n        credentials = self.make_credentials(\n            service_account_impersonation_url=self.SERVICE_ACCOUNT_IMPERSONATION_URL,\n            service_account_impersonation_options={\"token_lifetime_seconds\": 2800},\n            scopes=self.SCOPES,\n        )\n\n        credentials.refresh(request)\n\n        # Only 2 requests should be processed.\n        assert len(request.call_args_list) == 2\n        # Verify token exchange request parameters.\n        self.assert_token_request_kwargs(\n            request.call_args_list[0][1], token_headers, token_request_data\n        )\n        # Verify service account impersonation request parameters.\n        self.assert_impersonation_request_kwargs(\n            request.call_args_list[1][1],\n            impersonation_headers,\n            impersonation_request_data,\n        )\n        assert credentials.valid\n        assert credentials.expiry == expected_expiry\n        assert not credentials.expired\n        assert credentials.token == impersonation_response[\"accessToken\"]\n\n    def test_get_project_id_cloud_resource_manager_error(self):\n        # Simulate resource doesn't have sufficient permissions to access\n        # cloud resource manager.\n        request = self.make_mock_request(\n            status=http_client.OK,\n            data=self.SUCCESS_RESPONSE.copy(),\n            cloud_resource_manager_status=http_client.UNAUTHORIZED,\n        )\n        credentials = self.make_credentials(scopes=self.SCOPES)\n\n        project_id = credentials.get_project_id(request)\n\n        assert project_id is None\n        # Only 2 requests to STS and cloud resource manager should be sent.\n        assert len(request.call_args_list) == 2\n\n\ndef test_supplier_context():\n    context = external_account.SupplierContext(\"TestTokenType\", \"TestAudience\")\n\n    assert context.subject_token_type == \"TestTokenType\"\n    assert context.audience == \"TestAudience\"\n", "tests/test_external_account_authorized_user.py": "# Copyright 2022 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport datetime\nimport http.client as http_client\nimport json\n\nimport mock\nimport pytest  # type: ignore\n\nfrom google.auth import exceptions\nfrom google.auth import external_account_authorized_user\nfrom google.auth import transport\nfrom google.auth.credentials import DEFAULT_UNIVERSE_DOMAIN\n\nTOKEN_URL = \"https://sts.googleapis.com/v1/token\"\nTOKEN_INFO_URL = \"https://sts.googleapis.com/v1/introspect\"\nREVOKE_URL = \"https://sts.googleapis.com/v1/revoke\"\nPROJECT_NUMBER = \"123456\"\nQUOTA_PROJECT_ID = \"654321\"\nPOOL_ID = \"POOL_ID\"\nPROVIDER_ID = \"PROVIDER_ID\"\nAUDIENCE = (\n    \"//iam.googleapis.com/projects/{}\"\n    \"/locations/global/workloadIdentityPools/{}\"\n    \"/providers/{}\"\n).format(PROJECT_NUMBER, POOL_ID, PROVIDER_ID)\nREFRESH_TOKEN = \"REFRESH_TOKEN\"\nNEW_REFRESH_TOKEN = \"NEW_REFRESH_TOKEN\"\nACCESS_TOKEN = \"ACCESS_TOKEN\"\nCLIENT_ID = \"username\"\nCLIENT_SECRET = \"password\"\n# Base64 encoding of \"username:password\".\nBASIC_AUTH_ENCODING = \"dXNlcm5hbWU6cGFzc3dvcmQ=\"\nSCOPES = [\"email\", \"profile\"]\nNOW = datetime.datetime(1990, 8, 27, 6, 54, 30)\nFAKE_UNIVERSE_DOMAIN = \"fake-universe-domain\"\n\n\nclass TestCredentials(object):\n    @classmethod\n    def make_credentials(\n        cls,\n        audience=AUDIENCE,\n        refresh_token=REFRESH_TOKEN,\n        token_url=TOKEN_URL,\n        token_info_url=TOKEN_INFO_URL,\n        client_id=CLIENT_ID,\n        client_secret=CLIENT_SECRET,\n        **kwargs\n    ):\n        return external_account_authorized_user.Credentials(\n            audience=audience,\n            refresh_token=refresh_token,\n            token_url=token_url,\n            token_info_url=token_info_url,\n            client_id=client_id,\n            client_secret=client_secret,\n            **kwargs\n        )\n\n    @classmethod\n    def make_mock_request(cls, status=http_client.OK, data=None):\n        # STS token exchange request.\n        token_response = mock.create_autospec(transport.Response, instance=True)\n        token_response.status = status\n        token_response.data = json.dumps(data).encode(\"utf-8\")\n        responses = [token_response]\n\n        request = mock.create_autospec(transport.Request)\n        request.side_effect = responses\n\n        return request\n\n    def test_default_state(self):\n        creds = self.make_credentials()\n\n        assert not creds.expiry\n        assert not creds.expired\n        assert not creds.token\n        assert not creds.valid\n        assert not creds.requires_scopes\n        assert not creds.scopes\n        assert not creds.revoke_url\n        assert creds.token_info_url\n        assert creds.client_id\n        assert creds.client_secret\n        assert creds.is_user\n        assert creds.refresh_token == REFRESH_TOKEN\n        assert creds.audience == AUDIENCE\n        assert creds.token_url == TOKEN_URL\n        assert creds.universe_domain == DEFAULT_UNIVERSE_DOMAIN\n\n    def test_basic_create(self):\n        creds = external_account_authorized_user.Credentials(\n            token=ACCESS_TOKEN,\n            expiry=datetime.datetime.max,\n            scopes=SCOPES,\n            revoke_url=REVOKE_URL,\n            universe_domain=FAKE_UNIVERSE_DOMAIN,\n        )\n\n        assert creds.expiry == datetime.datetime.max\n        assert not creds.expired\n        assert creds.token == ACCESS_TOKEN\n        assert creds.valid\n        assert not creds.requires_scopes\n        assert creds.scopes == SCOPES\n        assert creds.is_user\n        assert creds.revoke_url == REVOKE_URL\n        assert creds.universe_domain == FAKE_UNIVERSE_DOMAIN\n\n    def test_stunted_create_no_refresh_token(self):\n        with pytest.raises(ValueError) as excinfo:\n            self.make_credentials(token=None, refresh_token=None)\n\n        assert excinfo.match(\n            r\"Token should be created with fields to make it valid \\(`token` and \"\n            r\"`expiry`\\), or fields to allow it to refresh \\(`refresh_token`, \"\n            r\"`token_url`, `client_id`, `client_secret`\\)\\.\"\n        )\n\n    def test_stunted_create_no_token_url(self):\n        with pytest.raises(ValueError) as excinfo:\n            self.make_credentials(token=None, token_url=None)\n\n        assert excinfo.match(\n            r\"Token should be created with fields to make it valid \\(`token` and \"\n            r\"`expiry`\\), or fields to allow it to refresh \\(`refresh_token`, \"\n            r\"`token_url`, `client_id`, `client_secret`\\)\\.\"\n        )\n\n    def test_stunted_create_no_client_id(self):\n        with pytest.raises(ValueError) as excinfo:\n            self.make_credentials(token=None, client_id=None)\n\n        assert excinfo.match(\n            r\"Token should be created with fields to make it valid \\(`token` and \"\n            r\"`expiry`\\), or fields to allow it to refresh \\(`refresh_token`, \"\n            r\"`token_url`, `client_id`, `client_secret`\\)\\.\"\n        )\n\n    def test_stunted_create_no_client_secret(self):\n        with pytest.raises(ValueError) as excinfo:\n            self.make_credentials(token=None, client_secret=None)\n\n        assert excinfo.match(\n            r\"Token should be created with fields to make it valid \\(`token` and \"\n            r\"`expiry`\\), or fields to allow it to refresh \\(`refresh_token`, \"\n            r\"`token_url`, `client_id`, `client_secret`\\)\\.\"\n        )\n\n    @mock.patch(\"google.auth._helpers.utcnow\", return_value=NOW)\n    def test_refresh_auth_success(self, utcnow):\n        request = self.make_mock_request(\n            status=http_client.OK,\n            data={\"access_token\": ACCESS_TOKEN, \"expires_in\": 3600},\n        )\n        creds = self.make_credentials()\n\n        creds.refresh(request)\n\n        assert creds.expiry == utcnow() + datetime.timedelta(seconds=3600)\n        assert not creds.expired\n        assert creds.token == ACCESS_TOKEN\n        assert creds.valid\n        assert not creds.requires_scopes\n        assert creds.is_user\n        assert creds._refresh_token == REFRESH_TOKEN\n\n        request.assert_called_once_with(\n            url=TOKEN_URL,\n            method=\"POST\",\n            headers={\n                \"Content-Type\": \"application/x-www-form-urlencoded\",\n                \"Authorization\": \"Basic \" + BASIC_AUTH_ENCODING,\n            },\n            body=(\"grant_type=refresh_token&refresh_token=\" + REFRESH_TOKEN).encode(\n                \"UTF-8\"\n            ),\n        )\n\n    @mock.patch(\"google.auth._helpers.utcnow\", return_value=NOW)\n    def test_refresh_auth_success_new_refresh_token(self, utcnow):\n        request = self.make_mock_request(\n            status=http_client.OK,\n            data={\n                \"access_token\": ACCESS_TOKEN,\n                \"expires_in\": 3600,\n                \"refresh_token\": NEW_REFRESH_TOKEN,\n            },\n        )\n        creds = self.make_credentials()\n\n        creds.refresh(request)\n\n        assert creds.expiry == utcnow() + datetime.timedelta(seconds=3600)\n        assert not creds.expired\n        assert creds.token == ACCESS_TOKEN\n        assert creds.valid\n        assert not creds.requires_scopes\n        assert creds.is_user\n        assert creds._refresh_token == NEW_REFRESH_TOKEN\n\n        request.assert_called_once_with(\n            url=TOKEN_URL,\n            method=\"POST\",\n            headers={\n                \"Content-Type\": \"application/x-www-form-urlencoded\",\n                \"Authorization\": \"Basic \" + BASIC_AUTH_ENCODING,\n            },\n            body=(\"grant_type=refresh_token&refresh_token=\" + REFRESH_TOKEN).encode(\n                \"UTF-8\"\n            ),\n        )\n\n    def test_refresh_auth_failure(self):\n        request = self.make_mock_request(\n            status=http_client.BAD_REQUEST,\n            data={\n                \"error\": \"invalid_request\",\n                \"error_description\": \"Invalid subject token\",\n                \"error_uri\": \"https://tools.ietf.org/html/rfc6749\",\n            },\n        )\n        creds = self.make_credentials()\n\n        with pytest.raises(exceptions.OAuthError) as excinfo:\n            creds.refresh(request)\n\n        assert excinfo.match(\n            r\"Error code invalid_request: Invalid subject token - https://tools.ietf.org/html/rfc6749\"\n        )\n\n        assert not creds.expiry\n        assert not creds.expired\n        assert not creds.token\n        assert not creds.valid\n        assert not creds.requires_scopes\n        assert creds.is_user\n\n        request.assert_called_once_with(\n            url=TOKEN_URL,\n            method=\"POST\",\n            headers={\n                \"Content-Type\": \"application/x-www-form-urlencoded\",\n                \"Authorization\": \"Basic \" + BASIC_AUTH_ENCODING,\n            },\n            body=(\"grant_type=refresh_token&refresh_token=\" + REFRESH_TOKEN).encode(\n                \"UTF-8\"\n            ),\n        )\n\n    def test_refresh_without_refresh_token(self):\n        request = self.make_mock_request()\n        creds = self.make_credentials(refresh_token=None, token=ACCESS_TOKEN)\n\n        with pytest.raises(exceptions.RefreshError) as excinfo:\n            creds.refresh(request)\n\n        assert excinfo.match(\n            r\"The credentials do not contain the necessary fields need to refresh the access token. You must specify refresh_token, token_url, client_id, and client_secret.\"\n        )\n\n        assert not creds.expiry\n        assert not creds.expired\n        assert not creds.requires_scopes\n        assert creds.is_user\n\n        request.assert_not_called()\n\n    def test_refresh_without_token_url(self):\n        request = self.make_mock_request()\n        creds = self.make_credentials(token_url=None, token=ACCESS_TOKEN)\n\n        with pytest.raises(exceptions.RefreshError) as excinfo:\n            creds.refresh(request)\n\n        assert excinfo.match(\n            r\"The credentials do not contain the necessary fields need to refresh the access token. You must specify refresh_token, token_url, client_id, and client_secret.\"\n        )\n\n        assert not creds.expiry\n        assert not creds.expired\n        assert not creds.requires_scopes\n        assert creds.is_user\n\n        request.assert_not_called()\n\n    def test_refresh_without_client_id(self):\n        request = self.make_mock_request()\n        creds = self.make_credentials(client_id=None, token=ACCESS_TOKEN)\n\n        with pytest.raises(exceptions.RefreshError) as excinfo:\n            creds.refresh(request)\n\n        assert excinfo.match(\n            r\"The credentials do not contain the necessary fields need to refresh the access token. You must specify refresh_token, token_url, client_id, and client_secret.\"\n        )\n\n        assert not creds.expiry\n        assert not creds.expired\n        assert not creds.requires_scopes\n        assert creds.is_user\n\n        request.assert_not_called()\n\n    def test_refresh_without_client_secret(self):\n        request = self.make_mock_request()\n        creds = self.make_credentials(client_secret=None, token=ACCESS_TOKEN)\n\n        with pytest.raises(exceptions.RefreshError) as excinfo:\n            creds.refresh(request)\n\n        assert excinfo.match(\n            r\"The credentials do not contain the necessary fields need to refresh the access token. You must specify refresh_token, token_url, client_id, and client_secret.\"\n        )\n\n        assert not creds.expiry\n        assert not creds.expired\n        assert not creds.requires_scopes\n        assert creds.is_user\n\n        request.assert_not_called()\n\n    def test_info(self):\n        creds = self.make_credentials()\n        info = creds.info\n\n        assert info[\"audience\"] == AUDIENCE\n        assert info[\"refresh_token\"] == REFRESH_TOKEN\n        assert info[\"token_url\"] == TOKEN_URL\n        assert info[\"token_info_url\"] == TOKEN_INFO_URL\n        assert info[\"client_id\"] == CLIENT_ID\n        assert info[\"client_secret\"] == CLIENT_SECRET\n        assert info[\"universe_domain\"] == DEFAULT_UNIVERSE_DOMAIN\n        assert \"token\" not in info\n        assert \"expiry\" not in info\n        assert \"revoke_url\" not in info\n        assert \"quota_project_id\" not in info\n\n    def test_info_full(self):\n        creds = self.make_credentials(\n            token=ACCESS_TOKEN,\n            expiry=NOW,\n            revoke_url=REVOKE_URL,\n            quota_project_id=QUOTA_PROJECT_ID,\n            universe_domain=FAKE_UNIVERSE_DOMAIN,\n        )\n        info = creds.info\n\n        assert info[\"audience\"] == AUDIENCE\n        assert info[\"refresh_token\"] == REFRESH_TOKEN\n        assert info[\"token_url\"] == TOKEN_URL\n        assert info[\"token_info_url\"] == TOKEN_INFO_URL\n        assert info[\"client_id\"] == CLIENT_ID\n        assert info[\"client_secret\"] == CLIENT_SECRET\n        assert info[\"token\"] == ACCESS_TOKEN\n        assert info[\"expiry\"] == NOW.isoformat() + \"Z\"\n        assert info[\"revoke_url\"] == REVOKE_URL\n        assert info[\"quota_project_id\"] == QUOTA_PROJECT_ID\n        assert info[\"universe_domain\"] == FAKE_UNIVERSE_DOMAIN\n\n    def test_to_json(self):\n        creds = self.make_credentials()\n        json_info = creds.to_json()\n        info = json.loads(json_info)\n\n        assert info[\"audience\"] == AUDIENCE\n        assert info[\"refresh_token\"] == REFRESH_TOKEN\n        assert info[\"token_url\"] == TOKEN_URL\n        assert info[\"token_info_url\"] == TOKEN_INFO_URL\n        assert info[\"client_id\"] == CLIENT_ID\n        assert info[\"client_secret\"] == CLIENT_SECRET\n        assert info[\"universe_domain\"] == DEFAULT_UNIVERSE_DOMAIN\n        assert \"token\" not in info\n        assert \"expiry\" not in info\n        assert \"revoke_url\" not in info\n        assert \"quota_project_id\" not in info\n\n    def test_to_json_full(self):\n        creds = self.make_credentials(\n            token=ACCESS_TOKEN,\n            expiry=NOW,\n            revoke_url=REVOKE_URL,\n            quota_project_id=QUOTA_PROJECT_ID,\n            universe_domain=FAKE_UNIVERSE_DOMAIN,\n        )\n        json_info = creds.to_json()\n        info = json.loads(json_info)\n\n        assert info[\"audience\"] == AUDIENCE\n        assert info[\"refresh_token\"] == REFRESH_TOKEN\n        assert info[\"token_url\"] == TOKEN_URL\n        assert info[\"token_info_url\"] == TOKEN_INFO_URL\n        assert info[\"client_id\"] == CLIENT_ID\n        assert info[\"client_secret\"] == CLIENT_SECRET\n        assert info[\"token\"] == ACCESS_TOKEN\n        assert info[\"expiry\"] == NOW.isoformat() + \"Z\"\n        assert info[\"revoke_url\"] == REVOKE_URL\n        assert info[\"quota_project_id\"] == QUOTA_PROJECT_ID\n        assert info[\"universe_domain\"] == FAKE_UNIVERSE_DOMAIN\n\n    def test_to_json_full_with_strip(self):\n        creds = self.make_credentials(\n            token=ACCESS_TOKEN,\n            expiry=NOW,\n            revoke_url=REVOKE_URL,\n            quota_project_id=QUOTA_PROJECT_ID,\n        )\n        json_info = creds.to_json(strip=[\"token\", \"expiry\"])\n        info = json.loads(json_info)\n\n        assert info[\"audience\"] == AUDIENCE\n        assert info[\"refresh_token\"] == REFRESH_TOKEN\n        assert info[\"token_url\"] == TOKEN_URL\n        assert info[\"token_info_url\"] == TOKEN_INFO_URL\n        assert info[\"client_id\"] == CLIENT_ID\n        assert info[\"client_secret\"] == CLIENT_SECRET\n        assert \"token\" not in info\n        assert \"expiry\" not in info\n        assert info[\"revoke_url\"] == REVOKE_URL\n        assert info[\"quota_project_id\"] == QUOTA_PROJECT_ID\n\n    def test_get_project_id(self):\n        creds = self.make_credentials()\n        request = mock.create_autospec(transport.Request)\n\n        assert creds.get_project_id(request) is None\n        request.assert_not_called()\n\n    def test_with_quota_project(self):\n        creds = self.make_credentials(\n            token=ACCESS_TOKEN,\n            expiry=NOW,\n            revoke_url=REVOKE_URL,\n            quota_project_id=QUOTA_PROJECT_ID,\n        )\n        new_creds = creds.with_quota_project(QUOTA_PROJECT_ID)\n        assert new_creds._audience == creds._audience\n        assert new_creds._refresh_token == creds._refresh_token\n        assert new_creds._token_url == creds._token_url\n        assert new_creds._token_info_url == creds._token_info_url\n        assert new_creds._client_id == creds._client_id\n        assert new_creds._client_secret == creds._client_secret\n        assert new_creds.token == creds.token\n        assert new_creds.expiry == creds.expiry\n        assert new_creds._revoke_url == creds._revoke_url\n        assert new_creds._quota_project_id == QUOTA_PROJECT_ID\n\n    def test_with_token_uri(self):\n        creds = self.make_credentials(\n            token=ACCESS_TOKEN,\n            expiry=NOW,\n            revoke_url=REVOKE_URL,\n            quota_project_id=QUOTA_PROJECT_ID,\n        )\n        new_creds = creds.with_token_uri(\"https://google.com\")\n        assert new_creds._audience == creds._audience\n        assert new_creds._refresh_token == creds._refresh_token\n        assert new_creds._token_url == \"https://google.com\"\n        assert new_creds._token_info_url == creds._token_info_url\n        assert new_creds._client_id == creds._client_id\n        assert new_creds._client_secret == creds._client_secret\n        assert new_creds.token == creds.token\n        assert new_creds.expiry == creds.expiry\n        assert new_creds._revoke_url == creds._revoke_url\n        assert new_creds._quota_project_id == creds._quota_project_id\n\n    def test_with_universe_domain(self):\n        creds = self.make_credentials(\n            token=ACCESS_TOKEN,\n            expiry=NOW,\n            revoke_url=REVOKE_URL,\n            quota_project_id=QUOTA_PROJECT_ID,\n        )\n        new_creds = creds.with_universe_domain(FAKE_UNIVERSE_DOMAIN)\n        assert new_creds._audience == creds._audience\n        assert new_creds._refresh_token == creds._refresh_token\n        assert new_creds._token_url == creds._token_url\n        assert new_creds._token_info_url == creds._token_info_url\n        assert new_creds._client_id == creds._client_id\n        assert new_creds._client_secret == creds._client_secret\n        assert new_creds.token == creds.token\n        assert new_creds.expiry == creds.expiry\n        assert new_creds._revoke_url == creds._revoke_url\n        assert new_creds._quota_project_id == QUOTA_PROJECT_ID\n        assert new_creds.universe_domain == FAKE_UNIVERSE_DOMAIN\n\n    def test_from_file_required_options_only(self, tmpdir):\n        from_creds = self.make_credentials()\n        config_file = tmpdir.join(\"config.json\")\n        config_file.write(from_creds.to_json())\n        creds = external_account_authorized_user.Credentials.from_file(str(config_file))\n\n        assert isinstance(creds, external_account_authorized_user.Credentials)\n        assert creds.audience == AUDIENCE\n        assert creds.refresh_token == REFRESH_TOKEN\n        assert creds.token_url == TOKEN_URL\n        assert creds.token_info_url == TOKEN_INFO_URL\n        assert creds.client_id == CLIENT_ID\n        assert creds.client_secret == CLIENT_SECRET\n        assert creds.token is None\n        assert creds.expiry is None\n        assert creds.scopes is None\n        assert creds._revoke_url is None\n        assert creds._quota_project_id is None\n\n    def test_from_file_full_options(self, tmpdir):\n        from_creds = self.make_credentials(\n            token=ACCESS_TOKEN,\n            expiry=NOW,\n            revoke_url=REVOKE_URL,\n            quota_project_id=QUOTA_PROJECT_ID,\n            scopes=SCOPES,\n        )\n        config_file = tmpdir.join(\"config.json\")\n        config_file.write(from_creds.to_json())\n        creds = external_account_authorized_user.Credentials.from_file(str(config_file))\n\n        assert isinstance(creds, external_account_authorized_user.Credentials)\n        assert creds.audience == AUDIENCE\n        assert creds.refresh_token == REFRESH_TOKEN\n        assert creds.token_url == TOKEN_URL\n        assert creds.token_info_url == TOKEN_INFO_URL\n        assert creds.client_id == CLIENT_ID\n        assert creds.client_secret == CLIENT_SECRET\n        assert creds.token == ACCESS_TOKEN\n        assert creds.expiry == NOW\n        assert creds.scopes == SCOPES\n        assert creds._revoke_url == REVOKE_URL\n        assert creds._quota_project_id == QUOTA_PROJECT_ID\n", "tests/test_credentials.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport datetime\n\nimport mock\nimport pytest  # type: ignore\n\nfrom google.auth import _helpers\nfrom google.auth import credentials\n\n\nclass CredentialsImpl(credentials.Credentials):\n    def refresh(self, request):\n        self.token = request\n        self.expiry = (\n            datetime.datetime.utcnow()\n            + _helpers.REFRESH_THRESHOLD\n            + datetime.timedelta(seconds=5)\n        )\n\n    def with_quota_project(self, quota_project_id):\n        raise NotImplementedError()\n\n\nclass CredentialsImplWithMetrics(credentials.Credentials):\n    def refresh(self, request):\n        self.token = request\n\n    def _metric_header_for_usage(self):\n        return \"foo\"\n\n\ndef test_credentials_constructor():\n    credentials = CredentialsImpl()\n    assert not credentials.token\n    assert not credentials.expiry\n    assert not credentials.expired\n    assert not credentials.valid\n    assert credentials.universe_domain == \"googleapis.com\"\n    assert not credentials._use_non_blocking_refresh\n\n\ndef test_with_non_blocking_refresh():\n    c = CredentialsImpl()\n    c.with_non_blocking_refresh()\n    assert c._use_non_blocking_refresh\n\n\ndef test_expired_and_valid():\n    credentials = CredentialsImpl()\n    credentials.token = \"token\"\n\n    assert credentials.valid\n    assert not credentials.expired\n\n    # Set the expiration to one second more than now plus the clock skew\n    # accomodation. These credentials should be valid.\n    credentials.expiry = (\n        _helpers.utcnow() + _helpers.REFRESH_THRESHOLD + datetime.timedelta(seconds=1)\n    )\n\n    assert credentials.valid\n    assert not credentials.expired\n\n    # Set the credentials expiration to now. Because of the clock skew\n    # accomodation, these credentials should report as expired.\n    credentials.expiry = _helpers.utcnow()\n\n    assert not credentials.valid\n    assert credentials.expired\n\n\ndef test_before_request():\n    credentials = CredentialsImpl()\n    request = \"token\"\n    headers = {}\n\n    # First call should call refresh, setting the token.\n    credentials.before_request(request, \"http://example.com\", \"GET\", headers)\n    assert credentials.valid\n    assert credentials.token == \"token\"\n    assert headers[\"authorization\"] == \"Bearer token\"\n    assert \"x-allowed-locations\" not in headers\n\n    request = \"token2\"\n    headers = {}\n\n    # Second call shouldn't call refresh.\n    credentials.before_request(request, \"http://example.com\", \"GET\", headers)\n    assert credentials.valid\n    assert credentials.token == \"token\"\n    assert headers[\"authorization\"] == \"Bearer token\"\n    assert \"x-allowed-locations\" not in headers\n\n\ndef test_before_request_with_trust_boundary():\n    DUMMY_BOUNDARY = \"0xA30\"\n    credentials = CredentialsImpl()\n    credentials._trust_boundary = {\"locations\": [], \"encoded_locations\": DUMMY_BOUNDARY}\n    request = \"token\"\n    headers = {}\n\n    # First call should call refresh, setting the token.\n    credentials.before_request(request, \"http://example.com\", \"GET\", headers)\n    assert credentials.valid\n    assert credentials.token == \"token\"\n    assert headers[\"authorization\"] == \"Bearer token\"\n    assert headers[\"x-allowed-locations\"] == DUMMY_BOUNDARY\n\n    request = \"token2\"\n    headers = {}\n\n    # Second call shouldn't call refresh.\n    credentials.before_request(request, \"http://example.com\", \"GET\", headers)\n    assert credentials.valid\n    assert credentials.token == \"token\"\n    assert headers[\"authorization\"] == \"Bearer token\"\n    assert headers[\"x-allowed-locations\"] == DUMMY_BOUNDARY\n\n\ndef test_before_request_metrics():\n    credentials = CredentialsImplWithMetrics()\n    request = \"token\"\n    headers = {}\n\n    credentials.before_request(request, \"http://example.com\", \"GET\", headers)\n    assert headers[\"x-goog-api-client\"] == \"foo\"\n\n\ndef test_anonymous_credentials_ctor():\n    anon = credentials.AnonymousCredentials()\n    assert anon.token is None\n    assert anon.expiry is None\n    assert not anon.expired\n    assert anon.valid\n\n\ndef test_anonymous_credentials_refresh():\n    anon = credentials.AnonymousCredentials()\n    request = object()\n    with pytest.raises(ValueError):\n        anon.refresh(request)\n\n\ndef test_anonymous_credentials_apply_default():\n    anon = credentials.AnonymousCredentials()\n    headers = {}\n    anon.apply(headers)\n    assert headers == {}\n    with pytest.raises(ValueError):\n        anon.apply(headers, token=\"TOKEN\")\n\n\ndef test_anonymous_credentials_before_request():\n    anon = credentials.AnonymousCredentials()\n    request = object()\n    method = \"GET\"\n    url = \"https://example.com/api/endpoint\"\n    headers = {}\n    anon.before_request(request, method, url, headers)\n    assert headers == {}\n\n\nclass ReadOnlyScopedCredentialsImpl(credentials.ReadOnlyScoped, CredentialsImpl):\n    @property\n    def requires_scopes(self):\n        return super(ReadOnlyScopedCredentialsImpl, self).requires_scopes\n\n\ndef test_readonly_scoped_credentials_constructor():\n    credentials = ReadOnlyScopedCredentialsImpl()\n    assert credentials._scopes is None\n\n\ndef test_readonly_scoped_credentials_scopes():\n    credentials = ReadOnlyScopedCredentialsImpl()\n    credentials._scopes = [\"one\", \"two\"]\n    assert credentials.scopes == [\"one\", \"two\"]\n    assert credentials.has_scopes([\"one\"])\n    assert credentials.has_scopes([\"two\"])\n    assert credentials.has_scopes([\"one\", \"two\"])\n    assert not credentials.has_scopes([\"three\"])\n\n\ndef test_readonly_scoped_credentials_requires_scopes():\n    credentials = ReadOnlyScopedCredentialsImpl()\n    assert not credentials.requires_scopes\n\n\nclass RequiresScopedCredentialsImpl(credentials.Scoped, CredentialsImpl):\n    def __init__(self, scopes=None, default_scopes=None):\n        super(RequiresScopedCredentialsImpl, self).__init__()\n        self._scopes = scopes\n        self._default_scopes = default_scopes\n\n    @property\n    def requires_scopes(self):\n        return not self.scopes\n\n    def with_scopes(self, scopes, default_scopes=None):\n        return RequiresScopedCredentialsImpl(\n            scopes=scopes, default_scopes=default_scopes\n        )\n\n\ndef test_create_scoped_if_required_scoped():\n    unscoped_credentials = RequiresScopedCredentialsImpl()\n    scoped_credentials = credentials.with_scopes_if_required(\n        unscoped_credentials, [\"one\", \"two\"]\n    )\n\n    assert scoped_credentials is not unscoped_credentials\n    assert not scoped_credentials.requires_scopes\n    assert scoped_credentials.has_scopes([\"one\", \"two\"])\n\n\ndef test_create_scoped_if_required_not_scopes():\n    unscoped_credentials = CredentialsImpl()\n    scoped_credentials = credentials.with_scopes_if_required(\n        unscoped_credentials, [\"one\", \"two\"]\n    )\n\n    assert scoped_credentials is unscoped_credentials\n\n\ndef test_nonblocking_refresh_fresh_credentials():\n    c = CredentialsImpl()\n\n    c._refresh_worker = mock.MagicMock()\n\n    request = \"token\"\n\n    c.refresh(request)\n    assert c.token_state == credentials.TokenState.FRESH\n\n    c.with_non_blocking_refresh()\n    c.before_request(request, \"http://example.com\", \"GET\", {})\n\n\ndef test_nonblocking_refresh_invalid_credentials():\n    c = CredentialsImpl()\n    c.with_non_blocking_refresh()\n\n    request = \"token\"\n    headers = {}\n\n    assert c.token_state == credentials.TokenState.INVALID\n\n    c.before_request(request, \"http://example.com\", \"GET\", headers)\n    assert c.token_state == credentials.TokenState.FRESH\n    assert c.valid\n    assert c.token == \"token\"\n    assert headers[\"authorization\"] == \"Bearer token\"\n    assert \"x-identity-trust-boundary\" not in headers\n\n\ndef test_nonblocking_refresh_stale_credentials():\n    c = CredentialsImpl()\n    c.with_non_blocking_refresh()\n\n    request = \"token\"\n    headers = {}\n\n    # Invalid credentials MUST require a blocking refresh.\n    c.before_request(request, \"http://example.com\", \"GET\", headers)\n    assert c.token_state == credentials.TokenState.FRESH\n    assert not c._refresh_worker._worker\n\n    c.expiry = (\n        datetime.datetime.utcnow()\n        + _helpers.REFRESH_THRESHOLD\n        - datetime.timedelta(seconds=1)\n    )\n\n    # STALE credentials SHOULD spawn a non-blocking worker\n    assert c.token_state == credentials.TokenState.STALE\n    c.before_request(request, \"http://example.com\", \"GET\", headers)\n    assert c._refresh_worker._worker is not None\n\n    assert c.token_state == credentials.TokenState.FRESH\n    assert c.valid\n    assert c.token == \"token\"\n    assert headers[\"authorization\"] == \"Bearer token\"\n    assert \"x-identity-trust-boundary\" not in headers\n\n\ndef test_nonblocking_refresh_failed_credentials():\n    c = CredentialsImpl()\n    c.with_non_blocking_refresh()\n\n    request = \"token\"\n    headers = {}\n\n    # Invalid credentials MUST require a blocking refresh.\n    c.before_request(request, \"http://example.com\", \"GET\", headers)\n    assert c.token_state == credentials.TokenState.FRESH\n    assert not c._refresh_worker._worker\n\n    c.expiry = (\n        datetime.datetime.utcnow()\n        + _helpers.REFRESH_THRESHOLD\n        - datetime.timedelta(seconds=1)\n    )\n\n    # STALE credentials SHOULD spawn a non-blocking worker\n    assert c.token_state == credentials.TokenState.STALE\n    c._refresh_worker._worker = mock.MagicMock()\n    c._refresh_worker._worker._error_info = \"Some Error\"\n    c.before_request(request, \"http://example.com\", \"GET\", headers)\n    assert c._refresh_worker._worker is not None\n\n    assert c.token_state == credentials.TokenState.FRESH\n    assert c.valid\n    assert c.token == \"token\"\n    assert headers[\"authorization\"] == \"Bearer token\"\n    assert \"x-identity-trust-boundary\" not in headers\n\n\ndef test_token_state_no_expiry():\n    c = CredentialsImpl()\n\n    request = \"token\"\n    c.refresh(request)\n\n    c.expiry = None\n    assert c.token_state == credentials.TokenState.FRESH\n\n    c.before_request(request, \"http://example.com\", \"GET\", {})\n", "tests/test__default.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport json\nimport os\n\nimport mock\nimport pytest  # type: ignore\n\nfrom google.auth import _default\nfrom google.auth import api_key\nfrom google.auth import app_engine\nfrom google.auth import aws\nfrom google.auth import compute_engine\nfrom google.auth import credentials\nfrom google.auth import environment_vars\nfrom google.auth import exceptions\nfrom google.auth import external_account\nfrom google.auth import external_account_authorized_user\nfrom google.auth import identity_pool\nfrom google.auth import impersonated_credentials\nfrom google.auth import pluggable\nfrom google.oauth2 import gdch_credentials\nfrom google.oauth2 import service_account\nimport google.oauth2.credentials\n\n\nDATA_DIR = os.path.join(os.path.dirname(__file__), \"data\")\nAUTHORIZED_USER_FILE = os.path.join(DATA_DIR, \"authorized_user.json\")\n\nwith open(AUTHORIZED_USER_FILE) as fh:\n    AUTHORIZED_USER_FILE_DATA = json.load(fh)\n\nAUTHORIZED_USER_CLOUD_SDK_FILE = os.path.join(\n    DATA_DIR, \"authorized_user_cloud_sdk.json\"\n)\n\nAUTHORIZED_USER_CLOUD_SDK_WITH_QUOTA_PROJECT_ID_FILE = os.path.join(\n    DATA_DIR, \"authorized_user_cloud_sdk_with_quota_project_id.json\"\n)\n\nSERVICE_ACCOUNT_FILE = os.path.join(DATA_DIR, \"service_account.json\")\n\nCLIENT_SECRETS_FILE = os.path.join(DATA_DIR, \"client_secrets.json\")\n\nGDCH_SERVICE_ACCOUNT_FILE = os.path.join(DATA_DIR, \"gdch_service_account.json\")\n\nwith open(SERVICE_ACCOUNT_FILE) as fh:\n    SERVICE_ACCOUNT_FILE_DATA = json.load(fh)\n\nSUBJECT_TOKEN_TEXT_FILE = os.path.join(DATA_DIR, \"external_subject_token.txt\")\nTOKEN_URL = \"https://sts.googleapis.com/v1/token\"\nAUDIENCE = \"//iam.googleapis.com/projects/123456/locations/global/workloadIdentityPools/POOL_ID/providers/PROVIDER_ID\"\nWORKFORCE_AUDIENCE = (\n    \"//iam.googleapis.com/locations/global/workforcePools/POOL_ID/providers/PROVIDER_ID\"\n)\nWORKFORCE_POOL_USER_PROJECT = \"WORKFORCE_POOL_USER_PROJECT_NUMBER\"\nREGION_URL = \"http://169.254.169.254/latest/meta-data/placement/availability-zone\"\nSECURITY_CREDS_URL = \"http://169.254.169.254/latest/meta-data/iam/security-credentials\"\nCRED_VERIFICATION_URL = (\n    \"https://sts.{region}.amazonaws.com?Action=GetCallerIdentity&Version=2011-06-15\"\n)\nIDENTITY_POOL_DATA = {\n    \"type\": \"external_account\",\n    \"audience\": AUDIENCE,\n    \"subject_token_type\": \"urn:ietf:params:oauth:token-type:jwt\",\n    \"token_url\": TOKEN_URL,\n    \"credential_source\": {\"file\": SUBJECT_TOKEN_TEXT_FILE},\n}\nPLUGGABLE_DATA = {\n    \"type\": \"external_account\",\n    \"audience\": AUDIENCE,\n    \"subject_token_type\": \"urn:ietf:params:oauth:token-type:jwt\",\n    \"token_url\": TOKEN_URL,\n    \"credential_source\": {\"executable\": {\"command\": \"command\"}},\n}\nAWS_DATA = {\n    \"type\": \"external_account\",\n    \"audience\": AUDIENCE,\n    \"subject_token_type\": \"urn:ietf:params:aws:token-type:aws4_request\",\n    \"token_url\": TOKEN_URL,\n    \"credential_source\": {\n        \"environment_id\": \"aws1\",\n        \"region_url\": REGION_URL,\n        \"url\": SECURITY_CREDS_URL,\n        \"regional_cred_verification_url\": CRED_VERIFICATION_URL,\n    },\n}\nSERVICE_ACCOUNT_EMAIL = \"service-1234@service-name.iam.gserviceaccount.com\"\nSERVICE_ACCOUNT_IMPERSONATION_URL = (\n    \"https://us-east1-iamcredentials.googleapis.com/v1/projects/-\"\n    + \"/serviceAccounts/{}:generateAccessToken\".format(SERVICE_ACCOUNT_EMAIL)\n)\nIMPERSONATED_IDENTITY_POOL_DATA = {\n    \"type\": \"external_account\",\n    \"audience\": AUDIENCE,\n    \"subject_token_type\": \"urn:ietf:params:oauth:token-type:jwt\",\n    \"token_url\": TOKEN_URL,\n    \"credential_source\": {\"file\": SUBJECT_TOKEN_TEXT_FILE},\n    \"service_account_impersonation_url\": SERVICE_ACCOUNT_IMPERSONATION_URL,\n}\nIMPERSONATED_AWS_DATA = {\n    \"type\": \"external_account\",\n    \"audience\": AUDIENCE,\n    \"subject_token_type\": \"urn:ietf:params:aws:token-type:aws4_request\",\n    \"token_url\": TOKEN_URL,\n    \"credential_source\": {\n        \"environment_id\": \"aws1\",\n        \"region_url\": REGION_URL,\n        \"url\": SECURITY_CREDS_URL,\n        \"regional_cred_verification_url\": CRED_VERIFICATION_URL,\n    },\n    \"service_account_impersonation_url\": SERVICE_ACCOUNT_IMPERSONATION_URL,\n}\nIDENTITY_POOL_WORKFORCE_DATA = {\n    \"type\": \"external_account\",\n    \"audience\": WORKFORCE_AUDIENCE,\n    \"subject_token_type\": \"urn:ietf:params:oauth:token-type:id_token\",\n    \"token_url\": TOKEN_URL,\n    \"credential_source\": {\"file\": SUBJECT_TOKEN_TEXT_FILE},\n    \"workforce_pool_user_project\": WORKFORCE_POOL_USER_PROJECT,\n}\nIMPERSONATED_IDENTITY_POOL_WORKFORCE_DATA = {\n    \"type\": \"external_account\",\n    \"audience\": WORKFORCE_AUDIENCE,\n    \"subject_token_type\": \"urn:ietf:params:oauth:token-type:id_token\",\n    \"token_url\": TOKEN_URL,\n    \"credential_source\": {\"file\": SUBJECT_TOKEN_TEXT_FILE},\n    \"service_account_impersonation_url\": SERVICE_ACCOUNT_IMPERSONATION_URL,\n    \"workforce_pool_user_project\": WORKFORCE_POOL_USER_PROJECT,\n}\n\nIMPERSONATED_SERVICE_ACCOUNT_AUTHORIZED_USER_SOURCE_FILE = os.path.join(\n    DATA_DIR, \"impersonated_service_account_authorized_user_source.json\"\n)\n\nIMPERSONATED_SERVICE_ACCOUNT_WITH_QUOTA_PROJECT_FILE = os.path.join(\n    DATA_DIR, \"impersonated_service_account_with_quota_project.json\"\n)\n\nIMPERSONATED_SERVICE_ACCOUNT_SERVICE_ACCOUNT_SOURCE_FILE = os.path.join(\n    DATA_DIR, \"impersonated_service_account_service_account_source.json\"\n)\n\nEXTERNAL_ACCOUNT_AUTHORIZED_USER_FILE = os.path.join(\n    DATA_DIR, \"external_account_authorized_user.json\"\n)\n\nEXTERNAL_ACCOUNT_AUTHORIZED_USER_NON_GDU_FILE = os.path.join(\n    DATA_DIR, \"external_account_authorized_user_non_gdu.json\"\n)\n\nMOCK_CREDENTIALS = mock.Mock(spec=credentials.CredentialsWithQuotaProject)\nMOCK_CREDENTIALS.with_quota_project.return_value = MOCK_CREDENTIALS\n\n\ndef get_project_id_side_effect(self, request=None):\n    # If no scopes are set, this will always return None.\n    if not self.scopes:\n        return None\n    return mock.sentinel.project_id\n\n\nLOAD_FILE_PATCH = mock.patch(\n    \"google.auth._default.load_credentials_from_file\",\n    return_value=(MOCK_CREDENTIALS, mock.sentinel.project_id),\n    autospec=True,\n)\nEXTERNAL_ACCOUNT_GET_PROJECT_ID_PATCH = mock.patch.object(\n    external_account.Credentials,\n    \"get_project_id\",\n    side_effect=get_project_id_side_effect,\n    autospec=True,\n)\n\n\ndef test_load_credentials_from_missing_file():\n    with pytest.raises(exceptions.DefaultCredentialsError) as excinfo:\n        _default.load_credentials_from_file(\"\")\n\n    assert excinfo.match(r\"not found\")\n\n\ndef test_load_credentials_from_dict_non_dict_object():\n    with pytest.raises(exceptions.DefaultCredentialsError) as excinfo:\n        _default.load_credentials_from_dict(\"\")\n    assert excinfo.match(r\"dict type was expected\")\n\n    with pytest.raises(exceptions.DefaultCredentialsError) as excinfo:\n        _default.load_credentials_from_dict(None)\n    assert excinfo.match(r\"dict type was expected\")\n\n    with pytest.raises(exceptions.DefaultCredentialsError) as excinfo:\n        _default.load_credentials_from_dict(1)\n    assert excinfo.match(r\"dict type was expected\")\n\n\ndef test_load_credentials_from_dict_authorized_user():\n    credentials, project_id = _default.load_credentials_from_dict(\n        AUTHORIZED_USER_FILE_DATA\n    )\n    assert isinstance(credentials, google.oauth2.credentials.Credentials)\n    assert project_id is None\n\n\ndef test_load_credentials_from_file_invalid_json(tmpdir):\n    jsonfile = tmpdir.join(\"invalid.json\")\n    jsonfile.write(\"{\")\n\n    with pytest.raises(exceptions.DefaultCredentialsError) as excinfo:\n        _default.load_credentials_from_file(str(jsonfile))\n\n    assert excinfo.match(r\"not a valid json file\")\n\n\ndef test_load_credentials_from_file_invalid_type(tmpdir):\n    jsonfile = tmpdir.join(\"invalid.json\")\n    jsonfile.write(json.dumps({\"type\": \"not-a-real-type\"}))\n\n    with pytest.raises(exceptions.DefaultCredentialsError) as excinfo:\n        _default.load_credentials_from_file(str(jsonfile))\n\n    assert excinfo.match(r\"does not have a valid type\")\n\n\ndef test_load_credentials_from_file_authorized_user():\n    credentials, project_id = _default.load_credentials_from_file(AUTHORIZED_USER_FILE)\n    assert isinstance(credentials, google.oauth2.credentials.Credentials)\n    assert project_id is None\n\n\ndef test_load_credentials_from_file_no_type(tmpdir):\n    # use the client_secrets.json, which is valid json but not a\n    # loadable credentials type\n    with pytest.raises(exceptions.DefaultCredentialsError) as excinfo:\n        _default.load_credentials_from_file(CLIENT_SECRETS_FILE)\n\n    assert excinfo.match(r\"does not have a valid type\")\n    assert excinfo.match(r\"Type is None\")\n\n\ndef test_load_credentials_from_file_authorized_user_bad_format(tmpdir):\n    filename = tmpdir.join(\"authorized_user_bad.json\")\n    filename.write(json.dumps({\"type\": \"authorized_user\"}))\n\n    with pytest.raises(exceptions.DefaultCredentialsError) as excinfo:\n        _default.load_credentials_from_file(str(filename))\n\n    assert excinfo.match(r\"Failed to load authorized user\")\n    assert excinfo.match(r\"missing fields\")\n\n\ndef test_load_credentials_from_file_authorized_user_cloud_sdk():\n    with pytest.warns(UserWarning, match=\"Cloud SDK\"):\n        credentials, project_id = _default.load_credentials_from_file(\n            AUTHORIZED_USER_CLOUD_SDK_FILE\n        )\n    assert isinstance(credentials, google.oauth2.credentials.Credentials)\n    assert project_id is None\n\n    # No warning if the json file has quota project id.\n    credentials, project_id = _default.load_credentials_from_file(\n        AUTHORIZED_USER_CLOUD_SDK_WITH_QUOTA_PROJECT_ID_FILE\n    )\n    assert isinstance(credentials, google.oauth2.credentials.Credentials)\n    assert project_id is None\n\n\ndef test_load_credentials_from_file_authorized_user_cloud_sdk_with_scopes():\n    with pytest.warns(UserWarning, match=\"Cloud SDK\"):\n        credentials, project_id = _default.load_credentials_from_file(\n            AUTHORIZED_USER_CLOUD_SDK_FILE,\n            scopes=[\"https://www.google.com/calendar/feeds\"],\n        )\n    assert isinstance(credentials, google.oauth2.credentials.Credentials)\n    assert project_id is None\n    assert credentials.scopes == [\"https://www.google.com/calendar/feeds\"]\n\n\ndef test_load_credentials_from_file_authorized_user_cloud_sdk_with_quota_project():\n    credentials, project_id = _default.load_credentials_from_file(\n        AUTHORIZED_USER_CLOUD_SDK_FILE, quota_project_id=\"project-foo\"\n    )\n\n    assert isinstance(credentials, google.oauth2.credentials.Credentials)\n    assert project_id is None\n    assert credentials.quota_project_id == \"project-foo\"\n\n\ndef test_load_credentials_from_file_service_account():\n    credentials, project_id = _default.load_credentials_from_file(SERVICE_ACCOUNT_FILE)\n    assert isinstance(credentials, service_account.Credentials)\n    assert project_id == SERVICE_ACCOUNT_FILE_DATA[\"project_id\"]\n\n\ndef test_load_credentials_from_file_service_account_with_scopes():\n    credentials, project_id = _default.load_credentials_from_file(\n        SERVICE_ACCOUNT_FILE, scopes=[\"https://www.google.com/calendar/feeds\"]\n    )\n    assert isinstance(credentials, service_account.Credentials)\n    assert project_id == SERVICE_ACCOUNT_FILE_DATA[\"project_id\"]\n    assert credentials.scopes == [\"https://www.google.com/calendar/feeds\"]\n\n\ndef test_load_credentials_from_file_service_account_with_quota_project():\n    credentials, project_id = _default.load_credentials_from_file(\n        SERVICE_ACCOUNT_FILE, quota_project_id=\"project-foo\"\n    )\n    assert isinstance(credentials, service_account.Credentials)\n    assert project_id == SERVICE_ACCOUNT_FILE_DATA[\"project_id\"]\n    assert credentials.quota_project_id == \"project-foo\"\n\n\ndef test_load_credentials_from_file_service_account_bad_format(tmpdir):\n    filename = tmpdir.join(\"serivce_account_bad.json\")\n    filename.write(json.dumps({\"type\": \"service_account\"}))\n\n    with pytest.raises(exceptions.DefaultCredentialsError) as excinfo:\n        _default.load_credentials_from_file(str(filename))\n\n    assert excinfo.match(r\"Failed to load service account\")\n    assert excinfo.match(r\"missing fields\")\n\n\ndef test_load_credentials_from_file_impersonated_with_authorized_user_source():\n    credentials, project_id = _default.load_credentials_from_file(\n        IMPERSONATED_SERVICE_ACCOUNT_AUTHORIZED_USER_SOURCE_FILE\n    )\n    assert isinstance(credentials, impersonated_credentials.Credentials)\n    assert isinstance(\n        credentials._source_credentials, google.oauth2.credentials.Credentials\n    )\n    assert credentials.service_account_email == \"service-account-target@example.com\"\n    assert credentials._delegates == [\"service-account-delegate@example.com\"]\n    assert not credentials._quota_project_id\n    assert not credentials._target_scopes\n    assert project_id is None\n\n\ndef test_load_credentials_from_file_impersonated_with_quota_project():\n    credentials, _ = _default.load_credentials_from_file(\n        IMPERSONATED_SERVICE_ACCOUNT_WITH_QUOTA_PROJECT_FILE\n    )\n    assert isinstance(credentials, impersonated_credentials.Credentials)\n    assert credentials._quota_project_id == \"quota_project\"\n\n\ndef test_load_credentials_from_file_impersonated_with_service_account_source():\n    credentials, _ = _default.load_credentials_from_file(\n        IMPERSONATED_SERVICE_ACCOUNT_SERVICE_ACCOUNT_SOURCE_FILE\n    )\n    assert isinstance(credentials, impersonated_credentials.Credentials)\n    assert isinstance(credentials._source_credentials, service_account.Credentials)\n    assert not credentials._quota_project_id\n\n\ndef test_load_credentials_from_file_impersonated_passing_quota_project():\n    credentials, _ = _default.load_credentials_from_file(\n        IMPERSONATED_SERVICE_ACCOUNT_SERVICE_ACCOUNT_SOURCE_FILE,\n        quota_project_id=\"new_quota_project\",\n    )\n    assert credentials._quota_project_id == \"new_quota_project\"\n\n\ndef test_load_credentials_from_file_impersonated_passing_scopes():\n    credentials, _ = _default.load_credentials_from_file(\n        IMPERSONATED_SERVICE_ACCOUNT_SERVICE_ACCOUNT_SOURCE_FILE,\n        scopes=[\"scope1\", \"scope2\"],\n    )\n    assert credentials._target_scopes == [\"scope1\", \"scope2\"]\n\n\ndef test_load_credentials_from_file_impersonated_wrong_target_principal(tmpdir):\n\n    with open(IMPERSONATED_SERVICE_ACCOUNT_AUTHORIZED_USER_SOURCE_FILE) as fh:\n        impersonated_credentials_info = json.load(fh)\n    impersonated_credentials_info[\n        \"service_account_impersonation_url\"\n    ] = \"something_wrong\"\n\n    jsonfile = tmpdir.join(\"invalid.json\")\n    jsonfile.write(json.dumps(impersonated_credentials_info))\n    with pytest.raises(exceptions.DefaultCredentialsError) as excinfo:\n        _default.load_credentials_from_file(str(jsonfile))\n\n    assert excinfo.match(r\"Cannot extract target principal\")\n\n\ndef test_load_credentials_from_file_impersonated_wrong_source_type(tmpdir):\n\n    with open(IMPERSONATED_SERVICE_ACCOUNT_AUTHORIZED_USER_SOURCE_FILE) as fh:\n        impersonated_credentials_info = json.load(fh)\n    impersonated_credentials_info[\"source_credentials\"][\"type\"] = \"external_account\"\n\n    jsonfile = tmpdir.join(\"invalid.json\")\n    jsonfile.write(json.dumps(impersonated_credentials_info))\n    with pytest.raises(exceptions.DefaultCredentialsError) as excinfo:\n        _default.load_credentials_from_file(str(jsonfile))\n\n    assert excinfo.match(r\"source credential of type external_account is not supported\")\n\n\n@EXTERNAL_ACCOUNT_GET_PROJECT_ID_PATCH\ndef test_load_credentials_from_file_external_account_identity_pool(\n    get_project_id, tmpdir\n):\n    config_file = tmpdir.join(\"config.json\")\n    config_file.write(json.dumps(IDENTITY_POOL_DATA))\n    credentials, project_id = _default.load_credentials_from_file(str(config_file))\n\n    assert isinstance(credentials, identity_pool.Credentials)\n    # Since no scopes are specified, the project ID cannot be determined.\n    assert project_id is None\n    assert get_project_id.called\n\n\n@EXTERNAL_ACCOUNT_GET_PROJECT_ID_PATCH\ndef test_load_credentials_from_file_external_account_aws(get_project_id, tmpdir):\n    config_file = tmpdir.join(\"config.json\")\n    config_file.write(json.dumps(AWS_DATA))\n    credentials, project_id = _default.load_credentials_from_file(str(config_file))\n\n    assert isinstance(credentials, aws.Credentials)\n    # Since no scopes are specified, the project ID cannot be determined.\n    assert project_id is None\n    assert get_project_id.called\n\n\n@EXTERNAL_ACCOUNT_GET_PROJECT_ID_PATCH\ndef test_load_credentials_from_file_external_account_identity_pool_impersonated(\n    get_project_id, tmpdir\n):\n    config_file = tmpdir.join(\"config.json\")\n    config_file.write(json.dumps(IMPERSONATED_IDENTITY_POOL_DATA))\n    credentials, project_id = _default.load_credentials_from_file(str(config_file))\n\n    assert isinstance(credentials, identity_pool.Credentials)\n    assert not credentials.is_user\n    assert not credentials.is_workforce_pool\n    # Since no scopes are specified, the project ID cannot be determined.\n    assert project_id is None\n    assert get_project_id.called\n\n\n@EXTERNAL_ACCOUNT_GET_PROJECT_ID_PATCH\ndef test_load_credentials_from_file_external_account_aws_impersonated(\n    get_project_id, tmpdir\n):\n    config_file = tmpdir.join(\"config.json\")\n    config_file.write(json.dumps(IMPERSONATED_AWS_DATA))\n    credentials, project_id = _default.load_credentials_from_file(str(config_file))\n\n    assert isinstance(credentials, aws.Credentials)\n    assert not credentials.is_user\n    assert not credentials.is_workforce_pool\n    # Since no scopes are specified, the project ID cannot be determined.\n    assert project_id is None\n    assert get_project_id.called\n\n\n@EXTERNAL_ACCOUNT_GET_PROJECT_ID_PATCH\ndef test_load_credentials_from_file_external_account_workforce(get_project_id, tmpdir):\n    config_file = tmpdir.join(\"config.json\")\n    config_file.write(json.dumps(IDENTITY_POOL_WORKFORCE_DATA))\n    credentials, project_id = _default.load_credentials_from_file(str(config_file))\n\n    assert isinstance(credentials, identity_pool.Credentials)\n    assert credentials.is_user\n    assert credentials.is_workforce_pool\n    # Since no scopes are specified, the project ID cannot be determined.\n    assert project_id is None\n    assert get_project_id.called\n\n\n@EXTERNAL_ACCOUNT_GET_PROJECT_ID_PATCH\ndef test_load_credentials_from_file_external_account_workforce_impersonated(\n    get_project_id, tmpdir\n):\n    config_file = tmpdir.join(\"config.json\")\n    config_file.write(json.dumps(IMPERSONATED_IDENTITY_POOL_WORKFORCE_DATA))\n    credentials, project_id = _default.load_credentials_from_file(str(config_file))\n\n    assert isinstance(credentials, identity_pool.Credentials)\n    assert not credentials.is_user\n    assert credentials.is_workforce_pool\n    # Since no scopes are specified, the project ID cannot be determined.\n    assert project_id is None\n    assert get_project_id.called\n\n\n@EXTERNAL_ACCOUNT_GET_PROJECT_ID_PATCH\ndef test_load_credentials_from_file_external_account_with_user_and_default_scopes(\n    get_project_id, tmpdir\n):\n    config_file = tmpdir.join(\"config.json\")\n    config_file.write(json.dumps(IDENTITY_POOL_DATA))\n    credentials, project_id = _default.load_credentials_from_file(\n        str(config_file),\n        scopes=[\"https://www.google.com/calendar/feeds\"],\n        default_scopes=[\"https://www.googleapis.com/auth/cloud-platform\"],\n    )\n\n    assert isinstance(credentials, identity_pool.Credentials)\n    # Since scopes are specified, the project ID can be determined.\n    assert project_id is mock.sentinel.project_id\n    assert credentials.scopes == [\"https://www.google.com/calendar/feeds\"]\n    assert credentials.default_scopes == [\n        \"https://www.googleapis.com/auth/cloud-platform\"\n    ]\n\n\n@EXTERNAL_ACCOUNT_GET_PROJECT_ID_PATCH\ndef test_load_credentials_from_file_external_account_with_quota_project(\n    get_project_id, tmpdir\n):\n    config_file = tmpdir.join(\"config.json\")\n    config_file.write(json.dumps(IDENTITY_POOL_DATA))\n    credentials, project_id = _default.load_credentials_from_file(\n        str(config_file), quota_project_id=\"project-foo\"\n    )\n\n    assert isinstance(credentials, identity_pool.Credentials)\n    # Since no scopes are specified, the project ID cannot be determined.\n    assert project_id is None\n    assert credentials.quota_project_id == \"project-foo\"\n\n\ndef test_load_credentials_from_file_external_account_bad_format(tmpdir):\n    filename = tmpdir.join(\"external_account_bad.json\")\n    filename.write(json.dumps({\"type\": \"external_account\"}))\n\n    with pytest.raises(exceptions.DefaultCredentialsError) as excinfo:\n        _default.load_credentials_from_file(str(filename))\n\n    assert excinfo.match(\n        \"Failed to load external account credentials from {}\".format(str(filename))\n    )\n\n\n@EXTERNAL_ACCOUNT_GET_PROJECT_ID_PATCH\ndef test_load_credentials_from_file_external_account_explicit_request(\n    get_project_id, tmpdir\n):\n    config_file = tmpdir.join(\"config.json\")\n    config_file.write(json.dumps(IDENTITY_POOL_DATA))\n    credentials, project_id = _default.load_credentials_from_file(\n        str(config_file),\n        request=mock.sentinel.request,\n        scopes=[\"https://www.googleapis.com/auth/cloud-platform\"],\n    )\n\n    assert isinstance(credentials, identity_pool.Credentials)\n    # Since scopes are specified, the project ID can be determined.\n    assert project_id is mock.sentinel.project_id\n    get_project_id.assert_called_with(credentials, request=mock.sentinel.request)\n\n\n@mock.patch.dict(os.environ, {}, clear=True)\ndef test__get_explicit_environ_credentials_no_env():\n    assert _default._get_explicit_environ_credentials() == (None, None)\n\n\ndef test_load_credentials_from_file_external_account_authorized_user():\n    credentials, project_id = _default.load_credentials_from_file(\n        EXTERNAL_ACCOUNT_AUTHORIZED_USER_FILE, request=mock.sentinel.request\n    )\n\n    assert isinstance(credentials, external_account_authorized_user.Credentials)\n    assert project_id is None\n\n\ndef test_load_credentials_from_file_external_account_authorized_user_non_gdu():\n    credentials, _ = _default.load_credentials_from_file(\n        EXTERNAL_ACCOUNT_AUTHORIZED_USER_NON_GDU_FILE, request=mock.sentinel.request\n    )\n\n    assert isinstance(credentials, external_account_authorized_user.Credentials)\n    assert credentials.universe_domain == \"fake_universe_domain\"\n\n\ndef test_load_credentials_from_file_external_account_authorized_user_bad_format(tmpdir):\n    filename = tmpdir.join(\"external_account_authorized_user_bad.json\")\n    filename.write(json.dumps({\"type\": \"external_account_authorized_user\"}))\n\n    with pytest.raises(exceptions.DefaultCredentialsError) as excinfo:\n        _default.load_credentials_from_file(str(filename))\n\n    assert excinfo.match(\n        \"Failed to load external account authorized user credentials from {}\".format(\n            str(filename)\n        )\n    )\n\n\n@pytest.mark.parametrize(\"quota_project_id\", [None, \"project-foo\"])\n@LOAD_FILE_PATCH\ndef test__get_explicit_environ_credentials(load, quota_project_id, monkeypatch):\n    monkeypatch.setenv(environment_vars.CREDENTIALS, \"filename\")\n\n    credentials, project_id = _default._get_explicit_environ_credentials(\n        quota_project_id=quota_project_id\n    )\n\n    assert credentials is MOCK_CREDENTIALS\n    assert project_id is mock.sentinel.project_id\n    load.assert_called_with(\"filename\", quota_project_id=quota_project_id)\n\n\n@LOAD_FILE_PATCH\ndef test__get_explicit_environ_credentials_no_project_id(load, monkeypatch):\n    load.return_value = MOCK_CREDENTIALS, None\n    monkeypatch.setenv(environment_vars.CREDENTIALS, \"filename\")\n\n    credentials, project_id = _default._get_explicit_environ_credentials()\n\n    assert credentials is MOCK_CREDENTIALS\n    assert project_id is None\n\n\n@pytest.mark.parametrize(\"quota_project_id\", [None, \"project-foo\"])\n@mock.patch(\n    \"google.auth._cloud_sdk.get_application_default_credentials_path\", autospec=True\n)\n@mock.patch(\"google.auth._default._get_gcloud_sdk_credentials\", autospec=True)\ndef test__get_explicit_environ_credentials_fallback_to_gcloud(\n    get_gcloud_creds, get_adc_path, quota_project_id, monkeypatch\n):\n    # Set explicit credentials path to cloud sdk credentials path.\n    get_adc_path.return_value = \"filename\"\n    monkeypatch.setenv(environment_vars.CREDENTIALS, \"filename\")\n\n    _default._get_explicit_environ_credentials(quota_project_id=quota_project_id)\n\n    # Check we fall back to cloud sdk flow since explicit credentials path is\n    # cloud sdk credentials path\n    get_gcloud_creds.assert_called_with(quota_project_id=quota_project_id)\n\n\n@pytest.mark.parametrize(\"quota_project_id\", [None, \"project-foo\"])\n@LOAD_FILE_PATCH\n@mock.patch(\n    \"google.auth._cloud_sdk.get_application_default_credentials_path\", autospec=True\n)\ndef test__get_gcloud_sdk_credentials(get_adc_path, load, quota_project_id):\n    get_adc_path.return_value = SERVICE_ACCOUNT_FILE\n\n    credentials, project_id = _default._get_gcloud_sdk_credentials(\n        quota_project_id=quota_project_id\n    )\n\n    assert credentials is MOCK_CREDENTIALS\n    assert project_id is mock.sentinel.project_id\n    load.assert_called_with(SERVICE_ACCOUNT_FILE, quota_project_id=quota_project_id)\n\n\n@mock.patch(\n    \"google.auth._cloud_sdk.get_application_default_credentials_path\", autospec=True\n)\ndef test__get_gcloud_sdk_credentials_non_existent(get_adc_path, tmpdir):\n    non_existent = tmpdir.join(\"non-existent\")\n    get_adc_path.return_value = str(non_existent)\n\n    credentials, project_id = _default._get_gcloud_sdk_credentials()\n\n    assert credentials is None\n    assert project_id is None\n\n\n@mock.patch(\n    \"google.auth._cloud_sdk.get_project_id\",\n    return_value=mock.sentinel.project_id,\n    autospec=True,\n)\n@mock.patch(\"os.path.isfile\", return_value=True, autospec=True)\n@LOAD_FILE_PATCH\ndef test__get_gcloud_sdk_credentials_project_id(load, unused_isfile, get_project_id):\n    # Don't return a project ID from load file, make the function check\n    # the Cloud SDK project.\n    load.return_value = MOCK_CREDENTIALS, None\n\n    credentials, project_id = _default._get_gcloud_sdk_credentials()\n\n    assert credentials == MOCK_CREDENTIALS\n    assert project_id == mock.sentinel.project_id\n    assert get_project_id.called\n\n\n@mock.patch(\"google.auth._cloud_sdk.get_project_id\", return_value=None, autospec=True)\n@mock.patch(\"os.path.isfile\", return_value=True)\n@LOAD_FILE_PATCH\ndef test__get_gcloud_sdk_credentials_no_project_id(load, unused_isfile, get_project_id):\n    # Don't return a project ID from load file, make the function check\n    # the Cloud SDK project.\n    load.return_value = MOCK_CREDENTIALS, None\n\n    credentials, project_id = _default._get_gcloud_sdk_credentials()\n\n    assert credentials == MOCK_CREDENTIALS\n    assert project_id is None\n    assert get_project_id.called\n\n\ndef test__get_gdch_service_account_credentials_invalid_format_version():\n    with pytest.raises(exceptions.DefaultCredentialsError) as excinfo:\n        _default._get_gdch_service_account_credentials(\n            \"file_name\", {\"format_version\": \"2\"}\n        )\n    assert excinfo.match(\"Failed to load GDCH service account credentials\")\n\n\ndef test_get_api_key_credentials():\n    creds = _default.get_api_key_credentials(\"api_key\")\n    assert isinstance(creds, api_key.Credentials)\n    assert creds.token == \"api_key\"\n\n\nclass _AppIdentityModule(object):\n    \"\"\"The interface of the App Idenity app engine module.\n    See https://cloud.google.com/appengine/docs/standard/python/refdocs\\\n    /google.appengine.api.app_identity.app_identity\n    \"\"\"\n\n    def get_application_id(self):\n        raise NotImplementedError()\n\n\n@pytest.fixture\ndef app_identity(monkeypatch):\n    \"\"\"Mocks the app_identity module for google.auth.app_engine.\"\"\"\n    app_identity_module = mock.create_autospec(_AppIdentityModule, instance=True)\n    monkeypatch.setattr(app_engine, \"app_identity\", app_identity_module)\n    yield app_identity_module\n\n\n@mock.patch.dict(os.environ)\ndef test__get_gae_credentials_gen1(app_identity):\n    os.environ[environment_vars.LEGACY_APPENGINE_RUNTIME] = \"python27\"\n    app_identity.get_application_id.return_value = mock.sentinel.project\n\n    credentials, project_id = _default._get_gae_credentials()\n\n    assert isinstance(credentials, app_engine.Credentials)\n    assert project_id == mock.sentinel.project\n\n\n@mock.patch.dict(os.environ)\ndef test__get_gae_credentials_gen2():\n    os.environ[\"GAE_RUNTIME\"] = \"python37\"\n    credentials, project_id = _default._get_gae_credentials()\n    assert credentials is None\n    assert project_id is None\n\n\n@mock.patch.dict(os.environ)\ndef test__get_gae_credentials_gen2_backwards_compat():\n    # compat helpers may copy GAE_RUNTIME to APPENGINE_RUNTIME\n    # for backwards compatibility with code that relies on it\n    os.environ[environment_vars.LEGACY_APPENGINE_RUNTIME] = \"python37\"\n    os.environ[\"GAE_RUNTIME\"] = \"python37\"\n    credentials, project_id = _default._get_gae_credentials()\n    assert credentials is None\n    assert project_id is None\n\n\ndef test__get_gae_credentials_env_unset():\n    assert environment_vars.LEGACY_APPENGINE_RUNTIME not in os.environ\n    assert \"GAE_RUNTIME\" not in os.environ\n    credentials, project_id = _default._get_gae_credentials()\n    assert credentials is None\n    assert project_id is None\n\n\n@mock.patch.dict(os.environ)\ndef test__get_gae_credentials_no_app_engine():\n    # test both with and without LEGACY_APPENGINE_RUNTIME setting\n    assert environment_vars.LEGACY_APPENGINE_RUNTIME not in os.environ\n\n    import sys\n\n    with mock.patch.dict(sys.modules, {\"google.auth.app_engine\": None}):\n        credentials, project_id = _default._get_gae_credentials()\n        assert credentials is None\n        assert project_id is None\n\n        os.environ[environment_vars.LEGACY_APPENGINE_RUNTIME] = \"python27\"\n        credentials, project_id = _default._get_gae_credentials()\n        assert credentials is None\n        assert project_id is None\n\n\n@mock.patch.dict(os.environ)\n@mock.patch.object(app_engine, \"app_identity\", new=None)\ndef test__get_gae_credentials_no_apis():\n    # test both with and without LEGACY_APPENGINE_RUNTIME setting\n    assert environment_vars.LEGACY_APPENGINE_RUNTIME not in os.environ\n\n    credentials, project_id = _default._get_gae_credentials()\n    assert credentials is None\n    assert project_id is None\n\n    os.environ[environment_vars.LEGACY_APPENGINE_RUNTIME] = \"python27\"\n    credentials, project_id = _default._get_gae_credentials()\n    assert credentials is None\n    assert project_id is None\n\n\n@mock.patch(\n    \"google.auth.compute_engine._metadata.is_on_gce\", return_value=True, autospec=True\n)\n@mock.patch(\n    \"google.auth.compute_engine._metadata.get_project_id\",\n    return_value=\"example-project\",\n    autospec=True,\n)\ndef test__get_gce_credentials(unused_get, unused_ping):\n    credentials, project_id = _default._get_gce_credentials()\n\n    assert isinstance(credentials, compute_engine.Credentials)\n    assert project_id == \"example-project\"\n\n\n@mock.patch(\n    \"google.auth.compute_engine._metadata.is_on_gce\", return_value=False, autospec=True\n)\ndef test__get_gce_credentials_no_ping(unused_ping):\n    credentials, project_id = _default._get_gce_credentials()\n\n    assert credentials is None\n    assert project_id is None\n\n\n@mock.patch(\n    \"google.auth.compute_engine._metadata.is_on_gce\", return_value=True, autospec=True\n)\n@mock.patch(\n    \"google.auth.compute_engine._metadata.get_project_id\",\n    side_effect=exceptions.TransportError(),\n    autospec=True,\n)\ndef test__get_gce_credentials_no_project_id(unused_get, unused_ping):\n    credentials, project_id = _default._get_gce_credentials()\n\n    assert isinstance(credentials, compute_engine.Credentials)\n    assert project_id is None\n\n\ndef test__get_gce_credentials_no_compute_engine():\n    import sys\n\n    with mock.patch.dict(\"sys.modules\"):\n        sys.modules[\"google.auth.compute_engine\"] = None\n        credentials, project_id = _default._get_gce_credentials()\n        assert credentials is None\n        assert project_id is None\n\n\n@mock.patch(\n    \"google.auth.compute_engine._metadata.is_on_gce\", return_value=False, autospec=True\n)\ndef test__get_gce_credentials_explicit_request(ping):\n    _default._get_gce_credentials(mock.sentinel.request)\n    ping.assert_called_with(request=mock.sentinel.request)\n\n\n@mock.patch(\n    \"google.auth._default._get_explicit_environ_credentials\",\n    return_value=(MOCK_CREDENTIALS, mock.sentinel.project_id),\n    autospec=True,\n)\ndef test_default_early_out(unused_get):\n    assert _default.default() == (MOCK_CREDENTIALS, mock.sentinel.project_id)\n\n\n@mock.patch(\n    \"google.auth._default._get_explicit_environ_credentials\",\n    return_value=(MOCK_CREDENTIALS, mock.sentinel.project_id),\n    autospec=True,\n)\ndef test_default_explict_project_id(unused_get, monkeypatch):\n    monkeypatch.setenv(environment_vars.PROJECT, \"explicit-env\")\n    assert _default.default() == (MOCK_CREDENTIALS, \"explicit-env\")\n\n\n@mock.patch(\n    \"google.auth._default._get_explicit_environ_credentials\",\n    return_value=(MOCK_CREDENTIALS, mock.sentinel.project_id),\n    autospec=True,\n)\ndef test_default_explict_legacy_project_id(unused_get, monkeypatch):\n    monkeypatch.setenv(environment_vars.LEGACY_PROJECT, \"explicit-env\")\n    assert _default.default() == (MOCK_CREDENTIALS, \"explicit-env\")\n\n\n@mock.patch(\"logging.Logger.warning\", autospec=True)\n@mock.patch(\n    \"google.auth._default._get_explicit_environ_credentials\",\n    return_value=(MOCK_CREDENTIALS, None),\n    autospec=True,\n)\n@mock.patch(\n    \"google.auth._default._get_gcloud_sdk_credentials\",\n    return_value=(MOCK_CREDENTIALS, None),\n    autospec=True,\n)\n@mock.patch(\n    \"google.auth._default._get_gae_credentials\",\n    return_value=(MOCK_CREDENTIALS, None),\n    autospec=True,\n)\n@mock.patch(\n    \"google.auth._default._get_gce_credentials\",\n    return_value=(MOCK_CREDENTIALS, None),\n    autospec=True,\n)\ndef test_default_without_project_id(\n    unused_gce, unused_gae, unused_sdk, unused_explicit, logger_warning\n):\n    assert _default.default() == (MOCK_CREDENTIALS, None)\n    logger_warning.assert_called_with(mock.ANY, mock.ANY, mock.ANY)\n\n\n@mock.patch(\n    \"google.auth._default._get_explicit_environ_credentials\",\n    return_value=(None, None),\n    autospec=True,\n)\n@mock.patch(\n    \"google.auth._default._get_gcloud_sdk_credentials\",\n    return_value=(None, None),\n    autospec=True,\n)\n@mock.patch(\n    \"google.auth._default._get_gae_credentials\",\n    return_value=(None, None),\n    autospec=True,\n)\n@mock.patch(\n    \"google.auth._default._get_gce_credentials\",\n    return_value=(None, None),\n    autospec=True,\n)\ndef test_default_fail(unused_gce, unused_gae, unused_sdk, unused_explicit):\n    with pytest.raises(exceptions.DefaultCredentialsError) as excinfo:\n        assert _default.default()\n\n    assert excinfo.match(_default._CLOUD_SDK_MISSING_CREDENTIALS)\n\n\n@mock.patch(\n    \"google.auth._default._get_explicit_environ_credentials\",\n    return_value=(MOCK_CREDENTIALS, mock.sentinel.project_id),\n    autospec=True,\n)\n@mock.patch(\n    \"google.auth.credentials.with_scopes_if_required\",\n    return_value=MOCK_CREDENTIALS,\n    autospec=True,\n)\ndef test_default_scoped(with_scopes, unused_get):\n    scopes = [\"one\", \"two\"]\n\n    credentials, project_id = _default.default(scopes=scopes)\n\n    assert credentials == with_scopes.return_value\n    assert project_id == mock.sentinel.project_id\n    with_scopes.assert_called_once_with(MOCK_CREDENTIALS, scopes, default_scopes=None)\n\n\n@mock.patch(\n    \"google.auth._default._get_explicit_environ_credentials\",\n    return_value=(MOCK_CREDENTIALS, mock.sentinel.project_id),\n    autospec=True,\n)\ndef test_default_quota_project(with_quota_project):\n    credentials, project_id = _default.default(quota_project_id=\"project-foo\")\n\n    MOCK_CREDENTIALS.with_quota_project.assert_called_once_with(\"project-foo\")\n    assert project_id == mock.sentinel.project_id\n\n\n@mock.patch(\n    \"google.auth._default._get_explicit_environ_credentials\",\n    return_value=(MOCK_CREDENTIALS, mock.sentinel.project_id),\n    autospec=True,\n)\ndef test_default_no_app_engine_compute_engine_module(unused_get):\n    \"\"\"\n    google.auth.compute_engine and google.auth.app_engine are both optional\n    to allow not including them when using this package. This verifies\n    that default fails gracefully if these modules are absent\n    \"\"\"\n    import sys\n\n    with mock.patch.dict(\"sys.modules\"):\n        sys.modules[\"google.auth.compute_engine\"] = None\n        sys.modules[\"google.auth.app_engine\"] = None\n        assert _default.default() == (MOCK_CREDENTIALS, mock.sentinel.project_id)\n\n\n@EXTERNAL_ACCOUNT_GET_PROJECT_ID_PATCH\ndef test_default_environ_external_credentials_identity_pool(\n    get_project_id, monkeypatch, tmpdir\n):\n    config_file = tmpdir.join(\"config.json\")\n    config_file.write(json.dumps(IDENTITY_POOL_DATA))\n    monkeypatch.setenv(environment_vars.CREDENTIALS, str(config_file))\n\n    credentials, project_id = _default.default()\n\n    assert isinstance(credentials, identity_pool.Credentials)\n    assert not credentials.is_user\n    assert not credentials.is_workforce_pool\n    # Without scopes, project ID cannot be determined.\n    assert project_id is None\n\n\n@EXTERNAL_ACCOUNT_GET_PROJECT_ID_PATCH\ndef test_default_environ_external_credentials_identity_pool_impersonated(\n    get_project_id, monkeypatch, tmpdir\n):\n    config_file = tmpdir.join(\"config.json\")\n    config_file.write(json.dumps(IMPERSONATED_IDENTITY_POOL_DATA))\n    monkeypatch.setenv(environment_vars.CREDENTIALS, str(config_file))\n\n    credentials, project_id = _default.default(\n        scopes=[\"https://www.google.com/calendar/feeds\"]\n    )\n\n    assert isinstance(credentials, identity_pool.Credentials)\n    assert not credentials.is_user\n    assert not credentials.is_workforce_pool\n    assert project_id is mock.sentinel.project_id\n    assert credentials.scopes == [\"https://www.google.com/calendar/feeds\"]\n\n    # The credential.get_project_id should have been used in _get_external_account_credentials and default\n    assert get_project_id.call_count == 2\n\n\n@EXTERNAL_ACCOUNT_GET_PROJECT_ID_PATCH\n@mock.patch.dict(os.environ)\ndef test_default_environ_external_credentials_project_from_env(\n    get_project_id, monkeypatch, tmpdir\n):\n    project_from_env = \"project_from_env\"\n    os.environ[environment_vars.PROJECT] = project_from_env\n\n    config_file = tmpdir.join(\"config.json\")\n    config_file.write(json.dumps(IMPERSONATED_IDENTITY_POOL_DATA))\n    monkeypatch.setenv(environment_vars.CREDENTIALS, str(config_file))\n\n    credentials, project_id = _default.default(\n        scopes=[\"https://www.google.com/calendar/feeds\"]\n    )\n\n    assert isinstance(credentials, identity_pool.Credentials)\n    assert not credentials.is_user\n    assert not credentials.is_workforce_pool\n    assert project_id == project_from_env\n    assert credentials.scopes == [\"https://www.google.com/calendar/feeds\"]\n\n    # The credential.get_project_id should have been used only in _get_external_account_credentials\n    assert get_project_id.call_count == 1\n\n\n@EXTERNAL_ACCOUNT_GET_PROJECT_ID_PATCH\n@mock.patch.dict(os.environ)\ndef test_default_environ_external_credentials_legacy_project_from_env(\n    get_project_id, monkeypatch, tmpdir\n):\n    project_from_env = \"project_from_env\"\n    os.environ[environment_vars.LEGACY_PROJECT] = project_from_env\n\n    config_file = tmpdir.join(\"config.json\")\n    config_file.write(json.dumps(IMPERSONATED_IDENTITY_POOL_DATA))\n    monkeypatch.setenv(environment_vars.CREDENTIALS, str(config_file))\n\n    credentials, project_id = _default.default(\n        scopes=[\"https://www.google.com/calendar/feeds\"]\n    )\n\n    assert isinstance(credentials, identity_pool.Credentials)\n    assert not credentials.is_user\n    assert not credentials.is_workforce_pool\n    assert project_id == project_from_env\n    assert credentials.scopes == [\"https://www.google.com/calendar/feeds\"]\n\n    # The credential.get_project_id should have been used only in _get_external_account_credentials\n    assert get_project_id.call_count == 1\n\n\n@EXTERNAL_ACCOUNT_GET_PROJECT_ID_PATCH\ndef test_default_environ_external_credentials_aws_impersonated(\n    get_project_id, monkeypatch, tmpdir\n):\n    config_file = tmpdir.join(\"config.json\")\n    config_file.write(json.dumps(IMPERSONATED_AWS_DATA))\n    monkeypatch.setenv(environment_vars.CREDENTIALS, str(config_file))\n\n    credentials, project_id = _default.default(\n        scopes=[\"https://www.google.com/calendar/feeds\"]\n    )\n\n    assert isinstance(credentials, aws.Credentials)\n    assert not credentials.is_user\n    assert not credentials.is_workforce_pool\n    assert project_id is mock.sentinel.project_id\n    assert credentials.scopes == [\"https://www.google.com/calendar/feeds\"]\n\n\n@EXTERNAL_ACCOUNT_GET_PROJECT_ID_PATCH\ndef test_default_environ_external_credentials_workforce(\n    get_project_id, monkeypatch, tmpdir\n):\n    config_file = tmpdir.join(\"config.json\")\n    config_file.write(json.dumps(IDENTITY_POOL_WORKFORCE_DATA))\n    monkeypatch.setenv(environment_vars.CREDENTIALS, str(config_file))\n\n    credentials, project_id = _default.default(\n        scopes=[\"https://www.google.com/calendar/feeds\"]\n    )\n\n    assert isinstance(credentials, identity_pool.Credentials)\n    assert credentials.is_user\n    assert credentials.is_workforce_pool\n    assert project_id is mock.sentinel.project_id\n    assert credentials.scopes == [\"https://www.google.com/calendar/feeds\"]\n\n\n@EXTERNAL_ACCOUNT_GET_PROJECT_ID_PATCH\ndef test_default_environ_external_credentials_workforce_impersonated(\n    get_project_id, monkeypatch, tmpdir\n):\n    config_file = tmpdir.join(\"config.json\")\n    config_file.write(json.dumps(IMPERSONATED_IDENTITY_POOL_WORKFORCE_DATA))\n    monkeypatch.setenv(environment_vars.CREDENTIALS, str(config_file))\n\n    credentials, project_id = _default.default(\n        scopes=[\"https://www.google.com/calendar/feeds\"]\n    )\n\n    assert isinstance(credentials, identity_pool.Credentials)\n    assert not credentials.is_user\n    assert credentials.is_workforce_pool\n    assert project_id is mock.sentinel.project_id\n    assert credentials.scopes == [\"https://www.google.com/calendar/feeds\"]\n\n\n@EXTERNAL_ACCOUNT_GET_PROJECT_ID_PATCH\ndef test_default_environ_external_credentials_with_user_and_default_scopes_and_quota_project_id(\n    get_project_id, monkeypatch, tmpdir\n):\n    config_file = tmpdir.join(\"config.json\")\n    config_file.write(json.dumps(IDENTITY_POOL_DATA))\n    monkeypatch.setenv(environment_vars.CREDENTIALS, str(config_file))\n\n    credentials, project_id = _default.default(\n        scopes=[\"https://www.google.com/calendar/feeds\"],\n        default_scopes=[\"https://www.googleapis.com/auth/cloud-platform\"],\n        quota_project_id=\"project-foo\",\n    )\n\n    assert isinstance(credentials, identity_pool.Credentials)\n    assert project_id is mock.sentinel.project_id\n    assert credentials.quota_project_id == \"project-foo\"\n    assert credentials.scopes == [\"https://www.google.com/calendar/feeds\"]\n    assert credentials.default_scopes == [\n        \"https://www.googleapis.com/auth/cloud-platform\"\n    ]\n\n\n@EXTERNAL_ACCOUNT_GET_PROJECT_ID_PATCH\ndef test_default_environ_external_credentials_explicit_request_with_scopes(\n    get_project_id, monkeypatch, tmpdir\n):\n    config_file = tmpdir.join(\"config.json\")\n    config_file.write(json.dumps(IDENTITY_POOL_DATA))\n    monkeypatch.setenv(environment_vars.CREDENTIALS, str(config_file))\n\n    credentials, project_id = _default.default(\n        request=mock.sentinel.request,\n        scopes=[\"https://www.googleapis.com/auth/cloud-platform\"],\n    )\n\n    assert isinstance(credentials, identity_pool.Credentials)\n    assert project_id is mock.sentinel.project_id\n    # default() will initialize new credentials via with_scopes_if_required\n    # and potentially with_quota_project.\n    # As a result the caller of get_project_id() will not match the returned\n    # credentials.\n    get_project_id.assert_called_with(mock.ANY, request=mock.sentinel.request)\n\n\ndef test_default_environ_external_credentials_bad_format(monkeypatch, tmpdir):\n    filename = tmpdir.join(\"external_account_bad.json\")\n    filename.write(json.dumps({\"type\": \"external_account\"}))\n    monkeypatch.setenv(environment_vars.CREDENTIALS, str(filename))\n\n    with pytest.raises(exceptions.DefaultCredentialsError) as excinfo:\n        _default.default()\n\n    assert excinfo.match(\n        \"Failed to load external account credentials from {}\".format(str(filename))\n    )\n\n\n@mock.patch(\n    \"google.auth._cloud_sdk.get_application_default_credentials_path\", autospec=True\n)\ndef test_default_warning_without_quota_project_id_for_user_creds(get_adc_path):\n    get_adc_path.return_value = AUTHORIZED_USER_CLOUD_SDK_FILE\n\n    with pytest.warns(UserWarning, match=_default._CLOUD_SDK_CREDENTIALS_WARNING):\n        credentials, project_id = _default.default(quota_project_id=None)\n\n\n@mock.patch(\n    \"google.auth._cloud_sdk.get_application_default_credentials_path\", autospec=True\n)\ndef test_default_no_warning_with_quota_project_id_for_user_creds(get_adc_path):\n    get_adc_path.return_value = AUTHORIZED_USER_CLOUD_SDK_FILE\n\n    credentials, project_id = _default.default(quota_project_id=\"project-foo\")\n\n\n@mock.patch(\n    \"google.auth._cloud_sdk.get_application_default_credentials_path\", autospec=True\n)\ndef test_default_impersonated_service_account(get_adc_path):\n    get_adc_path.return_value = IMPERSONATED_SERVICE_ACCOUNT_AUTHORIZED_USER_SOURCE_FILE\n\n    credentials, _ = _default.default()\n\n    assert isinstance(credentials, impersonated_credentials.Credentials)\n    assert isinstance(\n        credentials._source_credentials, google.oauth2.credentials.Credentials\n    )\n    assert credentials.service_account_email == \"service-account-target@example.com\"\n    assert credentials._delegates == [\"service-account-delegate@example.com\"]\n    assert not credentials._quota_project_id\n    assert not credentials._target_scopes\n\n\n@mock.patch(\n    \"google.auth._cloud_sdk.get_application_default_credentials_path\", autospec=True\n)\ndef test_default_impersonated_service_account_set_scopes(get_adc_path):\n    get_adc_path.return_value = IMPERSONATED_SERVICE_ACCOUNT_AUTHORIZED_USER_SOURCE_FILE\n    scopes = [\"scope1\", \"scope2\"]\n\n    credentials, _ = _default.default(scopes=scopes)\n    assert credentials._target_scopes == scopes\n\n\n@mock.patch(\n    \"google.auth._cloud_sdk.get_application_default_credentials_path\", autospec=True\n)\ndef test_default_impersonated_service_account_set_default_scopes(get_adc_path):\n    get_adc_path.return_value = IMPERSONATED_SERVICE_ACCOUNT_AUTHORIZED_USER_SOURCE_FILE\n    default_scopes = [\"scope1\", \"scope2\"]\n\n    credentials, _ = _default.default(default_scopes=default_scopes)\n    assert credentials._target_scopes == default_scopes\n\n\n@mock.patch(\n    \"google.auth._cloud_sdk.get_application_default_credentials_path\", autospec=True\n)\ndef test_default_impersonated_service_account_set_both_scopes_and_default_scopes(\n    get_adc_path\n):\n    get_adc_path.return_value = IMPERSONATED_SERVICE_ACCOUNT_AUTHORIZED_USER_SOURCE_FILE\n    scopes = [\"scope1\", \"scope2\"]\n    default_scopes = [\"scope3\", \"scope4\"]\n\n    credentials, _ = _default.default(scopes=scopes, default_scopes=default_scopes)\n    assert credentials._target_scopes == scopes\n\n\n@EXTERNAL_ACCOUNT_GET_PROJECT_ID_PATCH\ndef test_load_credentials_from_external_account_pluggable(get_project_id, tmpdir):\n    config_file = tmpdir.join(\"config.json\")\n    config_file.write(json.dumps(PLUGGABLE_DATA))\n    credentials, project_id = _default.load_credentials_from_file(str(config_file))\n\n    assert isinstance(credentials, pluggable.Credentials)\n    # Since no scopes are specified, the project ID cannot be determined.\n    assert project_id is None\n    assert get_project_id.called\n\n\n@mock.patch(\n    \"google.auth._cloud_sdk.get_application_default_credentials_path\", autospec=True\n)\ndef test_default_gdch_service_account_credentials(get_adc_path):\n    get_adc_path.return_value = GDCH_SERVICE_ACCOUNT_FILE\n\n    creds, project = _default.default(quota_project_id=\"project-foo\")\n\n    assert isinstance(creds, gdch_credentials.ServiceAccountCredentials)\n    assert creds._service_identity_name == \"service_identity_name\"\n    assert creds._audience is None\n    assert creds._token_uri == \"https://service-identity.<Domain>/authenticate\"\n    assert creds._ca_cert_path == \"/path/to/ca/cert\"\n    assert project == \"project_foo\"\n\n\n@mock.patch.dict(os.environ)\n@mock.patch(\n    \"google.auth._cloud_sdk.get_application_default_credentials_path\", autospec=True\n)\ndef test_quota_project_from_environment(get_adc_path):\n    get_adc_path.return_value = AUTHORIZED_USER_CLOUD_SDK_WITH_QUOTA_PROJECT_ID_FILE\n\n    credentials, _ = _default.default(quota_project_id=None)\n    assert credentials.quota_project_id == \"quota_project_id\"\n\n    quota_from_env = \"quota_from_env\"\n    os.environ[environment_vars.GOOGLE_CLOUD_QUOTA_PROJECT] = quota_from_env\n    credentials, _ = _default.default(quota_project_id=None)\n    assert credentials.quota_project_id == quota_from_env\n\n    explicit_quota = \"explicit_quota\"\n    credentials, _ = _default.default(quota_project_id=explicit_quota)\n    assert credentials.quota_project_id == explicit_quota\n\n\n@mock.patch(\n    \"google.auth.compute_engine._metadata.is_on_gce\", return_value=True, autospec=True\n)\n@mock.patch(\n    \"google.auth.compute_engine._metadata.get_project_id\",\n    return_value=\"example-project\",\n    autospec=True,\n)\n@mock.patch.dict(os.environ)\ndef test_quota_gce_credentials(unused_get, unused_ping):\n    # No quota\n    credentials, project_id = _default._get_gce_credentials()\n    assert project_id == \"example-project\"\n    assert credentials.quota_project_id is None\n\n    # Quota from environment\n    quota_from_env = \"quota_from_env\"\n    os.environ[environment_vars.GOOGLE_CLOUD_QUOTA_PROJECT] = quota_from_env\n    credentials, project_id = _default._get_gce_credentials()\n    assert credentials.quota_project_id == quota_from_env\n\n    # Explicit quota\n    explicit_quota = \"explicit_quota\"\n    credentials, project_id = _default._get_gce_credentials(\n        quota_project_id=explicit_quota\n    )\n    assert credentials.quota_project_id == explicit_quota\n", "tests/test_packaging.py": "# Copyright 2022 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport os\nimport subprocess\nimport sys\n\n\ndef test_namespace_package_compat(tmp_path):\n    \"\"\"\n    The ``google`` namespace package should not be masked\n    by the presence of ``google-auth``.\n    \"\"\"\n    google = tmp_path / \"google\"\n    google.mkdir()\n    google.joinpath(\"othermod.py\").write_text(\"\")\n    env = dict(os.environ, PYTHONPATH=str(tmp_path))\n    cmd = [sys.executable, \"-m\", \"google.othermod\"]\n    subprocess.check_call(cmd, env=env)\n", "tests/test_iam.py": "# Copyright 2017 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport base64\nimport datetime\nimport http.client as http_client\nimport json\n\nimport mock\nimport pytest  # type: ignore\n\nfrom google.auth import _helpers\nfrom google.auth import exceptions\nfrom google.auth import iam\nfrom google.auth import transport\nimport google.auth.credentials\n\n\ndef make_request(status, data=None):\n    response = mock.create_autospec(transport.Response, instance=True)\n    response.status = status\n\n    if data is not None:\n        response.data = json.dumps(data).encode(\"utf-8\")\n\n    request = mock.create_autospec(transport.Request)\n    request.return_value = response\n    return request\n\n\ndef make_credentials():\n    class CredentialsImpl(google.auth.credentials.Credentials):\n        def __init__(self):\n            super(CredentialsImpl, self).__init__()\n            self.token = \"token\"\n            # Force refresh\n            self.expiry = datetime.datetime.min + _helpers.REFRESH_THRESHOLD\n\n        def refresh(self, request):\n            pass\n\n        def with_quota_project(self, quota_project_id):\n            raise NotImplementedError()\n\n    return CredentialsImpl()\n\n\nclass TestSigner(object):\n    def test_constructor(self):\n        request = mock.sentinel.request\n        credentials = mock.create_autospec(\n            google.auth.credentials.Credentials, instance=True\n        )\n\n        signer = iam.Signer(request, credentials, mock.sentinel.service_account_email)\n\n        assert signer._request == mock.sentinel.request\n        assert signer._credentials == credentials\n        assert signer._service_account_email == mock.sentinel.service_account_email\n\n    def test_key_id(self):\n        signer = iam.Signer(\n            mock.sentinel.request,\n            mock.sentinel.credentials,\n            mock.sentinel.service_account_email,\n        )\n\n        assert signer.key_id is None\n\n    def test_sign_bytes(self):\n        signature = b\"DEADBEEF\"\n        encoded_signature = base64.b64encode(signature).decode(\"utf-8\")\n        request = make_request(http_client.OK, data={\"signedBlob\": encoded_signature})\n        credentials = make_credentials()\n\n        signer = iam.Signer(request, credentials, mock.sentinel.service_account_email)\n\n        returned_signature = signer.sign(\"123\")\n\n        assert returned_signature == signature\n        kwargs = request.call_args[1]\n        assert kwargs[\"headers\"][\"Content-Type\"] == \"application/json\"\n\n    def test_sign_bytes_failure(self):\n        request = make_request(http_client.UNAUTHORIZED)\n        credentials = make_credentials()\n\n        signer = iam.Signer(request, credentials, mock.sentinel.service_account_email)\n\n        with pytest.raises(exceptions.TransportError):\n            signer.sign(\"123\")\n", "tests/test_exceptions.py": "# Copyright 2022 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport pytest  # type: ignore\n\nfrom google.auth import exceptions  # type:ignore\n\n\n@pytest.fixture(\n    params=[\n        exceptions.GoogleAuthError,\n        exceptions.TransportError,\n        exceptions.RefreshError,\n        exceptions.UserAccessTokenError,\n        exceptions.DefaultCredentialsError,\n        exceptions.MutualTLSChannelError,\n        exceptions.OAuthError,\n        exceptions.ReauthFailError,\n        exceptions.ReauthSamlChallengeFailError,\n    ]\n)\ndef retryable_exception(request):\n    return request.param\n\n\n@pytest.fixture(params=[exceptions.ClientCertError])\ndef non_retryable_exception(request):\n    return request.param\n\n\ndef test_default_retryable_exceptions(retryable_exception):\n    assert not retryable_exception().retryable\n\n\n@pytest.mark.parametrize(\"retryable\", [True, False])\ndef test_retryable_exceptions(retryable_exception, retryable):\n    retryable_exception = retryable_exception(retryable=retryable)\n    assert retryable_exception.retryable == retryable\n\n\n@pytest.mark.parametrize(\"retryable\", [True, False])\ndef test_non_retryable_exceptions(non_retryable_exception, retryable):\n    non_retryable_exception = non_retryable_exception(retryable=retryable)\n    assert not non_retryable_exception.retryable\n", "tests/test_jwt.py": "# Copyright 2014 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport base64\nimport datetime\nimport json\nimport os\n\nimport mock\nimport pytest  # type: ignore\n\nfrom google.auth import _helpers\nfrom google.auth import crypt\nfrom google.auth import exceptions\nfrom google.auth import jwt\n\n\nDATA_DIR = os.path.join(os.path.dirname(__file__), \"data\")\n\nwith open(os.path.join(DATA_DIR, \"privatekey.pem\"), \"rb\") as fh:\n    PRIVATE_KEY_BYTES = fh.read()\n\nwith open(os.path.join(DATA_DIR, \"public_cert.pem\"), \"rb\") as fh:\n    PUBLIC_CERT_BYTES = fh.read()\n\nwith open(os.path.join(DATA_DIR, \"other_cert.pem\"), \"rb\") as fh:\n    OTHER_CERT_BYTES = fh.read()\n\nwith open(os.path.join(DATA_DIR, \"es256_privatekey.pem\"), \"rb\") as fh:\n    EC_PRIVATE_KEY_BYTES = fh.read()\n\nwith open(os.path.join(DATA_DIR, \"es256_public_cert.pem\"), \"rb\") as fh:\n    EC_PUBLIC_CERT_BYTES = fh.read()\n\nSERVICE_ACCOUNT_JSON_FILE = os.path.join(DATA_DIR, \"service_account.json\")\n\nwith open(SERVICE_ACCOUNT_JSON_FILE, \"rb\") as fh:\n    SERVICE_ACCOUNT_INFO = json.load(fh)\n\n\n@pytest.fixture\ndef signer():\n    return crypt.RSASigner.from_string(PRIVATE_KEY_BYTES, \"1\")\n\n\ndef test_encode_basic(signer):\n    test_payload = {\"test\": \"value\"}\n    encoded = jwt.encode(signer, test_payload)\n    header, payload, _, _ = jwt._unverified_decode(encoded)\n    assert payload == test_payload\n    assert header == {\"typ\": \"JWT\", \"alg\": \"RS256\", \"kid\": signer.key_id}\n\n\ndef test_encode_extra_headers(signer):\n    encoded = jwt.encode(signer, {}, header={\"extra\": \"value\"})\n    header = jwt.decode_header(encoded)\n    assert header == {\n        \"typ\": \"JWT\",\n        \"alg\": \"RS256\",\n        \"kid\": signer.key_id,\n        \"extra\": \"value\",\n    }\n\n\ndef test_encode_custom_alg_in_headers(signer):\n    encoded = jwt.encode(signer, {}, header={\"alg\": \"foo\"})\n    header = jwt.decode_header(encoded)\n    assert header == {\"typ\": \"JWT\", \"alg\": \"foo\", \"kid\": signer.key_id}\n\n\n@pytest.fixture\ndef es256_signer():\n    return crypt.ES256Signer.from_string(EC_PRIVATE_KEY_BYTES, \"1\")\n\n\ndef test_encode_basic_es256(es256_signer):\n    test_payload = {\"test\": \"value\"}\n    encoded = jwt.encode(es256_signer, test_payload)\n    header, payload, _, _ = jwt._unverified_decode(encoded)\n    assert payload == test_payload\n    assert header == {\"typ\": \"JWT\", \"alg\": \"ES256\", \"kid\": es256_signer.key_id}\n\n\n@pytest.fixture\ndef token_factory(signer, es256_signer):\n    def factory(claims=None, key_id=None, use_es256_signer=False):\n        now = _helpers.datetime_to_secs(_helpers.utcnow())\n        payload = {\n            \"aud\": \"audience@example.com\",\n            \"iat\": now,\n            \"exp\": now + 300,\n            \"user\": \"billy bob\",\n            \"metadata\": {\"meta\": \"data\"},\n        }\n        payload.update(claims or {})\n\n        # False is specified to remove the signer's key id for testing\n        # headers without key ids.\n        if key_id is False:\n            signer._key_id = None\n            key_id = None\n\n        if use_es256_signer:\n            return jwt.encode(es256_signer, payload, key_id=key_id)\n        else:\n            return jwt.encode(signer, payload, key_id=key_id)\n\n    return factory\n\n\ndef test_decode_valid(token_factory):\n    payload = jwt.decode(token_factory(), certs=PUBLIC_CERT_BYTES)\n    assert payload[\"aud\"] == \"audience@example.com\"\n    assert payload[\"user\"] == \"billy bob\"\n    assert payload[\"metadata\"][\"meta\"] == \"data\"\n\n\ndef test_decode_header_object(token_factory):\n    payload = token_factory()\n    # Create a malformed JWT token with a number as a header instead of a\n    # dictionary (3 == base64d(M7==))\n    payload = b\"M7.\" + b\".\".join(payload.split(b\".\")[1:])\n\n    with pytest.raises(ValueError) as excinfo:\n        jwt.decode(payload, certs=PUBLIC_CERT_BYTES)\n    assert excinfo.match(r\"Header segment should be a JSON object: \" + str(b\"M7\"))\n\n\ndef test_decode_payload_object(signer):\n    # Create a malformed JWT token with a payload containing both \"iat\" and\n    # \"exp\" strings, although not as fields of a dictionary\n    payload = jwt.encode(signer, \"iatexp\")\n\n    with pytest.raises(ValueError) as excinfo:\n        jwt.decode(payload, certs=PUBLIC_CERT_BYTES)\n    assert excinfo.match(\n        r\"Payload segment should be a JSON object: \" + str(b\"ImlhdGV4cCI\")\n    )\n\n\ndef test_decode_valid_es256(token_factory):\n    payload = jwt.decode(\n        token_factory(use_es256_signer=True), certs=EC_PUBLIC_CERT_BYTES\n    )\n    assert payload[\"aud\"] == \"audience@example.com\"\n    assert payload[\"user\"] == \"billy bob\"\n    assert payload[\"metadata\"][\"meta\"] == \"data\"\n\n\ndef test_decode_valid_with_audience(token_factory):\n    payload = jwt.decode(\n        token_factory(), certs=PUBLIC_CERT_BYTES, audience=\"audience@example.com\"\n    )\n    assert payload[\"aud\"] == \"audience@example.com\"\n    assert payload[\"user\"] == \"billy bob\"\n    assert payload[\"metadata\"][\"meta\"] == \"data\"\n\n\ndef test_decode_valid_with_audience_list(token_factory):\n    payload = jwt.decode(\n        token_factory(),\n        certs=PUBLIC_CERT_BYTES,\n        audience=[\"audience@example.com\", \"another_audience@example.com\"],\n    )\n    assert payload[\"aud\"] == \"audience@example.com\"\n    assert payload[\"user\"] == \"billy bob\"\n    assert payload[\"metadata\"][\"meta\"] == \"data\"\n\n\ndef test_decode_valid_unverified(token_factory):\n    payload = jwt.decode(token_factory(), certs=OTHER_CERT_BYTES, verify=False)\n    assert payload[\"aud\"] == \"audience@example.com\"\n    assert payload[\"user\"] == \"billy bob\"\n    assert payload[\"metadata\"][\"meta\"] == \"data\"\n\n\ndef test_decode_bad_token_wrong_number_of_segments():\n    with pytest.raises(ValueError) as excinfo:\n        jwt.decode(\"1.2\", PUBLIC_CERT_BYTES)\n    assert excinfo.match(r\"Wrong number of segments\")\n\n\ndef test_decode_bad_token_not_base64():\n    with pytest.raises((ValueError, TypeError)) as excinfo:\n        jwt.decode(\"1.2.3\", PUBLIC_CERT_BYTES)\n    assert excinfo.match(r\"Incorrect padding|more than a multiple of 4\")\n\n\ndef test_decode_bad_token_not_json():\n    token = b\".\".join([base64.urlsafe_b64encode(b\"123!\")] * 3)\n    with pytest.raises(ValueError) as excinfo:\n        jwt.decode(token, PUBLIC_CERT_BYTES)\n    assert excinfo.match(r\"Can\\'t parse segment\")\n\n\ndef test_decode_bad_token_no_iat_or_exp(signer):\n    token = jwt.encode(signer, {\"test\": \"value\"})\n    with pytest.raises(ValueError) as excinfo:\n        jwt.decode(token, PUBLIC_CERT_BYTES)\n    assert excinfo.match(r\"Token does not contain required claim\")\n\n\ndef test_decode_bad_token_too_early(token_factory):\n    token = token_factory(\n        claims={\n            \"iat\": _helpers.datetime_to_secs(\n                _helpers.utcnow() + datetime.timedelta(hours=1)\n            )\n        }\n    )\n    with pytest.raises(ValueError) as excinfo:\n        jwt.decode(token, PUBLIC_CERT_BYTES, clock_skew_in_seconds=59)\n    assert excinfo.match(r\"Token used too early\")\n\n\ndef test_decode_bad_token_expired(token_factory):\n    token = token_factory(\n        claims={\n            \"exp\": _helpers.datetime_to_secs(\n                _helpers.utcnow() - datetime.timedelta(hours=1)\n            )\n        }\n    )\n    with pytest.raises(ValueError) as excinfo:\n        jwt.decode(token, PUBLIC_CERT_BYTES, clock_skew_in_seconds=59)\n    assert excinfo.match(r\"Token expired\")\n\n\ndef test_decode_success_with_no_clock_skew(token_factory):\n    token = token_factory(\n        claims={\n            \"exp\": _helpers.datetime_to_secs(\n                _helpers.utcnow() + datetime.timedelta(seconds=1)\n            ),\n            \"iat\": _helpers.datetime_to_secs(\n                _helpers.utcnow() - datetime.timedelta(seconds=1)\n            ),\n        }\n    )\n\n    jwt.decode(token, PUBLIC_CERT_BYTES)\n\n\ndef test_decode_success_with_custom_clock_skew(token_factory):\n    token = token_factory(\n        claims={\n            \"exp\": _helpers.datetime_to_secs(\n                _helpers.utcnow() + datetime.timedelta(seconds=2)\n            ),\n            \"iat\": _helpers.datetime_to_secs(\n                _helpers.utcnow() - datetime.timedelta(seconds=2)\n            ),\n        }\n    )\n\n    jwt.decode(token, PUBLIC_CERT_BYTES, clock_skew_in_seconds=1)\n\n\ndef test_decode_bad_token_wrong_audience(token_factory):\n    token = token_factory()\n    audience = \"audience2@example.com\"\n    with pytest.raises(ValueError) as excinfo:\n        jwt.decode(token, PUBLIC_CERT_BYTES, audience=audience)\n    assert excinfo.match(r\"Token has wrong audience\")\n\n\ndef test_decode_bad_token_wrong_audience_list(token_factory):\n    token = token_factory()\n    audience = [\"audience2@example.com\", \"audience3@example.com\"]\n    with pytest.raises(ValueError) as excinfo:\n        jwt.decode(token, PUBLIC_CERT_BYTES, audience=audience)\n    assert excinfo.match(r\"Token has wrong audience\")\n\n\ndef test_decode_wrong_cert(token_factory):\n    with pytest.raises(ValueError) as excinfo:\n        jwt.decode(token_factory(), OTHER_CERT_BYTES)\n    assert excinfo.match(r\"Could not verify token signature\")\n\n\ndef test_decode_multicert_bad_cert(token_factory):\n    certs = {\"1\": OTHER_CERT_BYTES, \"2\": PUBLIC_CERT_BYTES}\n    with pytest.raises(ValueError) as excinfo:\n        jwt.decode(token_factory(), certs)\n    assert excinfo.match(r\"Could not verify token signature\")\n\n\ndef test_decode_no_cert(token_factory):\n    certs = {\"2\": PUBLIC_CERT_BYTES}\n    with pytest.raises(ValueError) as excinfo:\n        jwt.decode(token_factory(), certs)\n    assert excinfo.match(r\"Certificate for key id 1 not found\")\n\n\ndef test_decode_no_key_id(token_factory):\n    token = token_factory(key_id=False)\n    certs = {\"2\": PUBLIC_CERT_BYTES}\n    payload = jwt.decode(token, certs)\n    assert payload[\"user\"] == \"billy bob\"\n\n\ndef test_decode_unknown_alg():\n    headers = json.dumps({u\"kid\": u\"1\", u\"alg\": u\"fakealg\"})\n    token = b\".\".join(\n        map(lambda seg: base64.b64encode(seg.encode(\"utf-8\")), [headers, u\"{}\", u\"sig\"])\n    )\n\n    with pytest.raises(ValueError) as excinfo:\n        jwt.decode(token)\n    assert excinfo.match(r\"fakealg\")\n\n\ndef test_decode_missing_crytography_alg(monkeypatch):\n    monkeypatch.delitem(jwt._ALGORITHM_TO_VERIFIER_CLASS, \"ES256\")\n    headers = json.dumps({u\"kid\": u\"1\", u\"alg\": u\"ES256\"})\n    token = b\".\".join(\n        map(lambda seg: base64.b64encode(seg.encode(\"utf-8\")), [headers, u\"{}\", u\"sig\"])\n    )\n\n    with pytest.raises(ValueError) as excinfo:\n        jwt.decode(token)\n    assert excinfo.match(r\"cryptography\")\n\n\ndef test_roundtrip_explicit_key_id(token_factory):\n    token = token_factory(key_id=\"3\")\n    certs = {\"2\": OTHER_CERT_BYTES, \"3\": PUBLIC_CERT_BYTES}\n    payload = jwt.decode(token, certs)\n    assert payload[\"user\"] == \"billy bob\"\n\n\nclass TestCredentials(object):\n    SERVICE_ACCOUNT_EMAIL = \"service-account@example.com\"\n    SUBJECT = \"subject\"\n    AUDIENCE = \"audience\"\n    ADDITIONAL_CLAIMS = {\"meta\": \"data\"}\n    credentials = None\n\n    @pytest.fixture(autouse=True)\n    def credentials_fixture(self, signer):\n        self.credentials = jwt.Credentials(\n            signer,\n            self.SERVICE_ACCOUNT_EMAIL,\n            self.SERVICE_ACCOUNT_EMAIL,\n            self.AUDIENCE,\n        )\n\n    def test_from_service_account_info(self):\n        with open(SERVICE_ACCOUNT_JSON_FILE, \"r\") as fh:\n            info = json.load(fh)\n\n        credentials = jwt.Credentials.from_service_account_info(\n            info, audience=self.AUDIENCE\n        )\n\n        assert credentials._signer.key_id == info[\"private_key_id\"]\n        assert credentials._issuer == info[\"client_email\"]\n        assert credentials._subject == info[\"client_email\"]\n        assert credentials._audience == self.AUDIENCE\n\n    def test_from_service_account_info_args(self):\n        info = SERVICE_ACCOUNT_INFO.copy()\n\n        credentials = jwt.Credentials.from_service_account_info(\n            info,\n            subject=self.SUBJECT,\n            audience=self.AUDIENCE,\n            additional_claims=self.ADDITIONAL_CLAIMS,\n        )\n\n        assert credentials._signer.key_id == info[\"private_key_id\"]\n        assert credentials._issuer == info[\"client_email\"]\n        assert credentials._subject == self.SUBJECT\n        assert credentials._audience == self.AUDIENCE\n        assert credentials._additional_claims == self.ADDITIONAL_CLAIMS\n\n    def test_from_service_account_file(self):\n        info = SERVICE_ACCOUNT_INFO.copy()\n\n        credentials = jwt.Credentials.from_service_account_file(\n            SERVICE_ACCOUNT_JSON_FILE, audience=self.AUDIENCE\n        )\n\n        assert credentials._signer.key_id == info[\"private_key_id\"]\n        assert credentials._issuer == info[\"client_email\"]\n        assert credentials._subject == info[\"client_email\"]\n        assert credentials._audience == self.AUDIENCE\n\n    def test_from_service_account_file_args(self):\n        info = SERVICE_ACCOUNT_INFO.copy()\n\n        credentials = jwt.Credentials.from_service_account_file(\n            SERVICE_ACCOUNT_JSON_FILE,\n            subject=self.SUBJECT,\n            audience=self.AUDIENCE,\n            additional_claims=self.ADDITIONAL_CLAIMS,\n        )\n\n        assert credentials._signer.key_id == info[\"private_key_id\"]\n        assert credentials._issuer == info[\"client_email\"]\n        assert credentials._subject == self.SUBJECT\n        assert credentials._audience == self.AUDIENCE\n        assert credentials._additional_claims == self.ADDITIONAL_CLAIMS\n\n    def test_from_signing_credentials(self):\n        jwt_from_signing = self.credentials.from_signing_credentials(\n            self.credentials, audience=mock.sentinel.new_audience\n        )\n        jwt_from_info = jwt.Credentials.from_service_account_info(\n            SERVICE_ACCOUNT_INFO, audience=mock.sentinel.new_audience\n        )\n\n        assert isinstance(jwt_from_signing, jwt.Credentials)\n        assert jwt_from_signing._signer.key_id == jwt_from_info._signer.key_id\n        assert jwt_from_signing._issuer == jwt_from_info._issuer\n        assert jwt_from_signing._subject == jwt_from_info._subject\n        assert jwt_from_signing._audience == jwt_from_info._audience\n\n    def test_default_state(self):\n        assert not self.credentials.valid\n        # Expiration hasn't been set yet\n        assert not self.credentials.expired\n\n    def test_with_claims(self):\n        new_audience = \"new_audience\"\n        new_credentials = self.credentials.with_claims(audience=new_audience)\n\n        assert new_credentials._signer == self.credentials._signer\n        assert new_credentials._issuer == self.credentials._issuer\n        assert new_credentials._subject == self.credentials._subject\n        assert new_credentials._audience == new_audience\n        assert new_credentials._additional_claims == self.credentials._additional_claims\n        assert new_credentials._quota_project_id == self.credentials._quota_project_id\n\n    def test__make_jwt_without_audience(self):\n        cred = jwt.Credentials.from_service_account_info(\n            SERVICE_ACCOUNT_INFO.copy(),\n            subject=self.SUBJECT,\n            audience=None,\n            additional_claims={\"scope\": \"foo bar\"},\n        )\n        token, _ = cred._make_jwt()\n        payload = jwt.decode(token, PUBLIC_CERT_BYTES)\n        assert payload[\"scope\"] == \"foo bar\"\n        assert \"aud\" not in payload\n\n    def test_with_quota_project(self):\n        quota_project_id = \"project-foo\"\n\n        new_credentials = self.credentials.with_quota_project(quota_project_id)\n        assert new_credentials._signer == self.credentials._signer\n        assert new_credentials._issuer == self.credentials._issuer\n        assert new_credentials._subject == self.credentials._subject\n        assert new_credentials._audience == self.credentials._audience\n        assert new_credentials._additional_claims == self.credentials._additional_claims\n        assert new_credentials.additional_claims == self.credentials._additional_claims\n        assert new_credentials._quota_project_id == quota_project_id\n\n    def test_sign_bytes(self):\n        to_sign = b\"123\"\n        signature = self.credentials.sign_bytes(to_sign)\n        assert crypt.verify_signature(to_sign, signature, PUBLIC_CERT_BYTES)\n\n    def test_signer(self):\n        assert isinstance(self.credentials.signer, crypt.RSASigner)\n\n    def test_signer_email(self):\n        assert self.credentials.signer_email == SERVICE_ACCOUNT_INFO[\"client_email\"]\n\n    def _verify_token(self, token):\n        payload = jwt.decode(token, PUBLIC_CERT_BYTES)\n        assert payload[\"iss\"] == self.SERVICE_ACCOUNT_EMAIL\n        return payload\n\n    def test_refresh(self):\n        self.credentials.refresh(None)\n        assert self.credentials.valid\n        assert not self.credentials.expired\n\n    def test_expired(self):\n        assert not self.credentials.expired\n\n        self.credentials.refresh(None)\n        assert not self.credentials.expired\n\n        with mock.patch(\"google.auth._helpers.utcnow\") as now:\n            one_day = datetime.timedelta(days=1)\n            now.return_value = self.credentials.expiry + one_day\n            assert self.credentials.expired\n\n    def test_before_request(self):\n        headers = {}\n\n        self.credentials.refresh(None)\n        self.credentials.before_request(\n            None, \"GET\", \"http://example.com?a=1#3\", headers\n        )\n\n        header_value = headers[\"authorization\"]\n        _, token = header_value.split(\" \")\n\n        # Since the audience is set, it should use the existing token.\n        assert token.encode(\"utf-8\") == self.credentials.token\n\n        payload = self._verify_token(token)\n        assert payload[\"aud\"] == self.AUDIENCE\n\n    def test_before_request_refreshes(self):\n        assert not self.credentials.valid\n        self.credentials.before_request(None, \"GET\", \"http://example.com?a=1#3\", {})\n        assert self.credentials.valid\n\n\nclass TestOnDemandCredentials(object):\n    SERVICE_ACCOUNT_EMAIL = \"service-account@example.com\"\n    SUBJECT = \"subject\"\n    ADDITIONAL_CLAIMS = {\"meta\": \"data\"}\n    credentials = None\n\n    @pytest.fixture(autouse=True)\n    def credentials_fixture(self, signer):\n        self.credentials = jwt.OnDemandCredentials(\n            signer,\n            self.SERVICE_ACCOUNT_EMAIL,\n            self.SERVICE_ACCOUNT_EMAIL,\n            max_cache_size=2,\n        )\n\n    def test_from_service_account_info(self):\n        with open(SERVICE_ACCOUNT_JSON_FILE, \"r\") as fh:\n            info = json.load(fh)\n\n        credentials = jwt.OnDemandCredentials.from_service_account_info(info)\n\n        assert credentials._signer.key_id == info[\"private_key_id\"]\n        assert credentials._issuer == info[\"client_email\"]\n        assert credentials._subject == info[\"client_email\"]\n\n    def test_from_service_account_info_args(self):\n        info = SERVICE_ACCOUNT_INFO.copy()\n\n        credentials = jwt.OnDemandCredentials.from_service_account_info(\n            info, subject=self.SUBJECT, additional_claims=self.ADDITIONAL_CLAIMS\n        )\n\n        assert credentials._signer.key_id == info[\"private_key_id\"]\n        assert credentials._issuer == info[\"client_email\"]\n        assert credentials._subject == self.SUBJECT\n        assert credentials._additional_claims == self.ADDITIONAL_CLAIMS\n\n    def test_from_service_account_file(self):\n        info = SERVICE_ACCOUNT_INFO.copy()\n\n        credentials = jwt.OnDemandCredentials.from_service_account_file(\n            SERVICE_ACCOUNT_JSON_FILE\n        )\n\n        assert credentials._signer.key_id == info[\"private_key_id\"]\n        assert credentials._issuer == info[\"client_email\"]\n        assert credentials._subject == info[\"client_email\"]\n\n    def test_from_service_account_file_args(self):\n        info = SERVICE_ACCOUNT_INFO.copy()\n\n        credentials = jwt.OnDemandCredentials.from_service_account_file(\n            SERVICE_ACCOUNT_JSON_FILE,\n            subject=self.SUBJECT,\n            additional_claims=self.ADDITIONAL_CLAIMS,\n        )\n\n        assert credentials._signer.key_id == info[\"private_key_id\"]\n        assert credentials._issuer == info[\"client_email\"]\n        assert credentials._subject == self.SUBJECT\n        assert credentials._additional_claims == self.ADDITIONAL_CLAIMS\n\n    def test_from_signing_credentials(self):\n        jwt_from_signing = self.credentials.from_signing_credentials(self.credentials)\n        jwt_from_info = jwt.OnDemandCredentials.from_service_account_info(\n            SERVICE_ACCOUNT_INFO\n        )\n\n        assert isinstance(jwt_from_signing, jwt.OnDemandCredentials)\n        assert jwt_from_signing._signer.key_id == jwt_from_info._signer.key_id\n        assert jwt_from_signing._issuer == jwt_from_info._issuer\n        assert jwt_from_signing._subject == jwt_from_info._subject\n\n    def test_default_state(self):\n        # Credentials are *always* valid.\n        assert self.credentials.valid\n        # Credentials *never* expire.\n        assert not self.credentials.expired\n\n    def test_with_claims(self):\n        new_claims = {\"meep\": \"moop\"}\n        new_credentials = self.credentials.with_claims(additional_claims=new_claims)\n\n        assert new_credentials._signer == self.credentials._signer\n        assert new_credentials._issuer == self.credentials._issuer\n        assert new_credentials._subject == self.credentials._subject\n        assert new_credentials._additional_claims == new_claims\n\n    def test_with_quota_project(self):\n        quota_project_id = \"project-foo\"\n        new_credentials = self.credentials.with_quota_project(quota_project_id)\n\n        assert new_credentials._signer == self.credentials._signer\n        assert new_credentials._issuer == self.credentials._issuer\n        assert new_credentials._subject == self.credentials._subject\n        assert new_credentials._additional_claims == self.credentials._additional_claims\n        assert new_credentials._quota_project_id == quota_project_id\n\n    def test_sign_bytes(self):\n        to_sign = b\"123\"\n        signature = self.credentials.sign_bytes(to_sign)\n        assert crypt.verify_signature(to_sign, signature, PUBLIC_CERT_BYTES)\n\n    def test_signer(self):\n        assert isinstance(self.credentials.signer, crypt.RSASigner)\n\n    def test_signer_email(self):\n        assert self.credentials.signer_email == SERVICE_ACCOUNT_INFO[\"client_email\"]\n\n    def _verify_token(self, token):\n        payload = jwt.decode(token, PUBLIC_CERT_BYTES)\n        assert payload[\"iss\"] == self.SERVICE_ACCOUNT_EMAIL\n        return payload\n\n    def test_refresh(self):\n        with pytest.raises(exceptions.RefreshError):\n            self.credentials.refresh(None)\n\n    def test_before_request(self):\n        headers = {}\n\n        self.credentials.before_request(\n            None, \"GET\", \"http://example.com?a=1#3\", headers\n        )\n\n        _, token = headers[\"authorization\"].split(\" \")\n        payload = self._verify_token(token)\n\n        assert payload[\"aud\"] == \"http://example.com\"\n\n        # Making another request should re-use the same token.\n        self.credentials.before_request(None, \"GET\", \"http://example.com?b=2\", headers)\n\n        _, new_token = headers[\"authorization\"].split(\" \")\n\n        assert new_token == token\n\n    def test_expired_token(self):\n        self.credentials._cache[\"audience\"] = (\n            mock.sentinel.token,\n            datetime.datetime.min,\n        )\n\n        token = self.credentials._get_jwt_for_audience(\"audience\")\n\n        assert token != mock.sentinel.token\n", "tests/conftest.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport os\nimport sys\n\nimport mock\nimport pytest  # type: ignore\n\n\ndef pytest_configure():\n    \"\"\"Load public certificate and private key.\"\"\"\n    pytest.data_dir = os.path.join(os.path.dirname(__file__), \"data\")\n\n    with open(os.path.join(pytest.data_dir, \"privatekey.pem\"), \"rb\") as fh:\n        pytest.private_key_bytes = fh.read()\n\n    with open(os.path.join(pytest.data_dir, \"public_cert.pem\"), \"rb\") as fh:\n        pytest.public_cert_bytes = fh.read()\n\n\n@pytest.fixture\ndef mock_non_existent_module(monkeypatch):\n    \"\"\"Mocks a non-existing module in sys.modules.\n\n    Additionally mocks any non-existing modules specified in the dotted path.\n    \"\"\"\n\n    def _mock_non_existent_module(path):\n        parts = path.split(\".\")\n        partial = []\n        for part in parts:\n            partial.append(part)\n            current_module = \".\".join(partial)\n            if current_module not in sys.modules:\n                monkeypatch.setitem(sys.modules, current_module, mock.MagicMock())\n\n    return _mock_non_existent_module\n", "tests/test__exponential_backoff.py": "# Copyright 2022 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport mock\n\nfrom google.auth import _exponential_backoff\n\n\n@mock.patch(\"time.sleep\", return_value=None)\ndef test_exponential_backoff(mock_time):\n    eb = _exponential_backoff.ExponentialBackoff()\n    curr_wait = eb._current_wait_in_seconds\n    iteration_count = 0\n\n    for attempt in eb:\n        backoff_interval = mock_time.call_args[0][0]\n        jitter = curr_wait * eb._randomization_factor\n\n        assert (curr_wait - jitter) <= backoff_interval <= (curr_wait + jitter)\n        assert attempt == iteration_count + 1\n        assert eb.backoff_count == iteration_count + 1\n        assert eb._current_wait_in_seconds == eb._multiplier ** (iteration_count + 1)\n\n        curr_wait = eb._current_wait_in_seconds\n        iteration_count += 1\n\n    assert eb.total_attempts == _exponential_backoff._DEFAULT_RETRY_TOTAL_ATTEMPTS\n    assert eb.backoff_count == _exponential_backoff._DEFAULT_RETRY_TOTAL_ATTEMPTS\n    assert iteration_count == _exponential_backoff._DEFAULT_RETRY_TOTAL_ATTEMPTS\n    assert mock_time.call_count == _exponential_backoff._DEFAULT_RETRY_TOTAL_ATTEMPTS\n", "tests/test__helpers.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport datetime\nimport urllib\n\nimport pytest  # type: ignore\n\nfrom google.auth import _helpers\n\n\nclass SourceClass(object):\n    def func(self):  # pragma: NO COVER\n        \"\"\"example docstring\"\"\"\n\n\ndef test_copy_docstring_success():\n    def func():  # pragma: NO COVER\n        pass\n\n    _helpers.copy_docstring(SourceClass)(func)\n\n    assert func.__doc__ == SourceClass.func.__doc__\n\n\ndef test_copy_docstring_conflict():\n    def func():  # pragma: NO COVER\n        \"\"\"existing docstring\"\"\"\n        pass\n\n    with pytest.raises(ValueError):\n        _helpers.copy_docstring(SourceClass)(func)\n\n\ndef test_copy_docstring_non_existing():\n    def func2():  # pragma: NO COVER\n        pass\n\n    with pytest.raises(AttributeError):\n        _helpers.copy_docstring(SourceClass)(func2)\n\n\ndef test_parse_content_type_plain():\n    assert _helpers.parse_content_type(\"text/html\") == \"text/html\"\n    assert _helpers.parse_content_type(\"application/xml\") == \"application/xml\"\n    assert _helpers.parse_content_type(\"application/json\") == \"application/json\"\n\n\ndef test_parse_content_type_with_parameters():\n    content_type_html = \"text/html; charset=UTF-8\"\n    content_type_xml = \"application/xml; charset=UTF-16; version=1.0\"\n    content_type_json = \"application/json; charset=UTF-8; indent=2\"\n    assert _helpers.parse_content_type(content_type_html) == \"text/html\"\n    assert _helpers.parse_content_type(content_type_xml) == \"application/xml\"\n    assert _helpers.parse_content_type(content_type_json) == \"application/json\"\n\n\ndef test_parse_content_type_missing_or_broken():\n    content_type_foo = None\n    content_type_bar = \"\"\n    content_type_baz = \"1234\"\n    content_type_qux = \" ; charset=UTF-8\"\n    assert _helpers.parse_content_type(content_type_foo) == \"text/plain\"\n    assert _helpers.parse_content_type(content_type_bar) == \"text/plain\"\n    assert _helpers.parse_content_type(content_type_baz) == \"text/plain\"\n    assert _helpers.parse_content_type(content_type_qux) == \"text/plain\"\n\n\ndef test_utcnow():\n    assert isinstance(_helpers.utcnow(), datetime.datetime)\n\n\ndef test_datetime_to_secs():\n    assert _helpers.datetime_to_secs(datetime.datetime(1970, 1, 1)) == 0\n    assert _helpers.datetime_to_secs(datetime.datetime(1990, 5, 29)) == 643939200\n\n\ndef test_to_bytes_with_bytes():\n    value = b\"bytes-val\"\n    assert _helpers.to_bytes(value) == value\n\n\ndef test_to_bytes_with_unicode():\n    value = u\"string-val\"\n    encoded_value = b\"string-val\"\n    assert _helpers.to_bytes(value) == encoded_value\n\n\ndef test_to_bytes_with_nonstring_type():\n    with pytest.raises(ValueError):\n        _helpers.to_bytes(object())\n\n\ndef test_from_bytes_with_unicode():\n    value = u\"bytes-val\"\n    assert _helpers.from_bytes(value) == value\n\n\ndef test_from_bytes_with_bytes():\n    value = b\"string-val\"\n    decoded_value = u\"string-val\"\n    assert _helpers.from_bytes(value) == decoded_value\n\n\ndef test_from_bytes_with_nonstring_type():\n    with pytest.raises(ValueError):\n        _helpers.from_bytes(object())\n\n\ndef _assert_query(url, expected):\n    parts = urllib.parse.urlsplit(url)\n    query = urllib.parse.parse_qs(parts.query)\n    assert query == expected\n\n\ndef test_update_query_params_no_params():\n    uri = \"http://www.google.com\"\n    updated = _helpers.update_query(uri, {\"a\": \"b\"})\n    assert updated == uri + \"?a=b\"\n\n\ndef test_update_query_existing_params():\n    uri = \"http://www.google.com?x=y\"\n    updated = _helpers.update_query(uri, {\"a\": \"b\", \"c\": \"d&\"})\n    _assert_query(updated, {\"x\": [\"y\"], \"a\": [\"b\"], \"c\": [\"d&\"]})\n\n\ndef test_update_query_replace_param():\n    base_uri = \"http://www.google.com\"\n    uri = base_uri + \"?x=a\"\n    updated = _helpers.update_query(uri, {\"x\": \"b\", \"y\": \"c\"})\n    _assert_query(updated, {\"x\": [\"b\"], \"y\": [\"c\"]})\n\n\ndef test_update_query_remove_param():\n    base_uri = \"http://www.google.com\"\n    uri = base_uri + \"?x=a\"\n    updated = _helpers.update_query(uri, {\"y\": \"c\"}, remove=[\"x\"])\n    _assert_query(updated, {\"y\": [\"c\"]})\n\n\ndef test_scopes_to_string():\n    cases = [\n        (\"\", ()),\n        (\"\", []),\n        (\"\", (\"\",)),\n        (\"\", [\"\"]),\n        (\"a\", (\"a\",)),\n        (\"b\", [\"b\"]),\n        (\"a b\", [\"a\", \"b\"]),\n        (\"a b\", (\"a\", \"b\")),\n        (\"a b\", (s for s in [\"a\", \"b\"])),\n    ]\n    for expected, case in cases:\n        assert _helpers.scopes_to_string(case) == expected\n\n\ndef test_string_to_scopes():\n    cases = [(\"\", []), (\"a\", [\"a\"]), (\"a b c d e f\", [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"])]\n\n    for case, expected in cases:\n        assert _helpers.string_to_scopes(case) == expected\n\n\ndef test_padded_urlsafe_b64decode():\n    cases = [\n        (\"YQ==\", b\"a\"),\n        (\"YQ\", b\"a\"),\n        (\"YWE=\", b\"aa\"),\n        (\"YWE\", b\"aa\"),\n        (\"YWFhYQ==\", b\"aaaa\"),\n        (\"YWFhYQ\", b\"aaaa\"),\n        (\"YWFhYWE=\", b\"aaaaa\"),\n        (\"YWFhYWE\", b\"aaaaa\"),\n    ]\n\n    for case, expected in cases:\n        assert _helpers.padded_urlsafe_b64decode(case) == expected\n\n\ndef test_unpadded_urlsafe_b64encode():\n    cases = [(b\"\", b\"\"), (b\"a\", b\"YQ\"), (b\"aa\", b\"YWE\"), (b\"aaa\", b\"YWFh\")]\n\n    for case, expected in cases:\n        assert _helpers.unpadded_urlsafe_b64encode(case) == expected\n", "tests/test__oauth2client.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport datetime\nimport importlib\nimport os\nimport sys\n\nimport mock\nimport pytest  # type: ignore\n\ntry:\n    import oauth2client.client  # type: ignore\n    import oauth2client.contrib.gce  # type: ignore\n    import oauth2client.service_account  # type: ignore\nexcept ImportError:  # pragma: NO COVER\n    pytest.skip(\n        \"Skipping oauth2client tests since oauth2client is not installed.\",\n        allow_module_level=True,\n    )\n\nfrom google.auth import _oauth2client\n\n\nDATA_DIR = os.path.join(os.path.dirname(__file__), \"data\")\nSERVICE_ACCOUNT_JSON_FILE = os.path.join(DATA_DIR, \"service_account.json\")\n\n\ndef test__convert_oauth2_credentials():\n    old_credentials = oauth2client.client.OAuth2Credentials(\n        \"access_token\",\n        \"client_id\",\n        \"client_secret\",\n        \"refresh_token\",\n        datetime.datetime.min,\n        \"token_uri\",\n        \"user_agent\",\n        scopes=\"one two\",\n    )\n\n    new_credentials = _oauth2client._convert_oauth2_credentials(old_credentials)\n\n    assert new_credentials.token == old_credentials.access_token\n    assert new_credentials._refresh_token == old_credentials.refresh_token\n    assert new_credentials._client_id == old_credentials.client_id\n    assert new_credentials._client_secret == old_credentials.client_secret\n    assert new_credentials._token_uri == old_credentials.token_uri\n    assert new_credentials.scopes == old_credentials.scopes\n\n\ndef test__convert_service_account_credentials():\n    old_class = oauth2client.service_account.ServiceAccountCredentials\n    old_credentials = old_class.from_json_keyfile_name(SERVICE_ACCOUNT_JSON_FILE)\n\n    new_credentials = _oauth2client._convert_service_account_credentials(\n        old_credentials\n    )\n\n    assert (\n        new_credentials.service_account_email == old_credentials.service_account_email\n    )\n    assert new_credentials._signer.key_id == old_credentials._private_key_id\n    assert new_credentials._token_uri == old_credentials.token_uri\n\n\ndef test__convert_service_account_credentials_with_jwt():\n    old_class = oauth2client.service_account._JWTAccessCredentials\n    old_credentials = old_class.from_json_keyfile_name(SERVICE_ACCOUNT_JSON_FILE)\n\n    new_credentials = _oauth2client._convert_service_account_credentials(\n        old_credentials\n    )\n\n    assert (\n        new_credentials.service_account_email == old_credentials.service_account_email\n    )\n    assert new_credentials._signer.key_id == old_credentials._private_key_id\n    assert new_credentials._token_uri == old_credentials.token_uri\n\n\ndef test__convert_gce_app_assertion_credentials():\n    old_credentials = oauth2client.contrib.gce.AppAssertionCredentials(\n        email=\"some_email\"\n    )\n\n    new_credentials = _oauth2client._convert_gce_app_assertion_credentials(\n        old_credentials\n    )\n\n    assert (\n        new_credentials.service_account_email == old_credentials.service_account_email\n    )\n\n\n@pytest.fixture\ndef mock_oauth2client_gae_imports(mock_non_existent_module):\n    mock_non_existent_module(\"google.appengine.api.app_identity\")\n    mock_non_existent_module(\"google.appengine.ext.ndb\")\n    mock_non_existent_module(\"google.appengine.ext.webapp.util\")\n    mock_non_existent_module(\"webapp2\")\n\n\n@mock.patch(\"google.auth.app_engine.app_identity\")\ndef test__convert_appengine_app_assertion_credentials(\n    app_identity, mock_oauth2client_gae_imports\n):\n\n    import oauth2client.contrib.appengine  # type: ignore\n\n    service_account_id = \"service_account_id\"\n    old_credentials = oauth2client.contrib.appengine.AppAssertionCredentials(\n        scope=\"one two\", service_account_id=service_account_id\n    )\n\n    new_credentials = _oauth2client._convert_appengine_app_assertion_credentials(\n        old_credentials\n    )\n\n    assert new_credentials.scopes == [\"one\", \"two\"]\n    assert new_credentials._service_account_id == old_credentials.service_account_id\n\n\nclass FakeCredentials(object):\n    pass\n\n\ndef test_convert_success():\n    convert_function = mock.Mock(spec=[\"__call__\"])\n    conversion_map_patch = mock.patch.object(\n        _oauth2client, \"_CLASS_CONVERSION_MAP\", {FakeCredentials: convert_function}\n    )\n    credentials = FakeCredentials()\n\n    with conversion_map_patch:\n        result = _oauth2client.convert(credentials)\n\n    convert_function.assert_called_once_with(credentials)\n    assert result == convert_function.return_value\n\n\ndef test_convert_not_found():\n    with pytest.raises(ValueError) as excinfo:\n        _oauth2client.convert(\"a string is not a real credentials class\")\n\n    assert excinfo.match(\"Unable to convert\")\n\n\n@pytest.fixture\ndef reset__oauth2client_module():\n    \"\"\"Reloads the _oauth2client module after a test.\"\"\"\n    importlib.reload(_oauth2client)\n\n\ndef test_import_has_app_engine(\n    mock_oauth2client_gae_imports, reset__oauth2client_module\n):\n    importlib.reload(_oauth2client)\n    assert _oauth2client._HAS_APPENGINE\n\n\ndef test_import_without_oauth2client(monkeypatch, reset__oauth2client_module):\n    monkeypatch.setitem(sys.modules, \"oauth2client\", None)\n    with pytest.raises(ImportError) as excinfo:\n        importlib.reload(_oauth2client)\n\n    assert excinfo.match(\"oauth2client\")\n", "tests/__init__.py": "", "tests/test_identity_pool.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport datetime\nimport http.client as http_client\nimport json\nimport os\nimport urllib\n\nimport mock\nimport pytest  # type: ignore\n\nfrom google.auth import _helpers, external_account\nfrom google.auth import exceptions\nfrom google.auth import identity_pool\nfrom google.auth import metrics\nfrom google.auth import transport\nfrom google.auth.credentials import DEFAULT_UNIVERSE_DOMAIN\n\nCLIENT_ID = \"username\"\nCLIENT_SECRET = \"password\"\n# Base64 encoding of \"username:password\".\nBASIC_AUTH_ENCODING = \"dXNlcm5hbWU6cGFzc3dvcmQ=\"\nSERVICE_ACCOUNT_EMAIL = \"service-1234@service-name.iam.gserviceaccount.com\"\nSERVICE_ACCOUNT_IMPERSONATION_URL_BASE = (\n    \"https://us-east1-iamcredentials.googleapis.com\"\n)\nSERVICE_ACCOUNT_IMPERSONATION_URL_ROUTE = \"/v1/projects/-/serviceAccounts/{}:generateAccessToken\".format(\n    SERVICE_ACCOUNT_EMAIL\n)\nSERVICE_ACCOUNT_IMPERSONATION_URL = (\n    SERVICE_ACCOUNT_IMPERSONATION_URL_BASE + SERVICE_ACCOUNT_IMPERSONATION_URL_ROUTE\n)\n\nQUOTA_PROJECT_ID = \"QUOTA_PROJECT_ID\"\nSCOPES = [\"scope1\", \"scope2\"]\nDATA_DIR = os.path.join(os.path.dirname(__file__), \"data\")\nSUBJECT_TOKEN_TEXT_FILE = os.path.join(DATA_DIR, \"external_subject_token.txt\")\nSUBJECT_TOKEN_JSON_FILE = os.path.join(DATA_DIR, \"external_subject_token.json\")\nSUBJECT_TOKEN_FIELD_NAME = \"access_token\"\n\nwith open(SUBJECT_TOKEN_TEXT_FILE) as fh:\n    TEXT_FILE_SUBJECT_TOKEN = fh.read()\n\nwith open(SUBJECT_TOKEN_JSON_FILE) as fh:\n    JSON_FILE_CONTENT = json.load(fh)\n    JSON_FILE_SUBJECT_TOKEN = JSON_FILE_CONTENT.get(SUBJECT_TOKEN_FIELD_NAME)\n\nTOKEN_URL = \"https://sts.googleapis.com/v1/token\"\nTOKEN_INFO_URL = \"https://sts.googleapis.com/v1/introspect\"\nSUBJECT_TOKEN_TYPE = \"urn:ietf:params:oauth:token-type:jwt\"\nAUDIENCE = \"//iam.googleapis.com/projects/123456/locations/global/workloadIdentityPools/POOL_ID/providers/PROVIDER_ID\"\nWORKFORCE_AUDIENCE = (\n    \"//iam.googleapis.com/locations/global/workforcePools/POOL_ID/providers/PROVIDER_ID\"\n)\nWORKFORCE_SUBJECT_TOKEN_TYPE = \"urn:ietf:params:oauth:token-type:id_token\"\nWORKFORCE_POOL_USER_PROJECT = \"WORKFORCE_POOL_USER_PROJECT_NUMBER\"\n\nVALID_TOKEN_URLS = [\n    \"https://sts.googleapis.com\",\n    \"https://us-east-1.sts.googleapis.com\",\n    \"https://US-EAST-1.sts.googleapis.com\",\n    \"https://sts.us-east-1.googleapis.com\",\n    \"https://sts.US-WEST-1.googleapis.com\",\n    \"https://us-east-1-sts.googleapis.com\",\n    \"https://US-WEST-1-sts.googleapis.com\",\n    \"https://us-west-1-sts.googleapis.com/path?query\",\n    \"https://sts-us-east-1.p.googleapis.com\",\n]\nINVALID_TOKEN_URLS = [\n    \"https://iamcredentials.googleapis.com\",\n    \"sts.googleapis.com\",\n    \"https://\",\n    \"http://sts.googleapis.com\",\n    \"https://st.s.googleapis.com\",\n    \"https://us-eas\\t-1.sts.googleapis.com\",\n    \"https:/us-east-1.sts.googleapis.com\",\n    \"https://US-WE/ST-1-sts.googleapis.com\",\n    \"https://sts-us-east-1.googleapis.com\",\n    \"https://sts-US-WEST-1.googleapis.com\",\n    \"testhttps://us-east-1.sts.googleapis.com\",\n    \"https://us-east-1.sts.googleapis.comevil.com\",\n    \"https://us-east-1.us-east-1.sts.googleapis.com\",\n    \"https://us-ea.s.t.sts.googleapis.com\",\n    \"https://sts.googleapis.comevil.com\",\n    \"hhttps://us-east-1.sts.googleapis.com\",\n    \"https://us- -1.sts.googleapis.com\",\n    \"https://-sts.googleapis.com\",\n    \"https://us-east-1.sts.googleapis.com.evil.com\",\n    \"https://sts.pgoogleapis.com\",\n    \"https://p.googleapis.com\",\n    \"https://sts.p.com\",\n    \"http://sts.p.googleapis.com\",\n    \"https://xyz-sts.p.googleapis.com\",\n    \"https://sts-xyz.123.p.googleapis.com\",\n    \"https://sts-xyz.p1.googleapis.com\",\n    \"https://sts-xyz.p.foo.com\",\n    \"https://sts-xyz.p.foo.googleapis.com\",\n]\nVALID_SERVICE_ACCOUNT_IMPERSONATION_URLS = [\n    \"https://iamcredentials.googleapis.com\",\n    \"https://us-east-1.iamcredentials.googleapis.com\",\n    \"https://US-EAST-1.iamcredentials.googleapis.com\",\n    \"https://iamcredentials.us-east-1.googleapis.com\",\n    \"https://iamcredentials.US-WEST-1.googleapis.com\",\n    \"https://us-east-1-iamcredentials.googleapis.com\",\n    \"https://US-WEST-1-iamcredentials.googleapis.com\",\n    \"https://us-west-1-iamcredentials.googleapis.com/path?query\",\n    \"https://iamcredentials-us-east-1.p.googleapis.com\",\n]\nINVALID_SERVICE_ACCOUNT_IMPERSONATION_URLS = [\n    \"https://sts.googleapis.com\",\n    \"iamcredentials.googleapis.com\",\n    \"https://\",\n    \"http://iamcredentials.googleapis.com\",\n    \"https://iamcre.dentials.googleapis.com\",\n    \"https://us-eas\\t-1.iamcredentials.googleapis.com\",\n    \"https:/us-east-1.iamcredentials.googleapis.com\",\n    \"https://US-WE/ST-1-iamcredentials.googleapis.com\",\n    \"https://iamcredentials-us-east-1.googleapis.com\",\n    \"https://iamcredentials-US-WEST-1.googleapis.com\",\n    \"testhttps://us-east-1.iamcredentials.googleapis.com\",\n    \"https://us-east-1.iamcredentials.googleapis.comevil.com\",\n    \"https://us-east-1.us-east-1.iamcredentials.googleapis.com\",\n    \"https://us-ea.s.t.iamcredentials.googleapis.com\",\n    \"https://iamcredentials.googleapis.comevil.com\",\n    \"hhttps://us-east-1.iamcredentials.googleapis.com\",\n    \"https://us- -1.iamcredentials.googleapis.com\",\n    \"https://-iamcredentials.googleapis.com\",\n    \"https://us-east-1.iamcredentials.googleapis.com.evil.com\",\n    \"https://iamcredentials.pgoogleapis.com\",\n    \"https://p.googleapis.com\",\n    \"https://iamcredentials.p.com\",\n    \"http://iamcredentials.p.googleapis.com\",\n    \"https://xyz-iamcredentials.p.googleapis.com\",\n    \"https://iamcredentials-xyz.123.p.googleapis.com\",\n    \"https://iamcredentials-xyz.p1.googleapis.com\",\n    \"https://iamcredentials-xyz.p.foo.com\",\n    \"https://iamcredentials-xyz.p.foo.googleapis.com\",\n]\n\n\nclass TestSubjectTokenSupplier(identity_pool.SubjectTokenSupplier):\n    def __init__(\n        self, subject_token=None, subject_token_exception=None, expected_context=None\n    ):\n        self._subject_token = subject_token\n        self._subject_token_exception = subject_token_exception\n        self._expected_context = expected_context\n\n    def get_subject_token(self, context, request):\n        if self._expected_context is not None:\n            assert self._expected_context == context\n        if self._subject_token_exception is not None:\n            raise self._subject_token_exception\n        return self._subject_token\n\n\nclass TestCredentials(object):\n    CREDENTIAL_SOURCE_TEXT = {\"file\": SUBJECT_TOKEN_TEXT_FILE}\n    CREDENTIAL_SOURCE_JSON = {\n        \"file\": SUBJECT_TOKEN_JSON_FILE,\n        \"format\": {\"type\": \"json\", \"subject_token_field_name\": \"access_token\"},\n    }\n    CREDENTIAL_URL = \"http://fakeurl.com\"\n    CREDENTIAL_SOURCE_TEXT_URL = {\"url\": CREDENTIAL_URL}\n    CREDENTIAL_SOURCE_JSON_URL = {\n        \"url\": CREDENTIAL_URL,\n        \"format\": {\"type\": \"json\", \"subject_token_field_name\": \"access_token\"},\n    }\n    SUCCESS_RESPONSE = {\n        \"access_token\": \"ACCESS_TOKEN\",\n        \"issued_token_type\": \"urn:ietf:params:oauth:token-type:access_token\",\n        \"token_type\": \"Bearer\",\n        \"expires_in\": 3600,\n        \"scope\": \" \".join(SCOPES),\n    }\n\n    @classmethod\n    def make_mock_response(cls, status, data):\n        response = mock.create_autospec(transport.Response, instance=True)\n        response.status = status\n        if isinstance(data, dict):\n            response.data = json.dumps(data).encode(\"utf-8\")\n        else:\n            response.data = data\n        return response\n\n    @classmethod\n    def make_mock_request(\n        cls, token_status=http_client.OK, token_data=None, *extra_requests\n    ):\n        responses = []\n        responses.append(cls.make_mock_response(token_status, token_data))\n\n        while len(extra_requests) > 0:\n            # If service account impersonation is requested, mock the expected response.\n            status, data, extra_requests = (\n                extra_requests[0],\n                extra_requests[1],\n                extra_requests[2:],\n            )\n            responses.append(cls.make_mock_response(status, data))\n\n        request = mock.create_autospec(transport.Request)\n        request.side_effect = responses\n\n        return request\n\n    @classmethod\n    def assert_credential_request_kwargs(\n        cls, request_kwargs, headers, url=CREDENTIAL_URL\n    ):\n        assert request_kwargs[\"url\"] == url\n        assert request_kwargs[\"method\"] == \"GET\"\n        assert request_kwargs[\"headers\"] == headers\n        assert request_kwargs.get(\"body\", None) is None\n\n    @classmethod\n    def assert_token_request_kwargs(\n        cls, request_kwargs, headers, request_data, token_url=TOKEN_URL\n    ):\n        assert request_kwargs[\"url\"] == token_url\n        assert request_kwargs[\"method\"] == \"POST\"\n        assert request_kwargs[\"headers\"] == headers\n        assert request_kwargs[\"body\"] is not None\n        body_tuples = urllib.parse.parse_qsl(request_kwargs[\"body\"])\n        assert len(body_tuples) == len(request_data.keys())\n        for (k, v) in body_tuples:\n            assert v.decode(\"utf-8\") == request_data[k.decode(\"utf-8\")]\n\n    @classmethod\n    def assert_impersonation_request_kwargs(\n        cls,\n        request_kwargs,\n        headers,\n        request_data,\n        service_account_impersonation_url=SERVICE_ACCOUNT_IMPERSONATION_URL,\n    ):\n        assert request_kwargs[\"url\"] == service_account_impersonation_url\n        assert request_kwargs[\"method\"] == \"POST\"\n        assert request_kwargs[\"headers\"] == headers\n        assert request_kwargs[\"body\"] is not None\n        body_json = json.loads(request_kwargs[\"body\"].decode(\"utf-8\"))\n        assert body_json == request_data\n\n    @classmethod\n    def assert_underlying_credentials_refresh(\n        cls,\n        credentials,\n        audience,\n        subject_token,\n        subject_token_type,\n        token_url,\n        service_account_impersonation_url=None,\n        basic_auth_encoding=None,\n        quota_project_id=None,\n        used_scopes=None,\n        credential_data=None,\n        scopes=None,\n        default_scopes=None,\n        workforce_pool_user_project=None,\n    ):\n        \"\"\"Utility to assert that a credentials are initialized with the expected\n        attributes by calling refresh functionality and confirming response matches\n        expected one and that the underlying requests were populated with the\n        expected parameters.\n        \"\"\"\n        # STS token exchange request/response.\n        token_response = cls.SUCCESS_RESPONSE.copy()\n        token_headers = {\"Content-Type\": \"application/x-www-form-urlencoded\"}\n        if basic_auth_encoding:\n            token_headers[\"Authorization\"] = \"Basic \" + basic_auth_encoding\n\n        metrics_options = {}\n        if credentials._service_account_impersonation_url:\n            metrics_options[\"sa-impersonation\"] = \"true\"\n        else:\n            metrics_options[\"sa-impersonation\"] = \"false\"\n        metrics_options[\"config-lifetime\"] = \"false\"\n        if credentials._credential_source:\n            if credentials._credential_source_file:\n                metrics_options[\"source\"] = \"file\"\n            else:\n                metrics_options[\"source\"] = \"url\"\n        else:\n            metrics_options[\"source\"] = \"programmatic\"\n\n        token_headers[\"x-goog-api-client\"] = metrics.byoid_metrics_header(\n            metrics_options\n        )\n\n        if service_account_impersonation_url:\n            token_scopes = \"https://www.googleapis.com/auth/iam\"\n        else:\n            token_scopes = \" \".join(used_scopes or [])\n\n        token_request_data = {\n            \"grant_type\": \"urn:ietf:params:oauth:grant-type:token-exchange\",\n            \"audience\": audience,\n            \"requested_token_type\": \"urn:ietf:params:oauth:token-type:access_token\",\n            \"scope\": token_scopes,\n            \"subject_token\": subject_token,\n            \"subject_token_type\": subject_token_type,\n        }\n        if workforce_pool_user_project:\n            token_request_data[\"options\"] = urllib.parse.quote(\n                json.dumps({\"userProject\": workforce_pool_user_project})\n            )\n\n        metrics_header_value = (\n            \"gl-python/3.7 auth/1.1 auth-request-type/at cred-type/imp\"\n        )\n        if service_account_impersonation_url:\n            # Service account impersonation request/response.\n            expire_time = (\n                _helpers.utcnow().replace(microsecond=0)\n                + datetime.timedelta(seconds=3600)\n            ).isoformat(\"T\") + \"Z\"\n            impersonation_response = {\n                \"accessToken\": \"SA_ACCESS_TOKEN\",\n                \"expireTime\": expire_time,\n            }\n            impersonation_headers = {\n                \"Content-Type\": \"application/json\",\n                \"authorization\": \"Bearer {}\".format(token_response[\"access_token\"]),\n                \"x-goog-api-client\": metrics_header_value,\n                \"x-allowed-locations\": \"0x0\",\n            }\n            impersonation_request_data = {\n                \"delegates\": None,\n                \"scope\": used_scopes,\n                \"lifetime\": \"3600s\",\n            }\n\n        # Initialize mock request to handle token retrieval, token exchange and\n        # service account impersonation request.\n        requests = []\n        if credential_data:\n            requests.append((http_client.OK, credential_data))\n\n        token_request_index = len(requests)\n        requests.append((http_client.OK, token_response))\n\n        if service_account_impersonation_url:\n            impersonation_request_index = len(requests)\n            requests.append((http_client.OK, impersonation_response))\n\n        request = cls.make_mock_request(*[el for req in requests for el in req])\n\n        with mock.patch(\n            \"google.auth.metrics.token_request_access_token_impersonate\",\n            return_value=metrics_header_value,\n        ):\n            credentials.refresh(request)\n\n        assert len(request.call_args_list) == len(requests)\n        if credential_data:\n            cls.assert_credential_request_kwargs(request.call_args_list[0][1], None)\n        # Verify token exchange request parameters.\n        cls.assert_token_request_kwargs(\n            request.call_args_list[token_request_index][1],\n            token_headers,\n            token_request_data,\n            token_url,\n        )\n        # Verify service account impersonation request parameters if the request\n        # is processed.\n        if service_account_impersonation_url:\n            cls.assert_impersonation_request_kwargs(\n                request.call_args_list[impersonation_request_index][1],\n                impersonation_headers,\n                impersonation_request_data,\n                service_account_impersonation_url,\n            )\n            assert credentials.token == impersonation_response[\"accessToken\"]\n        else:\n            assert credentials.token == token_response[\"access_token\"]\n        assert credentials.quota_project_id == quota_project_id\n        assert credentials.scopes == scopes\n        assert credentials.default_scopes == default_scopes\n\n    @classmethod\n    def make_credentials(\n        cls,\n        audience=AUDIENCE,\n        subject_token_type=SUBJECT_TOKEN_TYPE,\n        token_url=TOKEN_URL,\n        token_info_url=TOKEN_INFO_URL,\n        client_id=None,\n        client_secret=None,\n        quota_project_id=None,\n        scopes=None,\n        default_scopes=None,\n        service_account_impersonation_url=None,\n        credential_source=None,\n        subject_token_supplier=None,\n        workforce_pool_user_project=None,\n    ):\n        return identity_pool.Credentials(\n            audience=audience,\n            subject_token_type=subject_token_type,\n            token_url=token_url,\n            token_info_url=token_info_url,\n            service_account_impersonation_url=service_account_impersonation_url,\n            credential_source=credential_source,\n            subject_token_supplier=subject_token_supplier,\n            client_id=client_id,\n            client_secret=client_secret,\n            quota_project_id=quota_project_id,\n            scopes=scopes,\n            default_scopes=default_scopes,\n            workforce_pool_user_project=workforce_pool_user_project,\n        )\n\n    @mock.patch.object(identity_pool.Credentials, \"__init__\", return_value=None)\n    def test_from_info_full_options(self, mock_init):\n        credentials = identity_pool.Credentials.from_info(\n            {\n                \"audience\": AUDIENCE,\n                \"subject_token_type\": SUBJECT_TOKEN_TYPE,\n                \"token_url\": TOKEN_URL,\n                \"token_info_url\": TOKEN_INFO_URL,\n                \"service_account_impersonation_url\": SERVICE_ACCOUNT_IMPERSONATION_URL,\n                \"service_account_impersonation\": {\"token_lifetime_seconds\": 2800},\n                \"client_id\": CLIENT_ID,\n                \"client_secret\": CLIENT_SECRET,\n                \"quota_project_id\": QUOTA_PROJECT_ID,\n                \"credential_source\": self.CREDENTIAL_SOURCE_TEXT,\n            }\n        )\n\n        # Confirm identity_pool.Credentials instantiated with expected attributes.\n        assert isinstance(credentials, identity_pool.Credentials)\n        mock_init.assert_called_once_with(\n            audience=AUDIENCE,\n            subject_token_type=SUBJECT_TOKEN_TYPE,\n            token_url=TOKEN_URL,\n            token_info_url=TOKEN_INFO_URL,\n            service_account_impersonation_url=SERVICE_ACCOUNT_IMPERSONATION_URL,\n            service_account_impersonation_options={\"token_lifetime_seconds\": 2800},\n            client_id=CLIENT_ID,\n            client_secret=CLIENT_SECRET,\n            credential_source=self.CREDENTIAL_SOURCE_TEXT,\n            subject_token_supplier=None,\n            quota_project_id=QUOTA_PROJECT_ID,\n            workforce_pool_user_project=None,\n            universe_domain=DEFAULT_UNIVERSE_DOMAIN,\n        )\n\n    @mock.patch.object(identity_pool.Credentials, \"__init__\", return_value=None)\n    def test_from_info_required_options_only(self, mock_init):\n        credentials = identity_pool.Credentials.from_info(\n            {\n                \"audience\": AUDIENCE,\n                \"subject_token_type\": SUBJECT_TOKEN_TYPE,\n                \"token_url\": TOKEN_URL,\n                \"credential_source\": self.CREDENTIAL_SOURCE_TEXT,\n            }\n        )\n\n        # Confirm identity_pool.Credentials instantiated with expected attributes.\n        assert isinstance(credentials, identity_pool.Credentials)\n        mock_init.assert_called_once_with(\n            audience=AUDIENCE,\n            subject_token_type=SUBJECT_TOKEN_TYPE,\n            token_url=TOKEN_URL,\n            token_info_url=None,\n            service_account_impersonation_url=None,\n            service_account_impersonation_options={},\n            client_id=None,\n            client_secret=None,\n            credential_source=self.CREDENTIAL_SOURCE_TEXT,\n            subject_token_supplier=None,\n            quota_project_id=None,\n            workforce_pool_user_project=None,\n            universe_domain=DEFAULT_UNIVERSE_DOMAIN,\n        )\n\n    @mock.patch.object(identity_pool.Credentials, \"__init__\", return_value=None)\n    def test_from_info_supplier(self, mock_init):\n        supplier = TestSubjectTokenSupplier()\n\n        credentials = identity_pool.Credentials.from_info(\n            {\n                \"audience\": AUDIENCE,\n                \"subject_token_type\": SUBJECT_TOKEN_TYPE,\n                \"token_url\": TOKEN_URL,\n                \"subject_token_supplier\": supplier,\n            }\n        )\n\n        # Confirm identity_pool.Credentials instantiated with expected attributes.\n        assert isinstance(credentials, identity_pool.Credentials)\n        mock_init.assert_called_once_with(\n            audience=AUDIENCE,\n            subject_token_type=SUBJECT_TOKEN_TYPE,\n            token_url=TOKEN_URL,\n            token_info_url=None,\n            service_account_impersonation_url=None,\n            service_account_impersonation_options={},\n            client_id=None,\n            client_secret=None,\n            credential_source=None,\n            subject_token_supplier=supplier,\n            quota_project_id=None,\n            workforce_pool_user_project=None,\n            universe_domain=DEFAULT_UNIVERSE_DOMAIN,\n        )\n\n    @mock.patch.object(identity_pool.Credentials, \"__init__\", return_value=None)\n    def test_from_info_workforce_pool(self, mock_init):\n        credentials = identity_pool.Credentials.from_info(\n            {\n                \"audience\": WORKFORCE_AUDIENCE,\n                \"subject_token_type\": WORKFORCE_SUBJECT_TOKEN_TYPE,\n                \"token_url\": TOKEN_URL,\n                \"credential_source\": self.CREDENTIAL_SOURCE_TEXT,\n                \"workforce_pool_user_project\": WORKFORCE_POOL_USER_PROJECT,\n            }\n        )\n\n        # Confirm identity_pool.Credentials instantiated with expected attributes.\n        assert isinstance(credentials, identity_pool.Credentials)\n        mock_init.assert_called_once_with(\n            audience=WORKFORCE_AUDIENCE,\n            subject_token_type=WORKFORCE_SUBJECT_TOKEN_TYPE,\n            token_url=TOKEN_URL,\n            token_info_url=None,\n            service_account_impersonation_url=None,\n            service_account_impersonation_options={},\n            client_id=None,\n            client_secret=None,\n            credential_source=self.CREDENTIAL_SOURCE_TEXT,\n            subject_token_supplier=None,\n            quota_project_id=None,\n            workforce_pool_user_project=WORKFORCE_POOL_USER_PROJECT,\n            universe_domain=DEFAULT_UNIVERSE_DOMAIN,\n        )\n\n    @mock.patch.object(identity_pool.Credentials, \"__init__\", return_value=None)\n    def test_from_file_full_options(self, mock_init, tmpdir):\n        info = {\n            \"audience\": AUDIENCE,\n            \"subject_token_type\": SUBJECT_TOKEN_TYPE,\n            \"token_url\": TOKEN_URL,\n            \"token_info_url\": TOKEN_INFO_URL,\n            \"service_account_impersonation_url\": SERVICE_ACCOUNT_IMPERSONATION_URL,\n            \"service_account_impersonation\": {\"token_lifetime_seconds\": 2800},\n            \"client_id\": CLIENT_ID,\n            \"client_secret\": CLIENT_SECRET,\n            \"quota_project_id\": QUOTA_PROJECT_ID,\n            \"credential_source\": self.CREDENTIAL_SOURCE_TEXT,\n        }\n        config_file = tmpdir.join(\"config.json\")\n        config_file.write(json.dumps(info))\n        credentials = identity_pool.Credentials.from_file(str(config_file))\n\n        # Confirm identity_pool.Credentials instantiated with expected attributes.\n        assert isinstance(credentials, identity_pool.Credentials)\n        mock_init.assert_called_once_with(\n            audience=AUDIENCE,\n            subject_token_type=SUBJECT_TOKEN_TYPE,\n            token_url=TOKEN_URL,\n            token_info_url=TOKEN_INFO_URL,\n            service_account_impersonation_url=SERVICE_ACCOUNT_IMPERSONATION_URL,\n            service_account_impersonation_options={\"token_lifetime_seconds\": 2800},\n            client_id=CLIENT_ID,\n            client_secret=CLIENT_SECRET,\n            credential_source=self.CREDENTIAL_SOURCE_TEXT,\n            subject_token_supplier=None,\n            quota_project_id=QUOTA_PROJECT_ID,\n            workforce_pool_user_project=None,\n            universe_domain=DEFAULT_UNIVERSE_DOMAIN,\n        )\n\n    @mock.patch.object(identity_pool.Credentials, \"__init__\", return_value=None)\n    def test_from_file_required_options_only(self, mock_init, tmpdir):\n        info = {\n            \"audience\": AUDIENCE,\n            \"subject_token_type\": SUBJECT_TOKEN_TYPE,\n            \"token_url\": TOKEN_URL,\n            \"credential_source\": self.CREDENTIAL_SOURCE_TEXT,\n        }\n        config_file = tmpdir.join(\"config.json\")\n        config_file.write(json.dumps(info))\n        credentials = identity_pool.Credentials.from_file(str(config_file))\n\n        # Confirm identity_pool.Credentials instantiated with expected attributes.\n        assert isinstance(credentials, identity_pool.Credentials)\n        mock_init.assert_called_once_with(\n            audience=AUDIENCE,\n            subject_token_type=SUBJECT_TOKEN_TYPE,\n            token_url=TOKEN_URL,\n            token_info_url=None,\n            service_account_impersonation_url=None,\n            service_account_impersonation_options={},\n            client_id=None,\n            client_secret=None,\n            credential_source=self.CREDENTIAL_SOURCE_TEXT,\n            subject_token_supplier=None,\n            quota_project_id=None,\n            workforce_pool_user_project=None,\n            universe_domain=DEFAULT_UNIVERSE_DOMAIN,\n        )\n\n    @mock.patch.object(identity_pool.Credentials, \"__init__\", return_value=None)\n    def test_from_file_workforce_pool(self, mock_init, tmpdir):\n        info = {\n            \"audience\": WORKFORCE_AUDIENCE,\n            \"subject_token_type\": WORKFORCE_SUBJECT_TOKEN_TYPE,\n            \"token_url\": TOKEN_URL,\n            \"credential_source\": self.CREDENTIAL_SOURCE_TEXT,\n            \"workforce_pool_user_project\": WORKFORCE_POOL_USER_PROJECT,\n        }\n        config_file = tmpdir.join(\"config.json\")\n        config_file.write(json.dumps(info))\n        credentials = identity_pool.Credentials.from_file(str(config_file))\n\n        # Confirm identity_pool.Credentials instantiated with expected attributes.\n        assert isinstance(credentials, identity_pool.Credentials)\n        mock_init.assert_called_once_with(\n            audience=WORKFORCE_AUDIENCE,\n            subject_token_type=WORKFORCE_SUBJECT_TOKEN_TYPE,\n            token_url=TOKEN_URL,\n            token_info_url=None,\n            service_account_impersonation_url=None,\n            service_account_impersonation_options={},\n            client_id=None,\n            client_secret=None,\n            credential_source=self.CREDENTIAL_SOURCE_TEXT,\n            subject_token_supplier=None,\n            quota_project_id=None,\n            workforce_pool_user_project=WORKFORCE_POOL_USER_PROJECT,\n            universe_domain=DEFAULT_UNIVERSE_DOMAIN,\n        )\n\n    def test_constructor_nonworkforce_with_workforce_pool_user_project(self):\n        with pytest.raises(ValueError) as excinfo:\n            self.make_credentials(\n                audience=AUDIENCE,\n                workforce_pool_user_project=WORKFORCE_POOL_USER_PROJECT,\n            )\n\n        assert excinfo.match(\n            \"workforce_pool_user_project should not be set for non-workforce \"\n            \"pool credentials\"\n        )\n\n    def test_constructor_invalid_options(self):\n        credential_source = {\"unsupported\": \"value\"}\n\n        with pytest.raises(ValueError) as excinfo:\n            self.make_credentials(credential_source=credential_source)\n\n        assert excinfo.match(r\"Missing credential_source\")\n\n    def test_constructor_invalid_options_url_and_file(self):\n        credential_source = {\n            \"url\": self.CREDENTIAL_URL,\n            \"file\": SUBJECT_TOKEN_TEXT_FILE,\n        }\n\n        with pytest.raises(ValueError) as excinfo:\n            self.make_credentials(credential_source=credential_source)\n\n        assert excinfo.match(r\"Ambiguous credential_source\")\n\n    def test_constructor_invalid_options_environment_id(self):\n        credential_source = {\"url\": self.CREDENTIAL_URL, \"environment_id\": \"aws1\"}\n\n        with pytest.raises(ValueError) as excinfo:\n            self.make_credentials(credential_source=credential_source)\n\n        assert excinfo.match(\n            r\"Invalid Identity Pool credential_source field 'environment_id'\"\n        )\n\n    def test_constructor_invalid_credential_source(self):\n        with pytest.raises(ValueError) as excinfo:\n            self.make_credentials(credential_source=\"non-dict\")\n\n        assert excinfo.match(\n            r\"Invalid credential_source. The credential_source is not a dict.\"\n        )\n\n    def test_constructor_invalid_no_credential_source_or_supplier(self):\n        with pytest.raises(ValueError) as excinfo:\n            self.make_credentials()\n\n        assert excinfo.match(\n            r\"A valid credential source or a subject token supplier must be provided.\"\n        )\n\n    def test_constructor_invalid_both_credential_source_and_supplier(self):\n        supplier = TestSubjectTokenSupplier()\n        with pytest.raises(ValueError) as excinfo:\n            self.make_credentials(\n                credential_source=self.CREDENTIAL_SOURCE_TEXT,\n                subject_token_supplier=supplier,\n            )\n\n        assert excinfo.match(\n            r\"Identity pool credential cannot have both a credential source and a subject token supplier.\"\n        )\n\n    def test_constructor_invalid_credential_source_format_type(self):\n        credential_source = {\"format\": {\"type\": \"xml\"}}\n\n        with pytest.raises(ValueError) as excinfo:\n            self.make_credentials(credential_source=credential_source)\n\n        assert excinfo.match(r\"Invalid credential_source format 'xml'\")\n\n    def test_constructor_missing_subject_token_field_name(self):\n        credential_source = {\"format\": {\"type\": \"json\"}}\n\n        with pytest.raises(ValueError) as excinfo:\n            self.make_credentials(credential_source=credential_source)\n\n        assert excinfo.match(\n            r\"Missing subject_token_field_name for JSON credential_source format\"\n        )\n\n    def test_info_with_workforce_pool_user_project(self):\n        credentials = self.make_credentials(\n            audience=WORKFORCE_AUDIENCE,\n            subject_token_type=WORKFORCE_SUBJECT_TOKEN_TYPE,\n            credential_source=self.CREDENTIAL_SOURCE_TEXT_URL.copy(),\n            workforce_pool_user_project=WORKFORCE_POOL_USER_PROJECT,\n        )\n\n        assert credentials.info == {\n            \"type\": \"external_account\",\n            \"audience\": WORKFORCE_AUDIENCE,\n            \"subject_token_type\": WORKFORCE_SUBJECT_TOKEN_TYPE,\n            \"token_url\": TOKEN_URL,\n            \"token_info_url\": TOKEN_INFO_URL,\n            \"credential_source\": self.CREDENTIAL_SOURCE_TEXT_URL,\n            \"workforce_pool_user_project\": WORKFORCE_POOL_USER_PROJECT,\n            \"universe_domain\": DEFAULT_UNIVERSE_DOMAIN,\n        }\n\n    def test_info_with_file_credential_source(self):\n        credentials = self.make_credentials(\n            credential_source=self.CREDENTIAL_SOURCE_TEXT_URL.copy()\n        )\n\n        assert credentials.info == {\n            \"type\": \"external_account\",\n            \"audience\": AUDIENCE,\n            \"subject_token_type\": SUBJECT_TOKEN_TYPE,\n            \"token_url\": TOKEN_URL,\n            \"token_info_url\": TOKEN_INFO_URL,\n            \"credential_source\": self.CREDENTIAL_SOURCE_TEXT_URL,\n            \"universe_domain\": DEFAULT_UNIVERSE_DOMAIN,\n        }\n\n    def test_info_with_url_credential_source(self):\n        credentials = self.make_credentials(\n            credential_source=self.CREDENTIAL_SOURCE_JSON_URL.copy()\n        )\n\n        assert credentials.info == {\n            \"type\": \"external_account\",\n            \"audience\": AUDIENCE,\n            \"subject_token_type\": SUBJECT_TOKEN_TYPE,\n            \"token_url\": TOKEN_URL,\n            \"token_info_url\": TOKEN_INFO_URL,\n            \"credential_source\": self.CREDENTIAL_SOURCE_JSON_URL,\n            \"universe_domain\": DEFAULT_UNIVERSE_DOMAIN,\n        }\n\n    def test_info_with_default_token_url(self):\n        credentials = identity_pool.Credentials(\n            audience=AUDIENCE,\n            subject_token_type=SUBJECT_TOKEN_TYPE,\n            credential_source=self.CREDENTIAL_SOURCE_TEXT_URL.copy(),\n        )\n\n        assert credentials.info == {\n            \"type\": \"external_account\",\n            \"audience\": AUDIENCE,\n            \"subject_token_type\": SUBJECT_TOKEN_TYPE,\n            \"token_url\": TOKEN_URL,\n            \"credential_source\": self.CREDENTIAL_SOURCE_TEXT_URL,\n            \"universe_domain\": DEFAULT_UNIVERSE_DOMAIN,\n        }\n\n    def test_info_with_default_token_url_with_universe_domain(self):\n        credentials = identity_pool.Credentials(\n            audience=AUDIENCE,\n            subject_token_type=SUBJECT_TOKEN_TYPE,\n            credential_source=self.CREDENTIAL_SOURCE_TEXT_URL.copy(),\n            universe_domain=\"testdomain.org\",\n        )\n\n        assert credentials.info == {\n            \"type\": \"external_account\",\n            \"audience\": AUDIENCE,\n            \"subject_token_type\": SUBJECT_TOKEN_TYPE,\n            \"token_url\": \"https://sts.testdomain.org/v1/token\",\n            \"credential_source\": self.CREDENTIAL_SOURCE_TEXT_URL,\n            \"universe_domain\": \"testdomain.org\",\n        }\n\n    def test_retrieve_subject_token_missing_subject_token(self, tmpdir):\n        # Provide empty text file.\n        empty_file = tmpdir.join(\"empty.txt\")\n        empty_file.write(\"\")\n        credential_source = {\"file\": str(empty_file)}\n        credentials = self.make_credentials(credential_source=credential_source)\n\n        with pytest.raises(exceptions.RefreshError) as excinfo:\n            credentials.retrieve_subject_token(None)\n\n        assert excinfo.match(r\"Missing subject_token in the credential_source file\")\n\n    def test_retrieve_subject_token_text_file(self):\n        credentials = self.make_credentials(\n            credential_source=self.CREDENTIAL_SOURCE_TEXT\n        )\n\n        subject_token = credentials.retrieve_subject_token(None)\n\n        assert subject_token == TEXT_FILE_SUBJECT_TOKEN\n\n    def test_retrieve_subject_token_json_file(self):\n        credentials = self.make_credentials(\n            credential_source=self.CREDENTIAL_SOURCE_JSON\n        )\n\n        subject_token = credentials.retrieve_subject_token(None)\n\n        assert subject_token == JSON_FILE_SUBJECT_TOKEN\n\n    def test_retrieve_subject_token_json_file_invalid_field_name(self):\n        credential_source = {\n            \"file\": SUBJECT_TOKEN_JSON_FILE,\n            \"format\": {\"type\": \"json\", \"subject_token_field_name\": \"not_found\"},\n        }\n        credentials = self.make_credentials(credential_source=credential_source)\n\n        with pytest.raises(exceptions.RefreshError) as excinfo:\n            credentials.retrieve_subject_token(None)\n\n        assert excinfo.match(\n            \"Unable to parse subject_token from JSON file '{}' using key '{}'\".format(\n                SUBJECT_TOKEN_JSON_FILE, \"not_found\"\n            )\n        )\n\n    def test_retrieve_subject_token_invalid_json(self, tmpdir):\n        # Provide JSON file. This should result in JSON parsing error.\n        invalid_json_file = tmpdir.join(\"invalid.json\")\n        invalid_json_file.write(\"{\")\n        credential_source = {\n            \"file\": str(invalid_json_file),\n            \"format\": {\"type\": \"json\", \"subject_token_field_name\": \"access_token\"},\n        }\n        credentials = self.make_credentials(credential_source=credential_source)\n\n        with pytest.raises(exceptions.RefreshError) as excinfo:\n            credentials.retrieve_subject_token(None)\n\n        assert excinfo.match(\n            \"Unable to parse subject_token from JSON file '{}' using key '{}'\".format(\n                str(invalid_json_file), \"access_token\"\n            )\n        )\n\n    def test_retrieve_subject_token_file_not_found(self):\n        credential_source = {\"file\": \"./not_found.txt\"}\n        credentials = self.make_credentials(credential_source=credential_source)\n\n        with pytest.raises(exceptions.RefreshError) as excinfo:\n            credentials.retrieve_subject_token(None)\n\n        assert excinfo.match(r\"File './not_found.txt' was not found\")\n\n    def test_token_info_url(self):\n        credentials = self.make_credentials(\n            credential_source=self.CREDENTIAL_SOURCE_JSON\n        )\n\n        assert credentials.token_info_url == TOKEN_INFO_URL\n\n    def test_token_info_url_custom(self):\n        for url in VALID_TOKEN_URLS:\n            credentials = self.make_credentials(\n                credential_source=self.CREDENTIAL_SOURCE_JSON.copy(),\n                token_info_url=(url + \"/introspect\"),\n            )\n\n            assert credentials.token_info_url == url + \"/introspect\"\n\n    def test_token_info_url_negative(self):\n        credentials = self.make_credentials(\n            credential_source=self.CREDENTIAL_SOURCE_JSON.copy(), token_info_url=None\n        )\n\n        assert not credentials.token_info_url\n\n    def test_token_url_custom(self):\n        for url in VALID_TOKEN_URLS:\n            credentials = self.make_credentials(\n                credential_source=self.CREDENTIAL_SOURCE_JSON.copy(),\n                token_url=(url + \"/token\"),\n            )\n\n            assert credentials._token_url == (url + \"/token\")\n\n    def test_service_account_impersonation_url_custom(self):\n        for url in VALID_SERVICE_ACCOUNT_IMPERSONATION_URLS:\n            credentials = self.make_credentials(\n                credential_source=self.CREDENTIAL_SOURCE_JSON.copy(),\n                service_account_impersonation_url=(\n                    url + SERVICE_ACCOUNT_IMPERSONATION_URL_ROUTE\n                ),\n            )\n\n            assert credentials._service_account_impersonation_url == (\n                url + SERVICE_ACCOUNT_IMPERSONATION_URL_ROUTE\n            )\n\n    def test_refresh_text_file_success_without_impersonation_ignore_default_scopes(\n        self,\n    ):\n        credentials = self.make_credentials(\n            client_id=CLIENT_ID,\n            client_secret=CLIENT_SECRET,\n            # Test with text format type.\n            credential_source=self.CREDENTIAL_SOURCE_TEXT,\n            scopes=SCOPES,\n            # Default scopes should be ignored.\n            default_scopes=[\"ignored\"],\n        )\n\n        self.assert_underlying_credentials_refresh(\n            credentials=credentials,\n            audience=AUDIENCE,\n            subject_token=TEXT_FILE_SUBJECT_TOKEN,\n            subject_token_type=SUBJECT_TOKEN_TYPE,\n            token_url=TOKEN_URL,\n            service_account_impersonation_url=None,\n            basic_auth_encoding=BASIC_AUTH_ENCODING,\n            quota_project_id=None,\n            used_scopes=SCOPES,\n            scopes=SCOPES,\n            default_scopes=[\"ignored\"],\n        )\n\n    def test_refresh_workforce_success_with_client_auth_without_impersonation(self):\n        credentials = self.make_credentials(\n            audience=WORKFORCE_AUDIENCE,\n            subject_token_type=WORKFORCE_SUBJECT_TOKEN_TYPE,\n            client_id=CLIENT_ID,\n            client_secret=CLIENT_SECRET,\n            # Test with text format type.\n            credential_source=self.CREDENTIAL_SOURCE_TEXT,\n            scopes=SCOPES,\n            # This will be ignored in favor of client auth.\n            workforce_pool_user_project=WORKFORCE_POOL_USER_PROJECT,\n        )\n\n        self.assert_underlying_credentials_refresh(\n            credentials=credentials,\n            audience=WORKFORCE_AUDIENCE,\n            subject_token=TEXT_FILE_SUBJECT_TOKEN,\n            subject_token_type=WORKFORCE_SUBJECT_TOKEN_TYPE,\n            token_url=TOKEN_URL,\n            service_account_impersonation_url=None,\n            basic_auth_encoding=BASIC_AUTH_ENCODING,\n            quota_project_id=None,\n            used_scopes=SCOPES,\n            scopes=SCOPES,\n            workforce_pool_user_project=None,\n        )\n\n    def test_refresh_workforce_success_with_client_auth_and_no_workforce_project(self):\n        credentials = self.make_credentials(\n            audience=WORKFORCE_AUDIENCE,\n            subject_token_type=WORKFORCE_SUBJECT_TOKEN_TYPE,\n            client_id=CLIENT_ID,\n            client_secret=CLIENT_SECRET,\n            # Test with text format type.\n            credential_source=self.CREDENTIAL_SOURCE_TEXT,\n            scopes=SCOPES,\n            # This is not needed when client Auth is used.\n            workforce_pool_user_project=None,\n        )\n\n        self.assert_underlying_credentials_refresh(\n            credentials=credentials,\n            audience=WORKFORCE_AUDIENCE,\n            subject_token=TEXT_FILE_SUBJECT_TOKEN,\n            subject_token_type=WORKFORCE_SUBJECT_TOKEN_TYPE,\n            token_url=TOKEN_URL,\n            service_account_impersonation_url=None,\n            basic_auth_encoding=BASIC_AUTH_ENCODING,\n            quota_project_id=None,\n            used_scopes=SCOPES,\n            scopes=SCOPES,\n            workforce_pool_user_project=None,\n        )\n\n    def test_refresh_workforce_success_without_client_auth_without_impersonation(self):\n        credentials = self.make_credentials(\n            audience=WORKFORCE_AUDIENCE,\n            subject_token_type=WORKFORCE_SUBJECT_TOKEN_TYPE,\n            client_id=None,\n            client_secret=None,\n            # Test with text format type.\n            credential_source=self.CREDENTIAL_SOURCE_TEXT,\n            scopes=SCOPES,\n            # This will not be ignored as client auth is not used.\n            workforce_pool_user_project=WORKFORCE_POOL_USER_PROJECT,\n        )\n\n        self.assert_underlying_credentials_refresh(\n            credentials=credentials,\n            audience=WORKFORCE_AUDIENCE,\n            subject_token=TEXT_FILE_SUBJECT_TOKEN,\n            subject_token_type=WORKFORCE_SUBJECT_TOKEN_TYPE,\n            token_url=TOKEN_URL,\n            service_account_impersonation_url=None,\n            basic_auth_encoding=None,\n            quota_project_id=None,\n            used_scopes=SCOPES,\n            scopes=SCOPES,\n            workforce_pool_user_project=WORKFORCE_POOL_USER_PROJECT,\n        )\n\n    def test_refresh_workforce_success_without_client_auth_with_impersonation(self):\n        credentials = self.make_credentials(\n            audience=WORKFORCE_AUDIENCE,\n            subject_token_type=WORKFORCE_SUBJECT_TOKEN_TYPE,\n            client_id=None,\n            client_secret=None,\n            service_account_impersonation_url=SERVICE_ACCOUNT_IMPERSONATION_URL,\n            # Test with text format type.\n            credential_source=self.CREDENTIAL_SOURCE_TEXT,\n            scopes=SCOPES,\n            # This will not be ignored as client auth is not used.\n            workforce_pool_user_project=WORKFORCE_POOL_USER_PROJECT,\n        )\n\n        self.assert_underlying_credentials_refresh(\n            credentials=credentials,\n            audience=WORKFORCE_AUDIENCE,\n            subject_token=TEXT_FILE_SUBJECT_TOKEN,\n            subject_token_type=WORKFORCE_SUBJECT_TOKEN_TYPE,\n            token_url=TOKEN_URL,\n            service_account_impersonation_url=SERVICE_ACCOUNT_IMPERSONATION_URL,\n            basic_auth_encoding=None,\n            quota_project_id=None,\n            used_scopes=SCOPES,\n            scopes=SCOPES,\n            workforce_pool_user_project=WORKFORCE_POOL_USER_PROJECT,\n        )\n\n    def test_refresh_text_file_success_without_impersonation_use_default_scopes(self):\n        credentials = self.make_credentials(\n            client_id=CLIENT_ID,\n            client_secret=CLIENT_SECRET,\n            # Test with text format type.\n            credential_source=self.CREDENTIAL_SOURCE_TEXT,\n            scopes=None,\n            # Default scopes should be used since user specified scopes are none.\n            default_scopes=SCOPES,\n        )\n\n        self.assert_underlying_credentials_refresh(\n            credentials=credentials,\n            audience=AUDIENCE,\n            subject_token=TEXT_FILE_SUBJECT_TOKEN,\n            subject_token_type=SUBJECT_TOKEN_TYPE,\n            token_url=TOKEN_URL,\n            service_account_impersonation_url=None,\n            basic_auth_encoding=BASIC_AUTH_ENCODING,\n            quota_project_id=None,\n            used_scopes=SCOPES,\n            scopes=None,\n            default_scopes=SCOPES,\n        )\n\n    def test_refresh_text_file_success_with_impersonation_ignore_default_scopes(self):\n        # Initialize credentials with service account impersonation and basic auth.\n        credentials = self.make_credentials(\n            # Test with text format type.\n            credential_source=self.CREDENTIAL_SOURCE_TEXT,\n            service_account_impersonation_url=SERVICE_ACCOUNT_IMPERSONATION_URL,\n            scopes=SCOPES,\n            # Default scopes should be ignored.\n            default_scopes=[\"ignored\"],\n        )\n\n        self.assert_underlying_credentials_refresh(\n            credentials=credentials,\n            audience=AUDIENCE,\n            subject_token=TEXT_FILE_SUBJECT_TOKEN,\n            subject_token_type=SUBJECT_TOKEN_TYPE,\n            token_url=TOKEN_URL,\n            service_account_impersonation_url=SERVICE_ACCOUNT_IMPERSONATION_URL,\n            basic_auth_encoding=None,\n            quota_project_id=None,\n            used_scopes=SCOPES,\n            scopes=SCOPES,\n            default_scopes=[\"ignored\"],\n        )\n\n    def test_refresh_text_file_success_with_impersonation_use_default_scopes(self):\n        # Initialize credentials with service account impersonation, basic auth\n        # and default scopes (no user scopes).\n        credentials = self.make_credentials(\n            # Test with text format type.\n            credential_source=self.CREDENTIAL_SOURCE_TEXT,\n            service_account_impersonation_url=SERVICE_ACCOUNT_IMPERSONATION_URL,\n            scopes=None,\n            # Default scopes should be used since user specified scopes are none.\n            default_scopes=SCOPES,\n        )\n\n        self.assert_underlying_credentials_refresh(\n            credentials=credentials,\n            audience=AUDIENCE,\n            subject_token=TEXT_FILE_SUBJECT_TOKEN,\n            subject_token_type=SUBJECT_TOKEN_TYPE,\n            token_url=TOKEN_URL,\n            service_account_impersonation_url=SERVICE_ACCOUNT_IMPERSONATION_URL,\n            basic_auth_encoding=None,\n            quota_project_id=None,\n            used_scopes=SCOPES,\n            scopes=None,\n            default_scopes=SCOPES,\n        )\n\n    def test_refresh_json_file_success_without_impersonation(self):\n        credentials = self.make_credentials(\n            client_id=CLIENT_ID,\n            client_secret=CLIENT_SECRET,\n            # Test with JSON format type.\n            credential_source=self.CREDENTIAL_SOURCE_JSON,\n            scopes=SCOPES,\n        )\n\n        self.assert_underlying_credentials_refresh(\n            credentials=credentials,\n            audience=AUDIENCE,\n            subject_token=JSON_FILE_SUBJECT_TOKEN,\n            subject_token_type=SUBJECT_TOKEN_TYPE,\n            token_url=TOKEN_URL,\n            service_account_impersonation_url=None,\n            basic_auth_encoding=BASIC_AUTH_ENCODING,\n            quota_project_id=None,\n            used_scopes=SCOPES,\n            scopes=SCOPES,\n            default_scopes=None,\n        )\n\n    def test_refresh_json_file_success_with_impersonation(self):\n        # Initialize credentials with service account impersonation and basic auth.\n        credentials = self.make_credentials(\n            # Test with JSON format type.\n            credential_source=self.CREDENTIAL_SOURCE_JSON,\n            service_account_impersonation_url=SERVICE_ACCOUNT_IMPERSONATION_URL,\n            scopes=SCOPES,\n        )\n\n        self.assert_underlying_credentials_refresh(\n            credentials=credentials,\n            audience=AUDIENCE,\n            subject_token=JSON_FILE_SUBJECT_TOKEN,\n            subject_token_type=SUBJECT_TOKEN_TYPE,\n            token_url=TOKEN_URL,\n            service_account_impersonation_url=SERVICE_ACCOUNT_IMPERSONATION_URL,\n            basic_auth_encoding=None,\n            quota_project_id=None,\n            used_scopes=SCOPES,\n            scopes=SCOPES,\n            default_scopes=None,\n        )\n\n    def test_refresh_with_retrieve_subject_token_error(self):\n        credential_source = {\n            \"file\": SUBJECT_TOKEN_JSON_FILE,\n            \"format\": {\"type\": \"json\", \"subject_token_field_name\": \"not_found\"},\n        }\n        credentials = self.make_credentials(credential_source=credential_source)\n\n        with pytest.raises(exceptions.RefreshError) as excinfo:\n            credentials.refresh(None)\n\n        assert excinfo.match(\n            \"Unable to parse subject_token from JSON file '{}' using key '{}'\".format(\n                SUBJECT_TOKEN_JSON_FILE, \"not_found\"\n            )\n        )\n\n    def test_retrieve_subject_token_from_url(self):\n        credentials = self.make_credentials(\n            credential_source=self.CREDENTIAL_SOURCE_TEXT_URL\n        )\n        request = self.make_mock_request(token_data=TEXT_FILE_SUBJECT_TOKEN)\n        subject_token = credentials.retrieve_subject_token(request)\n\n        assert subject_token == TEXT_FILE_SUBJECT_TOKEN\n        self.assert_credential_request_kwargs(request.call_args_list[0][1], None)\n\n    def test_retrieve_subject_token_from_url_with_headers(self):\n        credentials = self.make_credentials(\n            credential_source={\"url\": self.CREDENTIAL_URL, \"headers\": {\"foo\": \"bar\"}}\n        )\n        request = self.make_mock_request(token_data=TEXT_FILE_SUBJECT_TOKEN)\n        subject_token = credentials.retrieve_subject_token(request)\n\n        assert subject_token == TEXT_FILE_SUBJECT_TOKEN\n        self.assert_credential_request_kwargs(\n            request.call_args_list[0][1], {\"foo\": \"bar\"}\n        )\n\n    def test_retrieve_subject_token_from_url_json(self):\n        credentials = self.make_credentials(\n            credential_source=self.CREDENTIAL_SOURCE_JSON_URL\n        )\n        request = self.make_mock_request(token_data=JSON_FILE_CONTENT)\n        subject_token = credentials.retrieve_subject_token(request)\n\n        assert subject_token == JSON_FILE_SUBJECT_TOKEN\n        self.assert_credential_request_kwargs(request.call_args_list[0][1], None)\n\n    def test_retrieve_subject_token_from_url_json_with_headers(self):\n        credentials = self.make_credentials(\n            credential_source={\n                \"url\": self.CREDENTIAL_URL,\n                \"format\": {\"type\": \"json\", \"subject_token_field_name\": \"access_token\"},\n                \"headers\": {\"foo\": \"bar\"},\n            }\n        )\n        request = self.make_mock_request(token_data=JSON_FILE_CONTENT)\n        subject_token = credentials.retrieve_subject_token(request)\n\n        assert subject_token == JSON_FILE_SUBJECT_TOKEN\n        self.assert_credential_request_kwargs(\n            request.call_args_list[0][1], {\"foo\": \"bar\"}\n        )\n\n    def test_retrieve_subject_token_from_url_not_found(self):\n        credentials = self.make_credentials(\n            credential_source=self.CREDENTIAL_SOURCE_TEXT_URL\n        )\n        with pytest.raises(exceptions.RefreshError) as excinfo:\n            credentials.retrieve_subject_token(\n                self.make_mock_request(token_status=404, token_data=JSON_FILE_CONTENT)\n            )\n\n        assert excinfo.match(\"Unable to retrieve Identity Pool subject token\")\n\n    def test_retrieve_subject_token_from_url_json_invalid_field(self):\n        credential_source = {\n            \"url\": self.CREDENTIAL_URL,\n            \"format\": {\"type\": \"json\", \"subject_token_field_name\": \"not_found\"},\n        }\n        credentials = self.make_credentials(credential_source=credential_source)\n\n        with pytest.raises(exceptions.RefreshError) as excinfo:\n            credentials.retrieve_subject_token(\n                self.make_mock_request(token_data=JSON_FILE_CONTENT)\n            )\n\n        assert excinfo.match(\n            \"Unable to parse subject_token from JSON file '{}' using key '{}'\".format(\n                self.CREDENTIAL_URL, \"not_found\"\n            )\n        )\n\n    def test_retrieve_subject_token_from_url_json_invalid_format(self):\n        credentials = self.make_credentials(\n            credential_source=self.CREDENTIAL_SOURCE_JSON_URL\n        )\n\n        with pytest.raises(exceptions.RefreshError) as excinfo:\n            credentials.retrieve_subject_token(self.make_mock_request(token_data=\"{\"))\n\n        assert excinfo.match(\n            \"Unable to parse subject_token from JSON file '{}' using key '{}'\".format(\n                self.CREDENTIAL_URL, \"access_token\"\n            )\n        )\n\n    def test_refresh_text_file_success_without_impersonation_url(self):\n        credentials = self.make_credentials(\n            client_id=CLIENT_ID,\n            client_secret=CLIENT_SECRET,\n            # Test with text format type.\n            credential_source=self.CREDENTIAL_SOURCE_TEXT_URL,\n            scopes=SCOPES,\n        )\n\n        self.assert_underlying_credentials_refresh(\n            credentials=credentials,\n            audience=AUDIENCE,\n            subject_token=TEXT_FILE_SUBJECT_TOKEN,\n            subject_token_type=SUBJECT_TOKEN_TYPE,\n            token_url=TOKEN_URL,\n            service_account_impersonation_url=None,\n            basic_auth_encoding=BASIC_AUTH_ENCODING,\n            quota_project_id=None,\n            used_scopes=SCOPES,\n            scopes=SCOPES,\n            default_scopes=None,\n            credential_data=TEXT_FILE_SUBJECT_TOKEN,\n        )\n\n    def test_refresh_text_file_success_with_impersonation_url(self):\n        # Initialize credentials with service account impersonation and basic auth.\n        credentials = self.make_credentials(\n            # Test with text format type.\n            credential_source=self.CREDENTIAL_SOURCE_TEXT_URL,\n            service_account_impersonation_url=SERVICE_ACCOUNT_IMPERSONATION_URL,\n            scopes=SCOPES,\n        )\n\n        self.assert_underlying_credentials_refresh(\n            credentials=credentials,\n            audience=AUDIENCE,\n            subject_token=TEXT_FILE_SUBJECT_TOKEN,\n            subject_token_type=SUBJECT_TOKEN_TYPE,\n            token_url=TOKEN_URL,\n            service_account_impersonation_url=SERVICE_ACCOUNT_IMPERSONATION_URL,\n            basic_auth_encoding=None,\n            quota_project_id=None,\n            used_scopes=SCOPES,\n            scopes=SCOPES,\n            default_scopes=None,\n            credential_data=TEXT_FILE_SUBJECT_TOKEN,\n        )\n\n    def test_refresh_json_file_success_without_impersonation_url(self):\n        credentials = self.make_credentials(\n            client_id=CLIENT_ID,\n            client_secret=CLIENT_SECRET,\n            # Test with JSON format type.\n            credential_source=self.CREDENTIAL_SOURCE_JSON_URL,\n            scopes=SCOPES,\n        )\n\n        self.assert_underlying_credentials_refresh(\n            credentials=credentials,\n            audience=AUDIENCE,\n            subject_token=JSON_FILE_SUBJECT_TOKEN,\n            subject_token_type=SUBJECT_TOKEN_TYPE,\n            token_url=TOKEN_URL,\n            service_account_impersonation_url=None,\n            basic_auth_encoding=BASIC_AUTH_ENCODING,\n            quota_project_id=None,\n            used_scopes=SCOPES,\n            scopes=SCOPES,\n            default_scopes=None,\n            credential_data=JSON_FILE_CONTENT,\n        )\n\n    def test_refresh_json_file_success_with_impersonation_url(self):\n        # Initialize credentials with service account impersonation and basic auth.\n        credentials = self.make_credentials(\n            # Test with JSON format type.\n            credential_source=self.CREDENTIAL_SOURCE_JSON_URL,\n            service_account_impersonation_url=SERVICE_ACCOUNT_IMPERSONATION_URL,\n            scopes=SCOPES,\n        )\n\n        self.assert_underlying_credentials_refresh(\n            credentials=credentials,\n            audience=AUDIENCE,\n            subject_token=JSON_FILE_SUBJECT_TOKEN,\n            subject_token_type=SUBJECT_TOKEN_TYPE,\n            token_url=TOKEN_URL,\n            service_account_impersonation_url=SERVICE_ACCOUNT_IMPERSONATION_URL,\n            basic_auth_encoding=None,\n            quota_project_id=None,\n            used_scopes=SCOPES,\n            scopes=SCOPES,\n            default_scopes=None,\n            credential_data=JSON_FILE_CONTENT,\n        )\n\n    def test_refresh_with_retrieve_subject_token_error_url(self):\n        credential_source = {\n            \"url\": self.CREDENTIAL_URL,\n            \"format\": {\"type\": \"json\", \"subject_token_field_name\": \"not_found\"},\n        }\n        credentials = self.make_credentials(credential_source=credential_source)\n\n        with pytest.raises(exceptions.RefreshError) as excinfo:\n            credentials.refresh(self.make_mock_request(token_data=JSON_FILE_CONTENT))\n\n        assert excinfo.match(\n            \"Unable to parse subject_token from JSON file '{}' using key '{}'\".format(\n                self.CREDENTIAL_URL, \"not_found\"\n            )\n        )\n\n    def test_retrieve_subject_token_supplier(self):\n        supplier = TestSubjectTokenSupplier(subject_token=JSON_FILE_SUBJECT_TOKEN)\n\n        credentials = self.make_credentials(subject_token_supplier=supplier)\n\n        subject_token = credentials.retrieve_subject_token(None)\n\n        assert subject_token == JSON_FILE_SUBJECT_TOKEN\n\n    def test_retrieve_subject_token_supplier_correct_context(self):\n        supplier = TestSubjectTokenSupplier(\n            subject_token=JSON_FILE_SUBJECT_TOKEN,\n            expected_context=external_account.SupplierContext(\n                SUBJECT_TOKEN_TYPE, AUDIENCE\n            ),\n        )\n\n        credentials = self.make_credentials(subject_token_supplier=supplier)\n\n        credentials.retrieve_subject_token(None)\n\n    def test_retrieve_subject_token_supplier_error(self):\n        expected_exception = exceptions.RefreshError(\"test error\")\n        supplier = TestSubjectTokenSupplier(subject_token_exception=expected_exception)\n\n        credentials = self.make_credentials(subject_token_supplier=supplier)\n\n        with pytest.raises(exceptions.RefreshError) as excinfo:\n            credentials.refresh(self.make_mock_request(token_data=JSON_FILE_CONTENT))\n\n        assert excinfo.match(\"test error\")\n\n    def test_refresh_success_supplier_with_impersonation_url(self):\n        # Initialize credentials with service account impersonation and a supplier.\n        supplier = TestSubjectTokenSupplier(subject_token=JSON_FILE_SUBJECT_TOKEN)\n        credentials = self.make_credentials(\n            subject_token_supplier=supplier,\n            service_account_impersonation_url=SERVICE_ACCOUNT_IMPERSONATION_URL,\n            scopes=SCOPES,\n        )\n\n        self.assert_underlying_credentials_refresh(\n            credentials=credentials,\n            audience=AUDIENCE,\n            subject_token=TEXT_FILE_SUBJECT_TOKEN,\n            subject_token_type=SUBJECT_TOKEN_TYPE,\n            token_url=TOKEN_URL,\n            service_account_impersonation_url=SERVICE_ACCOUNT_IMPERSONATION_URL,\n            basic_auth_encoding=None,\n            quota_project_id=None,\n            used_scopes=SCOPES,\n            scopes=SCOPES,\n            default_scopes=None,\n        )\n\n    def test_refresh_success_supplier_without_impersonation_url(self):\n        # Initialize supplier credentials without service account impersonation.\n        supplier = TestSubjectTokenSupplier(subject_token=JSON_FILE_SUBJECT_TOKEN)\n        credentials = self.make_credentials(\n            subject_token_supplier=supplier, scopes=SCOPES\n        )\n\n        self.assert_underlying_credentials_refresh(\n            credentials=credentials,\n            audience=AUDIENCE,\n            subject_token=TEXT_FILE_SUBJECT_TOKEN,\n            subject_token_type=SUBJECT_TOKEN_TYPE,\n            token_url=TOKEN_URL,\n            basic_auth_encoding=None,\n            quota_project_id=None,\n            used_scopes=SCOPES,\n            scopes=SCOPES,\n            default_scopes=None,\n        )\n", "tests/test_impersonated_credentials.py": "# Copyright 2018 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport datetime\nimport http.client as http_client\nimport json\nimport os\n\nimport mock\nimport pytest  # type: ignore\n\nfrom google.auth import _helpers\nfrom google.auth import crypt\nfrom google.auth import exceptions\nfrom google.auth import impersonated_credentials\nfrom google.auth import transport\nfrom google.auth.impersonated_credentials import Credentials\nfrom google.oauth2 import credentials\nfrom google.oauth2 import service_account\n\nDATA_DIR = os.path.join(os.path.dirname(__file__), \"\", \"data\")\n\nwith open(os.path.join(DATA_DIR, \"privatekey.pem\"), \"rb\") as fh:\n    PRIVATE_KEY_BYTES = fh.read()\n\nSERVICE_ACCOUNT_JSON_FILE = os.path.join(DATA_DIR, \"service_account.json\")\n\nID_TOKEN_DATA = (\n    \"eyJhbGciOiJSUzI1NiIsImtpZCI6ImRmMzc1ODkwOGI3OTIyOTNhZDk3N2Ew\"\n    \"Yjk5MWQ5OGE3N2Y0ZWVlY2QiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJodHRwc\"\n    \"zovL2Zvby5iYXIiLCJhenAiOiIxMDIxMDE1NTA4MzQyMDA3MDg1NjgiLCJle\"\n    \"HAiOjE1NjQ0NzUwNTEsImlhdCI6MTU2NDQ3MTQ1MSwiaXNzIjoiaHR0cHM6L\"\n    \"y9hY2NvdW50cy5nb29nbGUuY29tIiwic3ViIjoiMTAyMTAxNTUwODM0MjAwN\"\n    \"zA4NTY4In0.redacted\"\n)\nID_TOKEN_EXPIRY = 1564475051\n\nwith open(SERVICE_ACCOUNT_JSON_FILE, \"rb\") as fh:\n    SERVICE_ACCOUNT_INFO = json.load(fh)\n\nSIGNER = crypt.RSASigner.from_string(PRIVATE_KEY_BYTES, \"1\")\nTOKEN_URI = \"https://example.com/oauth2/token\"\n\nACCESS_TOKEN_REQUEST_METRICS_HEADER_VALUE = (\n    \"gl-python/3.7 auth/1.1 auth-request-type/at cred-type/imp\"\n)\nID_TOKEN_REQUEST_METRICS_HEADER_VALUE = (\n    \"gl-python/3.7 auth/1.1 auth-request-type/it cred-type/imp\"\n)\n\n\n@pytest.fixture\ndef mock_donor_credentials():\n    with mock.patch(\"google.oauth2._client.jwt_grant\", autospec=True) as grant:\n        grant.return_value = (\n            \"source token\",\n            _helpers.utcnow() + datetime.timedelta(seconds=500),\n            {},\n        )\n        yield grant\n\n\nclass MockResponse:\n    def __init__(self, json_data, status_code):\n        self.json_data = json_data\n        self.status_code = status_code\n\n    def json(self):\n        return self.json_data\n\n\n@pytest.fixture\ndef mock_authorizedsession_sign():\n    with mock.patch(\n        \"google.auth.transport.requests.AuthorizedSession.request\", autospec=True\n    ) as auth_session:\n        data = {\"keyId\": \"1\", \"signedBlob\": \"c2lnbmF0dXJl\"}\n        auth_session.return_value = MockResponse(data, http_client.OK)\n        yield auth_session\n\n\n@pytest.fixture\ndef mock_authorizedsession_idtoken():\n    with mock.patch(\n        \"google.auth.transport.requests.AuthorizedSession.request\", autospec=True\n    ) as auth_session:\n        data = {\"token\": ID_TOKEN_DATA}\n        auth_session.return_value = MockResponse(data, http_client.OK)\n        yield auth_session\n\n\nclass TestImpersonatedCredentials(object):\n\n    SERVICE_ACCOUNT_EMAIL = \"service-account@example.com\"\n    TARGET_PRINCIPAL = \"impersonated@project.iam.gserviceaccount.com\"\n    TARGET_SCOPES = [\"https://www.googleapis.com/auth/devstorage.read_only\"]\n    # DELEGATES: List[str] = []\n    # Because Python 2.7:\n    DELEGATES = []  # type: ignore\n    LIFETIME = 3600\n    SOURCE_CREDENTIALS = service_account.Credentials(\n        SIGNER, SERVICE_ACCOUNT_EMAIL, TOKEN_URI\n    )\n    USER_SOURCE_CREDENTIALS = credentials.Credentials(token=\"ABCDE\")\n    IAM_ENDPOINT_OVERRIDE = (\n        \"https://us-east1-iamcredentials.googleapis.com/v1/projects/-\"\n        + \"/serviceAccounts/{}:generateAccessToken\".format(SERVICE_ACCOUNT_EMAIL)\n    )\n\n    def make_credentials(\n        self,\n        source_credentials=SOURCE_CREDENTIALS,\n        lifetime=LIFETIME,\n        target_principal=TARGET_PRINCIPAL,\n        iam_endpoint_override=None,\n    ):\n\n        return Credentials(\n            source_credentials=source_credentials,\n            target_principal=target_principal,\n            target_scopes=self.TARGET_SCOPES,\n            delegates=self.DELEGATES,\n            lifetime=lifetime,\n            iam_endpoint_override=iam_endpoint_override,\n        )\n\n    def test_make_from_user_credentials(self):\n        credentials = self.make_credentials(\n            source_credentials=self.USER_SOURCE_CREDENTIALS\n        )\n        assert not credentials.valid\n        assert credentials.expired\n\n    def test_default_state(self):\n        credentials = self.make_credentials()\n        assert not credentials.valid\n        assert credentials.expired\n\n    def test_make_from_service_account_self_signed_jwt(self):\n        source_credentials = service_account.Credentials(\n            SIGNER, self.SERVICE_ACCOUNT_EMAIL, TOKEN_URI, always_use_jwt_access=True\n        )\n        credentials = self.make_credentials(source_credentials=source_credentials)\n        # test the source credential don't lose self signed jwt setting\n        assert credentials._source_credentials._always_use_jwt_access\n        assert credentials._source_credentials._jwt_credentials\n\n    def make_request(\n        self,\n        data,\n        status=http_client.OK,\n        headers=None,\n        side_effect=None,\n        use_data_bytes=True,\n    ):\n        response = mock.create_autospec(transport.Response, instance=False)\n        response.status = status\n        response.data = _helpers.to_bytes(data) if use_data_bytes else data\n        response.headers = headers or {}\n\n        request = mock.create_autospec(transport.Request, instance=False)\n        request.side_effect = side_effect\n        request.return_value = response\n\n        return request\n\n    def test_token_usage_metrics(self):\n        credentials = self.make_credentials()\n        credentials.token = \"token\"\n        credentials.expiry = None\n\n        headers = {}\n        credentials.before_request(mock.Mock(), None, None, headers)\n        assert headers[\"authorization\"] == \"Bearer token\"\n        assert headers[\"x-goog-api-client\"] == \"cred-type/imp\"\n\n    @pytest.mark.parametrize(\"use_data_bytes\", [True, False])\n    def test_refresh_success(self, use_data_bytes, mock_donor_credentials):\n        credentials = self.make_credentials(lifetime=None)\n        token = \"token\"\n\n        expire_time = (\n            _helpers.utcnow().replace(microsecond=0) + datetime.timedelta(seconds=500)\n        ).isoformat(\"T\") + \"Z\"\n        response_body = {\"accessToken\": token, \"expireTime\": expire_time}\n\n        request = self.make_request(\n            data=json.dumps(response_body),\n            status=http_client.OK,\n            use_data_bytes=use_data_bytes,\n        )\n\n        with mock.patch(\n            \"google.auth.metrics.token_request_access_token_impersonate\",\n            return_value=ACCESS_TOKEN_REQUEST_METRICS_HEADER_VALUE,\n        ):\n            credentials.refresh(request)\n\n        assert credentials.valid\n        assert not credentials.expired\n        assert (\n            request.call_args.kwargs[\"headers\"][\"x-goog-api-client\"]\n            == ACCESS_TOKEN_REQUEST_METRICS_HEADER_VALUE\n        )\n\n    @pytest.mark.parametrize(\"use_data_bytes\", [True, False])\n    def test_refresh_success_iam_endpoint_override(\n        self, use_data_bytes, mock_donor_credentials\n    ):\n        credentials = self.make_credentials(\n            lifetime=None, iam_endpoint_override=self.IAM_ENDPOINT_OVERRIDE\n        )\n        token = \"token\"\n\n        expire_time = (\n            _helpers.utcnow().replace(microsecond=0) + datetime.timedelta(seconds=500)\n        ).isoformat(\"T\") + \"Z\"\n        response_body = {\"accessToken\": token, \"expireTime\": expire_time}\n\n        request = self.make_request(\n            data=json.dumps(response_body),\n            status=http_client.OK,\n            use_data_bytes=use_data_bytes,\n        )\n\n        credentials.refresh(request)\n\n        assert credentials.valid\n        assert not credentials.expired\n        # Confirm override endpoint used.\n        request_kwargs = request.call_args[1]\n        assert request_kwargs[\"url\"] == self.IAM_ENDPOINT_OVERRIDE\n\n    @pytest.mark.parametrize(\"time_skew\", [150, -150])\n    def test_refresh_source_credentials(self, time_skew):\n        credentials = self.make_credentials(lifetime=None)\n\n        # Source credentials is refreshed only if it is expired within\n        # _helpers.REFRESH_THRESHOLD from now. We add a time_skew to the expiry, so\n        # source credentials is refreshed only if time_skew <= 0.\n        credentials._source_credentials.expiry = (\n            _helpers.utcnow()\n            + _helpers.REFRESH_THRESHOLD\n            + datetime.timedelta(seconds=time_skew)\n        )\n        credentials._source_credentials.token = \"Token\"\n\n        with mock.patch(\n            \"google.oauth2.service_account.Credentials.refresh\", autospec=True\n        ) as source_cred_refresh:\n            expire_time = (\n                _helpers.utcnow().replace(microsecond=0)\n                + datetime.timedelta(seconds=500)\n            ).isoformat(\"T\") + \"Z\"\n            response_body = {\"accessToken\": \"token\", \"expireTime\": expire_time}\n            request = self.make_request(\n                data=json.dumps(response_body), status=http_client.OK\n            )\n\n            credentials.refresh(request)\n\n            assert credentials.valid\n            assert not credentials.expired\n\n            # Source credentials is refreshed only if it is expired within\n            # _helpers.REFRESH_THRESHOLD\n            if time_skew > 0:\n                source_cred_refresh.assert_not_called()\n            else:\n                source_cred_refresh.assert_called_once()\n\n    def test_refresh_failure_malformed_expire_time(self, mock_donor_credentials):\n        credentials = self.make_credentials(lifetime=None)\n        token = \"token\"\n\n        expire_time = (_helpers.utcnow() + datetime.timedelta(seconds=500)).isoformat(\n            \"T\"\n        )\n        response_body = {\"accessToken\": token, \"expireTime\": expire_time}\n\n        request = self.make_request(\n            data=json.dumps(response_body), status=http_client.OK\n        )\n\n        with pytest.raises(exceptions.RefreshError) as excinfo:\n            credentials.refresh(request)\n\n        assert excinfo.match(impersonated_credentials._REFRESH_ERROR)\n\n        assert not credentials.valid\n        assert credentials.expired\n\n    def test_refresh_failure_unauthorzed(self, mock_donor_credentials):\n        credentials = self.make_credentials(lifetime=None)\n\n        response_body = {\n            \"error\": {\n                \"code\": 403,\n                \"message\": \"The caller does not have permission\",\n                \"status\": \"PERMISSION_DENIED\",\n            }\n        }\n\n        request = self.make_request(\n            data=json.dumps(response_body), status=http_client.UNAUTHORIZED\n        )\n\n        with pytest.raises(exceptions.RefreshError) as excinfo:\n            credentials.refresh(request)\n\n        assert excinfo.match(impersonated_credentials._REFRESH_ERROR)\n\n        assert not credentials.valid\n        assert credentials.expired\n\n    def test_refresh_failure(self):\n        credentials = self.make_credentials(lifetime=None)\n        credentials.expiry = None\n        credentials.token = \"token\"\n        id_creds = impersonated_credentials.IDTokenCredentials(\n            credentials, target_audience=\"audience\"\n        )\n\n        response = mock.create_autospec(transport.Response, instance=False)\n        response.status_code = http_client.UNAUTHORIZED\n        response.json = mock.Mock(return_value=\"failed to get ID token\")\n\n        with mock.patch(\n            \"google.auth.transport.requests.AuthorizedSession.post\",\n            return_value=response,\n        ):\n            with pytest.raises(exceptions.RefreshError) as excinfo:\n                id_creds.refresh(None)\n\n        assert excinfo.match(\"Error getting ID token\")\n\n    def test_refresh_failure_http_error(self, mock_donor_credentials):\n        credentials = self.make_credentials(lifetime=None)\n\n        response_body = {}\n\n        request = self.make_request(\n            data=json.dumps(response_body), status=http_client.HTTPException\n        )\n\n        with pytest.raises(exceptions.RefreshError) as excinfo:\n            credentials.refresh(request)\n\n        assert excinfo.match(impersonated_credentials._REFRESH_ERROR)\n\n        assert not credentials.valid\n        assert credentials.expired\n\n    def test_expired(self):\n        credentials = self.make_credentials(lifetime=None)\n        assert credentials.expired\n\n    def test_signer(self):\n        credentials = self.make_credentials()\n        assert isinstance(credentials.signer, impersonated_credentials.Credentials)\n\n    def test_signer_email(self):\n        credentials = self.make_credentials(target_principal=self.TARGET_PRINCIPAL)\n        assert credentials.signer_email == self.TARGET_PRINCIPAL\n\n    def test_service_account_email(self):\n        credentials = self.make_credentials(target_principal=self.TARGET_PRINCIPAL)\n        assert credentials.service_account_email == self.TARGET_PRINCIPAL\n\n    def test_sign_bytes(self, mock_donor_credentials, mock_authorizedsession_sign):\n        credentials = self.make_credentials(lifetime=None)\n        token = \"token\"\n\n        expire_time = (\n            _helpers.utcnow().replace(microsecond=0) + datetime.timedelta(seconds=500)\n        ).isoformat(\"T\") + \"Z\"\n        token_response_body = {\"accessToken\": token, \"expireTime\": expire_time}\n\n        response = mock.create_autospec(transport.Response, instance=False)\n        response.status = http_client.OK\n        response.data = _helpers.to_bytes(json.dumps(token_response_body))\n\n        request = mock.create_autospec(transport.Request, instance=False)\n        request.return_value = response\n\n        credentials.refresh(request)\n\n        assert credentials.valid\n        assert not credentials.expired\n\n        signature = credentials.sign_bytes(b\"signed bytes\")\n        assert signature == b\"signature\"\n\n    def test_sign_bytes_failure(self):\n        credentials = self.make_credentials(lifetime=None)\n\n        with mock.patch(\n            \"google.auth.transport.requests.AuthorizedSession.request\", autospec=True\n        ) as auth_session:\n            data = {\"error\": {\"code\": 403, \"message\": \"unauthorized\"}}\n            auth_session.return_value = MockResponse(data, http_client.FORBIDDEN)\n\n            with pytest.raises(exceptions.TransportError) as excinfo:\n                credentials.sign_bytes(b\"foo\")\n            assert excinfo.match(\"'code': 403\")\n\n    def test_with_quota_project(self):\n        credentials = self.make_credentials()\n\n        quota_project_creds = credentials.with_quota_project(\"project-foo\")\n        assert quota_project_creds._quota_project_id == \"project-foo\"\n\n    @pytest.mark.parametrize(\"use_data_bytes\", [True, False])\n    def test_with_quota_project_iam_endpoint_override(\n        self, use_data_bytes, mock_donor_credentials\n    ):\n        credentials = self.make_credentials(\n            lifetime=None, iam_endpoint_override=self.IAM_ENDPOINT_OVERRIDE\n        )\n        token = \"token\"\n        # iam_endpoint_override should be copied to created credentials.\n        quota_project_creds = credentials.with_quota_project(\"project-foo\")\n\n        expire_time = (\n            _helpers.utcnow().replace(microsecond=0) + datetime.timedelta(seconds=500)\n        ).isoformat(\"T\") + \"Z\"\n        response_body = {\"accessToken\": token, \"expireTime\": expire_time}\n\n        request = self.make_request(\n            data=json.dumps(response_body),\n            status=http_client.OK,\n            use_data_bytes=use_data_bytes,\n        )\n\n        quota_project_creds.refresh(request)\n\n        assert quota_project_creds.valid\n        assert not quota_project_creds.expired\n        # Confirm override endpoint used.\n        request_kwargs = request.call_args[1]\n        assert request_kwargs[\"url\"] == self.IAM_ENDPOINT_OVERRIDE\n\n    def test_with_scopes(self):\n        credentials = self.make_credentials()\n        credentials._target_scopes = []\n        assert credentials.requires_scopes is True\n        credentials = credentials.with_scopes([\"fake_scope1\", \"fake_scope2\"])\n        assert credentials.requires_scopes is False\n        assert credentials._target_scopes == [\"fake_scope1\", \"fake_scope2\"]\n\n    def test_with_scopes_provide_default_scopes(self):\n        credentials = self.make_credentials()\n        credentials._target_scopes = []\n        credentials = credentials.with_scopes(\n            [\"fake_scope1\"], default_scopes=[\"fake_scope2\"]\n        )\n        assert credentials._target_scopes == [\"fake_scope1\"]\n\n    def test_id_token_success(\n        self, mock_donor_credentials, mock_authorizedsession_idtoken\n    ):\n        credentials = self.make_credentials(lifetime=None)\n        token = \"token\"\n        target_audience = \"https://foo.bar\"\n\n        expire_time = (\n            _helpers.utcnow().replace(microsecond=0) + datetime.timedelta(seconds=500)\n        ).isoformat(\"T\") + \"Z\"\n        response_body = {\"accessToken\": token, \"expireTime\": expire_time}\n\n        request = self.make_request(\n            data=json.dumps(response_body), status=http_client.OK\n        )\n\n        credentials.refresh(request)\n\n        assert credentials.valid\n        assert not credentials.expired\n\n        id_creds = impersonated_credentials.IDTokenCredentials(\n            credentials, target_audience=target_audience\n        )\n        id_creds.refresh(request)\n\n        assert id_creds.token == ID_TOKEN_DATA\n        assert id_creds.expiry == datetime.datetime.utcfromtimestamp(ID_TOKEN_EXPIRY)\n\n    def test_id_token_metrics(self, mock_donor_credentials):\n        credentials = self.make_credentials(lifetime=None)\n        credentials.token = \"token\"\n        credentials.expiry = None\n        target_audience = \"https://foo.bar\"\n\n        id_creds = impersonated_credentials.IDTokenCredentials(\n            credentials, target_audience=target_audience\n        )\n\n        with mock.patch(\n            \"google.auth.metrics.token_request_id_token_impersonate\",\n            return_value=ID_TOKEN_REQUEST_METRICS_HEADER_VALUE,\n        ):\n            with mock.patch(\n                \"google.auth.transport.requests.AuthorizedSession.post\", autospec=True\n            ) as mock_post:\n                data = {\"token\": ID_TOKEN_DATA}\n                mock_post.return_value = MockResponse(data, http_client.OK)\n                id_creds.refresh(None)\n\n                assert id_creds.token == ID_TOKEN_DATA\n                assert id_creds.expiry == datetime.datetime.utcfromtimestamp(\n                    ID_TOKEN_EXPIRY\n                )\n                assert (\n                    mock_post.call_args.kwargs[\"headers\"][\"x-goog-api-client\"]\n                    == ID_TOKEN_REQUEST_METRICS_HEADER_VALUE\n                )\n\n    def test_id_token_from_credential(\n        self, mock_donor_credentials, mock_authorizedsession_idtoken\n    ):\n        credentials = self.make_credentials(lifetime=None)\n        token = \"token\"\n        target_audience = \"https://foo.bar\"\n\n        expire_time = (\n            _helpers.utcnow().replace(microsecond=0) + datetime.timedelta(seconds=500)\n        ).isoformat(\"T\") + \"Z\"\n        response_body = {\"accessToken\": token, \"expireTime\": expire_time}\n\n        request = self.make_request(\n            data=json.dumps(response_body), status=http_client.OK\n        )\n\n        credentials.refresh(request)\n\n        assert credentials.valid\n        assert not credentials.expired\n\n        new_credentials = self.make_credentials(lifetime=None)\n\n        id_creds = impersonated_credentials.IDTokenCredentials(\n            credentials, target_audience=target_audience, include_email=True\n        )\n        id_creds = id_creds.from_credentials(target_credentials=new_credentials)\n        id_creds.refresh(request)\n\n        assert id_creds.token == ID_TOKEN_DATA\n        assert id_creds._include_email is True\n        assert id_creds._target_credentials is new_credentials\n\n    def test_id_token_with_target_audience(\n        self, mock_donor_credentials, mock_authorizedsession_idtoken\n    ):\n        credentials = self.make_credentials(lifetime=None)\n        token = \"token\"\n        target_audience = \"https://foo.bar\"\n\n        expire_time = (\n            _helpers.utcnow().replace(microsecond=0) + datetime.timedelta(seconds=500)\n        ).isoformat(\"T\") + \"Z\"\n        response_body = {\"accessToken\": token, \"expireTime\": expire_time}\n\n        request = self.make_request(\n            data=json.dumps(response_body), status=http_client.OK\n        )\n\n        credentials.refresh(request)\n\n        assert credentials.valid\n        assert not credentials.expired\n\n        id_creds = impersonated_credentials.IDTokenCredentials(\n            credentials, include_email=True\n        )\n        id_creds = id_creds.with_target_audience(target_audience=target_audience)\n        id_creds.refresh(request)\n\n        assert id_creds.token == ID_TOKEN_DATA\n        assert id_creds.expiry == datetime.datetime.utcfromtimestamp(ID_TOKEN_EXPIRY)\n        assert id_creds._include_email is True\n\n    def test_id_token_invalid_cred(\n        self, mock_donor_credentials, mock_authorizedsession_idtoken\n    ):\n        credentials = None\n\n        with pytest.raises(exceptions.GoogleAuthError) as excinfo:\n            impersonated_credentials.IDTokenCredentials(credentials)\n\n        assert excinfo.match(\"Provided Credential must be\" \" impersonated_credentials\")\n\n    def test_id_token_with_include_email(\n        self, mock_donor_credentials, mock_authorizedsession_idtoken\n    ):\n        credentials = self.make_credentials(lifetime=None)\n        token = \"token\"\n        target_audience = \"https://foo.bar\"\n\n        expire_time = (\n            _helpers.utcnow().replace(microsecond=0) + datetime.timedelta(seconds=500)\n        ).isoformat(\"T\") + \"Z\"\n        response_body = {\"accessToken\": token, \"expireTime\": expire_time}\n\n        request = self.make_request(\n            data=json.dumps(response_body), status=http_client.OK\n        )\n\n        credentials.refresh(request)\n\n        assert credentials.valid\n        assert not credentials.expired\n\n        id_creds = impersonated_credentials.IDTokenCredentials(\n            credentials, target_audience=target_audience\n        )\n        id_creds = id_creds.with_include_email(True)\n        id_creds.refresh(request)\n\n        assert id_creds.token == ID_TOKEN_DATA\n\n    def test_id_token_with_quota_project(\n        self, mock_donor_credentials, mock_authorizedsession_idtoken\n    ):\n        credentials = self.make_credentials(lifetime=None)\n        token = \"token\"\n        target_audience = \"https://foo.bar\"\n\n        expire_time = (\n            _helpers.utcnow().replace(microsecond=0) + datetime.timedelta(seconds=500)\n        ).isoformat(\"T\") + \"Z\"\n        response_body = {\"accessToken\": token, \"expireTime\": expire_time}\n\n        request = self.make_request(\n            data=json.dumps(response_body), status=http_client.OK\n        )\n\n        credentials.refresh(request)\n\n        assert credentials.valid\n        assert not credentials.expired\n\n        id_creds = impersonated_credentials.IDTokenCredentials(\n            credentials, target_audience=target_audience\n        )\n        id_creds = id_creds.with_quota_project(\"project-foo\")\n        id_creds.refresh(request)\n\n        assert id_creds.quota_project_id == \"project-foo\"\n", "tests/test_pluggable.py": "# Copyright 2022 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport json\nimport os\nimport subprocess\n\nimport mock\nimport pytest  # type: ignore\n\nfrom google.auth import exceptions\nfrom google.auth import pluggable\nfrom google.auth.credentials import DEFAULT_UNIVERSE_DOMAIN\nfrom tests.test__default import WORKFORCE_AUDIENCE\n\nCLIENT_ID = \"username\"\nCLIENT_SECRET = \"password\"\n# Base64 encoding of \"username:password\".\nBASIC_AUTH_ENCODING = \"dXNlcm5hbWU6cGFzc3dvcmQ=\"\nSERVICE_ACCOUNT_EMAIL = \"service-1234@service-name.iam.gserviceaccount.com\"\nSERVICE_ACCOUNT_IMPERSONATION_URL_BASE = (\n    \"https://us-east1-iamcredentials.googleapis.com\"\n)\nSERVICE_ACCOUNT_IMPERSONATION_URL_ROUTE = \"/v1/projects/-/serviceAccounts/{}:generateAccessToken\".format(\n    SERVICE_ACCOUNT_EMAIL\n)\nSERVICE_ACCOUNT_IMPERSONATION_URL = (\n    SERVICE_ACCOUNT_IMPERSONATION_URL_BASE + SERVICE_ACCOUNT_IMPERSONATION_URL_ROUTE\n)\nQUOTA_PROJECT_ID = \"QUOTA_PROJECT_ID\"\nSCOPES = [\"scope1\", \"scope2\"]\nSUBJECT_TOKEN_FIELD_NAME = \"access_token\"\n\nTOKEN_URL = \"https://sts.googleapis.com/v1/token\"\nTOKEN_INFO_URL = \"https://sts.googleapis.com/v1/introspect\"\nSUBJECT_TOKEN_TYPE = \"urn:ietf:params:oauth:token-type:jwt\"\nAUDIENCE = \"//iam.googleapis.com/projects/123456/locations/global/workloadIdentityPools/POOL_ID/providers/PROVIDER_ID\"\n\nVALID_TOKEN_URLS = [\n    \"https://sts.googleapis.com\",\n    \"https://us-east-1.sts.googleapis.com\",\n    \"https://US-EAST-1.sts.googleapis.com\",\n    \"https://sts.us-east-1.googleapis.com\",\n    \"https://sts.US-WEST-1.googleapis.com\",\n    \"https://us-east-1-sts.googleapis.com\",\n    \"https://US-WEST-1-sts.googleapis.com\",\n    \"https://us-west-1-sts.googleapis.com/path?query\",\n    \"https://sts-us-east-1.p.googleapis.com\",\n]\nINVALID_TOKEN_URLS = [\n    \"https://iamcredentials.googleapis.com\",\n    \"sts.googleapis.com\",\n    \"https://\",\n    \"http://sts.googleapis.com\",\n    \"https://st.s.googleapis.com\",\n    \"https://us-eas\\t-1.sts.googleapis.com\",\n    \"https:/us-east-1.sts.googleapis.com\",\n    \"https://US-WE/ST-1-sts.googleapis.com\",\n    \"https://sts-us-east-1.googleapis.com\",\n    \"https://sts-US-WEST-1.googleapis.com\",\n    \"testhttps://us-east-1.sts.googleapis.com\",\n    \"https://us-east-1.sts.googleapis.comevil.com\",\n    \"https://us-east-1.us-east-1.sts.googleapis.com\",\n    \"https://us-ea.s.t.sts.googleapis.com\",\n    \"https://sts.googleapis.comevil.com\",\n    \"hhttps://us-east-1.sts.googleapis.com\",\n    \"https://us- -1.sts.googleapis.com\",\n    \"https://-sts.googleapis.com\",\n    \"https://us-east-1.sts.googleapis.com.evil.com\",\n    \"https://sts.pgoogleapis.com\",\n    \"https://p.googleapis.com\",\n    \"https://sts.p.com\",\n    \"http://sts.p.googleapis.com\",\n    \"https://xyz-sts.p.googleapis.com\",\n    \"https://sts-xyz.123.p.googleapis.com\",\n    \"https://sts-xyz.p1.googleapis.com\",\n    \"https://sts-xyz.p.foo.com\",\n    \"https://sts-xyz.p.foo.googleapis.com\",\n]\nVALID_SERVICE_ACCOUNT_IMPERSONATION_URLS = [\n    \"https://iamcredentials.googleapis.com\",\n    \"https://us-east-1.iamcredentials.googleapis.com\",\n    \"https://US-EAST-1.iamcredentials.googleapis.com\",\n    \"https://iamcredentials.us-east-1.googleapis.com\",\n    \"https://iamcredentials.US-WEST-1.googleapis.com\",\n    \"https://us-east-1-iamcredentials.googleapis.com\",\n    \"https://US-WEST-1-iamcredentials.googleapis.com\",\n    \"https://us-west-1-iamcredentials.googleapis.com/path?query\",\n    \"https://iamcredentials-us-east-1.p.googleapis.com\",\n]\nINVALID_SERVICE_ACCOUNT_IMPERSONATION_URLS = [\n    \"https://sts.googleapis.com\",\n    \"iamcredentials.googleapis.com\",\n    \"https://\",\n    \"http://iamcredentials.googleapis.com\",\n    \"https://iamcre.dentials.googleapis.com\",\n    \"https://us-eas\\t-1.iamcredentials.googleapis.com\",\n    \"https:/us-east-1.iamcredentials.googleapis.com\",\n    \"https://US-WE/ST-1-iamcredentials.googleapis.com\",\n    \"https://iamcredentials-us-east-1.googleapis.com\",\n    \"https://iamcredentials-US-WEST-1.googleapis.com\",\n    \"testhttps://us-east-1.iamcredentials.googleapis.com\",\n    \"https://us-east-1.iamcredentials.googleapis.comevil.com\",\n    \"https://us-east-1.us-east-1.iamcredentials.googleapis.com\",\n    \"https://us-ea.s.t.iamcredentials.googleapis.com\",\n    \"https://iamcredentials.googleapis.comevil.com\",\n    \"hhttps://us-east-1.iamcredentials.googleapis.com\",\n    \"https://us- -1.iamcredentials.googleapis.com\",\n    \"https://-iamcredentials.googleapis.com\",\n    \"https://us-east-1.iamcredentials.googleapis.com.evil.com\",\n    \"https://iamcredentials.pgoogleapis.com\",\n    \"https://p.googleapis.com\",\n    \"https://iamcredentials.p.com\",\n    \"http://iamcredentials.p.googleapis.com\",\n    \"https://xyz-iamcredentials.p.googleapis.com\",\n    \"https://iamcredentials-xyz.123.p.googleapis.com\",\n    \"https://iamcredentials-xyz.p1.googleapis.com\",\n    \"https://iamcredentials-xyz.p.foo.com\",\n    \"https://iamcredentials-xyz.p.foo.googleapis.com\",\n]\n\n\nclass TestCredentials(object):\n    CREDENTIAL_SOURCE_EXECUTABLE_COMMAND = (\n        \"/fake/external/excutable --arg1=value1 --arg2=value2\"\n    )\n    CREDENTIAL_SOURCE_EXECUTABLE_OUTPUT_FILE = \"fake_output_file\"\n    CREDENTIAL_SOURCE_EXECUTABLE = {\n        \"command\": CREDENTIAL_SOURCE_EXECUTABLE_COMMAND,\n        \"timeout_millis\": 30000,\n        \"interactive_timeout_millis\": 300000,\n        \"output_file\": CREDENTIAL_SOURCE_EXECUTABLE_OUTPUT_FILE,\n    }\n    CREDENTIAL_SOURCE = {\"executable\": CREDENTIAL_SOURCE_EXECUTABLE}\n    EXECUTABLE_OIDC_TOKEN = \"FAKE_ID_TOKEN\"\n    EXECUTABLE_SUCCESSFUL_OIDC_RESPONSE_ID_TOKEN = {\n        \"version\": 1,\n        \"success\": True,\n        \"token_type\": \"urn:ietf:params:oauth:token-type:id_token\",\n        \"id_token\": EXECUTABLE_OIDC_TOKEN,\n        \"expiration_time\": 9999999999,\n    }\n    EXECUTABLE_SUCCESSFUL_OIDC_NO_EXPIRATION_TIME_RESPONSE_ID_TOKEN = {\n        \"version\": 1,\n        \"success\": True,\n        \"token_type\": \"urn:ietf:params:oauth:token-type:id_token\",\n        \"id_token\": EXECUTABLE_OIDC_TOKEN,\n    }\n    EXECUTABLE_SUCCESSFUL_OIDC_RESPONSE_JWT = {\n        \"version\": 1,\n        \"success\": True,\n        \"token_type\": \"urn:ietf:params:oauth:token-type:jwt\",\n        \"id_token\": EXECUTABLE_OIDC_TOKEN,\n        \"expiration_time\": 9999999999,\n    }\n    EXECUTABLE_SUCCESSFUL_OIDC_NO_EXPIRATION_TIME_RESPONSE_JWT = {\n        \"version\": 1,\n        \"success\": True,\n        \"token_type\": \"urn:ietf:params:oauth:token-type:jwt\",\n        \"id_token\": EXECUTABLE_OIDC_TOKEN,\n    }\n    EXECUTABLE_SAML_TOKEN = \"FAKE_SAML_RESPONSE\"\n    EXECUTABLE_SUCCESSFUL_SAML_RESPONSE = {\n        \"version\": 1,\n        \"success\": True,\n        \"token_type\": \"urn:ietf:params:oauth:token-type:saml2\",\n        \"saml_response\": EXECUTABLE_SAML_TOKEN,\n        \"expiration_time\": 9999999999,\n    }\n    EXECUTABLE_SUCCESSFUL_SAML_NO_EXPIRATION_TIME_RESPONSE = {\n        \"version\": 1,\n        \"success\": True,\n        \"token_type\": \"urn:ietf:params:oauth:token-type:saml2\",\n        \"saml_response\": EXECUTABLE_SAML_TOKEN,\n    }\n    EXECUTABLE_FAILED_RESPONSE = {\n        \"version\": 1,\n        \"success\": False,\n        \"code\": \"401\",\n        \"message\": \"Permission denied. Caller not authorized\",\n    }\n    CREDENTIAL_URL = \"http://fakeurl.com\"\n\n    @classmethod\n    def make_pluggable(\n        cls,\n        audience=AUDIENCE,\n        subject_token_type=SUBJECT_TOKEN_TYPE,\n        token_url=TOKEN_URL,\n        token_info_url=TOKEN_INFO_URL,\n        client_id=None,\n        client_secret=None,\n        quota_project_id=None,\n        scopes=None,\n        default_scopes=None,\n        service_account_impersonation_url=None,\n        credential_source=None,\n        workforce_pool_user_project=None,\n        interactive=None,\n    ):\n        return pluggable.Credentials(\n            audience=audience,\n            subject_token_type=subject_token_type,\n            token_url=token_url,\n            token_info_url=token_info_url,\n            service_account_impersonation_url=service_account_impersonation_url,\n            credential_source=credential_source,\n            client_id=client_id,\n            client_secret=client_secret,\n            quota_project_id=quota_project_id,\n            scopes=scopes,\n            default_scopes=default_scopes,\n            workforce_pool_user_project=workforce_pool_user_project,\n            interactive=interactive,\n        )\n\n    def test_from_constructor_and_injection(self):\n        credentials = pluggable.Credentials(\n            audience=AUDIENCE,\n            subject_token_type=SUBJECT_TOKEN_TYPE,\n            token_url=TOKEN_URL,\n            token_info_url=TOKEN_INFO_URL,\n            credential_source=self.CREDENTIAL_SOURCE,\n            interactive=True,\n        )\n        setattr(credentials, \"_tokeninfo_username\", \"mock_external_account_id\")\n\n        assert isinstance(credentials, pluggable.Credentials)\n        assert credentials.interactive\n        assert credentials.external_account_id == \"mock_external_account_id\"\n\n    @mock.patch.object(pluggable.Credentials, \"__init__\", return_value=None)\n    def test_from_info_full_options(self, mock_init):\n        credentials = pluggable.Credentials.from_info(\n            {\n                \"audience\": AUDIENCE,\n                \"subject_token_type\": SUBJECT_TOKEN_TYPE,\n                \"token_url\": TOKEN_URL,\n                \"token_info_url\": TOKEN_INFO_URL,\n                \"service_account_impersonation_url\": SERVICE_ACCOUNT_IMPERSONATION_URL,\n                \"service_account_impersonation\": {\"token_lifetime_seconds\": 2800},\n                \"client_id\": CLIENT_ID,\n                \"client_secret\": CLIENT_SECRET,\n                \"quota_project_id\": QUOTA_PROJECT_ID,\n                \"credential_source\": self.CREDENTIAL_SOURCE,\n            }\n        )\n\n        # Confirm pluggable.Credentials instantiated with expected attributes.\n        assert isinstance(credentials, pluggable.Credentials)\n        mock_init.assert_called_once_with(\n            audience=AUDIENCE,\n            subject_token_type=SUBJECT_TOKEN_TYPE,\n            token_url=TOKEN_URL,\n            token_info_url=TOKEN_INFO_URL,\n            service_account_impersonation_url=SERVICE_ACCOUNT_IMPERSONATION_URL,\n            service_account_impersonation_options={\"token_lifetime_seconds\": 2800},\n            client_id=CLIENT_ID,\n            client_secret=CLIENT_SECRET,\n            credential_source=self.CREDENTIAL_SOURCE,\n            quota_project_id=QUOTA_PROJECT_ID,\n            workforce_pool_user_project=None,\n            universe_domain=DEFAULT_UNIVERSE_DOMAIN,\n        )\n\n    @mock.patch.object(pluggable.Credentials, \"__init__\", return_value=None)\n    def test_from_info_required_options_only(self, mock_init):\n        credentials = pluggable.Credentials.from_info(\n            {\n                \"audience\": AUDIENCE,\n                \"subject_token_type\": SUBJECT_TOKEN_TYPE,\n                \"token_url\": TOKEN_URL,\n                \"credential_source\": self.CREDENTIAL_SOURCE,\n            }\n        )\n\n        # Confirm pluggable.Credentials instantiated with expected attributes.\n        assert isinstance(credentials, pluggable.Credentials)\n        mock_init.assert_called_once_with(\n            audience=AUDIENCE,\n            subject_token_type=SUBJECT_TOKEN_TYPE,\n            token_url=TOKEN_URL,\n            token_info_url=None,\n            service_account_impersonation_url=None,\n            service_account_impersonation_options={},\n            client_id=None,\n            client_secret=None,\n            credential_source=self.CREDENTIAL_SOURCE,\n            quota_project_id=None,\n            workforce_pool_user_project=None,\n            universe_domain=DEFAULT_UNIVERSE_DOMAIN,\n        )\n\n    @mock.patch.object(pluggable.Credentials, \"__init__\", return_value=None)\n    def test_from_file_full_options(self, mock_init, tmpdir):\n        info = {\n            \"audience\": AUDIENCE,\n            \"subject_token_type\": SUBJECT_TOKEN_TYPE,\n            \"token_url\": TOKEN_URL,\n            \"token_info_url\": TOKEN_INFO_URL,\n            \"service_account_impersonation_url\": SERVICE_ACCOUNT_IMPERSONATION_URL,\n            \"service_account_impersonation\": {\"token_lifetime_seconds\": 2800},\n            \"client_id\": CLIENT_ID,\n            \"client_secret\": CLIENT_SECRET,\n            \"quota_project_id\": QUOTA_PROJECT_ID,\n            \"credential_source\": self.CREDENTIAL_SOURCE,\n        }\n        config_file = tmpdir.join(\"config.json\")\n        config_file.write(json.dumps(info))\n        credentials = pluggable.Credentials.from_file(str(config_file))\n\n        # Confirm pluggable.Credentials instantiated with expected attributes.\n        assert isinstance(credentials, pluggable.Credentials)\n        mock_init.assert_called_once_with(\n            audience=AUDIENCE,\n            subject_token_type=SUBJECT_TOKEN_TYPE,\n            token_url=TOKEN_URL,\n            token_info_url=TOKEN_INFO_URL,\n            service_account_impersonation_url=SERVICE_ACCOUNT_IMPERSONATION_URL,\n            service_account_impersonation_options={\"token_lifetime_seconds\": 2800},\n            client_id=CLIENT_ID,\n            client_secret=CLIENT_SECRET,\n            credential_source=self.CREDENTIAL_SOURCE,\n            quota_project_id=QUOTA_PROJECT_ID,\n            workforce_pool_user_project=None,\n            universe_domain=DEFAULT_UNIVERSE_DOMAIN,\n        )\n\n    @mock.patch.object(pluggable.Credentials, \"__init__\", return_value=None)\n    def test_from_file_required_options_only(self, mock_init, tmpdir):\n        info = {\n            \"audience\": AUDIENCE,\n            \"subject_token_type\": SUBJECT_TOKEN_TYPE,\n            \"token_url\": TOKEN_URL,\n            \"credential_source\": self.CREDENTIAL_SOURCE,\n        }\n        config_file = tmpdir.join(\"config.json\")\n        config_file.write(json.dumps(info))\n        credentials = pluggable.Credentials.from_file(str(config_file))\n\n        # Confirm pluggable.Credentials instantiated with expected attributes.\n        assert isinstance(credentials, pluggable.Credentials)\n        mock_init.assert_called_once_with(\n            audience=AUDIENCE,\n            subject_token_type=SUBJECT_TOKEN_TYPE,\n            token_url=TOKEN_URL,\n            token_info_url=None,\n            service_account_impersonation_url=None,\n            service_account_impersonation_options={},\n            client_id=None,\n            client_secret=None,\n            credential_source=self.CREDENTIAL_SOURCE,\n            quota_project_id=None,\n            workforce_pool_user_project=None,\n            universe_domain=DEFAULT_UNIVERSE_DOMAIN,\n        )\n\n    def test_constructor_invalid_options(self):\n        credential_source = {\"unsupported\": \"value\"}\n\n        with pytest.raises(ValueError) as excinfo:\n            self.make_pluggable(credential_source=credential_source)\n\n        assert excinfo.match(r\"Missing credential_source\")\n\n    def test_constructor_invalid_credential_source(self):\n        with pytest.raises(ValueError) as excinfo:\n            self.make_pluggable(credential_source=\"non-dict\")\n\n        assert excinfo.match(r\"Missing credential_source\")\n\n    def test_info_with_credential_source(self):\n        credentials = self.make_pluggable(\n            credential_source=self.CREDENTIAL_SOURCE.copy()\n        )\n\n        assert credentials.info == {\n            \"type\": \"external_account\",\n            \"audience\": AUDIENCE,\n            \"subject_token_type\": SUBJECT_TOKEN_TYPE,\n            \"token_url\": TOKEN_URL,\n            \"token_info_url\": TOKEN_INFO_URL,\n            \"credential_source\": self.CREDENTIAL_SOURCE,\n            \"universe_domain\": DEFAULT_UNIVERSE_DOMAIN,\n        }\n\n    def test_token_info_url(self):\n        credentials = self.make_pluggable(\n            credential_source=self.CREDENTIAL_SOURCE.copy()\n        )\n\n        assert credentials.token_info_url == TOKEN_INFO_URL\n\n    def test_token_info_url_custom(self):\n        for url in VALID_TOKEN_URLS:\n            credentials = self.make_pluggable(\n                credential_source=self.CREDENTIAL_SOURCE.copy(),\n                token_info_url=(url + \"/introspect\"),\n            )\n\n            assert credentials.token_info_url == url + \"/introspect\"\n\n    def test_token_info_url_negative(self):\n        credentials = self.make_pluggable(\n            credential_source=self.CREDENTIAL_SOURCE.copy(), token_info_url=None\n        )\n\n        assert not credentials.token_info_url\n\n    def test_token_url_custom(self):\n        for url in VALID_TOKEN_URLS:\n            credentials = self.make_pluggable(\n                credential_source=self.CREDENTIAL_SOURCE.copy(),\n                token_url=(url + \"/token\"),\n            )\n\n            assert credentials._token_url == (url + \"/token\")\n\n    def test_service_account_impersonation_url_custom(self):\n        for url in VALID_SERVICE_ACCOUNT_IMPERSONATION_URLS:\n            credentials = self.make_pluggable(\n                credential_source=self.CREDENTIAL_SOURCE.copy(),\n                service_account_impersonation_url=(\n                    url + SERVICE_ACCOUNT_IMPERSONATION_URL_ROUTE\n                ),\n            )\n\n            assert credentials._service_account_impersonation_url == (\n                url + SERVICE_ACCOUNT_IMPERSONATION_URL_ROUTE\n            )\n\n    @mock.patch.dict(os.environ, {\"GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES\": \"1\"})\n    def test_retrieve_subject_token_successfully(self, tmpdir):\n        ACTUAL_CREDENTIAL_SOURCE_EXECUTABLE_OUTPUT_FILE = tmpdir.join(\n            \"actual_output_file\"\n        )\n        ACTUAL_CREDENTIAL_SOURCE_EXECUTABLE = {\n            \"command\": \"command\",\n            \"interactive_timeout_millis\": 300000,\n            \"output_file\": ACTUAL_CREDENTIAL_SOURCE_EXECUTABLE_OUTPUT_FILE,\n        }\n        ACTUAL_CREDENTIAL_SOURCE = {\"executable\": ACTUAL_CREDENTIAL_SOURCE_EXECUTABLE}\n\n        testData = {\n            \"subject_token_oidc_id_token\": {\n                \"stdout\": json.dumps(\n                    self.EXECUTABLE_SUCCESSFUL_OIDC_RESPONSE_ID_TOKEN\n                ).encode(\"UTF-8\"),\n                \"impersonation_url\": SERVICE_ACCOUNT_IMPERSONATION_URL,\n                \"file_content\": self.EXECUTABLE_SUCCESSFUL_OIDC_NO_EXPIRATION_TIME_RESPONSE_ID_TOKEN,\n                \"expect_token\": self.EXECUTABLE_OIDC_TOKEN,\n            },\n            \"subject_token_oidc_id_token_interacitve_mode\": {\n                \"audience\": WORKFORCE_AUDIENCE,\n                \"file_content\": self.EXECUTABLE_SUCCESSFUL_OIDC_NO_EXPIRATION_TIME_RESPONSE_ID_TOKEN,\n                \"interactive\": True,\n                \"expect_token\": self.EXECUTABLE_OIDC_TOKEN,\n            },\n            \"subject_token_oidc_jwt\": {\n                \"stdout\": json.dumps(\n                    self.EXECUTABLE_SUCCESSFUL_OIDC_RESPONSE_JWT\n                ).encode(\"UTF-8\"),\n                \"impersonation_url\": SERVICE_ACCOUNT_IMPERSONATION_URL,\n                \"file_content\": self.EXECUTABLE_SUCCESSFUL_OIDC_NO_EXPIRATION_TIME_RESPONSE_JWT,\n                \"expect_token\": self.EXECUTABLE_OIDC_TOKEN,\n            },\n            \"subject_token_oidc_jwt_interactive_mode\": {\n                \"audience\": WORKFORCE_AUDIENCE,\n                \"file_content\": self.EXECUTABLE_SUCCESSFUL_OIDC_NO_EXPIRATION_TIME_RESPONSE_JWT,\n                \"interactive\": True,\n                \"expect_token\": self.EXECUTABLE_OIDC_TOKEN,\n            },\n            \"subject_token_saml\": {\n                \"stdout\": json.dumps(self.EXECUTABLE_SUCCESSFUL_SAML_RESPONSE).encode(\n                    \"UTF-8\"\n                ),\n                \"impersonation_url\": SERVICE_ACCOUNT_IMPERSONATION_URL,\n                \"file_content\": self.EXECUTABLE_SUCCESSFUL_SAML_NO_EXPIRATION_TIME_RESPONSE,\n                \"expect_token\": self.EXECUTABLE_SAML_TOKEN,\n            },\n            \"subject_token_saml_interactive_mode\": {\n                \"audience\": WORKFORCE_AUDIENCE,\n                \"file_content\": self.EXECUTABLE_SUCCESSFUL_SAML_NO_EXPIRATION_TIME_RESPONSE,\n                \"interactive\": True,\n                \"expect_token\": self.EXECUTABLE_SAML_TOKEN,\n            },\n        }\n\n        for data in testData.values():\n            with open(\n                ACTUAL_CREDENTIAL_SOURCE_EXECUTABLE_OUTPUT_FILE, \"w\"\n            ) as output_file:\n                json.dump(data.get(\"file_content\"), output_file)\n\n            with mock.patch(\n                \"subprocess.run\",\n                return_value=subprocess.CompletedProcess(\n                    args=[], stdout=data.get(\"stdout\"), returncode=0\n                ),\n            ):\n                credentials = self.make_pluggable(\n                    audience=data.get(\"audience\", AUDIENCE),\n                    service_account_impersonation_url=data.get(\"impersonation_url\"),\n                    credential_source=ACTUAL_CREDENTIAL_SOURCE,\n                    interactive=data.get(\"interactive\", False),\n                )\n                subject_token = credentials.retrieve_subject_token(None)\n                assert subject_token == data.get(\"expect_token\")\n            os.remove(ACTUAL_CREDENTIAL_SOURCE_EXECUTABLE_OUTPUT_FILE)\n\n    @mock.patch.dict(os.environ, {\"GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES\": \"1\"})\n    def test_retrieve_subject_token_saml(self):\n        with mock.patch(\n            \"subprocess.run\",\n            return_value=subprocess.CompletedProcess(\n                args=[],\n                stdout=json.dumps(self.EXECUTABLE_SUCCESSFUL_SAML_RESPONSE).encode(\n                    \"UTF-8\"\n                ),\n                returncode=0,\n            ),\n        ):\n            credentials = self.make_pluggable(credential_source=self.CREDENTIAL_SOURCE)\n\n            subject_token = credentials.retrieve_subject_token(None)\n\n            assert subject_token == self.EXECUTABLE_SAML_TOKEN\n\n    @mock.patch.dict(os.environ, {\"GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES\": \"1\"})\n    def test_retrieve_subject_token_saml_interactive_mode(self, tmpdir):\n\n        ACTUAL_CREDENTIAL_SOURCE_EXECUTABLE_OUTPUT_FILE = tmpdir.join(\n            \"actual_output_file\"\n        )\n        ACTUAL_CREDENTIAL_SOURCE_EXECUTABLE = {\n            \"command\": \"command\",\n            \"interactive_timeout_millis\": 300000,\n            \"output_file\": ACTUAL_CREDENTIAL_SOURCE_EXECUTABLE_OUTPUT_FILE,\n        }\n        ACTUAL_CREDENTIAL_SOURCE = {\"executable\": ACTUAL_CREDENTIAL_SOURCE_EXECUTABLE}\n        with open(ACTUAL_CREDENTIAL_SOURCE_EXECUTABLE_OUTPUT_FILE, \"w\") as output_file:\n            json.dump(\n                self.EXECUTABLE_SUCCESSFUL_SAML_NO_EXPIRATION_TIME_RESPONSE, output_file\n            )\n\n        with mock.patch(\n            \"subprocess.run\",\n            return_value=subprocess.CompletedProcess(args=[], returncode=0),\n        ):\n            credentials = self.make_pluggable(\n                audience=WORKFORCE_AUDIENCE,\n                credential_source=ACTUAL_CREDENTIAL_SOURCE,\n                interactive=True,\n            )\n\n            subject_token = credentials.retrieve_subject_token(None)\n\n            assert subject_token == self.EXECUTABLE_SAML_TOKEN\n            os.remove(ACTUAL_CREDENTIAL_SOURCE_EXECUTABLE_OUTPUT_FILE)\n\n    @mock.patch.dict(os.environ, {\"GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES\": \"1\"})\n    def test_retrieve_subject_token_failed(self):\n        with mock.patch(\n            \"subprocess.run\",\n            return_value=subprocess.CompletedProcess(\n                args=[],\n                stdout=json.dumps(self.EXECUTABLE_FAILED_RESPONSE).encode(\"UTF-8\"),\n                returncode=0,\n            ),\n        ):\n            credentials = self.make_pluggable(credential_source=self.CREDENTIAL_SOURCE)\n\n            with pytest.raises(exceptions.RefreshError) as excinfo:\n                _ = credentials.retrieve_subject_token(None)\n\n            assert excinfo.match(\n                r\"Executable returned unsuccessful response: code: 401, message: Permission denied. Caller not authorized.\"\n            )\n\n    @mock.patch.dict(\n        os.environ,\n        {\n            \"GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES\": \"1\",\n            \"GOOGLE_EXTERNAL_ACCOUNT_INTERACTIVE\": \"1\",\n        },\n    )\n    def test_retrieve_subject_token_failed_interactive_mode(self, tmpdir):\n        ACTUAL_CREDENTIAL_SOURCE_EXECUTABLE_OUTPUT_FILE = tmpdir.join(\n            \"actual_output_file\"\n        )\n        ACTUAL_CREDENTIAL_SOURCE_EXECUTABLE = {\n            \"command\": \"command\",\n            \"interactive_timeout_millis\": 300000,\n            \"output_file\": ACTUAL_CREDENTIAL_SOURCE_EXECUTABLE_OUTPUT_FILE,\n        }\n        ACTUAL_CREDENTIAL_SOURCE = {\"executable\": ACTUAL_CREDENTIAL_SOURCE_EXECUTABLE}\n        with open(\n            ACTUAL_CREDENTIAL_SOURCE_EXECUTABLE_OUTPUT_FILE, \"w\", encoding=\"utf-8\"\n        ) as output_file:\n            json.dump(self.EXECUTABLE_FAILED_RESPONSE, output_file)\n\n        with mock.patch(\n            \"subprocess.run\",\n            return_value=subprocess.CompletedProcess(args=[], returncode=0),\n        ):\n            credentials = self.make_pluggable(\n                audience=WORKFORCE_AUDIENCE,\n                credential_source=ACTUAL_CREDENTIAL_SOURCE,\n                interactive=True,\n            )\n\n            with pytest.raises(exceptions.RefreshError) as excinfo:\n                _ = credentials.retrieve_subject_token(None)\n\n            assert excinfo.match(\n                r\"Executable returned unsuccessful response: code: 401, message: Permission denied. Caller not authorized.\"\n            )\n            os.remove(ACTUAL_CREDENTIAL_SOURCE_EXECUTABLE_OUTPUT_FILE)\n\n    @mock.patch.dict(os.environ, {\"GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES\": \"0\"})\n    def test_retrieve_subject_token_not_allowd(self):\n        with mock.patch(\n            \"subprocess.run\",\n            return_value=subprocess.CompletedProcess(\n                args=[],\n                stdout=json.dumps(\n                    self.EXECUTABLE_SUCCESSFUL_OIDC_RESPONSE_ID_TOKEN\n                ).encode(\"UTF-8\"),\n                returncode=0,\n            ),\n        ):\n            credentials = self.make_pluggable(credential_source=self.CREDENTIAL_SOURCE)\n\n            with pytest.raises(ValueError) as excinfo:\n                _ = credentials.retrieve_subject_token(None)\n\n            assert excinfo.match(r\"Executables need to be explicitly allowed\")\n\n    @mock.patch.dict(os.environ, {\"GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES\": \"1\"})\n    def test_retrieve_subject_token_invalid_version(self):\n        EXECUTABLE_SUCCESSFUL_OIDC_RESPONSE_VERSION_2 = {\n            \"version\": 2,\n            \"success\": True,\n            \"token_type\": \"urn:ietf:params:oauth:token-type:id_token\",\n            \"id_token\": self.EXECUTABLE_OIDC_TOKEN,\n            \"expiration_time\": 9999999999,\n        }\n\n        with mock.patch(\n            \"subprocess.run\",\n            return_value=subprocess.CompletedProcess(\n                args=[],\n                stdout=json.dumps(EXECUTABLE_SUCCESSFUL_OIDC_RESPONSE_VERSION_2).encode(\n                    \"UTF-8\"\n                ),\n                returncode=0,\n            ),\n        ):\n            credentials = self.make_pluggable(credential_source=self.CREDENTIAL_SOURCE)\n\n            with pytest.raises(exceptions.RefreshError) as excinfo:\n                _ = credentials.retrieve_subject_token(None)\n\n            assert excinfo.match(r\"Executable returned unsupported version.\")\n\n    @mock.patch.dict(os.environ, {\"GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES\": \"1\"})\n    def test_retrieve_subject_token_expired_token(self):\n        EXECUTABLE_SUCCESSFUL_OIDC_RESPONSE_EXPIRED = {\n            \"version\": 1,\n            \"success\": True,\n            \"token_type\": \"urn:ietf:params:oauth:token-type:id_token\",\n            \"id_token\": self.EXECUTABLE_OIDC_TOKEN,\n            \"expiration_time\": 0,\n        }\n\n        with mock.patch(\n            \"subprocess.run\",\n            return_value=subprocess.CompletedProcess(\n                args=[],\n                stdout=json.dumps(EXECUTABLE_SUCCESSFUL_OIDC_RESPONSE_EXPIRED).encode(\n                    \"UTF-8\"\n                ),\n                returncode=0,\n            ),\n        ):\n            credentials = self.make_pluggable(credential_source=self.CREDENTIAL_SOURCE)\n\n            with pytest.raises(exceptions.RefreshError) as excinfo:\n                _ = credentials.retrieve_subject_token(None)\n\n            assert excinfo.match(r\"The token returned by the executable is expired.\")\n\n    @mock.patch.dict(os.environ, {\"GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES\": \"1\"})\n    def test_retrieve_subject_token_file_cache(self, tmpdir):\n        ACTUAL_CREDENTIAL_SOURCE_EXECUTABLE_OUTPUT_FILE = tmpdir.join(\n            \"actual_output_file\"\n        )\n        ACTUAL_CREDENTIAL_SOURCE_EXECUTABLE = {\n            \"command\": \"command\",\n            \"timeout_millis\": 30000,\n            \"output_file\": ACTUAL_CREDENTIAL_SOURCE_EXECUTABLE_OUTPUT_FILE,\n        }\n        ACTUAL_CREDENTIAL_SOURCE = {\"executable\": ACTUAL_CREDENTIAL_SOURCE_EXECUTABLE}\n        with open(ACTUAL_CREDENTIAL_SOURCE_EXECUTABLE_OUTPUT_FILE, \"w\") as output_file:\n            json.dump(self.EXECUTABLE_SUCCESSFUL_OIDC_RESPONSE_ID_TOKEN, output_file)\n\n        credentials = self.make_pluggable(credential_source=ACTUAL_CREDENTIAL_SOURCE)\n\n        subject_token = credentials.retrieve_subject_token(None)\n        assert subject_token == self.EXECUTABLE_OIDC_TOKEN\n\n        os.remove(ACTUAL_CREDENTIAL_SOURCE_EXECUTABLE_OUTPUT_FILE)\n\n    @mock.patch.dict(os.environ, {\"GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES\": \"1\"})\n    def test_retrieve_subject_token_no_file_cache(self):\n        ACTUAL_CREDENTIAL_SOURCE_EXECUTABLE = {\n            \"command\": \"command\",\n            \"timeout_millis\": 30000,\n        }\n        ACTUAL_CREDENTIAL_SOURCE = {\"executable\": ACTUAL_CREDENTIAL_SOURCE_EXECUTABLE}\n\n        with mock.patch(\n            \"subprocess.run\",\n            return_value=subprocess.CompletedProcess(\n                args=[],\n                stdout=json.dumps(\n                    self.EXECUTABLE_SUCCESSFUL_OIDC_RESPONSE_ID_TOKEN\n                ).encode(\"UTF-8\"),\n                returncode=0,\n            ),\n        ):\n            credentials = self.make_pluggable(\n                credential_source=ACTUAL_CREDENTIAL_SOURCE\n            )\n\n            subject_token = credentials.retrieve_subject_token(None)\n\n            assert subject_token == self.EXECUTABLE_OIDC_TOKEN\n\n    @mock.patch.dict(os.environ, {\"GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES\": \"1\"})\n    def test_retrieve_subject_token_file_cache_value_error_report(self, tmpdir):\n        ACTUAL_CREDENTIAL_SOURCE_EXECUTABLE_OUTPUT_FILE = tmpdir.join(\n            \"actual_output_file\"\n        )\n        ACTUAL_CREDENTIAL_SOURCE_EXECUTABLE = {\n            \"command\": \"command\",\n            \"timeout_millis\": 30000,\n            \"output_file\": ACTUAL_CREDENTIAL_SOURCE_EXECUTABLE_OUTPUT_FILE,\n        }\n        ACTUAL_CREDENTIAL_SOURCE = {\"executable\": ACTUAL_CREDENTIAL_SOURCE_EXECUTABLE}\n        ACTUAL_EXECUTABLE_RESPONSE = {\n            \"success\": True,\n            \"token_type\": \"urn:ietf:params:oauth:token-type:id_token\",\n            \"id_token\": self.EXECUTABLE_OIDC_TOKEN,\n            \"expiration_time\": 9999999999,\n        }\n        with open(ACTUAL_CREDENTIAL_SOURCE_EXECUTABLE_OUTPUT_FILE, \"w\") as output_file:\n            json.dump(ACTUAL_EXECUTABLE_RESPONSE, output_file)\n\n        credentials = self.make_pluggable(credential_source=ACTUAL_CREDENTIAL_SOURCE)\n\n        with pytest.raises(ValueError) as excinfo:\n            _ = credentials.retrieve_subject_token(None)\n\n        assert excinfo.match(r\"The executable response is missing the version field.\")\n\n        os.remove(ACTUAL_CREDENTIAL_SOURCE_EXECUTABLE_OUTPUT_FILE)\n\n    @mock.patch.dict(os.environ, {\"GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES\": \"1\"})\n    def test_retrieve_subject_token_file_cache_refresh_error_retry(self, tmpdir):\n        ACTUAL_CREDENTIAL_SOURCE_EXECUTABLE_OUTPUT_FILE = tmpdir.join(\n            \"actual_output_file\"\n        )\n        ACTUAL_CREDENTIAL_SOURCE_EXECUTABLE = {\n            \"command\": \"command\",\n            \"timeout_millis\": 30000,\n            \"output_file\": ACTUAL_CREDENTIAL_SOURCE_EXECUTABLE_OUTPUT_FILE,\n        }\n        ACTUAL_CREDENTIAL_SOURCE = {\"executable\": ACTUAL_CREDENTIAL_SOURCE_EXECUTABLE}\n        ACTUAL_EXECUTABLE_RESPONSE = {\n            \"version\": 2,\n            \"success\": True,\n            \"token_type\": \"urn:ietf:params:oauth:token-type:id_token\",\n            \"id_token\": self.EXECUTABLE_OIDC_TOKEN,\n            \"expiration_time\": 9999999999,\n        }\n        with open(ACTUAL_CREDENTIAL_SOURCE_EXECUTABLE_OUTPUT_FILE, \"w\") as output_file:\n            json.dump(ACTUAL_EXECUTABLE_RESPONSE, output_file)\n\n        with mock.patch(\n            \"subprocess.run\",\n            return_value=subprocess.CompletedProcess(\n                args=[],\n                stdout=json.dumps(\n                    self.EXECUTABLE_SUCCESSFUL_OIDC_RESPONSE_ID_TOKEN\n                ).encode(\"UTF-8\"),\n                returncode=0,\n            ),\n        ):\n            credentials = self.make_pluggable(\n                credential_source=ACTUAL_CREDENTIAL_SOURCE\n            )\n\n            subject_token = credentials.retrieve_subject_token(None)\n\n            assert subject_token == self.EXECUTABLE_OIDC_TOKEN\n\n        os.remove(ACTUAL_CREDENTIAL_SOURCE_EXECUTABLE_OUTPUT_FILE)\n\n    @mock.patch.dict(os.environ, {\"GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES\": \"1\"})\n    def test_retrieve_subject_token_unsupported_token_type(self):\n        EXECUTABLE_SUCCESSFUL_OIDC_RESPONSE = {\n            \"version\": 1,\n            \"success\": True,\n            \"token_type\": \"unsupported_token_type\",\n            \"id_token\": self.EXECUTABLE_OIDC_TOKEN,\n            \"expiration_time\": 9999999999,\n        }\n\n        with mock.patch(\n            \"subprocess.run\",\n            return_value=subprocess.CompletedProcess(\n                args=[],\n                stdout=json.dumps(EXECUTABLE_SUCCESSFUL_OIDC_RESPONSE).encode(\"UTF-8\"),\n                returncode=0,\n            ),\n        ):\n            credentials = self.make_pluggable(credential_source=self.CREDENTIAL_SOURCE)\n\n            with pytest.raises(exceptions.RefreshError) as excinfo:\n                _ = credentials.retrieve_subject_token(None)\n\n            assert excinfo.match(r\"Executable returned unsupported token type.\")\n\n    @mock.patch.dict(os.environ, {\"GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES\": \"1\"})\n    def test_retrieve_subject_token_missing_version(self):\n        EXECUTABLE_SUCCESSFUL_OIDC_RESPONSE = {\n            \"success\": True,\n            \"token_type\": \"urn:ietf:params:oauth:token-type:id_token\",\n            \"id_token\": self.EXECUTABLE_OIDC_TOKEN,\n            \"expiration_time\": 9999999999,\n        }\n\n        with mock.patch(\n            \"subprocess.run\",\n            return_value=subprocess.CompletedProcess(\n                args=[],\n                stdout=json.dumps(EXECUTABLE_SUCCESSFUL_OIDC_RESPONSE).encode(\"UTF-8\"),\n                returncode=0,\n            ),\n        ):\n            credentials = self.make_pluggable(credential_source=self.CREDENTIAL_SOURCE)\n\n            with pytest.raises(ValueError) as excinfo:\n                _ = credentials.retrieve_subject_token(None)\n\n            assert excinfo.match(\n                r\"The executable response is missing the version field.\"\n            )\n\n    @mock.patch.dict(os.environ, {\"GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES\": \"1\"})\n    def test_retrieve_subject_token_missing_success(self):\n        EXECUTABLE_SUCCESSFUL_OIDC_RESPONSE = {\n            \"version\": 1,\n            \"token_type\": \"urn:ietf:params:oauth:token-type:id_token\",\n            \"id_token\": self.EXECUTABLE_OIDC_TOKEN,\n            \"expiration_time\": 9999999999,\n        }\n\n        with mock.patch(\n            \"subprocess.run\",\n            return_value=subprocess.CompletedProcess(\n                args=[],\n                stdout=json.dumps(EXECUTABLE_SUCCESSFUL_OIDC_RESPONSE).encode(\"UTF-8\"),\n                returncode=0,\n            ),\n        ):\n            credentials = self.make_pluggable(credential_source=self.CREDENTIAL_SOURCE)\n\n            with pytest.raises(ValueError) as excinfo:\n                _ = credentials.retrieve_subject_token(None)\n\n            assert excinfo.match(\n                r\"The executable response is missing the success field.\"\n            )\n\n    @mock.patch.dict(os.environ, {\"GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES\": \"1\"})\n    def test_retrieve_subject_token_missing_error_code_message(self):\n        EXECUTABLE_SUCCESSFUL_OIDC_RESPONSE = {\"version\": 1, \"success\": False}\n\n        with mock.patch(\n            \"subprocess.run\",\n            return_value=subprocess.CompletedProcess(\n                args=[],\n                stdout=json.dumps(EXECUTABLE_SUCCESSFUL_OIDC_RESPONSE).encode(\"UTF-8\"),\n                returncode=0,\n            ),\n        ):\n            credentials = self.make_pluggable(credential_source=self.CREDENTIAL_SOURCE)\n\n            with pytest.raises(ValueError) as excinfo:\n                _ = credentials.retrieve_subject_token(None)\n\n            assert excinfo.match(\n                r\"Error code and message fields are required in the response.\"\n            )\n\n    @mock.patch.dict(os.environ, {\"GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES\": \"1\"})\n    def test_retrieve_subject_token_without_expiration_time_should_pass_when_output_file_not_specified(\n        self,\n    ):\n        EXECUTABLE_SUCCESSFUL_OIDC_RESPONSE = {\n            \"version\": 1,\n            \"success\": True,\n            \"token_type\": \"urn:ietf:params:oauth:token-type:id_token\",\n            \"id_token\": self.EXECUTABLE_OIDC_TOKEN,\n        }\n\n        CREDENTIAL_SOURCE = {\n            \"executable\": {\"command\": \"command\", \"timeout_millis\": 30000}\n        }\n\n        with mock.patch(\n            \"subprocess.run\",\n            return_value=subprocess.CompletedProcess(\n                args=[],\n                stdout=json.dumps(EXECUTABLE_SUCCESSFUL_OIDC_RESPONSE).encode(\"UTF-8\"),\n                returncode=0,\n            ),\n        ):\n            credentials = self.make_pluggable(credential_source=CREDENTIAL_SOURCE)\n            subject_token = credentials.retrieve_subject_token(None)\n\n            assert subject_token == self.EXECUTABLE_OIDC_TOKEN\n\n    @mock.patch.dict(os.environ, {\"GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES\": \"1\"})\n    def test_retrieve_subject_token_missing_token_type(self):\n        EXECUTABLE_SUCCESSFUL_OIDC_RESPONSE = {\n            \"version\": 1,\n            \"success\": True,\n            \"id_token\": self.EXECUTABLE_OIDC_TOKEN,\n            \"expiration_time\": 9999999999,\n        }\n\n        with mock.patch(\n            \"subprocess.run\",\n            return_value=subprocess.CompletedProcess(\n                args=[],\n                stdout=json.dumps(EXECUTABLE_SUCCESSFUL_OIDC_RESPONSE).encode(\"UTF-8\"),\n                returncode=0,\n            ),\n        ):\n            credentials = self.make_pluggable(credential_source=self.CREDENTIAL_SOURCE)\n\n            with pytest.raises(ValueError) as excinfo:\n                _ = credentials.retrieve_subject_token(None)\n\n            assert excinfo.match(\n                r\"The executable response is missing the token_type field.\"\n            )\n\n    @mock.patch.dict(os.environ, {\"GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES\": \"1\"})\n    def test_credential_source_missing_command(self):\n        with pytest.raises(ValueError) as excinfo:\n            CREDENTIAL_SOURCE = {\n                \"executable\": {\n                    \"timeout_millis\": 30000,\n                    \"output_file\": self.CREDENTIAL_SOURCE_EXECUTABLE_OUTPUT_FILE,\n                }\n            }\n            _ = self.make_pluggable(credential_source=CREDENTIAL_SOURCE)\n\n        assert excinfo.match(\n            r\"Missing command field. Executable command must be provided.\"\n        )\n\n    @mock.patch.dict(os.environ, {\"GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES\": \"1\"})\n    def test_credential_source_missing_output_interactive_mode(self):\n        CREDENTIAL_SOURCE = {\n            \"executable\": {\"command\": self.CREDENTIAL_SOURCE_EXECUTABLE_COMMAND}\n        }\n        credentials = self.make_pluggable(\n            credential_source=CREDENTIAL_SOURCE, interactive=True\n        )\n        with pytest.raises(ValueError) as excinfo:\n            _ = credentials.retrieve_subject_token(None)\n\n        assert excinfo.match(\n            r\"An output_file must be specified in the credential configuration for interactive mode.\"\n        )\n\n    @mock.patch.dict(os.environ, {\"GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES\": \"1\"})\n    def test_credential_source_timeout_missing_will_use_default_timeout_value(self):\n        CREDENTIAL_SOURCE = {\n            \"executable\": {\n                \"command\": self.CREDENTIAL_SOURCE_EXECUTABLE_COMMAND,\n                \"output_file\": self.CREDENTIAL_SOURCE_EXECUTABLE_OUTPUT_FILE,\n            }\n        }\n        credentials = self.make_pluggable(credential_source=CREDENTIAL_SOURCE)\n\n        assert (\n            credentials._credential_source_executable_timeout_millis\n            == pluggable.EXECUTABLE_TIMEOUT_MILLIS_DEFAULT\n        )\n\n    @mock.patch.dict(os.environ, {\"GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES\": \"1\"})\n    def test_credential_source_timeout_small(self):\n        with pytest.raises(ValueError) as excinfo:\n            CREDENTIAL_SOURCE = {\n                \"executable\": {\n                    \"command\": self.CREDENTIAL_SOURCE_EXECUTABLE_COMMAND,\n                    \"timeout_millis\": 5000 - 1,\n                    \"output_file\": self.CREDENTIAL_SOURCE_EXECUTABLE_OUTPUT_FILE,\n                }\n            }\n            _ = self.make_pluggable(credential_source=CREDENTIAL_SOURCE)\n\n        assert excinfo.match(r\"Timeout must be between 5 and 120 seconds.\")\n\n    @mock.patch.dict(os.environ, {\"GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES\": \"1\"})\n    def test_credential_source_timeout_large(self):\n        with pytest.raises(ValueError) as excinfo:\n            CREDENTIAL_SOURCE = {\n                \"executable\": {\n                    \"command\": self.CREDENTIAL_SOURCE_EXECUTABLE_COMMAND,\n                    \"timeout_millis\": 120000 + 1,\n                    \"output_file\": self.CREDENTIAL_SOURCE_EXECUTABLE_OUTPUT_FILE,\n                }\n            }\n            _ = self.make_pluggable(credential_source=CREDENTIAL_SOURCE)\n\n        assert excinfo.match(r\"Timeout must be between 5 and 120 seconds.\")\n\n    @mock.patch.dict(os.environ, {\"GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES\": \"1\"})\n    def test_credential_source_interactive_timeout_small(self):\n        with pytest.raises(ValueError) as excinfo:\n            CREDENTIAL_SOURCE = {\n                \"executable\": {\n                    \"command\": self.CREDENTIAL_SOURCE_EXECUTABLE_COMMAND,\n                    \"interactive_timeout_millis\": 30000 - 1,\n                    \"output_file\": self.CREDENTIAL_SOURCE_EXECUTABLE_OUTPUT_FILE,\n                }\n            }\n            _ = self.make_pluggable(credential_source=CREDENTIAL_SOURCE)\n\n        assert excinfo.match(\n            r\"Interactive timeout must be between 30 seconds and 30 minutes.\"\n        )\n\n    @mock.patch.dict(os.environ, {\"GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES\": \"1\"})\n    def test_credential_source_interactive_timeout_large(self):\n        with pytest.raises(ValueError) as excinfo:\n            CREDENTIAL_SOURCE = {\n                \"executable\": {\n                    \"command\": self.CREDENTIAL_SOURCE_EXECUTABLE_COMMAND,\n                    \"interactive_timeout_millis\": 1800000 + 1,\n                    \"output_file\": self.CREDENTIAL_SOURCE_EXECUTABLE_OUTPUT_FILE,\n                }\n            }\n            _ = self.make_pluggable(credential_source=CREDENTIAL_SOURCE)\n\n        assert excinfo.match(\n            r\"Interactive timeout must be between 30 seconds and 30 minutes.\"\n        )\n\n    @mock.patch.dict(os.environ, {\"GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES\": \"1\"})\n    def test_retrieve_subject_token_executable_fail(self):\n        with mock.patch(\n            \"subprocess.run\",\n            return_value=subprocess.CompletedProcess(\n                args=[], stdout=None, returncode=1\n            ),\n        ):\n            credentials = self.make_pluggable(credential_source=self.CREDENTIAL_SOURCE)\n\n            with pytest.raises(exceptions.RefreshError) as excinfo:\n                _ = credentials.retrieve_subject_token(None)\n\n            assert excinfo.match(\n                r\"Executable exited with non-zero return code 1. Error: None\"\n            )\n\n    @mock.patch.dict(os.environ, {\"GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES\": \"1\"})\n    def test_retrieve_subject_token_non_workforce_fail_interactive_mode(self):\n        credentials = self.make_pluggable(\n            credential_source=self.CREDENTIAL_SOURCE, interactive=True\n        )\n        with pytest.raises(ValueError) as excinfo:\n            _ = credentials.retrieve_subject_token(None)\n\n        assert excinfo.match(r\"Interactive mode is only enabled for workforce pool.\")\n\n    @mock.patch.dict(os.environ, {\"GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES\": \"1\"})\n    def test_retrieve_subject_token_fail_on_validation_missing_interactive_timeout(\n        self\n    ):\n        CREDENTIAL_SOURCE_EXECUTABLE = {\n            \"command\": self.CREDENTIAL_SOURCE_EXECUTABLE_COMMAND,\n            \"output_file\": self.CREDENTIAL_SOURCE_EXECUTABLE_OUTPUT_FILE,\n        }\n        CREDENTIAL_SOURCE = {\"executable\": CREDENTIAL_SOURCE_EXECUTABLE}\n        credentials = self.make_pluggable(\n            credential_source=CREDENTIAL_SOURCE, interactive=True\n        )\n        with pytest.raises(ValueError) as excinfo:\n            _ = credentials.retrieve_subject_token(None)\n\n        assert excinfo.match(\n            r\"Interactive mode cannot run without an interactive timeout.\"\n        )\n\n    @mock.patch.dict(os.environ, {\"GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES\": \"1\"})\n    def test_retrieve_subject_token_executable_fail_interactive_mode(self):\n        with mock.patch(\n            \"subprocess.run\",\n            return_value=subprocess.CompletedProcess(\n                args=[], stdout=None, returncode=1\n            ),\n        ):\n            credentials = self.make_pluggable(\n                audience=WORKFORCE_AUDIENCE,\n                credential_source=self.CREDENTIAL_SOURCE,\n                interactive=True,\n            )\n\n            with pytest.raises(exceptions.RefreshError) as excinfo:\n                _ = credentials.retrieve_subject_token(None)\n\n            assert excinfo.match(\n                r\"Executable exited with non-zero return code 1. Error: None\"\n            )\n\n    @mock.patch.dict(os.environ, {\"GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES\": \"0\"})\n    def test_revoke_failed_executable_not_allowed(self):\n        credentials = self.make_pluggable(\n            credential_source=self.CREDENTIAL_SOURCE, interactive=True\n        )\n        with pytest.raises(ValueError) as excinfo:\n            _ = credentials.revoke(None)\n\n        assert excinfo.match(r\"Executables need to be explicitly allowed\")\n\n    @mock.patch.dict(os.environ, {\"GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES\": \"1\"})\n    def test_revoke_failed(self):\n        testData = {\n            \"non_interactive_mode\": {\n                \"interactive\": False,\n                \"expectErrType\": ValueError,\n                \"expectErrPattern\": r\"Revoke is only enabled under interactive mode.\",\n            },\n            \"executable_failed\": {\n                \"returncode\": 1,\n                \"expectErrType\": exceptions.RefreshError,\n                \"expectErrPattern\": r\"Auth revoke failed on executable.\",\n            },\n            \"response_validation_missing_version\": {\n                \"response\": {},\n                \"expectErrType\": ValueError,\n                \"expectErrPattern\": r\"The executable response is missing the version field.\",\n            },\n            \"response_validation_invalid_version\": {\n                \"response\": {\"version\": 2},\n                \"expectErrType\": exceptions.RefreshError,\n                \"expectErrPattern\": r\"Executable returned unsupported version.\",\n            },\n            \"response_validation_missing_success\": {\n                \"response\": {\"version\": 1},\n                \"expectErrType\": ValueError,\n                \"expectErrPattern\": r\"The executable response is missing the success field.\",\n            },\n            \"response_validation_failed_with_success_field_is_false\": {\n                \"response\": {\"version\": 1, \"success\": False},\n                \"expectErrType\": exceptions.RefreshError,\n                \"expectErrPattern\": r\"Revoke failed with unsuccessful response.\",\n            },\n        }\n        for data in testData.values():\n            with mock.patch(\n                \"subprocess.run\",\n                return_value=subprocess.CompletedProcess(\n                    args=[],\n                    stdout=json.dumps(data.get(\"response\")).encode(\"UTF-8\"),\n                    returncode=data.get(\"returncode\", 0),\n                ),\n            ):\n                credentials = self.make_pluggable(\n                    audience=WORKFORCE_AUDIENCE,\n                    service_account_impersonation_url=SERVICE_ACCOUNT_IMPERSONATION_URL,\n                    credential_source=self.CREDENTIAL_SOURCE,\n                    interactive=data.get(\"interactive\", True),\n                )\n\n                with pytest.raises(data.get(\"expectErrType\")) as excinfo:\n                    _ = credentials.revoke(None)\n\n                assert excinfo.match(data.get(\"expectErrPattern\"))\n\n    @mock.patch.dict(os.environ, {\"GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES\": \"1\"})\n    def test_revoke_successfully(self):\n        ACTUAL_RESPONSE = {\"version\": 1, \"success\": True}\n        with mock.patch(\n            \"subprocess.run\",\n            return_value=subprocess.CompletedProcess(\n                args=[],\n                stdout=json.dumps(ACTUAL_RESPONSE).encode(\"utf-8\"),\n                returncode=0,\n            ),\n        ):\n            credentials = self.make_pluggable(\n                audience=WORKFORCE_AUDIENCE,\n                credential_source=self.CREDENTIAL_SOURCE,\n                interactive=True,\n            )\n            _ = credentials.revoke(None)\n\n    @mock.patch.dict(os.environ, {\"GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES\": \"1\"})\n    def test_retrieve_subject_token_python_2(self):\n        with mock.patch(\"sys.version_info\", (2, 7)):\n            credentials = self.make_pluggable(credential_source=self.CREDENTIAL_SOURCE)\n\n            with pytest.raises(exceptions.RefreshError) as excinfo:\n                _ = credentials.retrieve_subject_token(None)\n\n            assert excinfo.match(r\"Pluggable auth is only supported for python 3.7+\")\n\n    @mock.patch.dict(os.environ, {\"GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES\": \"1\"})\n    def test_revoke_subject_token_python_2(self):\n        with mock.patch(\"sys.version_info\", (2, 7)):\n            credentials = self.make_pluggable(\n                audience=WORKFORCE_AUDIENCE,\n                credential_source=self.CREDENTIAL_SOURCE,\n                interactive=True,\n            )\n\n            with pytest.raises(exceptions.RefreshError) as excinfo:\n                _ = credentials.revoke(None)\n\n            assert excinfo.match(r\"Pluggable auth is only supported for python 3.7+\")\n", "tests/test_downscoped.py": "# Copyright 2021 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport datetime\nimport http.client as http_client\nimport json\nimport urllib\n\nimport mock\nimport pytest  # type: ignore\n\nfrom google.auth import _helpers\nfrom google.auth import credentials\nfrom google.auth import downscoped\nfrom google.auth import exceptions\nfrom google.auth import transport\nfrom google.auth.credentials import DEFAULT_UNIVERSE_DOMAIN\nfrom google.auth.credentials import TokenState\n\n\nEXPRESSION = (\n    \"resource.name.startsWith('projects/_/buckets/example-bucket/objects/customer-a')\"\n)\nTITLE = \"customer-a-objects\"\nDESCRIPTION = (\n    \"Condition to make permissions available for objects starting with customer-a\"\n)\nAVAILABLE_RESOURCE = \"//storage.googleapis.com/projects/_/buckets/example-bucket\"\nAVAILABLE_PERMISSIONS = [\"inRole:roles/storage.objectViewer\"]\n\nOTHER_EXPRESSION = (\n    \"resource.name.startsWith('projects/_/buckets/example-bucket/objects/customer-b')\"\n)\nOTHER_TITLE = \"customer-b-objects\"\nOTHER_DESCRIPTION = (\n    \"Condition to make permissions available for objects starting with customer-b\"\n)\nOTHER_AVAILABLE_RESOURCE = \"//storage.googleapis.com/projects/_/buckets/other-bucket\"\nOTHER_AVAILABLE_PERMISSIONS = [\"inRole:roles/storage.objectCreator\"]\nQUOTA_PROJECT_ID = \"QUOTA_PROJECT_ID\"\nGRANT_TYPE = \"urn:ietf:params:oauth:grant-type:token-exchange\"\nREQUESTED_TOKEN_TYPE = \"urn:ietf:params:oauth:token-type:access_token\"\nTOKEN_EXCHANGE_ENDPOINT = \"https://sts.googleapis.com/v1/token\"\nSUBJECT_TOKEN_TYPE = \"urn:ietf:params:oauth:token-type:access_token\"\nSUCCESS_RESPONSE = {\n    \"access_token\": \"ACCESS_TOKEN\",\n    \"issued_token_type\": \"urn:ietf:params:oauth:token-type:access_token\",\n    \"token_type\": \"Bearer\",\n    \"expires_in\": 3600,\n}\nERROR_RESPONSE = {\n    \"error\": \"invalid_grant\",\n    \"error_description\": \"Subject token is invalid.\",\n    \"error_uri\": \"https://tools.ietf.org/html/rfc6749\",\n}\nCREDENTIAL_ACCESS_BOUNDARY_JSON = {\n    \"accessBoundary\": {\n        \"accessBoundaryRules\": [\n            {\n                \"availablePermissions\": AVAILABLE_PERMISSIONS,\n                \"availableResource\": AVAILABLE_RESOURCE,\n                \"availabilityCondition\": {\n                    \"expression\": EXPRESSION,\n                    \"title\": TITLE,\n                    \"description\": DESCRIPTION,\n                },\n            }\n        ]\n    }\n}\n\n\nclass SourceCredentials(credentials.Credentials):\n    def __init__(self, raise_error=False, expires_in=3600):\n        super(SourceCredentials, self).__init__()\n        self._counter = 0\n        self._raise_error = raise_error\n        self._expires_in = expires_in\n\n    def refresh(self, request):\n        if self._raise_error:\n            raise exceptions.RefreshError(\n                \"Failed to refresh access token in source credentials.\"\n            )\n        now = _helpers.utcnow()\n        self._counter += 1\n        self.token = \"ACCESS_TOKEN_{}\".format(self._counter)\n        self.expiry = now + datetime.timedelta(seconds=self._expires_in)\n\n\ndef make_availability_condition(expression, title=None, description=None):\n    return downscoped.AvailabilityCondition(expression, title, description)\n\n\ndef make_access_boundary_rule(\n    available_resource, available_permissions, availability_condition=None\n):\n    return downscoped.AccessBoundaryRule(\n        available_resource, available_permissions, availability_condition\n    )\n\n\ndef make_credential_access_boundary(rules):\n    return downscoped.CredentialAccessBoundary(rules)\n\n\nclass TestAvailabilityCondition(object):\n    def test_constructor(self):\n        availability_condition = make_availability_condition(\n            EXPRESSION, TITLE, DESCRIPTION\n        )\n\n        assert availability_condition.expression == EXPRESSION\n        assert availability_condition.title == TITLE\n        assert availability_condition.description == DESCRIPTION\n\n    def test_constructor_required_params_only(self):\n        availability_condition = make_availability_condition(EXPRESSION)\n\n        assert availability_condition.expression == EXPRESSION\n        assert availability_condition.title is None\n        assert availability_condition.description is None\n\n    def test_setters(self):\n        availability_condition = make_availability_condition(\n            EXPRESSION, TITLE, DESCRIPTION\n        )\n        availability_condition.expression = OTHER_EXPRESSION\n        availability_condition.title = OTHER_TITLE\n        availability_condition.description = OTHER_DESCRIPTION\n\n        assert availability_condition.expression == OTHER_EXPRESSION\n        assert availability_condition.title == OTHER_TITLE\n        assert availability_condition.description == OTHER_DESCRIPTION\n\n    def test_invalid_expression_type(self):\n        with pytest.raises(TypeError) as excinfo:\n            make_availability_condition([EXPRESSION], TITLE, DESCRIPTION)\n\n        assert excinfo.match(\"The provided expression is not a string.\")\n\n    def test_invalid_title_type(self):\n        with pytest.raises(TypeError) as excinfo:\n            make_availability_condition(EXPRESSION, False, DESCRIPTION)\n\n        assert excinfo.match(\"The provided title is not a string or None.\")\n\n    def test_invalid_description_type(self):\n        with pytest.raises(TypeError) as excinfo:\n            make_availability_condition(EXPRESSION, TITLE, False)\n\n        assert excinfo.match(\"The provided description is not a string or None.\")\n\n    def test_to_json_required_params_only(self):\n        availability_condition = make_availability_condition(EXPRESSION)\n\n        assert availability_condition.to_json() == {\"expression\": EXPRESSION}\n\n    def test_to_json_(self):\n        availability_condition = make_availability_condition(\n            EXPRESSION, TITLE, DESCRIPTION\n        )\n\n        assert availability_condition.to_json() == {\n            \"expression\": EXPRESSION,\n            \"title\": TITLE,\n            \"description\": DESCRIPTION,\n        }\n\n\nclass TestAccessBoundaryRule(object):\n    def test_constructor(self):\n        availability_condition = make_availability_condition(\n            EXPRESSION, TITLE, DESCRIPTION\n        )\n        access_boundary_rule = make_access_boundary_rule(\n            AVAILABLE_RESOURCE, AVAILABLE_PERMISSIONS, availability_condition\n        )\n\n        assert access_boundary_rule.available_resource == AVAILABLE_RESOURCE\n        assert access_boundary_rule.available_permissions == tuple(\n            AVAILABLE_PERMISSIONS\n        )\n        assert access_boundary_rule.availability_condition == availability_condition\n\n    def test_constructor_required_params_only(self):\n        access_boundary_rule = make_access_boundary_rule(\n            AVAILABLE_RESOURCE, AVAILABLE_PERMISSIONS\n        )\n\n        assert access_boundary_rule.available_resource == AVAILABLE_RESOURCE\n        assert access_boundary_rule.available_permissions == tuple(\n            AVAILABLE_PERMISSIONS\n        )\n        assert access_boundary_rule.availability_condition is None\n\n    def test_setters(self):\n        availability_condition = make_availability_condition(\n            EXPRESSION, TITLE, DESCRIPTION\n        )\n        other_availability_condition = make_availability_condition(\n            OTHER_EXPRESSION, OTHER_TITLE, OTHER_DESCRIPTION\n        )\n        access_boundary_rule = make_access_boundary_rule(\n            AVAILABLE_RESOURCE, AVAILABLE_PERMISSIONS, availability_condition\n        )\n        access_boundary_rule.available_resource = OTHER_AVAILABLE_RESOURCE\n        access_boundary_rule.available_permissions = OTHER_AVAILABLE_PERMISSIONS\n        access_boundary_rule.availability_condition = other_availability_condition\n\n        assert access_boundary_rule.available_resource == OTHER_AVAILABLE_RESOURCE\n        assert access_boundary_rule.available_permissions == tuple(\n            OTHER_AVAILABLE_PERMISSIONS\n        )\n        assert (\n            access_boundary_rule.availability_condition == other_availability_condition\n        )\n\n    def test_invalid_available_resource_type(self):\n        availability_condition = make_availability_condition(\n            EXPRESSION, TITLE, DESCRIPTION\n        )\n        with pytest.raises(TypeError) as excinfo:\n            make_access_boundary_rule(\n                None, AVAILABLE_PERMISSIONS, availability_condition\n            )\n\n        assert excinfo.match(\"The provided available_resource is not a string.\")\n\n    def test_invalid_available_permissions_type(self):\n        availability_condition = make_availability_condition(\n            EXPRESSION, TITLE, DESCRIPTION\n        )\n        with pytest.raises(TypeError) as excinfo:\n            make_access_boundary_rule(\n                AVAILABLE_RESOURCE, [0, 1, 2], availability_condition\n            )\n\n        assert excinfo.match(\n            \"Provided available_permissions are not a list of strings.\"\n        )\n\n    def test_invalid_available_permissions_value(self):\n        availability_condition = make_availability_condition(\n            EXPRESSION, TITLE, DESCRIPTION\n        )\n        with pytest.raises(ValueError) as excinfo:\n            make_access_boundary_rule(\n                AVAILABLE_RESOURCE,\n                [\"roles/storage.objectViewer\"],\n                availability_condition,\n            )\n\n        assert excinfo.match(\"available_permissions must be prefixed with 'inRole:'.\")\n\n    def test_invalid_availability_condition_type(self):\n        with pytest.raises(TypeError) as excinfo:\n            make_access_boundary_rule(\n                AVAILABLE_RESOURCE, AVAILABLE_PERMISSIONS, {\"foo\": \"bar\"}\n            )\n\n        assert excinfo.match(\n            \"The provided availability_condition is not a 'google.auth.downscoped.AvailabilityCondition' or None.\"\n        )\n\n    def test_to_json(self):\n        availability_condition = make_availability_condition(\n            EXPRESSION, TITLE, DESCRIPTION\n        )\n        access_boundary_rule = make_access_boundary_rule(\n            AVAILABLE_RESOURCE, AVAILABLE_PERMISSIONS, availability_condition\n        )\n\n        assert access_boundary_rule.to_json() == {\n            \"availablePermissions\": AVAILABLE_PERMISSIONS,\n            \"availableResource\": AVAILABLE_RESOURCE,\n            \"availabilityCondition\": {\n                \"expression\": EXPRESSION,\n                \"title\": TITLE,\n                \"description\": DESCRIPTION,\n            },\n        }\n\n    def test_to_json_required_params_only(self):\n        access_boundary_rule = make_access_boundary_rule(\n            AVAILABLE_RESOURCE, AVAILABLE_PERMISSIONS\n        )\n\n        assert access_boundary_rule.to_json() == {\n            \"availablePermissions\": AVAILABLE_PERMISSIONS,\n            \"availableResource\": AVAILABLE_RESOURCE,\n        }\n\n\nclass TestCredentialAccessBoundary(object):\n    def test_constructor(self):\n        availability_condition = make_availability_condition(\n            EXPRESSION, TITLE, DESCRIPTION\n        )\n        access_boundary_rule = make_access_boundary_rule(\n            AVAILABLE_RESOURCE, AVAILABLE_PERMISSIONS, availability_condition\n        )\n        rules = [access_boundary_rule]\n        credential_access_boundary = make_credential_access_boundary(rules)\n\n        assert credential_access_boundary.rules == tuple(rules)\n\n    def test_setters(self):\n        availability_condition = make_availability_condition(\n            EXPRESSION, TITLE, DESCRIPTION\n        )\n        access_boundary_rule = make_access_boundary_rule(\n            AVAILABLE_RESOURCE, AVAILABLE_PERMISSIONS, availability_condition\n        )\n        rules = [access_boundary_rule]\n        other_availability_condition = make_availability_condition(\n            OTHER_EXPRESSION, OTHER_TITLE, OTHER_DESCRIPTION\n        )\n        other_access_boundary_rule = make_access_boundary_rule(\n            OTHER_AVAILABLE_RESOURCE,\n            OTHER_AVAILABLE_PERMISSIONS,\n            other_availability_condition,\n        )\n        other_rules = [other_access_boundary_rule]\n        credential_access_boundary = make_credential_access_boundary(rules)\n        credential_access_boundary.rules = other_rules\n\n        assert credential_access_boundary.rules == tuple(other_rules)\n\n    def test_add_rule(self):\n        availability_condition = make_availability_condition(\n            EXPRESSION, TITLE, DESCRIPTION\n        )\n        access_boundary_rule = make_access_boundary_rule(\n            AVAILABLE_RESOURCE, AVAILABLE_PERMISSIONS, availability_condition\n        )\n        rules = [access_boundary_rule] * 9\n        credential_access_boundary = make_credential_access_boundary(rules)\n\n        # Add one more rule. This should not raise an error.\n        additional_access_boundary_rule = make_access_boundary_rule(\n            OTHER_AVAILABLE_RESOURCE, OTHER_AVAILABLE_PERMISSIONS\n        )\n        credential_access_boundary.add_rule(additional_access_boundary_rule)\n\n        assert len(credential_access_boundary.rules) == 10\n        assert credential_access_boundary.rules[9] == additional_access_boundary_rule\n\n    def test_add_rule_invalid_value(self):\n        availability_condition = make_availability_condition(\n            EXPRESSION, TITLE, DESCRIPTION\n        )\n        access_boundary_rule = make_access_boundary_rule(\n            AVAILABLE_RESOURCE, AVAILABLE_PERMISSIONS, availability_condition\n        )\n        rules = [access_boundary_rule] * 10\n        credential_access_boundary = make_credential_access_boundary(rules)\n\n        # Add one more rule to exceed maximum allowed rules.\n        with pytest.raises(ValueError) as excinfo:\n            credential_access_boundary.add_rule(access_boundary_rule)\n\n        assert excinfo.match(\n            \"Credential access boundary rules can have a maximum of 10 rules.\"\n        )\n        assert len(credential_access_boundary.rules) == 10\n\n    def test_add_rule_invalid_type(self):\n        availability_condition = make_availability_condition(\n            EXPRESSION, TITLE, DESCRIPTION\n        )\n        access_boundary_rule = make_access_boundary_rule(\n            AVAILABLE_RESOURCE, AVAILABLE_PERMISSIONS, availability_condition\n        )\n        rules = [access_boundary_rule]\n        credential_access_boundary = make_credential_access_boundary(rules)\n\n        # Add an invalid rule to exceed maximum allowed rules.\n        with pytest.raises(TypeError) as excinfo:\n            credential_access_boundary.add_rule(\"invalid\")\n\n        assert excinfo.match(\n            \"The provided rule does not contain a valid 'google.auth.downscoped.AccessBoundaryRule'.\"\n        )\n        assert len(credential_access_boundary.rules) == 1\n        assert credential_access_boundary.rules[0] == access_boundary_rule\n\n    def test_invalid_rules_type(self):\n        with pytest.raises(TypeError) as excinfo:\n            make_credential_access_boundary([\"invalid\"])\n\n        assert excinfo.match(\n            \"List of rules provided do not contain a valid 'google.auth.downscoped.AccessBoundaryRule'.\"\n        )\n\n    def test_invalid_rules_value(self):\n        availability_condition = make_availability_condition(\n            EXPRESSION, TITLE, DESCRIPTION\n        )\n        access_boundary_rule = make_access_boundary_rule(\n            AVAILABLE_RESOURCE, AVAILABLE_PERMISSIONS, availability_condition\n        )\n        too_many_rules = [access_boundary_rule] * 11\n        with pytest.raises(ValueError) as excinfo:\n            make_credential_access_boundary(too_many_rules)\n\n        assert excinfo.match(\n            \"Credential access boundary rules can have a maximum of 10 rules.\"\n        )\n\n    def test_to_json(self):\n        availability_condition = make_availability_condition(\n            EXPRESSION, TITLE, DESCRIPTION\n        )\n        access_boundary_rule = make_access_boundary_rule(\n            AVAILABLE_RESOURCE, AVAILABLE_PERMISSIONS, availability_condition\n        )\n        rules = [access_boundary_rule]\n        credential_access_boundary = make_credential_access_boundary(rules)\n\n        assert credential_access_boundary.to_json() == {\n            \"accessBoundary\": {\n                \"accessBoundaryRules\": [\n                    {\n                        \"availablePermissions\": AVAILABLE_PERMISSIONS,\n                        \"availableResource\": AVAILABLE_RESOURCE,\n                        \"availabilityCondition\": {\n                            \"expression\": EXPRESSION,\n                            \"title\": TITLE,\n                            \"description\": DESCRIPTION,\n                        },\n                    }\n                ]\n            }\n        }\n\n\nclass TestCredentials(object):\n    @staticmethod\n    def make_credentials(\n        source_credentials=SourceCredentials(),\n        quota_project_id=None,\n        universe_domain=None,\n    ):\n        availability_condition = make_availability_condition(\n            EXPRESSION, TITLE, DESCRIPTION\n        )\n        access_boundary_rule = make_access_boundary_rule(\n            AVAILABLE_RESOURCE, AVAILABLE_PERMISSIONS, availability_condition\n        )\n        rules = [access_boundary_rule]\n        credential_access_boundary = make_credential_access_boundary(rules)\n\n        return downscoped.Credentials(\n            source_credentials,\n            credential_access_boundary,\n            quota_project_id,\n            universe_domain,\n        )\n\n    @staticmethod\n    def make_mock_request(data, status=http_client.OK):\n        response = mock.create_autospec(transport.Response, instance=True)\n        response.status = status\n        response.data = json.dumps(data).encode(\"utf-8\")\n\n        request = mock.create_autospec(transport.Request)\n        request.return_value = response\n\n        return request\n\n    @staticmethod\n    def assert_request_kwargs(\n        request_kwargs, headers, request_data, token_endpoint=TOKEN_EXCHANGE_ENDPOINT\n    ):\n        \"\"\"Asserts the request was called with the expected parameters.\n        \"\"\"\n        assert request_kwargs[\"url\"] == token_endpoint\n        assert request_kwargs[\"method\"] == \"POST\"\n        assert request_kwargs[\"headers\"] == headers\n        assert request_kwargs[\"body\"] is not None\n        body_tuples = urllib.parse.parse_qsl(request_kwargs[\"body\"])\n        for (k, v) in body_tuples:\n            assert v.decode(\"utf-8\") == request_data[k.decode(\"utf-8\")]\n        assert len(body_tuples) == len(request_data.keys())\n\n    def test_default_state(self):\n        credentials = self.make_credentials()\n\n        # No token acquired yet.\n        assert not credentials.token\n        assert not credentials.valid\n        # Expiration hasn't been set yet.\n        assert not credentials.expiry\n        assert not credentials.expired\n        # No quota project ID set.\n        assert not credentials.quota_project_id\n        assert credentials.universe_domain == DEFAULT_UNIVERSE_DOMAIN\n\n    def test_default_state_with_explicit_none_value(self):\n        credentials = self.make_credentials(universe_domain=None)\n\n        # No token acquired yet.\n        assert not credentials.token\n        assert not credentials.valid\n        # Expiration hasn't been set yet.\n        assert not credentials.expiry\n        assert not credentials.expired\n        # No quota project ID set.\n        assert not credentials.quota_project_id\n        assert credentials.universe_domain == DEFAULT_UNIVERSE_DOMAIN\n\n    def test_create_with_customized_universe_domain(self):\n        test_universe_domain = \"foo.com\"\n        credentials = self.make_credentials(universe_domain=test_universe_domain)\n        # No token acquired yet.\n        assert not credentials.token\n        assert not credentials.valid\n        # Expiration hasn't been set yet.\n        assert not credentials.expiry\n        assert not credentials.expired\n        # No quota project ID set.\n        assert not credentials.quota_project_id\n        assert credentials.universe_domain == test_universe_domain\n\n    def test_with_quota_project(self):\n        credentials = self.make_credentials()\n\n        assert not credentials.quota_project_id\n\n        quota_project_creds = credentials.with_quota_project(\"project-foo\")\n\n        assert quota_project_creds.quota_project_id == \"project-foo\"\n\n    @mock.patch(\"google.auth._helpers.utcnow\", return_value=datetime.datetime.min)\n    def test_refresh_on_custom_universe(self, unused_utcnow):\n        test_universe_domain = \"foo.com\"\n        response = SUCCESS_RESPONSE.copy()\n        # Test custom expiration to confirm expiry is set correctly.\n        response[\"expires_in\"] = 2800\n        expected_expiry = datetime.datetime.min + datetime.timedelta(\n            seconds=response[\"expires_in\"]\n        )\n        headers = {\"Content-Type\": \"application/x-www-form-urlencoded\"}\n        request_data = {\n            \"grant_type\": GRANT_TYPE,\n            \"subject_token\": \"ACCESS_TOKEN_1\",\n            \"subject_token_type\": SUBJECT_TOKEN_TYPE,\n            \"requested_token_type\": REQUESTED_TOKEN_TYPE,\n            \"options\": urllib.parse.quote(json.dumps(CREDENTIAL_ACCESS_BOUNDARY_JSON)),\n        }\n        request = self.make_mock_request(status=http_client.OK, data=response)\n        source_credentials = SourceCredentials()\n        credentials = self.make_credentials(\n            source_credentials=source_credentials, universe_domain=test_universe_domain\n        )\n        token_exchange_endpoint = downscoped._STS_TOKEN_URL_PATTERN.format(\n            test_universe_domain\n        )\n\n        # Spy on calls to source credentials refresh to confirm the expected request\n        # instance is used.\n        with mock.patch.object(\n            source_credentials, \"refresh\", wraps=source_credentials.refresh\n        ) as wrapped_souce_cred_refresh:\n            credentials.refresh(request)\n\n            self.assert_request_kwargs(\n                request.call_args[1], headers, request_data, token_exchange_endpoint\n            )\n            assert credentials.valid\n            assert credentials.expiry == expected_expiry\n            assert not credentials.expired\n            assert credentials.token == response[\"access_token\"]\n            # Confirm source credentials called with the same request instance.\n            wrapped_souce_cred_refresh.assert_called_with(request)\n\n    @mock.patch(\"google.auth._helpers.utcnow\", return_value=datetime.datetime.min)\n    def test_refresh(self, unused_utcnow):\n        response = SUCCESS_RESPONSE.copy()\n        # Test custom expiration to confirm expiry is set correctly.\n        response[\"expires_in\"] = 2800\n        expected_expiry = datetime.datetime.min + datetime.timedelta(\n            seconds=response[\"expires_in\"]\n        )\n        headers = {\"Content-Type\": \"application/x-www-form-urlencoded\"}\n        request_data = {\n            \"grant_type\": GRANT_TYPE,\n            \"subject_token\": \"ACCESS_TOKEN_1\",\n            \"subject_token_type\": SUBJECT_TOKEN_TYPE,\n            \"requested_token_type\": REQUESTED_TOKEN_TYPE,\n            \"options\": urllib.parse.quote(json.dumps(CREDENTIAL_ACCESS_BOUNDARY_JSON)),\n        }\n        request = self.make_mock_request(status=http_client.OK, data=response)\n        source_credentials = SourceCredentials()\n        credentials = self.make_credentials(source_credentials=source_credentials)\n\n        # Spy on calls to source credentials refresh to confirm the expected request\n        # instance is used.\n        with mock.patch.object(\n            source_credentials, \"refresh\", wraps=source_credentials.refresh\n        ) as wrapped_souce_cred_refresh:\n            credentials.refresh(request)\n\n            self.assert_request_kwargs(request.call_args[1], headers, request_data)\n            assert credentials.valid\n            assert credentials.expiry == expected_expiry\n            assert not credentials.expired\n            assert credentials.token == response[\"access_token\"]\n            # Confirm source credentials called with the same request instance.\n            wrapped_souce_cred_refresh.assert_called_with(request)\n\n    @mock.patch(\"google.auth._helpers.utcnow\", return_value=datetime.datetime.min)\n    def test_refresh_without_response_expires_in(self, unused_utcnow):\n        response = SUCCESS_RESPONSE.copy()\n        # Simulate the response is missing the expires_in field.\n        # The downscoped token expiration should match the source credentials\n        # expiration.\n        del response[\"expires_in\"]\n        expected_expires_in = 1800\n        # Simulate the source credentials generates a token with 1800 second\n        # expiration time. The generated downscoped token should have the same\n        # expiration time.\n        source_credentials = SourceCredentials(expires_in=expected_expires_in)\n        expected_expiry = datetime.datetime.min + datetime.timedelta(\n            seconds=expected_expires_in\n        )\n        headers = {\"Content-Type\": \"application/x-www-form-urlencoded\"}\n        request_data = {\n            \"grant_type\": GRANT_TYPE,\n            \"subject_token\": \"ACCESS_TOKEN_1\",\n            \"subject_token_type\": SUBJECT_TOKEN_TYPE,\n            \"requested_token_type\": REQUESTED_TOKEN_TYPE,\n            \"options\": urllib.parse.quote(json.dumps(CREDENTIAL_ACCESS_BOUNDARY_JSON)),\n        }\n        request = self.make_mock_request(status=http_client.OK, data=response)\n        credentials = self.make_credentials(source_credentials=source_credentials)\n\n        # Spy on calls to source credentials refresh to confirm the expected request\n        # instance is used.\n        with mock.patch.object(\n            source_credentials, \"refresh\", wraps=source_credentials.refresh\n        ) as wrapped_souce_cred_refresh:\n            credentials.refresh(request)\n\n            self.assert_request_kwargs(request.call_args[1], headers, request_data)\n            assert credentials.valid\n            assert credentials.expiry == expected_expiry\n            assert not credentials.expired\n            assert credentials.token == response[\"access_token\"]\n            # Confirm source credentials called with the same request instance.\n            wrapped_souce_cred_refresh.assert_called_with(request)\n\n    def test_refresh_token_exchange_error(self):\n        request = self.make_mock_request(\n            status=http_client.BAD_REQUEST, data=ERROR_RESPONSE\n        )\n        credentials = self.make_credentials()\n\n        with pytest.raises(exceptions.OAuthError) as excinfo:\n            credentials.refresh(request)\n\n        assert excinfo.match(\n            r\"Error code invalid_grant: Subject token is invalid. - https://tools.ietf.org/html/rfc6749\"\n        )\n        assert not credentials.expired\n        assert credentials.token is None\n\n    def test_refresh_source_credentials_refresh_error(self):\n        # Initialize downscoped credentials with source credentials that raise\n        # an error on refresh.\n        credentials = self.make_credentials(\n            source_credentials=SourceCredentials(raise_error=True)\n        )\n\n        with pytest.raises(exceptions.RefreshError) as excinfo:\n            credentials.refresh(mock.sentinel.request)\n\n        assert excinfo.match(r\"Failed to refresh access token in source credentials.\")\n        assert not credentials.expired\n        assert credentials.token is None\n\n    def test_apply_without_quota_project_id(self):\n        headers = {}\n        request = self.make_mock_request(status=http_client.OK, data=SUCCESS_RESPONSE)\n        credentials = self.make_credentials()\n\n        credentials.refresh(request)\n        credentials.apply(headers)\n\n        assert headers == {\n            \"authorization\": \"Bearer {}\".format(SUCCESS_RESPONSE[\"access_token\"])\n        }\n\n    def test_apply_with_quota_project_id(self):\n        headers = {\"other\": \"header-value\"}\n        request = self.make_mock_request(status=http_client.OK, data=SUCCESS_RESPONSE)\n        credentials = self.make_credentials(quota_project_id=QUOTA_PROJECT_ID)\n\n        credentials.refresh(request)\n        credentials.apply(headers)\n\n        assert headers == {\n            \"other\": \"header-value\",\n            \"authorization\": \"Bearer {}\".format(SUCCESS_RESPONSE[\"access_token\"]),\n            \"x-goog-user-project\": QUOTA_PROJECT_ID,\n        }\n\n    def test_before_request(self):\n        headers = {\"other\": \"header-value\"}\n        request = self.make_mock_request(status=http_client.OK, data=SUCCESS_RESPONSE)\n        credentials = self.make_credentials()\n\n        # First call should call refresh, setting the token.\n        credentials.before_request(request, \"POST\", \"https://example.com/api\", headers)\n\n        assert headers == {\n            \"other\": \"header-value\",\n            \"authorization\": \"Bearer {}\".format(SUCCESS_RESPONSE[\"access_token\"]),\n        }\n\n        # Second call shouldn't call refresh (request should be untouched).\n        credentials.before_request(\n            mock.sentinel.request, \"POST\", \"https://example.com/api\", headers\n        )\n\n        assert headers == {\n            \"other\": \"header-value\",\n            \"authorization\": \"Bearer {}\".format(SUCCESS_RESPONSE[\"access_token\"]),\n        }\n\n    @mock.patch(\"google.auth._helpers.utcnow\")\n    def test_before_request_expired(self, utcnow):\n        headers = {}\n        request = self.make_mock_request(status=http_client.OK, data=SUCCESS_RESPONSE)\n        credentials = self.make_credentials()\n        credentials.token = \"token\"\n        utcnow.return_value = datetime.datetime.min\n        # Set the expiration to one second more than now plus the clock skew\n        # accommodation. These credentials should be valid.\n        credentials.expiry = (\n            datetime.datetime.min\n            + _helpers.REFRESH_THRESHOLD\n            + datetime.timedelta(seconds=1)\n        )\n\n        assert credentials.valid\n        assert not credentials.expired\n        assert credentials.token_state == TokenState.FRESH\n\n        credentials.before_request(request, \"POST\", \"https://example.com/api\", headers)\n\n        # Cached token should be used.\n        assert headers == {\"authorization\": \"Bearer token\"}\n\n        # Next call should simulate 1 second passed.\n        utcnow.return_value = datetime.datetime.min + datetime.timedelta(seconds=1)\n\n        assert not credentials.valid\n        assert credentials.expired\n        assert credentials.token_state == TokenState.STALE\n\n        credentials.before_request(request, \"POST\", \"https://example.com/api\", headers)\n        assert credentials.token_state == TokenState.FRESH\n\n        # New token should be retrieved.\n        assert headers == {\n            \"authorization\": \"Bearer {}\".format(SUCCESS_RESPONSE[\"access_token\"])\n        }\n\n        utcnow.return_value = datetime.datetime.min + datetime.timedelta(seconds=6000)\n\n        assert not credentials.valid\n        assert credentials.expired\n        assert credentials.token_state == TokenState.INVALID\n\n        credentials.before_request(request, \"POST\", \"https://example.com/api\", headers)\n        assert credentials.token_state == TokenState.FRESH\n\n        # New token should be retrieved.\n        assert headers == {\n            \"authorization\": \"Bearer {}\".format(SUCCESS_RESPONSE[\"access_token\"])\n        }\n", "tests/oauth2/test_webauthn_handler_factory.py": "import mock\nimport pytest  # type: ignore\n\nfrom google.oauth2 import webauthn_handler\nfrom google.oauth2 import webauthn_handler_factory\n\n\n@pytest.fixture\ndef os_get_stub():\n    with mock.patch.object(\n        webauthn_handler.os.environ,\n        \"get\",\n        return_value=\"gcloud_webauthn_plugin\",\n        name=\"fake os.environ.get\",\n    ) as mock_os_environ_get:\n        yield mock_os_environ_get\n\n\n# Check that get_handler returns a value when env is set,\n# that type is PluginHandler, and that no value is returned\n# if env not set.\ndef test_WebauthHandlerFactory_get(os_get_stub):\n    factory = webauthn_handler_factory.WebauthnHandlerFactory()\n    assert factory.get_handler() is not None\n\n    assert isinstance(factory.get_handler(), webauthn_handler.PluginHandler)\n\n    os_get_stub.return_value = None\n    assert factory.get_handler() is None\n", "tests/oauth2/test__client.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport datetime\nimport http.client as http_client\nimport json\nimport os\nimport urllib\n\nimport mock\nimport pytest  # type: ignore\n\nfrom google.auth import _helpers\nfrom google.auth import crypt\nfrom google.auth import exceptions\nfrom google.auth import iam\nfrom google.auth import jwt\nfrom google.auth import transport\nfrom google.oauth2 import _client\n\n\nDATA_DIR = os.path.join(os.path.dirname(__file__), \"..\", \"data\")\n\nwith open(os.path.join(DATA_DIR, \"privatekey.pem\"), \"rb\") as fh:\n    PRIVATE_KEY_BYTES = fh.read()\n\nSIGNER = crypt.RSASigner.from_string(PRIVATE_KEY_BYTES, \"1\")\n\nSCOPES_AS_LIST = [\n    \"https://www.googleapis.com/auth/pubsub\",\n    \"https://www.googleapis.com/auth/logging.write\",\n]\nSCOPES_AS_STRING = (\n    \"https://www.googleapis.com/auth/pubsub\"\n    \" https://www.googleapis.com/auth/logging.write\"\n)\n\nACCESS_TOKEN_REQUEST_METRICS_HEADER_VALUE = (\n    \"gl-python/3.7 auth/1.1 auth-request-type/at cred-type/sa\"\n)\nID_TOKEN_REQUEST_METRICS_HEADER_VALUE = (\n    \"gl-python/3.7 auth/1.1 auth-request-type/it cred-type/sa\"\n)\n\n\n@pytest.mark.parametrize(\"retryable\", [True, False])\ndef test__handle_error_response(retryable):\n    response_data = {\"error\": \"help\", \"error_description\": \"I'm alive\"}\n\n    with pytest.raises(exceptions.RefreshError) as excinfo:\n        _client._handle_error_response(response_data, retryable)\n\n    assert excinfo.value.retryable == retryable\n    assert excinfo.match(r\"help: I\\'m alive\")\n\n\ndef test__handle_error_response_no_error():\n    response_data = {\"foo\": \"bar\"}\n\n    with pytest.raises(exceptions.RefreshError) as excinfo:\n        _client._handle_error_response(response_data, False)\n\n    assert not excinfo.value.retryable\n    assert excinfo.match(r\"{\\\"foo\\\": \\\"bar\\\"}\")\n\n\ndef test__handle_error_response_not_json():\n    response_data = \"this is an error message\"\n\n    with pytest.raises(exceptions.RefreshError) as excinfo:\n        _client._handle_error_response(response_data, False)\n\n    assert not excinfo.value.retryable\n    assert excinfo.match(response_data)\n\n\ndef test__can_retry_retryable():\n    retryable_codes = transport.DEFAULT_RETRYABLE_STATUS_CODES\n    for status_code in range(100, 600):\n        if status_code in retryable_codes:\n            assert _client._can_retry(status_code, {\"error\": \"invalid_scope\"})\n        else:\n            assert not _client._can_retry(status_code, {\"error\": \"invalid_scope\"})\n\n\n@pytest.mark.parametrize(\n    \"response_data\", [{\"error\": \"internal_failure\"}, {\"error\": \"server_error\"}]\n)\ndef test__can_retry_message(response_data):\n    assert _client._can_retry(http_client.OK, response_data)\n\n\n@pytest.mark.parametrize(\n    \"response_data\",\n    [\n        {\"error\": \"invalid_scope\"},\n        {\"error\": {\"foo\": \"bar\"}},\n        {\"error_description\": {\"foo\", \"bar\"}},\n    ],\n)\ndef test__can_retry_no_retry_message(response_data):\n    assert not _client._can_retry(http_client.OK, response_data)\n\n\n@pytest.mark.parametrize(\"mock_expires_in\", [500, \"500\"])\n@mock.patch(\"google.auth._helpers.utcnow\", return_value=datetime.datetime.min)\ndef test__parse_expiry(unused_utcnow, mock_expires_in):\n    result = _client._parse_expiry({\"expires_in\": mock_expires_in})\n    assert result == datetime.datetime.min + datetime.timedelta(seconds=500)\n\n\ndef test__parse_expiry_none():\n    assert _client._parse_expiry({}) is None\n\n\ndef make_request(response_data, status=http_client.OK):\n    response = mock.create_autospec(transport.Response, instance=True)\n    response.status = status\n    response.data = json.dumps(response_data).encode(\"utf-8\")\n    request = mock.create_autospec(transport.Request)\n    request.return_value = response\n    return request\n\n\ndef test__token_endpoint_request():\n    request = make_request({\"test\": \"response\"})\n\n    result = _client._token_endpoint_request(\n        request, \"http://example.com\", {\"test\": \"params\"}\n    )\n\n    # Check request call\n    request.assert_called_with(\n        method=\"POST\",\n        url=\"http://example.com\",\n        headers={\"Content-Type\": \"application/x-www-form-urlencoded\"},\n        body=\"test=params\".encode(\"utf-8\"),\n    )\n\n    # Check result\n    assert result == {\"test\": \"response\"}\n\n\ndef test__token_endpoint_request_use_json():\n    request = make_request({\"test\": \"response\"})\n\n    result = _client._token_endpoint_request(\n        request,\n        \"http://example.com\",\n        {\"test\": \"params\"},\n        access_token=\"access_token\",\n        use_json=True,\n    )\n\n    # Check request call\n    request.assert_called_with(\n        method=\"POST\",\n        url=\"http://example.com\",\n        headers={\n            \"Content-Type\": \"application/json\",\n            \"Authorization\": \"Bearer access_token\",\n        },\n        body=b'{\"test\": \"params\"}',\n    )\n\n    # Check result\n    assert result == {\"test\": \"response\"}\n\n\ndef test__token_endpoint_request_error():\n    request = make_request({}, status=http_client.BAD_REQUEST)\n\n    with pytest.raises(exceptions.RefreshError):\n        _client._token_endpoint_request(request, \"http://example.com\", {})\n\n\ndef test__token_endpoint_request_internal_failure_error():\n    request = make_request(\n        {\"error_description\": \"internal_failure\"}, status=http_client.BAD_REQUEST\n    )\n\n    with pytest.raises(exceptions.RefreshError):\n        _client._token_endpoint_request(\n            request, \"http://example.com\", {\"error_description\": \"internal_failure\"}\n        )\n    # request should be called once and then with 3 retries\n    assert request.call_count == 4\n\n    request = make_request(\n        {\"error\": \"internal_failure\"}, status=http_client.BAD_REQUEST\n    )\n\n    with pytest.raises(exceptions.RefreshError):\n        _client._token_endpoint_request(\n            request, \"http://example.com\", {\"error\": \"internal_failure\"}\n        )\n    # request should be called once and then with 3 retries\n    assert request.call_count == 4\n\n\ndef test__token_endpoint_request_internal_failure_and_retry_failure_error():\n    retryable_error = mock.create_autospec(transport.Response, instance=True)\n    retryable_error.status = http_client.BAD_REQUEST\n    retryable_error.data = json.dumps({\"error_description\": \"internal_failure\"}).encode(\n        \"utf-8\"\n    )\n\n    unretryable_error = mock.create_autospec(transport.Response, instance=True)\n    unretryable_error.status = http_client.BAD_REQUEST\n    unretryable_error.data = json.dumps({\"error_description\": \"invalid_scope\"}).encode(\n        \"utf-8\"\n    )\n\n    request = mock.create_autospec(transport.Request)\n\n    request.side_effect = [retryable_error, retryable_error, unretryable_error]\n\n    with pytest.raises(exceptions.RefreshError):\n        _client._token_endpoint_request(\n            request, \"http://example.com\", {\"error_description\": \"invalid_scope\"}\n        )\n    # request should be called three times. Two retryable errors and one\n    # unretryable error to break the retry loop.\n    assert request.call_count == 3\n\n\ndef test__token_endpoint_request_internal_failure_and_retry_succeeds():\n    retryable_error = mock.create_autospec(transport.Response, instance=True)\n    retryable_error.status = http_client.BAD_REQUEST\n    retryable_error.data = json.dumps({\"error_description\": \"internal_failure\"}).encode(\n        \"utf-8\"\n    )\n\n    response = mock.create_autospec(transport.Response, instance=True)\n    response.status = http_client.OK\n    response.data = json.dumps({\"hello\": \"world\"}).encode(\"utf-8\")\n\n    request = mock.create_autospec(transport.Request)\n\n    request.side_effect = [retryable_error, response]\n\n    _ = _client._token_endpoint_request(\n        request, \"http://example.com\", {\"test\": \"params\"}\n    )\n\n    assert request.call_count == 2\n\n\ndef test__token_endpoint_request_string_error():\n    response = mock.create_autospec(transport.Response, instance=True)\n    response.status = http_client.BAD_REQUEST\n    response.data = \"this is an error message\"\n    request = mock.create_autospec(transport.Request)\n    request.return_value = response\n\n    with pytest.raises(exceptions.RefreshError) as excinfo:\n        _client._token_endpoint_request(request, \"http://example.com\", {})\n    assert excinfo.match(\"this is an error message\")\n\n\ndef verify_request_params(request, params):\n    request_body = request.call_args[1][\"body\"].decode(\"utf-8\")\n    request_params = urllib.parse.parse_qs(request_body)\n\n    for key, value in params.items():\n        assert request_params[key][0] == value\n\n\n@mock.patch(\"google.auth._helpers.utcnow\", return_value=datetime.datetime.min)\ndef test_jwt_grant(utcnow):\n    request = make_request(\n        {\"access_token\": \"token\", \"expires_in\": 500, \"extra\": \"data\"}\n    )\n\n    token, expiry, extra_data = _client.jwt_grant(\n        request, \"http://example.com\", \"assertion_value\"\n    )\n\n    # Check request call\n    verify_request_params(\n        request, {\"grant_type\": _client._JWT_GRANT_TYPE, \"assertion\": \"assertion_value\"}\n    )\n\n    # Check result\n    assert token == \"token\"\n    assert expiry == utcnow() + datetime.timedelta(seconds=500)\n    assert extra_data[\"extra\"] == \"data\"\n\n\ndef test_jwt_grant_no_access_token():\n    request = make_request(\n        {\n            # No access token.\n            \"expires_in\": 500,\n            \"extra\": \"data\",\n        }\n    )\n\n    with pytest.raises(exceptions.RefreshError) as excinfo:\n        _client.jwt_grant(request, \"http://example.com\", \"assertion_value\")\n    assert not excinfo.value.retryable\n\n\ndef test_call_iam_generate_id_token_endpoint():\n    now = _helpers.utcnow()\n    id_token_expiry = _helpers.datetime_to_secs(now)\n    id_token = jwt.encode(SIGNER, {\"exp\": id_token_expiry}).decode(\"utf-8\")\n    request = make_request({\"token\": id_token})\n\n    token, expiry = _client.call_iam_generate_id_token_endpoint(\n        request,\n        iam._IAM_IDTOKEN_ENDPOINT,\n        \"fake_email\",\n        \"fake_audience\",\n        \"fake_access_token\",\n    )\n\n    assert (\n        request.call_args[1][\"url\"]\n        == \"https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/fake_email:generateIdToken\"\n    )\n    assert request.call_args[1][\"headers\"][\"Content-Type\"] == \"application/json\"\n    assert (\n        request.call_args[1][\"headers\"][\"Authorization\"] == \"Bearer fake_access_token\"\n    )\n    response_body = json.loads(request.call_args[1][\"body\"])\n    assert response_body[\"audience\"] == \"fake_audience\"\n    assert response_body[\"includeEmail\"] == \"true\"\n    assert response_body[\"useEmailAzp\"] == \"true\"\n\n    # Check result\n    assert token == id_token\n    # JWT does not store microseconds\n    now = now.replace(microsecond=0)\n    assert expiry == now\n\n\ndef test_call_iam_generate_id_token_endpoint_no_id_token():\n    request = make_request(\n        {\n            # No access token.\n            \"error\": \"no token\"\n        }\n    )\n\n    with pytest.raises(exceptions.RefreshError) as excinfo:\n        _client.call_iam_generate_id_token_endpoint(\n            request,\n            iam._IAM_IDTOKEN_ENDPOINT,\n            \"fake_email\",\n            \"fake_audience\",\n            \"fake_access_token\",\n        )\n    assert excinfo.match(\"No ID token in response\")\n\n\ndef test_id_token_jwt_grant():\n    now = _helpers.utcnow()\n    id_token_expiry = _helpers.datetime_to_secs(now)\n    id_token = jwt.encode(SIGNER, {\"exp\": id_token_expiry}).decode(\"utf-8\")\n    request = make_request({\"id_token\": id_token, \"extra\": \"data\"})\n\n    token, expiry, extra_data = _client.id_token_jwt_grant(\n        request, \"http://example.com\", \"assertion_value\"\n    )\n\n    # Check request call\n    verify_request_params(\n        request, {\"grant_type\": _client._JWT_GRANT_TYPE, \"assertion\": \"assertion_value\"}\n    )\n\n    # Check result\n    assert token == id_token\n    # JWT does not store microseconds\n    now = now.replace(microsecond=0)\n    assert expiry == now\n    assert extra_data[\"extra\"] == \"data\"\n\n\ndef test_id_token_jwt_grant_no_access_token():\n    request = make_request(\n        {\n            # No access token.\n            \"expires_in\": 500,\n            \"extra\": \"data\",\n        }\n    )\n\n    with pytest.raises(exceptions.RefreshError) as excinfo:\n        _client.id_token_jwt_grant(request, \"http://example.com\", \"assertion_value\")\n    assert not excinfo.value.retryable\n\n\n@mock.patch(\"google.auth._helpers.utcnow\", return_value=datetime.datetime.min)\ndef test_refresh_grant(unused_utcnow):\n    request = make_request(\n        {\n            \"access_token\": \"token\",\n            \"refresh_token\": \"new_refresh_token\",\n            \"expires_in\": 500,\n            \"extra\": \"data\",\n        }\n    )\n\n    token, refresh_token, expiry, extra_data = _client.refresh_grant(\n        request,\n        \"http://example.com\",\n        \"refresh_token\",\n        \"client_id\",\n        \"client_secret\",\n        rapt_token=\"rapt_token\",\n    )\n\n    # Check request call\n    verify_request_params(\n        request,\n        {\n            \"grant_type\": _client._REFRESH_GRANT_TYPE,\n            \"refresh_token\": \"refresh_token\",\n            \"client_id\": \"client_id\",\n            \"client_secret\": \"client_secret\",\n            \"rapt\": \"rapt_token\",\n        },\n    )\n\n    # Check result\n    assert token == \"token\"\n    assert refresh_token == \"new_refresh_token\"\n    assert expiry == datetime.datetime.min + datetime.timedelta(seconds=500)\n    assert extra_data[\"extra\"] == \"data\"\n\n\n@mock.patch(\"google.auth._helpers.utcnow\", return_value=datetime.datetime.min)\ndef test_refresh_grant_with_scopes(unused_utcnow):\n    request = make_request(\n        {\n            \"access_token\": \"token\",\n            \"refresh_token\": \"new_refresh_token\",\n            \"expires_in\": 500,\n            \"extra\": \"data\",\n            \"scope\": SCOPES_AS_STRING,\n        }\n    )\n\n    token, refresh_token, expiry, extra_data = _client.refresh_grant(\n        request,\n        \"http://example.com\",\n        \"refresh_token\",\n        \"client_id\",\n        \"client_secret\",\n        SCOPES_AS_LIST,\n    )\n\n    # Check request call.\n    verify_request_params(\n        request,\n        {\n            \"grant_type\": _client._REFRESH_GRANT_TYPE,\n            \"refresh_token\": \"refresh_token\",\n            \"client_id\": \"client_id\",\n            \"client_secret\": \"client_secret\",\n            \"scope\": SCOPES_AS_STRING,\n        },\n    )\n\n    # Check result.\n    assert token == \"token\"\n    assert refresh_token == \"new_refresh_token\"\n    assert expiry == datetime.datetime.min + datetime.timedelta(seconds=500)\n    assert extra_data[\"extra\"] == \"data\"\n\n\ndef test_refresh_grant_no_access_token():\n    request = make_request(\n        {\n            # No access token.\n            \"refresh_token\": \"new_refresh_token\",\n            \"expires_in\": 500,\n            \"extra\": \"data\",\n        }\n    )\n\n    with pytest.raises(exceptions.RefreshError) as excinfo:\n        _client.refresh_grant(\n            request, \"http://example.com\", \"refresh_token\", \"client_id\", \"client_secret\"\n        )\n    assert not excinfo.value.retryable\n\n\n@mock.patch(\n    \"google.auth.metrics.token_request_access_token_sa_assertion\",\n    return_value=ACCESS_TOKEN_REQUEST_METRICS_HEADER_VALUE,\n)\n@mock.patch(\"google.oauth2._client._parse_expiry\", return_value=None)\n@mock.patch.object(_client, \"_token_endpoint_request\", autospec=True)\ndef test_jwt_grant_retry_default(\n    mock_token_endpoint_request, mock_expiry, mock_metrics_header_value\n):\n    _client.jwt_grant(mock.Mock(), mock.Mock(), mock.Mock())\n    mock_token_endpoint_request.assert_called_with(\n        mock.ANY,\n        mock.ANY,\n        mock.ANY,\n        can_retry=True,\n        headers={\"x-goog-api-client\": ACCESS_TOKEN_REQUEST_METRICS_HEADER_VALUE},\n    )\n\n\n@pytest.mark.parametrize(\"can_retry\", [True, False])\n@mock.patch(\n    \"google.auth.metrics.token_request_access_token_sa_assertion\",\n    return_value=ACCESS_TOKEN_REQUEST_METRICS_HEADER_VALUE,\n)\n@mock.patch(\"google.oauth2._client._parse_expiry\", return_value=None)\n@mock.patch.object(_client, \"_token_endpoint_request\", autospec=True)\ndef test_jwt_grant_retry_with_retry(\n    mock_token_endpoint_request, mock_expiry, mock_metrics_header_value, can_retry\n):\n    _client.jwt_grant(mock.Mock(), mock.Mock(), mock.Mock(), can_retry=can_retry)\n    mock_token_endpoint_request.assert_called_with(\n        mock.ANY,\n        mock.ANY,\n        mock.ANY,\n        can_retry=can_retry,\n        headers={\"x-goog-api-client\": ACCESS_TOKEN_REQUEST_METRICS_HEADER_VALUE},\n    )\n\n\n@mock.patch(\n    \"google.auth.metrics.token_request_id_token_sa_assertion\",\n    return_value=ID_TOKEN_REQUEST_METRICS_HEADER_VALUE,\n)\n@mock.patch(\"google.auth.jwt.decode\", return_value={\"exp\": 0})\n@mock.patch.object(_client, \"_token_endpoint_request\", autospec=True)\ndef test_id_token_jwt_grant_retry_default(\n    mock_token_endpoint_request, mock_jwt_decode, mock_metrics_header_value\n):\n    _client.id_token_jwt_grant(mock.Mock(), mock.Mock(), mock.Mock())\n    mock_token_endpoint_request.assert_called_with(\n        mock.ANY,\n        mock.ANY,\n        mock.ANY,\n        can_retry=True,\n        headers={\"x-goog-api-client\": ID_TOKEN_REQUEST_METRICS_HEADER_VALUE},\n    )\n\n\n@pytest.mark.parametrize(\"can_retry\", [True, False])\n@mock.patch(\n    \"google.auth.metrics.token_request_id_token_sa_assertion\",\n    return_value=ID_TOKEN_REQUEST_METRICS_HEADER_VALUE,\n)\n@mock.patch(\"google.auth.jwt.decode\", return_value={\"exp\": 0})\n@mock.patch.object(_client, \"_token_endpoint_request\", autospec=True)\ndef test_id_token_jwt_grant_retry_with_retry(\n    mock_token_endpoint_request, mock_jwt_decode, mock_metrics_header_value, can_retry\n):\n    _client.id_token_jwt_grant(\n        mock.Mock(), mock.Mock(), mock.Mock(), can_retry=can_retry\n    )\n    mock_token_endpoint_request.assert_called_with(\n        mock.ANY,\n        mock.ANY,\n        mock.ANY,\n        can_retry=can_retry,\n        headers={\"x-goog-api-client\": ID_TOKEN_REQUEST_METRICS_HEADER_VALUE},\n    )\n\n\n@mock.patch(\"google.oauth2._client._parse_expiry\", return_value=None)\n@mock.patch.object(_client, \"_token_endpoint_request\", autospec=True)\ndef test_refresh_grant_retry_default(mock_token_endpoint_request, mock_parse_expiry):\n    _client.refresh_grant(\n        mock.Mock(), mock.Mock(), mock.Mock(), mock.Mock(), mock.Mock()\n    )\n    mock_token_endpoint_request.assert_called_with(\n        mock.ANY, mock.ANY, mock.ANY, can_retry=True\n    )\n\n\n@pytest.mark.parametrize(\"can_retry\", [True, False])\n@mock.patch(\"google.oauth2._client._parse_expiry\", return_value=None)\n@mock.patch.object(_client, \"_token_endpoint_request\", autospec=True)\ndef test_refresh_grant_retry_with_retry(\n    mock_token_endpoint_request, mock_parse_expiry, can_retry\n):\n    _client.refresh_grant(\n        mock.Mock(),\n        mock.Mock(),\n        mock.Mock(),\n        mock.Mock(),\n        mock.Mock(),\n        can_retry=can_retry,\n    )\n    mock_token_endpoint_request.assert_called_with(\n        mock.ANY, mock.ANY, mock.ANY, can_retry=can_retry\n    )\n\n\n@pytest.mark.parametrize(\"can_retry\", [True, False])\ndef test__token_endpoint_request_no_throw_with_retry(can_retry):\n    response_data = {\"error\": \"help\", \"error_description\": \"I'm alive\"}\n    body = \"dummy body\"\n\n    mock_response = mock.create_autospec(transport.Response, instance=True)\n    mock_response.status = http_client.INTERNAL_SERVER_ERROR\n    mock_response.data = json.dumps(response_data).encode(\"utf-8\")\n\n    mock_request = mock.create_autospec(transport.Request)\n    mock_request.return_value = mock_response\n\n    _client._token_endpoint_request_no_throw(\n        mock_request, mock.Mock(), body, mock.Mock(), mock.Mock(), can_retry=can_retry\n    )\n\n    if can_retry:\n        assert mock_request.call_count == 4\n    else:\n        assert mock_request.call_count == 1\n", "tests/oauth2/test_gdch_credentials.py": "# Copyright 2022 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport copy\nimport datetime\nimport json\nimport os\n\nimport mock\nimport pytest  # type: ignore\nimport requests\n\nfrom google.auth import exceptions\nfrom google.auth import jwt\nimport google.auth.transport.requests\nfrom google.oauth2 import gdch_credentials\nfrom google.oauth2.gdch_credentials import ServiceAccountCredentials\n\n\nclass TestServiceAccountCredentials(object):\n    AUDIENCE = \"https://service-identity.<Domain>/authenticate\"\n    PROJECT = \"project_foo\"\n    PRIVATE_KEY_ID = \"key_foo\"\n    NAME = \"service_identity_name\"\n    CA_CERT_PATH = \"/path/to/ca/cert\"\n    TOKEN_URI = \"https://service-identity.<Domain>/authenticate\"\n\n    JSON_PATH = os.path.join(\n        os.path.dirname(__file__), \"..\", \"data\", \"gdch_service_account.json\"\n    )\n    with open(JSON_PATH, \"rb\") as fh:\n        INFO = json.load(fh)\n\n    def test_with_gdch_audience(self):\n        mock_signer = mock.Mock()\n        creds = ServiceAccountCredentials._from_signer_and_info(mock_signer, self.INFO)\n        assert creds._signer == mock_signer\n        assert creds._service_identity_name == self.NAME\n        assert creds._audience is None\n        assert creds._token_uri == self.TOKEN_URI\n        assert creds._ca_cert_path == self.CA_CERT_PATH\n\n        new_creds = creds.with_gdch_audience(self.AUDIENCE)\n        assert new_creds._signer == mock_signer\n        assert new_creds._service_identity_name == self.NAME\n        assert new_creds._audience == self.AUDIENCE\n        assert new_creds._token_uri == self.TOKEN_URI\n        assert new_creds._ca_cert_path == self.CA_CERT_PATH\n\n    def test__create_jwt(self):\n        creds = ServiceAccountCredentials.from_service_account_file(self.JSON_PATH)\n        with mock.patch(\"google.auth._helpers.utcnow\") as utcnow:\n            utcnow.return_value = datetime.datetime.now()\n            jwt_token = creds._create_jwt()\n            header, payload, _, _ = jwt._unverified_decode(jwt_token)\n\n        expected_iss_sub_value = (\n            \"system:serviceaccount:project_foo:service_identity_name\"\n        )\n        assert isinstance(jwt_token, str)\n        assert header[\"alg\"] == \"ES256\"\n        assert header[\"kid\"] == self.PRIVATE_KEY_ID\n        assert payload[\"iss\"] == expected_iss_sub_value\n        assert payload[\"sub\"] == expected_iss_sub_value\n        assert payload[\"aud\"] == self.AUDIENCE\n        assert payload[\"exp\"] == (payload[\"iat\"] + 3600)\n\n    @mock.patch(\n        \"google.oauth2.gdch_credentials.ServiceAccountCredentials._create_jwt\",\n        autospec=True,\n    )\n    @mock.patch(\"google.oauth2._client._token_endpoint_request\", autospec=True)\n    def test_refresh(self, token_endpoint_request, create_jwt):\n        creds = ServiceAccountCredentials.from_service_account_info(self.INFO)\n        creds = creds.with_gdch_audience(self.AUDIENCE)\n        req = google.auth.transport.requests.Request()\n\n        mock_jwt_token = \"jwt token\"\n        create_jwt.return_value = mock_jwt_token\n        sts_token = \"STS token\"\n        token_endpoint_request.return_value = {\n            \"access_token\": sts_token,\n            \"issued_token_type\": \"urn:ietf:params:oauth:token-type:access_token\",\n            \"token_type\": \"Bearer\",\n            \"expires_in\": 3600,\n        }\n\n        creds.refresh(req)\n\n        token_endpoint_request.assert_called_with(\n            req,\n            self.TOKEN_URI,\n            {\n                \"grant_type\": gdch_credentials.TOKEN_EXCHANGE_TYPE,\n                \"audience\": self.AUDIENCE,\n                \"requested_token_type\": gdch_credentials.ACCESS_TOKEN_TOKEN_TYPE,\n                \"subject_token\": mock_jwt_token,\n                \"subject_token_type\": gdch_credentials.SERVICE_ACCOUNT_TOKEN_TYPE,\n            },\n            access_token=None,\n            use_json=True,\n            verify=self.CA_CERT_PATH,\n        )\n        assert creds.token == sts_token\n\n    def test_refresh_wrong_requests_object(self):\n        creds = ServiceAccountCredentials.from_service_account_info(self.INFO)\n        creds = creds.with_gdch_audience(self.AUDIENCE)\n        req = requests.Request()\n\n        with pytest.raises(exceptions.RefreshError) as excinfo:\n            creds.refresh(req)\n        assert excinfo.match(\n            \"request must be a google.auth.transport.requests.Request object\"\n        )\n\n    def test__from_signer_and_info_wrong_format_version(self):\n        with pytest.raises(ValueError) as excinfo:\n            ServiceAccountCredentials._from_signer_and_info(\n                mock.Mock(), {\"format_version\": \"2\"}\n            )\n        assert excinfo.match(\"Only format version 1 is supported\")\n\n    def test_from_service_account_info_miss_field(self):\n        for field in [\n            \"format_version\",\n            \"private_key_id\",\n            \"private_key\",\n            \"name\",\n            \"project\",\n            \"token_uri\",\n        ]:\n            info_with_missing_field = copy.deepcopy(self.INFO)\n            del info_with_missing_field[field]\n            with pytest.raises(ValueError) as excinfo:\n                ServiceAccountCredentials.from_service_account_info(\n                    info_with_missing_field\n                )\n            assert excinfo.match(\"missing fields\")\n\n    @mock.patch(\"google.auth._service_account_info.from_filename\")\n    def test_from_service_account_file(self, from_filename):\n        mock_signer = mock.Mock()\n        from_filename.return_value = (self.INFO, mock_signer)\n        creds = ServiceAccountCredentials.from_service_account_file(self.JSON_PATH)\n        from_filename.assert_called_with(\n            self.JSON_PATH,\n            require=[\n                \"format_version\",\n                \"private_key_id\",\n                \"private_key\",\n                \"name\",\n                \"project\",\n                \"token_uri\",\n            ],\n            use_rsa_signer=False,\n        )\n        assert creds._signer == mock_signer\n        assert creds._service_identity_name == self.NAME\n        assert creds._audience is None\n        assert creds._token_uri == self.TOKEN_URI\n        assert creds._ca_cert_path == self.CA_CERT_PATH\n", "tests/oauth2/test_webauthn_handler.py": "import json\nimport struct\n\nimport mock\nimport pytest  # type: ignore\n\nfrom google.auth import exceptions\nfrom google.oauth2 import webauthn_handler\nfrom google.oauth2 import webauthn_types\n\n\n@pytest.fixture\ndef os_get_stub():\n    with mock.patch.object(\n        webauthn_handler.os.environ,\n        \"get\",\n        return_value=\"gcloud_webauthn_plugin\",\n        name=\"fake os.environ.get\",\n    ) as mock_os_environ_get:\n        yield mock_os_environ_get\n\n\n@pytest.fixture\ndef subprocess_run_stub():\n    with mock.patch.object(\n        webauthn_handler.subprocess, \"run\", name=\"fake subprocess.run\"\n    ) as mock_subprocess_run:\n        yield mock_subprocess_run\n\n\ndef test_PluginHandler_is_available(os_get_stub):\n    test_handler = webauthn_handler.PluginHandler()\n\n    assert test_handler.is_available() is True\n\n    os_get_stub.return_value = None\n    assert test_handler.is_available() is False\n\n\nGET_ASSERTION_REQUEST = webauthn_types.GetRequest(\n    origin=\"fake_origin\",\n    rpid=\"fake_rpid\",\n    challenge=\"fake_challenge\",\n    allow_credentials=[webauthn_types.PublicKeyCredentialDescriptor(id=\"fake_id_1\")],\n)\n\n\ndef test_malformated_get_assertion_response(os_get_stub, subprocess_run_stub):\n    response_len = struct.pack(\"<I\", 5)\n    response = \"1234567890\"\n    mock_response = mock.Mock()\n    mock_response.stdout = response_len + response.encode()\n    subprocess_run_stub.return_value = mock_response\n\n    test_handler = webauthn_handler.PluginHandler()\n    with pytest.raises(exceptions.MalformedError) as excinfo:\n        test_handler.get(GET_ASSERTION_REQUEST)\n    assert \"Plugin response length\" in str(excinfo.value)\n\n\ndef test_failure_get_assertion(os_get_stub, subprocess_run_stub):\n    failure_response = {\n        \"type\": \"getResponse\",\n        \"error\": \"fake_plugin_get_assertion_failure\",\n    }\n    response_json = json.dumps(failure_response).encode()\n    response_len = struct.pack(\"<I\", len(response_json))\n\n    # process returns get response in json\n    mock_response = mock.Mock()\n    mock_response.stdout = response_len + response_json\n    subprocess_run_stub.return_value = mock_response\n\n    test_handler = webauthn_handler.PluginHandler()\n    with pytest.raises(exceptions.ReauthFailError) as excinfo:\n        test_handler.get(GET_ASSERTION_REQUEST)\n    assert failure_response[\"error\"] in str(excinfo.value)\n\n\ndef test_success_get_assertion(os_get_stub, subprocess_run_stub):\n    success_response = {\n        \"type\": \"public-key\",\n        \"id\": \"fake-id\",\n        \"authenticatorAttachment\": \"cross-platform\",\n        \"clientExtensionResults\": {\"appid\": True},\n        \"response\": {\n            \"clientDataJSON\": \"fake_client_data_json_base64\",\n            \"authenticatorData\": \"fake_authenticator_data_base64\",\n            \"signature\": \"fake_signature_base64\",\n            \"userHandle\": \"fake_user_handle_base64\",\n        },\n    }\n    valid_plugin_response = {\"type\": \"getResponse\", \"responseData\": success_response}\n    valid_plugin_response_json = json.dumps(valid_plugin_response).encode()\n    valid_plugin_response_len = struct.pack(\"<I\", len(valid_plugin_response_json))\n\n    # process returns get response in json\n    mock_response = mock.Mock()\n    mock_response.stdout = valid_plugin_response_len + valid_plugin_response_json\n    subprocess_run_stub.return_value = mock_response\n\n    # Call get()\n    test_handler = webauthn_handler.PluginHandler()\n    got_response = test_handler.get(GET_ASSERTION_REQUEST)\n\n    # Validate expected plugin request\n    os_get_stub.assert_called_once()\n    subprocess_run_stub.assert_called_once()\n\n    stdin_input = subprocess_run_stub.call_args.kwargs[\"input\"]\n    input_json_len_le = stdin_input[:4]\n    input_json_len = struct.unpack(\"<I\", input_json_len_le)[0]\n    input_json = stdin_input[4:]\n    assert len(input_json) == input_json_len\n\n    input_dict = json.loads(input_json.decode(\"utf8\"))\n    assert input_dict == {\n        \"type\": \"get\",\n        \"origin\": \"fake_origin\",\n        \"requestData\": {\n            \"rpid\": \"fake_rpid\",\n            \"challenge\": \"fake_challenge\",\n            \"allowCredentials\": [{\"type\": \"public-key\", \"id\": \"fake_id_1\"}],\n        },\n    }\n\n    # Validate get assertion response\n    assert got_response.id == success_response[\"id\"]\n    assert (\n        got_response.authenticator_attachment\n        == success_response[\"authenticatorAttachment\"]\n    )\n    assert (\n        got_response.client_extension_results\n        == success_response[\"clientExtensionResults\"]\n    )\n    assert (\n        got_response.response.client_data_json\n        == success_response[\"response\"][\"clientDataJSON\"]\n    )\n    assert (\n        got_response.response.authenticator_data\n        == success_response[\"response\"][\"authenticatorData\"]\n    )\n    assert got_response.response.signature == success_response[\"response\"][\"signature\"]\n    assert (\n        got_response.response.user_handle == success_response[\"response\"][\"userHandle\"]\n    )\n", "tests/oauth2/test_reauth.py": "# Copyright 2021 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport copy\n\nimport mock\nimport pytest  # type: ignore\n\nfrom google.auth import exceptions\nfrom google.oauth2 import reauth\n\n\nMOCK_REQUEST = mock.Mock()\nCHALLENGES_RESPONSE_TEMPLATE = {\n    \"status\": \"CHALLENGE_REQUIRED\",\n    \"sessionId\": \"123\",\n    \"challenges\": [\n        {\n            \"status\": \"READY\",\n            \"challengeId\": 1,\n            \"challengeType\": \"PASSWORD\",\n            \"securityKey\": {},\n        }\n    ],\n}\nCHALLENGES_RESPONSE_AUTHENTICATED = {\n    \"status\": \"AUTHENTICATED\",\n    \"sessionId\": \"123\",\n    \"encodedProofOfReauthToken\": \"new_rapt_token\",\n}\n\nREAUTH_START_METRICS_HEADER_VALUE = \"gl-python/3.7 auth/1.1 auth-request-type/re-start\"\nREAUTH_CONTINUE_METRICS_HEADER_VALUE = (\n    \"gl-python/3.7 auth/1.1 auth-request-type/re-cont\"\n)\nTOKEN_REQUEST_METRICS_HEADER_VALUE = \"gl-python/3.7 auth/1.1 cred-type/u\"\n\n\nclass MockChallenge(object):\n    def __init__(self, name, locally_eligible, challenge_input):\n        self.name = name\n        self.is_locally_eligible = locally_eligible\n        self.challenge_input = challenge_input\n\n    def obtain_challenge_input(self, metadata):\n        return self.challenge_input\n\n\ndef test_is_interactive():\n    with mock.patch(\"sys.stdin.isatty\", return_value=True):\n        assert reauth.is_interactive()\n\n\n@mock.patch(\n    \"google.auth.metrics.reauth_start\", return_value=REAUTH_START_METRICS_HEADER_VALUE\n)\ndef test__get_challenges(mock_metrics_header_value):\n    with mock.patch(\n        \"google.oauth2._client._token_endpoint_request\"\n    ) as mock_token_endpoint_request:\n        reauth._get_challenges(MOCK_REQUEST, [\"SAML\"], \"token\")\n        mock_token_endpoint_request.assert_called_with(\n            MOCK_REQUEST,\n            reauth._REAUTH_API + \":start\",\n            {\"supportedChallengeTypes\": [\"SAML\"]},\n            access_token=\"token\",\n            use_json=True,\n            headers={\"x-goog-api-client\": REAUTH_START_METRICS_HEADER_VALUE},\n        )\n\n\n@mock.patch(\n    \"google.auth.metrics.reauth_start\", return_value=REAUTH_START_METRICS_HEADER_VALUE\n)\ndef test__get_challenges_with_scopes(mock_metrics_header_value):\n    with mock.patch(\n        \"google.oauth2._client._token_endpoint_request\"\n    ) as mock_token_endpoint_request:\n        reauth._get_challenges(\n            MOCK_REQUEST, [\"SAML\"], \"token\", requested_scopes=[\"scope\"]\n        )\n        mock_token_endpoint_request.assert_called_with(\n            MOCK_REQUEST,\n            reauth._REAUTH_API + \":start\",\n            {\n                \"supportedChallengeTypes\": [\"SAML\"],\n                \"oauthScopesForDomainPolicyLookup\": [\"scope\"],\n            },\n            access_token=\"token\",\n            use_json=True,\n            headers={\"x-goog-api-client\": REAUTH_START_METRICS_HEADER_VALUE},\n        )\n\n\n@mock.patch(\n    \"google.auth.metrics.reauth_continue\",\n    return_value=REAUTH_CONTINUE_METRICS_HEADER_VALUE,\n)\ndef test__send_challenge_result(mock_metrics_header_value):\n    with mock.patch(\n        \"google.oauth2._client._token_endpoint_request\"\n    ) as mock_token_endpoint_request:\n        reauth._send_challenge_result(\n            MOCK_REQUEST, \"123\", \"1\", {\"credential\": \"password\"}, \"token\"\n        )\n        mock_token_endpoint_request.assert_called_with(\n            MOCK_REQUEST,\n            reauth._REAUTH_API + \"/123:continue\",\n            {\n                \"sessionId\": \"123\",\n                \"challengeId\": \"1\",\n                \"action\": \"RESPOND\",\n                \"proposalResponse\": {\"credential\": \"password\"},\n            },\n            access_token=\"token\",\n            use_json=True,\n            headers={\"x-goog-api-client\": REAUTH_CONTINUE_METRICS_HEADER_VALUE},\n        )\n\n\ndef test__run_next_challenge_not_ready():\n    challenges_response = copy.deepcopy(CHALLENGES_RESPONSE_TEMPLATE)\n    challenges_response[\"challenges\"][0][\"status\"] = \"STATUS_UNSPECIFIED\"\n    assert (\n        reauth._run_next_challenge(challenges_response, MOCK_REQUEST, \"token\") is None\n    )\n\n\ndef test__run_next_challenge_not_supported():\n    challenges_response = copy.deepcopy(CHALLENGES_RESPONSE_TEMPLATE)\n    challenges_response[\"challenges\"][0][\"challengeType\"] = \"CHALLENGE_TYPE_UNSPECIFIED\"\n    with pytest.raises(exceptions.ReauthFailError) as excinfo:\n        reauth._run_next_challenge(challenges_response, MOCK_REQUEST, \"token\")\n    assert excinfo.match(r\"Unsupported challenge type CHALLENGE_TYPE_UNSPECIFIED\")\n\n\ndef test__run_next_challenge_not_locally_eligible():\n    mock_challenge = MockChallenge(\"PASSWORD\", False, \"challenge_input\")\n    with mock.patch(\n        \"google.oauth2.challenges.AVAILABLE_CHALLENGES\", {\"PASSWORD\": mock_challenge}\n    ):\n        with pytest.raises(exceptions.ReauthFailError) as excinfo:\n            reauth._run_next_challenge(\n                CHALLENGES_RESPONSE_TEMPLATE, MOCK_REQUEST, \"token\"\n            )\n        assert excinfo.match(r\"Challenge PASSWORD is not locally eligible\")\n\n\ndef test__run_next_challenge_no_challenge_input():\n    mock_challenge = MockChallenge(\"PASSWORD\", True, None)\n    with mock.patch(\n        \"google.oauth2.challenges.AVAILABLE_CHALLENGES\", {\"PASSWORD\": mock_challenge}\n    ):\n        assert (\n            reauth._run_next_challenge(\n                CHALLENGES_RESPONSE_TEMPLATE, MOCK_REQUEST, \"token\"\n            )\n            is None\n        )\n\n\ndef test__run_next_challenge_success():\n    mock_challenge = MockChallenge(\"PASSWORD\", True, {\"credential\": \"password\"})\n    with mock.patch(\n        \"google.oauth2.challenges.AVAILABLE_CHALLENGES\", {\"PASSWORD\": mock_challenge}\n    ):\n        with mock.patch(\n            \"google.oauth2.reauth._send_challenge_result\"\n        ) as mock_send_challenge_result:\n            reauth._run_next_challenge(\n                CHALLENGES_RESPONSE_TEMPLATE, MOCK_REQUEST, \"token\"\n            )\n            mock_send_challenge_result.assert_called_with(\n                MOCK_REQUEST, \"123\", 1, {\"credential\": \"password\"}, \"token\"\n            )\n\n\ndef test__obtain_rapt_authenticated():\n    with mock.patch(\n        \"google.oauth2.reauth._get_challenges\",\n        return_value=CHALLENGES_RESPONSE_AUTHENTICATED,\n    ):\n        assert reauth._obtain_rapt(MOCK_REQUEST, \"token\", None) == \"new_rapt_token\"\n\n\ndef test__obtain_rapt_authenticated_after_run_next_challenge():\n    with mock.patch(\n        \"google.oauth2.reauth._get_challenges\",\n        return_value=CHALLENGES_RESPONSE_TEMPLATE,\n    ):\n        with mock.patch(\n            \"google.oauth2.reauth._run_next_challenge\",\n            side_effect=[\n                CHALLENGES_RESPONSE_TEMPLATE,\n                CHALLENGES_RESPONSE_AUTHENTICATED,\n            ],\n        ):\n            with mock.patch(\"google.oauth2.reauth.is_interactive\", return_value=True):\n                assert (\n                    reauth._obtain_rapt(MOCK_REQUEST, \"token\", None) == \"new_rapt_token\"\n                )\n\n\ndef test__obtain_rapt_unsupported_status():\n    challenges_response = copy.deepcopy(CHALLENGES_RESPONSE_TEMPLATE)\n    challenges_response[\"status\"] = \"STATUS_UNSPECIFIED\"\n    with mock.patch(\n        \"google.oauth2.reauth._get_challenges\", return_value=challenges_response\n    ):\n        with pytest.raises(exceptions.ReauthFailError) as excinfo:\n            reauth._obtain_rapt(MOCK_REQUEST, \"token\", None)\n        assert excinfo.match(r\"API error: STATUS_UNSPECIFIED\")\n\n\ndef test__obtain_rapt_no_challenge_output():\n    challenges_response = copy.deepcopy(CHALLENGES_RESPONSE_TEMPLATE)\n    with mock.patch(\n        \"google.oauth2.reauth._get_challenges\", return_value=challenges_response\n    ):\n        with mock.patch(\"google.oauth2.reauth.is_interactive\", return_value=True):\n            with mock.patch(\n                \"google.oauth2.reauth._run_next_challenge\", return_value=None\n            ):\n                with pytest.raises(exceptions.ReauthFailError) as excinfo:\n                    reauth._obtain_rapt(MOCK_REQUEST, \"token\", None)\n        assert excinfo.match(r\"Failed to obtain rapt token\")\n\n\ndef test__obtain_rapt_not_interactive():\n    with mock.patch(\n        \"google.oauth2.reauth._get_challenges\",\n        return_value=CHALLENGES_RESPONSE_TEMPLATE,\n    ):\n        with mock.patch(\"google.oauth2.reauth.is_interactive\", return_value=False):\n            with pytest.raises(exceptions.ReauthFailError) as excinfo:\n                reauth._obtain_rapt(MOCK_REQUEST, \"token\", None)\n            assert excinfo.match(r\"not in an interactive session\")\n\n\ndef test__obtain_rapt_not_authenticated():\n    with mock.patch(\n        \"google.oauth2.reauth._get_challenges\",\n        return_value=CHALLENGES_RESPONSE_TEMPLATE,\n    ):\n        with mock.patch(\"google.oauth2.reauth.RUN_CHALLENGE_RETRY_LIMIT\", 0):\n            with pytest.raises(exceptions.ReauthFailError) as excinfo:\n                reauth._obtain_rapt(MOCK_REQUEST, \"token\", None)\n            assert excinfo.match(r\"Reauthentication failed\")\n\n\ndef test_get_rapt_token():\n    with mock.patch(\n        \"google.oauth2._client.refresh_grant\", return_value=(\"token\", None, None, None)\n    ) as mock_refresh_grant:\n        with mock.patch(\n            \"google.oauth2.reauth._obtain_rapt\", return_value=\"new_rapt_token\"\n        ) as mock_obtain_rapt:\n            assert (\n                reauth.get_rapt_token(\n                    MOCK_REQUEST,\n                    \"client_id\",\n                    \"client_secret\",\n                    \"refresh_token\",\n                    \"token_uri\",\n                )\n                == \"new_rapt_token\"\n            )\n            mock_refresh_grant.assert_called_with(\n                request=MOCK_REQUEST,\n                client_id=\"client_id\",\n                client_secret=\"client_secret\",\n                refresh_token=\"refresh_token\",\n                token_uri=\"token_uri\",\n                scopes=[reauth._REAUTH_SCOPE],\n            )\n            mock_obtain_rapt.assert_called_with(\n                MOCK_REQUEST, \"token\", requested_scopes=None\n            )\n\n\n@mock.patch(\n    \"google.auth.metrics.token_request_user\",\n    return_value=TOKEN_REQUEST_METRICS_HEADER_VALUE,\n)\ndef test_refresh_grant_failed(mock_metrics_header_value):\n    with mock.patch(\n        \"google.oauth2._client._token_endpoint_request_no_throw\"\n    ) as mock_token_request:\n        mock_token_request.return_value = (False, {\"error\": \"Bad request\"}, False)\n        with pytest.raises(exceptions.RefreshError) as excinfo:\n            reauth.refresh_grant(\n                MOCK_REQUEST,\n                \"token_uri\",\n                \"refresh_token\",\n                \"client_id\",\n                \"client_secret\",\n                scopes=[\"foo\", \"bar\"],\n                rapt_token=\"rapt_token\",\n                enable_reauth_refresh=True,\n            )\n        assert excinfo.match(r\"Bad request\")\n        assert not excinfo.value.retryable\n        mock_token_request.assert_called_with(\n            MOCK_REQUEST,\n            \"token_uri\",\n            {\n                \"grant_type\": \"refresh_token\",\n                \"client_id\": \"client_id\",\n                \"client_secret\": \"client_secret\",\n                \"refresh_token\": \"refresh_token\",\n                \"scope\": \"foo bar\",\n                \"rapt\": \"rapt_token\",\n            },\n            headers={\"x-goog-api-client\": TOKEN_REQUEST_METRICS_HEADER_VALUE},\n        )\n\n\ndef test_refresh_grant_failed_with_string_type_response():\n    with mock.patch(\n        \"google.oauth2._client._token_endpoint_request_no_throw\"\n    ) as mock_token_request:\n        mock_token_request.return_value = (False, \"string type error\", False)\n        with pytest.raises(exceptions.RefreshError) as excinfo:\n            reauth.refresh_grant(\n                MOCK_REQUEST,\n                \"token_uri\",\n                \"refresh_token\",\n                \"client_id\",\n                \"client_secret\",\n                scopes=[\"foo\", \"bar\"],\n                rapt_token=\"rapt_token\",\n                enable_reauth_refresh=True,\n            )\n        assert excinfo.match(r\"string type error\")\n        assert not excinfo.value.retryable\n\n\ndef test_refresh_grant_success():\n    with mock.patch(\n        \"google.oauth2._client._token_endpoint_request_no_throw\"\n    ) as mock_token_request:\n        mock_token_request.side_effect = [\n            (False, {\"error\": \"invalid_grant\", \"error_subtype\": \"rapt_required\"}, True),\n            (True, {\"access_token\": \"access_token\"}, None),\n        ]\n        with mock.patch(\n            \"google.oauth2.reauth.get_rapt_token\", return_value=\"new_rapt_token\"\n        ):\n            assert reauth.refresh_grant(\n                MOCK_REQUEST,\n                \"token_uri\",\n                \"refresh_token\",\n                \"client_id\",\n                \"client_secret\",\n                enable_reauth_refresh=True,\n            ) == (\n                \"access_token\",\n                \"refresh_token\",\n                None,\n                {\"access_token\": \"access_token\"},\n                \"new_rapt_token\",\n            )\n\n\ndef test_refresh_grant_reauth_refresh_disabled():\n    with mock.patch(\n        \"google.oauth2._client._token_endpoint_request_no_throw\"\n    ) as mock_token_request:\n        mock_token_request.side_effect = [\n            (False, {\"error\": \"invalid_grant\", \"error_subtype\": \"rapt_required\"}, True),\n            (True, {\"access_token\": \"access_token\"}, None),\n        ]\n        with pytest.raises(exceptions.RefreshError) as excinfo:\n            reauth.refresh_grant(\n                MOCK_REQUEST, \"token_uri\", \"refresh_token\", \"client_id\", \"client_secret\"\n            )\n        assert excinfo.match(r\"Reauthentication is needed\")\n", "tests/oauth2/test_credentials.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport datetime\nimport json\nimport os\nimport pickle\nimport sys\n\nimport mock\nimport pytest  # type: ignore\n\nfrom google.auth import _helpers\nfrom google.auth import exceptions\nfrom google.auth import transport\nfrom google.auth.credentials import TokenState\nfrom google.oauth2 import credentials\n\n\nDATA_DIR = os.path.join(os.path.dirname(__file__), \"..\", \"data\")\n\nAUTH_USER_JSON_FILE = os.path.join(DATA_DIR, \"authorized_user.json\")\n\nwith open(AUTH_USER_JSON_FILE, \"r\") as fh:\n    AUTH_USER_INFO = json.load(fh)\n\n\nclass TestCredentials(object):\n    TOKEN_URI = \"https://example.com/oauth2/token\"\n    REFRESH_TOKEN = \"refresh_token\"\n    RAPT_TOKEN = \"rapt_token\"\n    CLIENT_ID = \"client_id\"\n    CLIENT_SECRET = \"client_secret\"\n\n    @classmethod\n    def make_credentials(cls):\n        return credentials.Credentials(\n            token=None,\n            refresh_token=cls.REFRESH_TOKEN,\n            token_uri=cls.TOKEN_URI,\n            client_id=cls.CLIENT_ID,\n            client_secret=cls.CLIENT_SECRET,\n            rapt_token=cls.RAPT_TOKEN,\n            enable_reauth_refresh=True,\n        )\n\n    def test_default_state(self):\n        credentials = self.make_credentials()\n        assert not credentials.valid\n        # Expiration hasn't been set yet\n        assert not credentials.expired\n        # Scopes aren't required for these credentials\n        assert not credentials.requires_scopes\n        assert credentials.token_state == TokenState.INVALID\n        # Test properties\n        assert credentials.refresh_token == self.REFRESH_TOKEN\n        assert credentials.token_uri == self.TOKEN_URI\n        assert credentials.client_id == self.CLIENT_ID\n        assert credentials.client_secret == self.CLIENT_SECRET\n        assert credentials.rapt_token == self.RAPT_TOKEN\n        assert credentials.refresh_handler is None\n\n    def test_token_usage_metrics(self):\n        credentials = self.make_credentials()\n        credentials.token = \"token\"\n        credentials.expiry = None\n\n        headers = {}\n        credentials.before_request(mock.Mock(), None, None, headers)\n        assert headers[\"authorization\"] == \"Bearer token\"\n        assert headers[\"x-goog-api-client\"] == \"cred-type/u\"\n\n    def test_refresh_handler_setter_and_getter(self):\n        scopes = [\"email\", \"profile\"]\n        original_refresh_handler = mock.Mock(return_value=(\"ACCESS_TOKEN_1\", None))\n        updated_refresh_handler = mock.Mock(return_value=(\"ACCESS_TOKEN_2\", None))\n        creds = credentials.Credentials(\n            token=None,\n            refresh_token=None,\n            token_uri=None,\n            client_id=None,\n            client_secret=None,\n            rapt_token=None,\n            scopes=scopes,\n            default_scopes=None,\n            refresh_handler=original_refresh_handler,\n        )\n\n        assert creds.refresh_handler is original_refresh_handler\n\n        creds.refresh_handler = updated_refresh_handler\n\n        assert creds.refresh_handler is updated_refresh_handler\n\n        creds.refresh_handler = None\n\n        assert creds.refresh_handler is None\n\n    def test_invalid_refresh_handler(self):\n        scopes = [\"email\", \"profile\"]\n        with pytest.raises(TypeError) as excinfo:\n            credentials.Credentials(\n                token=None,\n                refresh_token=None,\n                token_uri=None,\n                client_id=None,\n                client_secret=None,\n                rapt_token=None,\n                scopes=scopes,\n                default_scopes=None,\n                refresh_handler=object(),\n            )\n\n        assert excinfo.match(\"The provided refresh_handler is not a callable or None.\")\n\n    def test_refresh_with_non_default_universe_domain(self):\n        creds = credentials.Credentials(\n            token=\"token\", universe_domain=\"dummy_universe.com\"\n        )\n        with pytest.raises(exceptions.RefreshError) as excinfo:\n            creds.refresh(mock.Mock())\n\n        assert excinfo.match(\n            \"refresh is only supported in the default googleapis.com universe domain\"\n        )\n\n    @mock.patch(\"google.oauth2.reauth.refresh_grant\", autospec=True)\n    @mock.patch(\n        \"google.auth._helpers.utcnow\",\n        return_value=datetime.datetime.min + _helpers.REFRESH_THRESHOLD,\n    )\n    def test_refresh_success(self, unused_utcnow, refresh_grant):\n        token = \"token\"\n        new_rapt_token = \"new_rapt_token\"\n        expiry = _helpers.utcnow() + datetime.timedelta(seconds=500)\n        grant_response = {\"id_token\": mock.sentinel.id_token}\n        refresh_grant.return_value = (\n            # Access token\n            token,\n            # New refresh token\n            None,\n            # Expiry,\n            expiry,\n            # Extra data\n            grant_response,\n            # rapt_token\n            new_rapt_token,\n        )\n\n        request = mock.create_autospec(transport.Request)\n        credentials = self.make_credentials()\n\n        # Refresh credentials\n        credentials.refresh(request)\n\n        # Check jwt grant call.\n        refresh_grant.assert_called_with(\n            request,\n            self.TOKEN_URI,\n            self.REFRESH_TOKEN,\n            self.CLIENT_ID,\n            self.CLIENT_SECRET,\n            None,\n            self.RAPT_TOKEN,\n            True,\n        )\n\n        # Check that the credentials have the token and expiry\n        assert credentials.token == token\n        assert credentials.expiry == expiry\n        assert credentials.id_token == mock.sentinel.id_token\n        assert credentials.rapt_token == new_rapt_token\n\n        # Check that the credentials are valid (have a token and are not\n        # expired)\n        assert credentials.valid\n\n    def test_refresh_no_refresh_token(self):\n        request = mock.create_autospec(transport.Request)\n        credentials_ = credentials.Credentials(token=None, refresh_token=None)\n\n        with pytest.raises(exceptions.RefreshError, match=\"necessary fields\"):\n            credentials_.refresh(request)\n\n        request.assert_not_called()\n\n    @mock.patch(\"google.oauth2.reauth.refresh_grant\", autospec=True)\n    @mock.patch(\n        \"google.auth._helpers.utcnow\",\n        return_value=datetime.datetime.min + _helpers.REFRESH_THRESHOLD,\n    )\n    def test_refresh_with_refresh_token_and_refresh_handler(\n        self, unused_utcnow, refresh_grant\n    ):\n        token = \"token\"\n        new_rapt_token = \"new_rapt_token\"\n        expiry = _helpers.utcnow() + datetime.timedelta(seconds=500)\n        grant_response = {\"id_token\": mock.sentinel.id_token}\n        refresh_grant.return_value = (\n            # Access token\n            token,\n            # New refresh token\n            None,\n            # Expiry,\n            expiry,\n            # Extra data\n            grant_response,\n            # rapt_token\n            new_rapt_token,\n        )\n\n        refresh_handler = mock.Mock()\n        request = mock.create_autospec(transport.Request)\n        creds = credentials.Credentials(\n            token=None,\n            refresh_token=self.REFRESH_TOKEN,\n            token_uri=self.TOKEN_URI,\n            client_id=self.CLIENT_ID,\n            client_secret=self.CLIENT_SECRET,\n            rapt_token=self.RAPT_TOKEN,\n            refresh_handler=refresh_handler,\n        )\n\n        # Refresh credentials\n        creds.refresh(request)\n\n        # Check jwt grant call.\n        refresh_grant.assert_called_with(\n            request,\n            self.TOKEN_URI,\n            self.REFRESH_TOKEN,\n            self.CLIENT_ID,\n            self.CLIENT_SECRET,\n            None,\n            self.RAPT_TOKEN,\n            False,\n        )\n\n        # Check that the credentials have the token and expiry\n        assert creds.token == token\n        assert creds.expiry == expiry\n        assert creds.id_token == mock.sentinel.id_token\n        assert creds.rapt_token == new_rapt_token\n\n        # Check that the credentials are valid (have a token and are not\n        # expired)\n        assert creds.valid\n\n        # Assert refresh handler not called as the refresh token has\n        # higher priority.\n        refresh_handler.assert_not_called()\n\n    @mock.patch(\"google.auth._helpers.utcnow\", return_value=datetime.datetime.min)\n    def test_refresh_with_refresh_handler_success_scopes(self, unused_utcnow):\n        expected_expiry = datetime.datetime.min + datetime.timedelta(seconds=2800)\n        refresh_handler = mock.Mock(return_value=(\"ACCESS_TOKEN\", expected_expiry))\n        scopes = [\"email\", \"profile\"]\n        default_scopes = [\"https://www.googleapis.com/auth/cloud-platform\"]\n        request = mock.create_autospec(transport.Request)\n        creds = credentials.Credentials(\n            token=None,\n            refresh_token=None,\n            token_uri=None,\n            client_id=None,\n            client_secret=None,\n            rapt_token=None,\n            scopes=scopes,\n            default_scopes=default_scopes,\n            refresh_handler=refresh_handler,\n        )\n\n        creds.refresh(request)\n\n        assert creds.token == \"ACCESS_TOKEN\"\n        assert creds.expiry == expected_expiry\n        assert creds.valid\n        assert not creds.expired\n        # Confirm refresh handler called with the expected arguments.\n        refresh_handler.assert_called_with(request, scopes=scopes)\n\n    @mock.patch(\"google.auth._helpers.utcnow\", return_value=datetime.datetime.min)\n    def test_refresh_with_refresh_handler_success_default_scopes(self, unused_utcnow):\n        expected_expiry = datetime.datetime.min + datetime.timedelta(seconds=2800)\n        original_refresh_handler = mock.Mock(\n            return_value=(\"UNUSED_TOKEN\", expected_expiry)\n        )\n        refresh_handler = mock.Mock(return_value=(\"ACCESS_TOKEN\", expected_expiry))\n        default_scopes = [\"https://www.googleapis.com/auth/cloud-platform\"]\n        request = mock.create_autospec(transport.Request)\n        creds = credentials.Credentials(\n            token=None,\n            refresh_token=None,\n            token_uri=None,\n            client_id=None,\n            client_secret=None,\n            rapt_token=None,\n            scopes=None,\n            default_scopes=default_scopes,\n            refresh_handler=original_refresh_handler,\n        )\n\n        # Test newly set refresh_handler is used instead of the original one.\n        creds.refresh_handler = refresh_handler\n        creds.refresh(request)\n\n        assert creds.token == \"ACCESS_TOKEN\"\n        assert creds.expiry == expected_expiry\n        assert creds.valid\n        assert not creds.expired\n        # default_scopes should be used since no developer provided scopes\n        # are provided.\n        refresh_handler.assert_called_with(request, scopes=default_scopes)\n\n    @mock.patch(\"google.auth._helpers.utcnow\", return_value=datetime.datetime.min)\n    def test_refresh_with_refresh_handler_invalid_token(self, unused_utcnow):\n        expected_expiry = datetime.datetime.min + datetime.timedelta(seconds=2800)\n        # Simulate refresh handler does not return a valid token.\n        refresh_handler = mock.Mock(return_value=(None, expected_expiry))\n        scopes = [\"email\", \"profile\"]\n        default_scopes = [\"https://www.googleapis.com/auth/cloud-platform\"]\n        request = mock.create_autospec(transport.Request)\n        creds = credentials.Credentials(\n            token=None,\n            refresh_token=None,\n            token_uri=None,\n            client_id=None,\n            client_secret=None,\n            rapt_token=None,\n            scopes=scopes,\n            default_scopes=default_scopes,\n            refresh_handler=refresh_handler,\n        )\n\n        with pytest.raises(\n            exceptions.RefreshError, match=\"returned token is not a string\"\n        ):\n            creds.refresh(request)\n\n        assert creds.token is None\n        assert creds.expiry is None\n        assert not creds.valid\n        # Confirm refresh handler called with the expected arguments.\n        refresh_handler.assert_called_with(request, scopes=scopes)\n\n    def test_refresh_with_refresh_handler_invalid_expiry(self):\n        # Simulate refresh handler returns expiration time in an invalid unit.\n        refresh_handler = mock.Mock(return_value=(\"TOKEN\", 2800))\n        scopes = [\"email\", \"profile\"]\n        default_scopes = [\"https://www.googleapis.com/auth/cloud-platform\"]\n        request = mock.create_autospec(transport.Request)\n        creds = credentials.Credentials(\n            token=None,\n            refresh_token=None,\n            token_uri=None,\n            client_id=None,\n            client_secret=None,\n            rapt_token=None,\n            scopes=scopes,\n            default_scopes=default_scopes,\n            refresh_handler=refresh_handler,\n        )\n\n        with pytest.raises(\n            exceptions.RefreshError, match=\"returned expiry is not a datetime object\"\n        ):\n            creds.refresh(request)\n\n        assert creds.token is None\n        assert creds.expiry is None\n        assert not creds.valid\n        # Confirm refresh handler called with the expected arguments.\n        refresh_handler.assert_called_with(request, scopes=scopes)\n\n    @mock.patch(\"google.auth._helpers.utcnow\", return_value=datetime.datetime.min)\n    def test_refresh_with_refresh_handler_expired_token(self, unused_utcnow):\n        expected_expiry = datetime.datetime.min + _helpers.REFRESH_THRESHOLD\n        # Simulate refresh handler returns an expired token.\n        refresh_handler = mock.Mock(return_value=(\"TOKEN\", expected_expiry))\n        scopes = [\"email\", \"profile\"]\n        default_scopes = [\"https://www.googleapis.com/auth/cloud-platform\"]\n        request = mock.create_autospec(transport.Request)\n        creds = credentials.Credentials(\n            token=None,\n            refresh_token=None,\n            token_uri=None,\n            client_id=None,\n            client_secret=None,\n            rapt_token=None,\n            scopes=scopes,\n            default_scopes=default_scopes,\n            refresh_handler=refresh_handler,\n        )\n\n        with pytest.raises(exceptions.RefreshError, match=\"already expired\"):\n            creds.refresh(request)\n\n        assert creds.token is None\n        assert creds.expiry is None\n        assert not creds.valid\n        # Confirm refresh handler called with the expected arguments.\n        refresh_handler.assert_called_with(request, scopes=scopes)\n\n    @mock.patch(\"google.oauth2.reauth.refresh_grant\", autospec=True)\n    @mock.patch(\n        \"google.auth._helpers.utcnow\",\n        return_value=datetime.datetime.min + _helpers.REFRESH_THRESHOLD,\n    )\n    def test_credentials_with_scopes_requested_refresh_success(\n        self, unused_utcnow, refresh_grant\n    ):\n        scopes = [\"email\", \"profile\"]\n        default_scopes = [\"https://www.googleapis.com/auth/cloud-platform\"]\n        token = \"token\"\n        new_rapt_token = \"new_rapt_token\"\n        expiry = _helpers.utcnow() + datetime.timedelta(seconds=500)\n        grant_response = {\"id_token\": mock.sentinel.id_token, \"scope\": \"email profile\"}\n        refresh_grant.return_value = (\n            # Access token\n            token,\n            # New refresh token\n            None,\n            # Expiry,\n            expiry,\n            # Extra data\n            grant_response,\n            # rapt token\n            new_rapt_token,\n        )\n\n        request = mock.create_autospec(transport.Request)\n        creds = credentials.Credentials(\n            token=None,\n            refresh_token=self.REFRESH_TOKEN,\n            token_uri=self.TOKEN_URI,\n            client_id=self.CLIENT_ID,\n            client_secret=self.CLIENT_SECRET,\n            scopes=scopes,\n            default_scopes=default_scopes,\n            rapt_token=self.RAPT_TOKEN,\n            enable_reauth_refresh=True,\n        )\n\n        # Refresh credentials\n        creds.refresh(request)\n\n        # Check jwt grant call.\n        refresh_grant.assert_called_with(\n            request,\n            self.TOKEN_URI,\n            self.REFRESH_TOKEN,\n            self.CLIENT_ID,\n            self.CLIENT_SECRET,\n            scopes,\n            self.RAPT_TOKEN,\n            True,\n        )\n\n        # Check that the credentials have the token and expiry\n        assert creds.token == token\n        assert creds.expiry == expiry\n        assert creds.id_token == mock.sentinel.id_token\n        assert creds.has_scopes(scopes)\n        assert creds.rapt_token == new_rapt_token\n        assert creds.granted_scopes == scopes\n\n        # Check that the credentials are valid (have a token and are not\n        # expired.)\n        assert creds.valid\n\n    @mock.patch(\"google.oauth2.reauth.refresh_grant\", autospec=True)\n    @mock.patch(\n        \"google.auth._helpers.utcnow\",\n        return_value=datetime.datetime.min + _helpers.REFRESH_THRESHOLD,\n    )\n    def test_credentials_with_only_default_scopes_requested(\n        self, unused_utcnow, refresh_grant\n    ):\n        default_scopes = [\"email\", \"profile\"]\n        token = \"token\"\n        new_rapt_token = \"new_rapt_token\"\n        expiry = _helpers.utcnow() + datetime.timedelta(seconds=500)\n        grant_response = {\"id_token\": mock.sentinel.id_token, \"scope\": \"email profile\"}\n        refresh_grant.return_value = (\n            # Access token\n            token,\n            # New refresh token\n            None,\n            # Expiry,\n            expiry,\n            # Extra data\n            grant_response,\n            # rapt token\n            new_rapt_token,\n        )\n\n        request = mock.create_autospec(transport.Request)\n        creds = credentials.Credentials(\n            token=None,\n            refresh_token=self.REFRESH_TOKEN,\n            token_uri=self.TOKEN_URI,\n            client_id=self.CLIENT_ID,\n            client_secret=self.CLIENT_SECRET,\n            default_scopes=default_scopes,\n            rapt_token=self.RAPT_TOKEN,\n            enable_reauth_refresh=True,\n        )\n\n        # Refresh credentials\n        creds.refresh(request)\n\n        # Check jwt grant call.\n        refresh_grant.assert_called_with(\n            request,\n            self.TOKEN_URI,\n            self.REFRESH_TOKEN,\n            self.CLIENT_ID,\n            self.CLIENT_SECRET,\n            default_scopes,\n            self.RAPT_TOKEN,\n            True,\n        )\n\n        # Check that the credentials have the token and expiry\n        assert creds.token == token\n        assert creds.expiry == expiry\n        assert creds.id_token == mock.sentinel.id_token\n        assert creds.has_scopes(default_scopes)\n        assert creds.rapt_token == new_rapt_token\n        assert creds.granted_scopes == default_scopes\n\n        # Check that the credentials are valid (have a token and are not\n        # expired.)\n        assert creds.valid\n\n    @mock.patch(\"google.oauth2.reauth.refresh_grant\", autospec=True)\n    @mock.patch(\n        \"google.auth._helpers.utcnow\",\n        return_value=datetime.datetime.min + _helpers.REFRESH_THRESHOLD,\n    )\n    def test_credentials_with_scopes_returned_refresh_success(\n        self, unused_utcnow, refresh_grant\n    ):\n        scopes = [\"email\", \"profile\"]\n        token = \"token\"\n        new_rapt_token = \"new_rapt_token\"\n        expiry = _helpers.utcnow() + datetime.timedelta(seconds=500)\n        grant_response = {\"id_token\": mock.sentinel.id_token, \"scope\": \" \".join(scopes)}\n        refresh_grant.return_value = (\n            # Access token\n            token,\n            # New refresh token\n            None,\n            # Expiry,\n            expiry,\n            # Extra data\n            grant_response,\n            # rapt token\n            new_rapt_token,\n        )\n\n        request = mock.create_autospec(transport.Request)\n        creds = credentials.Credentials(\n            token=None,\n            refresh_token=self.REFRESH_TOKEN,\n            token_uri=self.TOKEN_URI,\n            client_id=self.CLIENT_ID,\n            client_secret=self.CLIENT_SECRET,\n            scopes=scopes,\n            rapt_token=self.RAPT_TOKEN,\n            enable_reauth_refresh=True,\n        )\n\n        # Refresh credentials\n        creds.refresh(request)\n\n        # Check jwt grant call.\n        refresh_grant.assert_called_with(\n            request,\n            self.TOKEN_URI,\n            self.REFRESH_TOKEN,\n            self.CLIENT_ID,\n            self.CLIENT_SECRET,\n            scopes,\n            self.RAPT_TOKEN,\n            True,\n        )\n\n        # Check that the credentials have the token and expiry\n        assert creds.token == token\n        assert creds.expiry == expiry\n        assert creds.id_token == mock.sentinel.id_token\n        assert creds.has_scopes(scopes)\n        assert creds.rapt_token == new_rapt_token\n        assert creds.granted_scopes == scopes\n\n        # Check that the credentials are valid (have a token and are not\n        # expired.)\n        assert creds.valid\n\n    @mock.patch(\"google.oauth2.reauth.refresh_grant\", autospec=True)\n    @mock.patch(\n        \"google.auth._helpers.utcnow\",\n        return_value=datetime.datetime.min + _helpers.REFRESH_THRESHOLD,\n    )\n    def test_credentials_with_only_default_scopes_requested_different_granted_scopes(\n        self, unused_utcnow, refresh_grant\n    ):\n        default_scopes = [\"email\", \"profile\"]\n        token = \"token\"\n        new_rapt_token = \"new_rapt_token\"\n        expiry = _helpers.utcnow() + datetime.timedelta(seconds=500)\n        grant_response = {\"id_token\": mock.sentinel.id_token, \"scope\": \"email\"}\n        refresh_grant.return_value = (\n            # Access token\n            token,\n            # New refresh token\n            None,\n            # Expiry,\n            expiry,\n            # Extra data\n            grant_response,\n            # rapt token\n            new_rapt_token,\n        )\n\n        request = mock.create_autospec(transport.Request)\n        creds = credentials.Credentials(\n            token=None,\n            refresh_token=self.REFRESH_TOKEN,\n            token_uri=self.TOKEN_URI,\n            client_id=self.CLIENT_ID,\n            client_secret=self.CLIENT_SECRET,\n            default_scopes=default_scopes,\n            rapt_token=self.RAPT_TOKEN,\n            enable_reauth_refresh=True,\n        )\n\n        # Refresh credentials\n        creds.refresh(request)\n\n        # Check jwt grant call.\n        refresh_grant.assert_called_with(\n            request,\n            self.TOKEN_URI,\n            self.REFRESH_TOKEN,\n            self.CLIENT_ID,\n            self.CLIENT_SECRET,\n            default_scopes,\n            self.RAPT_TOKEN,\n            True,\n        )\n\n        # Check that the credentials have the token and expiry\n        assert creds.token == token\n        assert creds.expiry == expiry\n        assert creds.id_token == mock.sentinel.id_token\n        assert creds.has_scopes(default_scopes)\n        assert creds.rapt_token == new_rapt_token\n        assert creds.granted_scopes == [\"email\"]\n\n        # Check that the credentials are valid (have a token and are not\n        # expired.)\n        assert creds.valid\n\n    @mock.patch(\"google.oauth2.reauth.refresh_grant\", autospec=True)\n    @mock.patch(\n        \"google.auth._helpers.utcnow\",\n        return_value=datetime.datetime.min + _helpers.REFRESH_THRESHOLD,\n    )\n    def test_credentials_with_scopes_refresh_different_granted_scopes(\n        self, unused_utcnow, refresh_grant\n    ):\n        scopes = [\"email\", \"profile\"]\n        scopes_returned = [\"email\"]\n        token = \"token\"\n        new_rapt_token = \"new_rapt_token\"\n        expiry = _helpers.utcnow() + datetime.timedelta(seconds=500)\n        grant_response = {\n            \"id_token\": mock.sentinel.id_token,\n            \"scope\": \" \".join(scopes_returned),\n        }\n        refresh_grant.return_value = (\n            # Access token\n            token,\n            # New refresh token\n            None,\n            # Expiry,\n            expiry,\n            # Extra data\n            grant_response,\n            # rapt token\n            new_rapt_token,\n        )\n\n        request = mock.create_autospec(transport.Request)\n        creds = credentials.Credentials(\n            token=None,\n            refresh_token=self.REFRESH_TOKEN,\n            token_uri=self.TOKEN_URI,\n            client_id=self.CLIENT_ID,\n            client_secret=self.CLIENT_SECRET,\n            scopes=scopes,\n            rapt_token=self.RAPT_TOKEN,\n            enable_reauth_refresh=True,\n        )\n\n        # Refresh credentials\n        creds.refresh(request)\n\n        # Check jwt grant call.\n        refresh_grant.assert_called_with(\n            request,\n            self.TOKEN_URI,\n            self.REFRESH_TOKEN,\n            self.CLIENT_ID,\n            self.CLIENT_SECRET,\n            scopes,\n            self.RAPT_TOKEN,\n            True,\n        )\n\n        # Check that the credentials have the token and expiry\n        assert creds.token == token\n        assert creds.expiry == expiry\n        assert creds.id_token == mock.sentinel.id_token\n        assert creds.has_scopes(scopes)\n        assert creds.rapt_token == new_rapt_token\n        assert creds.granted_scopes == scopes_returned\n\n        # Check that the credentials are valid (have a token and are not\n        # expired.)\n        assert creds.valid\n\n    def test_apply_with_quota_project_id(self):\n        creds = credentials.Credentials(\n            token=\"token\",\n            refresh_token=self.REFRESH_TOKEN,\n            token_uri=self.TOKEN_URI,\n            client_id=self.CLIENT_ID,\n            client_secret=self.CLIENT_SECRET,\n            quota_project_id=\"quota-project-123\",\n        )\n\n        headers = {}\n        creds.apply(headers)\n        assert headers[\"x-goog-user-project\"] == \"quota-project-123\"\n        assert \"token\" in headers[\"authorization\"]\n\n    def test_apply_with_no_quota_project_id(self):\n        creds = credentials.Credentials(\n            token=\"token\",\n            refresh_token=self.REFRESH_TOKEN,\n            token_uri=self.TOKEN_URI,\n            client_id=self.CLIENT_ID,\n            client_secret=self.CLIENT_SECRET,\n        )\n\n        headers = {}\n        creds.apply(headers)\n        assert \"x-goog-user-project\" not in headers\n        assert \"token\" in headers[\"authorization\"]\n\n    def test_with_quota_project(self):\n        creds = credentials.Credentials(\n            token=\"token\",\n            refresh_token=self.REFRESH_TOKEN,\n            token_uri=self.TOKEN_URI,\n            client_id=self.CLIENT_ID,\n            client_secret=self.CLIENT_SECRET,\n            quota_project_id=\"quota-project-123\",\n        )\n\n        new_creds = creds.with_quota_project(\"new-project-456\")\n        assert new_creds.quota_project_id == \"new-project-456\"\n        headers = {}\n        creds.apply(headers)\n        assert \"x-goog-user-project\" in headers\n\n    def test_with_universe_domain(self):\n        creds = credentials.Credentials(token=\"token\")\n        assert creds.universe_domain == \"googleapis.com\"\n        new_creds = creds.with_universe_domain(\"dummy_universe.com\")\n        assert new_creds.universe_domain == \"dummy_universe.com\"\n\n    def test_with_account(self):\n        creds = credentials.Credentials(token=\"token\")\n        assert creds.account == \"\"\n        new_creds = creds.with_account(\"mock@example.com\")\n        assert new_creds.account == \"mock@example.com\"\n\n    def test_with_token_uri(self):\n        info = AUTH_USER_INFO.copy()\n\n        creds = credentials.Credentials.from_authorized_user_info(info)\n        new_token_uri = \"https://oauth2-eu.googleapis.com/token\"\n\n        assert creds._token_uri == credentials._GOOGLE_OAUTH2_TOKEN_ENDPOINT\n\n        creds_with_new_token_uri = creds.with_token_uri(new_token_uri)\n\n        assert creds_with_new_token_uri._token_uri == new_token_uri\n\n    def test_from_authorized_user_info(self):\n        info = AUTH_USER_INFO.copy()\n\n        creds = credentials.Credentials.from_authorized_user_info(info)\n        assert creds.client_secret == info[\"client_secret\"]\n        assert creds.client_id == info[\"client_id\"]\n        assert creds.refresh_token == info[\"refresh_token\"]\n        assert creds.token_uri == credentials._GOOGLE_OAUTH2_TOKEN_ENDPOINT\n        assert creds.scopes is None\n\n        scopes = [\"email\", \"profile\"]\n        creds = credentials.Credentials.from_authorized_user_info(info, scopes)\n        assert creds.client_secret == info[\"client_secret\"]\n        assert creds.client_id == info[\"client_id\"]\n        assert creds.refresh_token == info[\"refresh_token\"]\n        assert creds.token_uri == credentials._GOOGLE_OAUTH2_TOKEN_ENDPOINT\n        assert creds.scopes == scopes\n\n        info[\"scopes\"] = \"email\"  # single non-array scope from file\n        creds = credentials.Credentials.from_authorized_user_info(info)\n        assert creds.scopes == [info[\"scopes\"]]\n\n        info[\"scopes\"] = [\"email\", \"profile\"]  # array scope from file\n        creds = credentials.Credentials.from_authorized_user_info(info)\n        assert creds.scopes == info[\"scopes\"]\n\n        expiry = datetime.datetime(2020, 8, 14, 15, 54, 1)\n        info[\"expiry\"] = expiry.isoformat() + \"Z\"\n        creds = credentials.Credentials.from_authorized_user_info(info)\n        assert creds.expiry == expiry\n        assert creds.expired\n\n    def test_from_authorized_user_file(self):\n        info = AUTH_USER_INFO.copy()\n\n        creds = credentials.Credentials.from_authorized_user_file(AUTH_USER_JSON_FILE)\n        assert creds.client_secret == info[\"client_secret\"]\n        assert creds.client_id == info[\"client_id\"]\n        assert creds.refresh_token == info[\"refresh_token\"]\n        assert creds.token_uri == credentials._GOOGLE_OAUTH2_TOKEN_ENDPOINT\n        assert creds.scopes is None\n        assert creds.rapt_token is None\n\n        scopes = [\"email\", \"profile\"]\n        creds = credentials.Credentials.from_authorized_user_file(\n            AUTH_USER_JSON_FILE, scopes\n        )\n        assert creds.client_secret == info[\"client_secret\"]\n        assert creds.client_id == info[\"client_id\"]\n        assert creds.refresh_token == info[\"refresh_token\"]\n        assert creds.token_uri == credentials._GOOGLE_OAUTH2_TOKEN_ENDPOINT\n        assert creds.scopes == scopes\n\n    def test_from_authorized_user_file_with_rapt_token(self):\n        info = AUTH_USER_INFO.copy()\n        file_path = os.path.join(DATA_DIR, \"authorized_user_with_rapt_token.json\")\n\n        creds = credentials.Credentials.from_authorized_user_file(file_path)\n        assert creds.client_secret == info[\"client_secret\"]\n        assert creds.client_id == info[\"client_id\"]\n        assert creds.refresh_token == info[\"refresh_token\"]\n        assert creds.token_uri == credentials._GOOGLE_OAUTH2_TOKEN_ENDPOINT\n        assert creds.scopes is None\n        assert creds.rapt_token == \"rapt\"\n\n    def test_to_json(self):\n        info = AUTH_USER_INFO.copy()\n        expiry = datetime.datetime(2020, 8, 14, 15, 54, 1)\n        info[\"expiry\"] = expiry.isoformat() + \"Z\"\n        creds = credentials.Credentials.from_authorized_user_info(info)\n        assert creds.expiry == expiry\n\n        # Test with no `strip` arg\n        json_output = creds.to_json()\n        json_asdict = json.loads(json_output)\n        assert json_asdict.get(\"token\") == creds.token\n        assert json_asdict.get(\"refresh_token\") == creds.refresh_token\n        assert json_asdict.get(\"token_uri\") == creds.token_uri\n        assert json_asdict.get(\"client_id\") == creds.client_id\n        assert json_asdict.get(\"scopes\") == creds.scopes\n        assert json_asdict.get(\"client_secret\") == creds.client_secret\n        assert json_asdict.get(\"expiry\") == info[\"expiry\"]\n        assert json_asdict.get(\"universe_domain\") == creds.universe_domain\n        assert json_asdict.get(\"account\") == creds.account\n\n        # Test with a `strip` arg\n        json_output = creds.to_json(strip=[\"client_secret\"])\n        json_asdict = json.loads(json_output)\n        assert json_asdict.get(\"token\") == creds.token\n        assert json_asdict.get(\"refresh_token\") == creds.refresh_token\n        assert json_asdict.get(\"token_uri\") == creds.token_uri\n        assert json_asdict.get(\"client_id\") == creds.client_id\n        assert json_asdict.get(\"scopes\") == creds.scopes\n        assert json_asdict.get(\"client_secret\") is None\n\n        # Test with no expiry\n        creds.expiry = None\n        json_output = creds.to_json()\n        json_asdict = json.loads(json_output)\n        assert json_asdict.get(\"expiry\") is None\n\n    def test_pickle_and_unpickle(self):\n        creds = self.make_credentials()\n        unpickled = pickle.loads(pickle.dumps(creds))\n\n        # make sure attributes aren't lost during pickling\n        assert list(creds.__dict__).sort() == list(unpickled.__dict__).sort()\n\n        for attr in list(creds.__dict__):\n            # Worker should always be None\n            if attr == \"_refresh_worker\":\n                assert getattr(unpickled, attr) is None\n            else:\n                assert getattr(creds, attr) == getattr(unpickled, attr)\n\n    def test_pickle_and_unpickle_universe_domain(self):\n        # old version of auth lib doesn't have _universe_domain, so the pickled\n        # cred doesn't have such a field.\n        creds = self.make_credentials()\n        del creds._universe_domain\n\n        unpickled = pickle.loads(pickle.dumps(creds))\n\n        # make sure the unpickled cred sets _universe_domain to default.\n        assert unpickled.universe_domain == \"googleapis.com\"\n\n    def test_pickle_and_unpickle_with_refresh_handler(self):\n        expected_expiry = _helpers.utcnow() + datetime.timedelta(seconds=2800)\n        refresh_handler = mock.Mock(return_value=(\"TOKEN\", expected_expiry))\n\n        creds = credentials.Credentials(\n            token=None,\n            refresh_token=None,\n            token_uri=None,\n            client_id=None,\n            client_secret=None,\n            rapt_token=None,\n            refresh_handler=refresh_handler,\n        )\n        unpickled = pickle.loads(pickle.dumps(creds))\n\n        # make sure attributes aren't lost during pickling\n        assert list(creds.__dict__).sort() == list(unpickled.__dict__).sort()\n\n        for attr in list(creds.__dict__):\n            # For the _refresh_handler property, the unpickled creds should be\n            # set to None.\n            if attr == \"_refresh_handler\" or attr == \"_refresh_worker\":\n                assert getattr(unpickled, attr) is None\n            else:\n                assert getattr(creds, attr) == getattr(unpickled, attr)\n\n    def test_pickle_with_missing_attribute(self):\n        creds = self.make_credentials()\n\n        # remove an optional attribute before pickling\n        # this mimics a pickle created with a previous class definition with\n        # fewer attributes\n        del creds.__dict__[\"_quota_project_id\"]\n        del creds.__dict__[\"_refresh_handler\"]\n        del creds.__dict__[\"_refresh_worker\"]\n\n        unpickled = pickle.loads(pickle.dumps(creds))\n\n        # Attribute should be initialized by `__setstate__`\n        assert unpickled.quota_project_id is None\n\n    # pickles are not compatible across versions\n    @pytest.mark.skipif(\n        sys.version_info < (3, 5),\n        reason=\"pickle file can only be loaded with Python >= 3.5\",\n    )\n    def test_unpickle_old_credentials_pickle(self):\n        # make sure a credentials file pickled with an older\n        # library version (google-auth==1.5.1) can be unpickled\n        with open(\n            os.path.join(DATA_DIR, \"old_oauth_credentials_py3.pickle\"), \"rb\"\n        ) as f:\n            credentials = pickle.load(f)\n            assert credentials.quota_project_id is None\n\n\nclass TestUserAccessTokenCredentials(object):\n    def test_instance(self):\n        with pytest.warns(\n            UserWarning, match=\"UserAccessTokenCredentials is deprecated\"\n        ):\n            cred = credentials.UserAccessTokenCredentials()\n            assert cred._account is None\n\n            cred = cred.with_account(\"account\")\n            assert cred._account == \"account\"\n\n    @mock.patch(\"google.auth._cloud_sdk.get_auth_access_token\", autospec=True)\n    def test_refresh(self, get_auth_access_token):\n        with pytest.warns(\n            UserWarning, match=\"UserAccessTokenCredentials is deprecated\"\n        ):\n            get_auth_access_token.return_value = \"access_token\"\n            cred = credentials.UserAccessTokenCredentials()\n            cred.refresh(None)\n            assert cred.token == \"access_token\"\n\n    def test_with_quota_project(self):\n        with pytest.warns(\n            UserWarning, match=\"UserAccessTokenCredentials is deprecated\"\n        ):\n            cred = credentials.UserAccessTokenCredentials()\n            quota_project_cred = cred.with_quota_project(\"project-foo\")\n\n            assert quota_project_cred._quota_project_id == \"project-foo\"\n            assert quota_project_cred._account == cred._account\n\n    @mock.patch(\n        \"google.oauth2.credentials.UserAccessTokenCredentials.apply\", autospec=True\n    )\n    @mock.patch(\n        \"google.oauth2.credentials.UserAccessTokenCredentials.refresh\", autospec=True\n    )\n    def test_before_request(self, refresh, apply):\n        with pytest.warns(\n            UserWarning, match=\"UserAccessTokenCredentials is deprecated\"\n        ):\n            cred = credentials.UserAccessTokenCredentials()\n            cred.before_request(mock.Mock(), \"GET\", \"https://example.com\", {})\n            refresh.assert_called()\n            apply.assert_called()\n", "tests/oauth2/test_sts.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport http.client as http_client\nimport json\nimport urllib\n\nimport mock\nimport pytest  # type: ignore\n\nfrom google.auth import exceptions\nfrom google.auth import transport\nfrom google.oauth2 import sts\nfrom google.oauth2 import utils\n\nCLIENT_ID = \"username\"\nCLIENT_SECRET = \"password\"\n# Base64 encoding of \"username:password\"\nBASIC_AUTH_ENCODING = \"dXNlcm5hbWU6cGFzc3dvcmQ=\"\n\n\nclass TestStsClient(object):\n    GRANT_TYPE = \"urn:ietf:params:oauth:grant-type:token-exchange\"\n    RESOURCE = \"https://api.example.com/\"\n    AUDIENCE = \"urn:example:cooperation-context\"\n    SCOPES = [\"scope1\", \"scope2\"]\n    REQUESTED_TOKEN_TYPE = \"urn:ietf:params:oauth:token-type:access_token\"\n    SUBJECT_TOKEN = \"HEADER.SUBJECT_TOKEN_PAYLOAD.SIGNATURE\"\n    SUBJECT_TOKEN_TYPE = \"urn:ietf:params:oauth:token-type:jwt\"\n    ACTOR_TOKEN = \"HEADER.ACTOR_TOKEN_PAYLOAD.SIGNATURE\"\n    ACTOR_TOKEN_TYPE = \"urn:ietf:params:oauth:token-type:jwt\"\n    TOKEN_EXCHANGE_ENDPOINT = \"https://example.com/token.oauth2\"\n    ADDON_HEADERS = {\"x-client-version\": \"0.1.2\"}\n    ADDON_OPTIONS = {\"additional\": {\"non-standard\": [\"options\"], \"other\": \"some-value\"}}\n    SUCCESS_RESPONSE = {\n        \"access_token\": \"ACCESS_TOKEN\",\n        \"issued_token_type\": \"urn:ietf:params:oauth:token-type:access_token\",\n        \"token_type\": \"Bearer\",\n        \"expires_in\": 3600,\n        \"scope\": \"scope1 scope2\",\n    }\n    SUCCESS_RESPONSE_WITH_REFRESH = {\n        \"access_token\": \"abc\",\n        \"refresh_token\": \"xyz\",\n        \"expires_in\": 3600,\n    }\n    ERROR_RESPONSE = {\n        \"error\": \"invalid_request\",\n        \"error_description\": \"Invalid subject token\",\n        \"error_uri\": \"https://tools.ietf.org/html/rfc6749\",\n    }\n    CLIENT_AUTH_BASIC = utils.ClientAuthentication(\n        utils.ClientAuthType.basic, CLIENT_ID, CLIENT_SECRET\n    )\n    CLIENT_AUTH_REQUEST_BODY = utils.ClientAuthentication(\n        utils.ClientAuthType.request_body, CLIENT_ID, CLIENT_SECRET\n    )\n\n    @classmethod\n    def make_client(cls, client_auth=None):\n        return sts.Client(cls.TOKEN_EXCHANGE_ENDPOINT, client_auth)\n\n    @classmethod\n    def make_mock_request(cls, data, status=http_client.OK):\n        response = mock.create_autospec(transport.Response, instance=True)\n        response.status = status\n        response.data = json.dumps(data).encode(\"utf-8\")\n\n        request = mock.create_autospec(transport.Request)\n        request.return_value = response\n\n        return request\n\n    @classmethod\n    def assert_request_kwargs(cls, request_kwargs, headers, request_data):\n        \"\"\"Asserts the request was called with the expected parameters.\n        \"\"\"\n        assert request_kwargs[\"url\"] == cls.TOKEN_EXCHANGE_ENDPOINT\n        assert request_kwargs[\"method\"] == \"POST\"\n        assert request_kwargs[\"headers\"] == headers\n        assert request_kwargs[\"body\"] is not None\n        body_tuples = urllib.parse.parse_qsl(request_kwargs[\"body\"])\n        for (k, v) in body_tuples:\n            assert v.decode(\"utf-8\") == request_data[k.decode(\"utf-8\")]\n        assert len(body_tuples) == len(request_data.keys())\n\n    def test_exchange_token_full_success_without_auth(self):\n        \"\"\"Test token exchange success without client authentication using full\n        parameters.\n        \"\"\"\n        client = self.make_client()\n        headers = self.ADDON_HEADERS.copy()\n        headers[\"Content-Type\"] = \"application/x-www-form-urlencoded\"\n        request_data = {\n            \"grant_type\": self.GRANT_TYPE,\n            \"resource\": self.RESOURCE,\n            \"audience\": self.AUDIENCE,\n            \"scope\": \" \".join(self.SCOPES),\n            \"requested_token_type\": self.REQUESTED_TOKEN_TYPE,\n            \"subject_token\": self.SUBJECT_TOKEN,\n            \"subject_token_type\": self.SUBJECT_TOKEN_TYPE,\n            \"actor_token\": self.ACTOR_TOKEN,\n            \"actor_token_type\": self.ACTOR_TOKEN_TYPE,\n            \"options\": urllib.parse.quote(json.dumps(self.ADDON_OPTIONS)),\n        }\n        request = self.make_mock_request(\n            status=http_client.OK, data=self.SUCCESS_RESPONSE\n        )\n\n        response = client.exchange_token(\n            request,\n            self.GRANT_TYPE,\n            self.SUBJECT_TOKEN,\n            self.SUBJECT_TOKEN_TYPE,\n            self.RESOURCE,\n            self.AUDIENCE,\n            self.SCOPES,\n            self.REQUESTED_TOKEN_TYPE,\n            self.ACTOR_TOKEN,\n            self.ACTOR_TOKEN_TYPE,\n            self.ADDON_OPTIONS,\n            self.ADDON_HEADERS,\n        )\n\n        self.assert_request_kwargs(request.call_args[1], headers, request_data)\n        assert response == self.SUCCESS_RESPONSE\n\n    def test_exchange_token_partial_success_without_auth(self):\n        \"\"\"Test token exchange success without client authentication using\n        partial (required only) parameters.\n        \"\"\"\n        client = self.make_client()\n        headers = {\"Content-Type\": \"application/x-www-form-urlencoded\"}\n        request_data = {\n            \"grant_type\": self.GRANT_TYPE,\n            \"audience\": self.AUDIENCE,\n            \"requested_token_type\": self.REQUESTED_TOKEN_TYPE,\n            \"subject_token\": self.SUBJECT_TOKEN,\n            \"subject_token_type\": self.SUBJECT_TOKEN_TYPE,\n        }\n        request = self.make_mock_request(\n            status=http_client.OK, data=self.SUCCESS_RESPONSE\n        )\n\n        response = client.exchange_token(\n            request,\n            grant_type=self.GRANT_TYPE,\n            subject_token=self.SUBJECT_TOKEN,\n            subject_token_type=self.SUBJECT_TOKEN_TYPE,\n            audience=self.AUDIENCE,\n            requested_token_type=self.REQUESTED_TOKEN_TYPE,\n        )\n\n        self.assert_request_kwargs(request.call_args[1], headers, request_data)\n        assert response == self.SUCCESS_RESPONSE\n\n    def test_exchange_token_non200_without_auth(self):\n        \"\"\"Test token exchange without client auth responding with non-200 status.\n        \"\"\"\n        client = self.make_client()\n        request = self.make_mock_request(\n            status=http_client.BAD_REQUEST, data=self.ERROR_RESPONSE\n        )\n\n        with pytest.raises(exceptions.OAuthError) as excinfo:\n            client.exchange_token(\n                request,\n                self.GRANT_TYPE,\n                self.SUBJECT_TOKEN,\n                self.SUBJECT_TOKEN_TYPE,\n                self.RESOURCE,\n                self.AUDIENCE,\n                self.SCOPES,\n                self.REQUESTED_TOKEN_TYPE,\n                self.ACTOR_TOKEN,\n                self.ACTOR_TOKEN_TYPE,\n                self.ADDON_OPTIONS,\n                self.ADDON_HEADERS,\n            )\n\n        assert excinfo.match(\n            r\"Error code invalid_request: Invalid subject token - https://tools.ietf.org/html/rfc6749\"\n        )\n\n    def test_exchange_token_full_success_with_basic_auth(self):\n        \"\"\"Test token exchange success with basic client authentication using full\n        parameters.\n        \"\"\"\n        client = self.make_client(self.CLIENT_AUTH_BASIC)\n        headers = self.ADDON_HEADERS.copy()\n        headers[\"Content-Type\"] = \"application/x-www-form-urlencoded\"\n        headers[\"Authorization\"] = \"Basic {}\".format(BASIC_AUTH_ENCODING)\n        request_data = {\n            \"grant_type\": self.GRANT_TYPE,\n            \"resource\": self.RESOURCE,\n            \"audience\": self.AUDIENCE,\n            \"scope\": \" \".join(self.SCOPES),\n            \"requested_token_type\": self.REQUESTED_TOKEN_TYPE,\n            \"subject_token\": self.SUBJECT_TOKEN,\n            \"subject_token_type\": self.SUBJECT_TOKEN_TYPE,\n            \"actor_token\": self.ACTOR_TOKEN,\n            \"actor_token_type\": self.ACTOR_TOKEN_TYPE,\n            \"options\": urllib.parse.quote(json.dumps(self.ADDON_OPTIONS)),\n        }\n        request = self.make_mock_request(\n            status=http_client.OK, data=self.SUCCESS_RESPONSE\n        )\n\n        response = client.exchange_token(\n            request,\n            self.GRANT_TYPE,\n            self.SUBJECT_TOKEN,\n            self.SUBJECT_TOKEN_TYPE,\n            self.RESOURCE,\n            self.AUDIENCE,\n            self.SCOPES,\n            self.REQUESTED_TOKEN_TYPE,\n            self.ACTOR_TOKEN,\n            self.ACTOR_TOKEN_TYPE,\n            self.ADDON_OPTIONS,\n            self.ADDON_HEADERS,\n        )\n\n        self.assert_request_kwargs(request.call_args[1], headers, request_data)\n        assert response == self.SUCCESS_RESPONSE\n\n    def test_exchange_token_partial_success_with_basic_auth(self):\n        \"\"\"Test token exchange success with basic client authentication using\n        partial (required only) parameters.\n        \"\"\"\n        client = self.make_client(self.CLIENT_AUTH_BASIC)\n        headers = {\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n            \"Authorization\": \"Basic {}\".format(BASIC_AUTH_ENCODING),\n        }\n        request_data = {\n            \"grant_type\": self.GRANT_TYPE,\n            \"audience\": self.AUDIENCE,\n            \"requested_token_type\": self.REQUESTED_TOKEN_TYPE,\n            \"subject_token\": self.SUBJECT_TOKEN,\n            \"subject_token_type\": self.SUBJECT_TOKEN_TYPE,\n        }\n        request = self.make_mock_request(\n            status=http_client.OK, data=self.SUCCESS_RESPONSE\n        )\n\n        response = client.exchange_token(\n            request,\n            grant_type=self.GRANT_TYPE,\n            subject_token=self.SUBJECT_TOKEN,\n            subject_token_type=self.SUBJECT_TOKEN_TYPE,\n            audience=self.AUDIENCE,\n            requested_token_type=self.REQUESTED_TOKEN_TYPE,\n        )\n\n        self.assert_request_kwargs(request.call_args[1], headers, request_data)\n        assert response == self.SUCCESS_RESPONSE\n\n    def test_exchange_token_non200_with_basic_auth(self):\n        \"\"\"Test token exchange with basic client auth responding with non-200\n        status.\n        \"\"\"\n        client = self.make_client(self.CLIENT_AUTH_BASIC)\n        request = self.make_mock_request(\n            status=http_client.BAD_REQUEST, data=self.ERROR_RESPONSE\n        )\n\n        with pytest.raises(exceptions.OAuthError) as excinfo:\n            client.exchange_token(\n                request,\n                self.GRANT_TYPE,\n                self.SUBJECT_TOKEN,\n                self.SUBJECT_TOKEN_TYPE,\n                self.RESOURCE,\n                self.AUDIENCE,\n                self.SCOPES,\n                self.REQUESTED_TOKEN_TYPE,\n                self.ACTOR_TOKEN,\n                self.ACTOR_TOKEN_TYPE,\n                self.ADDON_OPTIONS,\n                self.ADDON_HEADERS,\n            )\n\n        assert excinfo.match(\n            r\"Error code invalid_request: Invalid subject token - https://tools.ietf.org/html/rfc6749\"\n        )\n\n    def test_exchange_token_full_success_with_reqbody_auth(self):\n        \"\"\"Test token exchange success with request body client authenticaiton\n        using full parameters.\n        \"\"\"\n        client = self.make_client(self.CLIENT_AUTH_REQUEST_BODY)\n        headers = self.ADDON_HEADERS.copy()\n        headers[\"Content-Type\"] = \"application/x-www-form-urlencoded\"\n        request_data = {\n            \"grant_type\": self.GRANT_TYPE,\n            \"resource\": self.RESOURCE,\n            \"audience\": self.AUDIENCE,\n            \"scope\": \" \".join(self.SCOPES),\n            \"requested_token_type\": self.REQUESTED_TOKEN_TYPE,\n            \"subject_token\": self.SUBJECT_TOKEN,\n            \"subject_token_type\": self.SUBJECT_TOKEN_TYPE,\n            \"actor_token\": self.ACTOR_TOKEN,\n            \"actor_token_type\": self.ACTOR_TOKEN_TYPE,\n            \"options\": urllib.parse.quote(json.dumps(self.ADDON_OPTIONS)),\n            \"client_id\": CLIENT_ID,\n            \"client_secret\": CLIENT_SECRET,\n        }\n        request = self.make_mock_request(\n            status=http_client.OK, data=self.SUCCESS_RESPONSE\n        )\n\n        response = client.exchange_token(\n            request,\n            self.GRANT_TYPE,\n            self.SUBJECT_TOKEN,\n            self.SUBJECT_TOKEN_TYPE,\n            self.RESOURCE,\n            self.AUDIENCE,\n            self.SCOPES,\n            self.REQUESTED_TOKEN_TYPE,\n            self.ACTOR_TOKEN,\n            self.ACTOR_TOKEN_TYPE,\n            self.ADDON_OPTIONS,\n            self.ADDON_HEADERS,\n        )\n\n        self.assert_request_kwargs(request.call_args[1], headers, request_data)\n        assert response == self.SUCCESS_RESPONSE\n\n    def test_exchange_token_partial_success_with_reqbody_auth(self):\n        \"\"\"Test token exchange success with request body client authentication\n        using partial (required only) parameters.\n        \"\"\"\n        client = self.make_client(self.CLIENT_AUTH_REQUEST_BODY)\n        headers = {\"Content-Type\": \"application/x-www-form-urlencoded\"}\n        request_data = {\n            \"grant_type\": self.GRANT_TYPE,\n            \"audience\": self.AUDIENCE,\n            \"requested_token_type\": self.REQUESTED_TOKEN_TYPE,\n            \"subject_token\": self.SUBJECT_TOKEN,\n            \"subject_token_type\": self.SUBJECT_TOKEN_TYPE,\n            \"client_id\": CLIENT_ID,\n            \"client_secret\": CLIENT_SECRET,\n        }\n        request = self.make_mock_request(\n            status=http_client.OK, data=self.SUCCESS_RESPONSE\n        )\n\n        response = client.exchange_token(\n            request,\n            grant_type=self.GRANT_TYPE,\n            subject_token=self.SUBJECT_TOKEN,\n            subject_token_type=self.SUBJECT_TOKEN_TYPE,\n            audience=self.AUDIENCE,\n            requested_token_type=self.REQUESTED_TOKEN_TYPE,\n        )\n\n        self.assert_request_kwargs(request.call_args[1], headers, request_data)\n        assert response == self.SUCCESS_RESPONSE\n\n    def test_exchange_token_non200_with_reqbody_auth(self):\n        \"\"\"Test token exchange with POST request body client auth responding\n        with non-200 status.\n        \"\"\"\n        client = self.make_client(self.CLIENT_AUTH_REQUEST_BODY)\n        request = self.make_mock_request(\n            status=http_client.BAD_REQUEST, data=self.ERROR_RESPONSE\n        )\n\n        with pytest.raises(exceptions.OAuthError) as excinfo:\n            client.exchange_token(\n                request,\n                self.GRANT_TYPE,\n                self.SUBJECT_TOKEN,\n                self.SUBJECT_TOKEN_TYPE,\n                self.RESOURCE,\n                self.AUDIENCE,\n                self.SCOPES,\n                self.REQUESTED_TOKEN_TYPE,\n                self.ACTOR_TOKEN,\n                self.ACTOR_TOKEN_TYPE,\n                self.ADDON_OPTIONS,\n                self.ADDON_HEADERS,\n            )\n\n        assert excinfo.match(\n            r\"Error code invalid_request: Invalid subject token - https://tools.ietf.org/html/rfc6749\"\n        )\n\n    def test_refresh_token_success(self):\n        \"\"\"Test refresh token with successful response.\"\"\"\n        client = self.make_client(self.CLIENT_AUTH_BASIC)\n        request = self.make_mock_request(\n            status=http_client.OK, data=self.SUCCESS_RESPONSE\n        )\n\n        response = client.refresh_token(request, \"refreshtoken\")\n\n        headers = {\n            \"Authorization\": \"Basic dXNlcm5hbWU6cGFzc3dvcmQ=\",\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n        }\n        request_data = {\"grant_type\": \"refresh_token\", \"refresh_token\": \"refreshtoken\"}\n        self.assert_request_kwargs(request.call_args[1], headers, request_data)\n        assert response == self.SUCCESS_RESPONSE\n\n    def test_refresh_token_success_with_refresh(self):\n        \"\"\"Test refresh token with successful response.\"\"\"\n        client = self.make_client(self.CLIENT_AUTH_BASIC)\n        request = self.make_mock_request(\n            status=http_client.OK, data=self.SUCCESS_RESPONSE_WITH_REFRESH\n        )\n\n        response = client.refresh_token(request, \"refreshtoken\")\n\n        headers = {\n            \"Authorization\": \"Basic dXNlcm5hbWU6cGFzc3dvcmQ=\",\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n        }\n        request_data = {\"grant_type\": \"refresh_token\", \"refresh_token\": \"refreshtoken\"}\n        self.assert_request_kwargs(request.call_args[1], headers, request_data)\n        assert response == self.SUCCESS_RESPONSE_WITH_REFRESH\n\n    def test_refresh_token_failure(self):\n        \"\"\"Test refresh token with failure response.\"\"\"\n        client = self.make_client(self.CLIENT_AUTH_BASIC)\n        request = self.make_mock_request(\n            status=http_client.BAD_REQUEST, data=self.ERROR_RESPONSE\n        )\n\n        with pytest.raises(exceptions.OAuthError) as excinfo:\n            client.refresh_token(request, \"refreshtoken\")\n\n        assert excinfo.match(\n            r\"Error code invalid_request: Invalid subject token - https://tools.ietf.org/html/rfc6749\"\n        )\n\n    def test__make_request_success(self):\n        \"\"\"Test base method with successful response.\"\"\"\n        client = self.make_client(self.CLIENT_AUTH_BASIC)\n        request = self.make_mock_request(\n            status=http_client.OK, data=self.SUCCESS_RESPONSE\n        )\n\n        response = client._make_request(request, {\"a\": \"b\"}, {\"c\": \"d\"})\n\n        headers = {\n            \"Authorization\": \"Basic dXNlcm5hbWU6cGFzc3dvcmQ=\",\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n            \"a\": \"b\",\n        }\n        request_data = {\"c\": \"d\"}\n        self.assert_request_kwargs(request.call_args[1], headers, request_data)\n        assert response == self.SUCCESS_RESPONSE\n\n    def test_make_request_failure(self):\n        \"\"\"Test refresh token with failure response.\"\"\"\n        client = self.make_client(self.CLIENT_AUTH_BASIC)\n        request = self.make_mock_request(\n            status=http_client.BAD_REQUEST, data=self.ERROR_RESPONSE\n        )\n\n        with pytest.raises(exceptions.OAuthError) as excinfo:\n            client._make_request(request, {\"a\": \"b\"}, {\"c\": \"d\"})\n\n        assert excinfo.match(\n            r\"Error code invalid_request: Invalid subject token - https://tools.ietf.org/html/rfc6749\"\n        )\n", "tests/oauth2/test_challenges.py": "# Copyright 2021 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Tests for the reauth module.\"\"\"\n\nimport base64\nimport os\nimport sys\n\nimport mock\nimport pytest  # type: ignore\nimport pyu2f  # type: ignore\n\nfrom google.auth import exceptions\nfrom google.oauth2 import challenges\nfrom google.oauth2.webauthn_types import (\n    AuthenticationExtensionsClientInputs,\n    AuthenticatorAssertionResponse,\n    GetRequest,\n    GetResponse,\n    PublicKeyCredentialDescriptor,\n)\n\n\ndef test_get_user_password():\n    with mock.patch(\"getpass.getpass\", return_value=\"foo\"):\n        assert challenges.get_user_password(\"\") == \"foo\"\n\n\ndef test_security_key():\n    metadata = {\n        \"status\": \"READY\",\n        \"challengeId\": 2,\n        \"challengeType\": \"SECURITY_KEY\",\n        \"securityKey\": {\n            \"applicationId\": \"security_key_application_id\",\n            \"challenges\": [\n                {\n                    \"keyHandle\": \"some_key\",\n                    \"challenge\": base64.urlsafe_b64encode(\n                        \"some_challenge\".encode(\"ascii\")\n                    ).decode(\"ascii\"),\n                }\n            ],\n            \"relyingPartyId\": \"security_key_application_id\",\n        },\n    }\n    mock_key = mock.Mock()\n\n    challenge = challenges.SecurityKeyChallenge()\n\n    # Test the case that security key challenge is passed with applicationId and\n    # relyingPartyId the same.\n    os.environ.pop('\"GOOGLE_AUTH_WEBAUTHN_PLUGIN\"', None)\n\n    with mock.patch(\"pyu2f.model.RegisteredKey\", return_value=mock_key):\n        with mock.patch(\n            \"pyu2f.convenience.authenticator.CompositeAuthenticator.Authenticate\"\n        ) as mock_authenticate:\n            mock_authenticate.return_value = \"security key response\"\n            assert challenge.name == \"SECURITY_KEY\"\n            assert challenge.is_locally_eligible\n            assert challenge.obtain_challenge_input(metadata) == {\n                \"securityKey\": \"security key response\"\n            }\n            mock_authenticate.assert_called_with(\n                \"security_key_application_id\",\n                [{\"key\": mock_key, \"challenge\": b\"some_challenge\"}],\n                print_callback=sys.stderr.write,\n            )\n\n    # Test the case that webauthn plugin is available\n    os.environ[\"GOOGLE_AUTH_WEBAUTHN_PLUGIN\"] = \"plugin\"\n\n    with mock.patch(\n        \"google.oauth2.challenges.SecurityKeyChallenge._obtain_challenge_input_webauthn\",\n        return_value={\"securityKey\": \"security key response\"},\n    ):\n\n        assert challenge.obtain_challenge_input(metadata) == {\n            \"securityKey\": \"security key response\"\n        }\n    os.environ.pop('\"GOOGLE_AUTH_WEBAUTHN_PLUGIN\"', None)\n\n    # Test the case that security key challenge is passed with applicationId and\n    # relyingPartyId different, first call works.\n    metadata[\"securityKey\"][\"relyingPartyId\"] = \"security_key_relying_party_id\"\n    sys.stderr.write(\"metadata=\" + str(metadata) + \"\\n\")\n    with mock.patch(\"pyu2f.model.RegisteredKey\", return_value=mock_key):\n        with mock.patch(\n            \"pyu2f.convenience.authenticator.CompositeAuthenticator.Authenticate\"\n        ) as mock_authenticate:\n            mock_authenticate.return_value = \"security key response\"\n            assert challenge.name == \"SECURITY_KEY\"\n            assert challenge.is_locally_eligible\n            assert challenge.obtain_challenge_input(metadata) == {\n                \"securityKey\": \"security key response\"\n            }\n            mock_authenticate.assert_called_with(\n                \"security_key_relying_party_id\",\n                [{\"key\": mock_key, \"challenge\": b\"some_challenge\"}],\n                print_callback=sys.stderr.write,\n            )\n\n    # Test the case that security key challenge is passed with applicationId and\n    # relyingPartyId different, first call fails, requires retry.\n    metadata[\"securityKey\"][\"relyingPartyId\"] = \"security_key_relying_party_id\"\n    with mock.patch(\"pyu2f.model.RegisteredKey\", return_value=mock_key):\n        with mock.patch(\n            \"pyu2f.convenience.authenticator.CompositeAuthenticator.Authenticate\"\n        ) as mock_authenticate:\n            assert challenge.name == \"SECURITY_KEY\"\n            assert challenge.is_locally_eligible\n            mock_authenticate.side_effect = [\n                pyu2f.errors.U2FError(pyu2f.errors.U2FError.DEVICE_INELIGIBLE),\n                \"security key response\",\n            ]\n            assert challenge.obtain_challenge_input(metadata) == {\n                \"securityKey\": \"security key response\"\n            }\n            calls = [\n                mock.call(\n                    \"security_key_relying_party_id\",\n                    [{\"key\": mock_key, \"challenge\": b\"some_challenge\"}],\n                    print_callback=sys.stderr.write,\n                ),\n                mock.call(\n                    \"security_key_application_id\",\n                    [{\"key\": mock_key, \"challenge\": b\"some_challenge\"}],\n                    print_callback=sys.stderr.write,\n                ),\n            ]\n            mock_authenticate.assert_has_calls(calls)\n\n    # Test various types of exceptions.\n    with mock.patch(\"pyu2f.model.RegisteredKey\", return_value=mock_key):\n        with mock.patch(\n            \"pyu2f.convenience.authenticator.CompositeAuthenticator.Authenticate\"\n        ) as mock_authenticate:\n            mock_authenticate.side_effect = pyu2f.errors.U2FError(\n                pyu2f.errors.U2FError.DEVICE_INELIGIBLE\n            )\n            assert challenge.obtain_challenge_input(metadata) is None\n\n        with mock.patch(\n            \"pyu2f.convenience.authenticator.CompositeAuthenticator.Authenticate\"\n        ) as mock_authenticate:\n            mock_authenticate.side_effect = pyu2f.errors.U2FError(\n                pyu2f.errors.U2FError.TIMEOUT\n            )\n            assert challenge.obtain_challenge_input(metadata) is None\n\n        with mock.patch(\n            \"pyu2f.convenience.authenticator.CompositeAuthenticator.Authenticate\"\n        ) as mock_authenticate:\n            mock_authenticate.side_effect = pyu2f.errors.PluginError()\n            assert challenge.obtain_challenge_input(metadata) is None\n\n        with mock.patch(\n            \"pyu2f.convenience.authenticator.CompositeAuthenticator.Authenticate\"\n        ) as mock_authenticate:\n            mock_authenticate.side_effect = pyu2f.errors.U2FError(\n                pyu2f.errors.U2FError.BAD_REQUEST\n            )\n            with pytest.raises(pyu2f.errors.U2FError):\n                challenge.obtain_challenge_input(metadata)\n\n        with mock.patch(\n            \"pyu2f.convenience.authenticator.CompositeAuthenticator.Authenticate\"\n        ) as mock_authenticate:\n            mock_authenticate.side_effect = pyu2f.errors.NoDeviceFoundError()\n            assert challenge.obtain_challenge_input(metadata) is None\n\n        with mock.patch(\n            \"pyu2f.convenience.authenticator.CompositeAuthenticator.Authenticate\"\n        ) as mock_authenticate:\n            mock_authenticate.side_effect = pyu2f.errors.UnsupportedVersionException()\n            with pytest.raises(pyu2f.errors.UnsupportedVersionException):\n                challenge.obtain_challenge_input(metadata)\n\n        with mock.patch.dict(\"sys.modules\"):\n            sys.modules[\"pyu2f\"] = None\n            with pytest.raises(exceptions.ReauthFailError) as excinfo:\n                challenge.obtain_challenge_input(metadata)\n            assert excinfo.match(r\"pyu2f dependency is required\")\n\n\ndef test_security_key_webauthn():\n    metadata = {\n        \"status\": \"READY\",\n        \"challengeId\": 2,\n        \"challengeType\": \"SECURITY_KEY\",\n        \"securityKey\": {\n            \"applicationId\": \"security_key_application_id\",\n            \"challenges\": [\n                {\n                    \"keyHandle\": \"some_key\",\n                    \"challenge\": base64.urlsafe_b64encode(\n                        \"some_challenge\".encode(\"ascii\")\n                    ).decode(\"ascii\"),\n                }\n            ],\n            \"relyingPartyId\": \"security_key_application_id\",\n        },\n    }\n\n    challenge = challenges.SecurityKeyChallenge()\n\n    sk = metadata[\"securityKey\"]\n    sk_challenges = sk[\"challenges\"]\n\n    application_id = sk[\"applicationId\"]\n\n    allow_credentials = []\n    for sk_challenge in sk_challenges:\n        allow_credentials.append(\n            PublicKeyCredentialDescriptor(id=sk_challenge[\"keyHandle\"])\n        )\n\n    extension = AuthenticationExtensionsClientInputs(appid=application_id)\n\n    get_request = GetRequest(\n        origin=challenges.REAUTH_ORIGIN,\n        rpid=application_id,\n        challenge=challenge._unpadded_urlsafe_b64recode(sk_challenge[\"challenge\"]),\n        timeout_ms=challenges.WEBAUTHN_TIMEOUT_MS,\n        allow_credentials=allow_credentials,\n        user_verification=\"required\",\n        extensions=extension,\n    )\n\n    assertion_resp = AuthenticatorAssertionResponse(\n        client_data_json=\"clientDataJSON\",\n        authenticator_data=\"authenticatorData\",\n        signature=\"signature\",\n        user_handle=\"userHandle\",\n    )\n    get_response = GetResponse(\n        id=\"id\",\n        response=assertion_resp,\n        authenticator_attachment=\"authenticatorAttachment\",\n        client_extension_results=\"clientExtensionResults\",\n    )\n    response = {\n        \"clientData\": get_response.response.client_data_json,\n        \"authenticatorData\": get_response.response.authenticator_data,\n        \"signatureData\": get_response.response.signature,\n        \"applicationId\": \"security_key_application_id\",\n        \"keyHandle\": get_response.id,\n        \"securityKeyReplyType\": 2,\n    }\n\n    mock_handler = mock.Mock()\n    mock_handler.get.return_value = get_response\n\n    # Test success case\n    assert challenge._obtain_challenge_input_webauthn(metadata, mock_handler) == {\n        \"securityKey\": response\n    }\n    mock_handler.get.assert_called_with(get_request)\n\n    # Test exceptions\n\n    # Missing Values\n    sk = metadata[\"securityKey\"]\n    metadata[\"securityKey\"] = None\n    with pytest.raises(exceptions.InvalidValue):\n        challenge._obtain_challenge_input_webauthn(metadata, mock_handler)\n    metadata[\"securityKey\"] = sk\n\n    c = metadata[\"securityKey\"][\"challenges\"]\n    metadata[\"securityKey\"][\"challenges\"] = None\n    with pytest.raises(exceptions.InvalidValue):\n        challenge._obtain_challenge_input_webauthn(metadata, mock_handler)\n    metadata[\"securityKey\"][\"challenges\"] = []\n    with pytest.raises(exceptions.InvalidValue):\n        challenge._obtain_challenge_input_webauthn(metadata, mock_handler)\n    metadata[\"securityKey\"][\"challenges\"] = c\n\n    aid = metadata[\"securityKey\"][\"applicationId\"]\n    metadata[\"securityKey\"][\"applicationId\"] = None\n    with pytest.raises(exceptions.InvalidValue):\n        challenge._obtain_challenge_input_webauthn(metadata, mock_handler)\n    metadata[\"securityKey\"][\"applicationId\"] = aid\n\n    rpi = metadata[\"securityKey\"][\"relyingPartyId\"]\n    metadata[\"securityKey\"][\"relyingPartyId\"] = None\n    with pytest.raises(exceptions.InvalidValue):\n        challenge._obtain_challenge_input_webauthn(metadata, mock_handler)\n    metadata[\"securityKey\"][\"relyingPartyId\"] = rpi\n\n    kh = metadata[\"securityKey\"][\"challenges\"][0][\"keyHandle\"]\n    metadata[\"securityKey\"][\"challenges\"][0][\"keyHandle\"] = None\n    with pytest.raises(exceptions.InvalidValue):\n        challenge._obtain_challenge_input_webauthn(metadata, mock_handler)\n    metadata[\"securityKey\"][\"challenges\"][0][\"keyHandle\"] = kh\n\n    ch = metadata[\"securityKey\"][\"challenges\"][0][\"challenge\"]\n    metadata[\"securityKey\"][\"challenges\"][0][\"challenge\"] = None\n    with pytest.raises(exceptions.InvalidValue):\n        challenge._obtain_challenge_input_webauthn(metadata, mock_handler)\n    metadata[\"securityKey\"][\"challenges\"][0][\"challenge\"] = ch\n\n    # Handler Exceptions\n    mock_handler.get.side_effect = exceptions.MalformedError\n    with pytest.raises(exceptions.MalformedError):\n        challenge._obtain_challenge_input_webauthn(metadata, mock_handler)\n\n    mock_handler.get.side_effect = exceptions.InvalidResource\n    with pytest.raises(exceptions.InvalidResource):\n        challenge._obtain_challenge_input_webauthn(metadata, mock_handler)\n\n    mock_handler.get.side_effect = exceptions.ReauthFailError\n    with pytest.raises(exceptions.ReauthFailError):\n        challenge._obtain_challenge_input_webauthn(metadata, mock_handler)\n\n\n@mock.patch(\"getpass.getpass\", return_value=\"foo\")\ndef test_password_challenge(getpass_mock):\n    challenge = challenges.PasswordChallenge()\n\n    with mock.patch(\"getpass.getpass\", return_value=\"foo\"):\n        assert challenge.is_locally_eligible\n        assert challenge.name == \"PASSWORD\"\n        assert challenges.PasswordChallenge().obtain_challenge_input({}) == {\n            \"credential\": \"foo\"\n        }\n\n    with mock.patch(\"getpass.getpass\", return_value=None):\n        assert challenges.PasswordChallenge().obtain_challenge_input({}) == {\n            \"credential\": \" \"\n        }\n\n\ndef test_saml_challenge():\n    challenge = challenges.SamlChallenge()\n    assert challenge.is_locally_eligible\n    assert challenge.name == \"SAML\"\n    with pytest.raises(exceptions.ReauthSamlChallengeFailError):\n        challenge.obtain_challenge_input(None)\n", "tests/oauth2/test_service_account.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport datetime\nimport json\nimport os\n\nimport mock\nimport pytest  # type: ignore\n\nfrom google.auth import _helpers\nfrom google.auth import crypt\nfrom google.auth import exceptions\nfrom google.auth import iam\nfrom google.auth import jwt\nfrom google.auth import transport\nfrom google.auth.credentials import DEFAULT_UNIVERSE_DOMAIN\nfrom google.oauth2 import service_account\n\n\nDATA_DIR = os.path.join(os.path.dirname(__file__), \"..\", \"data\")\n\nwith open(os.path.join(DATA_DIR, \"privatekey.pem\"), \"rb\") as fh:\n    PRIVATE_KEY_BYTES = fh.read()\n\nwith open(os.path.join(DATA_DIR, \"public_cert.pem\"), \"rb\") as fh:\n    PUBLIC_CERT_BYTES = fh.read()\n\nwith open(os.path.join(DATA_DIR, \"other_cert.pem\"), \"rb\") as fh:\n    OTHER_CERT_BYTES = fh.read()\n\nSERVICE_ACCOUNT_JSON_FILE = os.path.join(DATA_DIR, \"service_account.json\")\nSERVICE_ACCOUNT_NON_GDU_JSON_FILE = os.path.join(\n    DATA_DIR, \"service_account_non_gdu.json\"\n)\nFAKE_UNIVERSE_DOMAIN = \"universe.foo\"\n\nwith open(SERVICE_ACCOUNT_JSON_FILE, \"rb\") as fh:\n    SERVICE_ACCOUNT_INFO = json.load(fh)\n\nwith open(SERVICE_ACCOUNT_NON_GDU_JSON_FILE, \"rb\") as fh:\n    SERVICE_ACCOUNT_INFO_NON_GDU = json.load(fh)\n\nSIGNER = crypt.RSASigner.from_string(PRIVATE_KEY_BYTES, \"1\")\n\n\nclass TestCredentials(object):\n    SERVICE_ACCOUNT_EMAIL = \"service-account@example.com\"\n    TOKEN_URI = \"https://example.com/oauth2/token\"\n\n    @classmethod\n    def make_credentials(cls, universe_domain=DEFAULT_UNIVERSE_DOMAIN):\n        return service_account.Credentials(\n            SIGNER,\n            cls.SERVICE_ACCOUNT_EMAIL,\n            cls.TOKEN_URI,\n            universe_domain=universe_domain,\n        )\n\n    def test_constructor_no_universe_domain(self):\n        credentials = service_account.Credentials(\n            SIGNER, self.SERVICE_ACCOUNT_EMAIL, self.TOKEN_URI, universe_domain=None\n        )\n        assert credentials.universe_domain == DEFAULT_UNIVERSE_DOMAIN\n\n    def test_from_service_account_info(self):\n        credentials = service_account.Credentials.from_service_account_info(\n            SERVICE_ACCOUNT_INFO\n        )\n\n        assert credentials._signer.key_id == SERVICE_ACCOUNT_INFO[\"private_key_id\"]\n        assert credentials.service_account_email == SERVICE_ACCOUNT_INFO[\"client_email\"]\n        assert credentials._token_uri == SERVICE_ACCOUNT_INFO[\"token_uri\"]\n        assert credentials._universe_domain == DEFAULT_UNIVERSE_DOMAIN\n        assert not credentials._always_use_jwt_access\n\n    def test_from_service_account_info_non_gdu(self):\n        credentials = service_account.Credentials.from_service_account_info(\n            SERVICE_ACCOUNT_INFO_NON_GDU\n        )\n\n        assert credentials.universe_domain == FAKE_UNIVERSE_DOMAIN\n        assert credentials._always_use_jwt_access\n\n    def test_from_service_account_info_args(self):\n        info = SERVICE_ACCOUNT_INFO.copy()\n        scopes = [\"email\", \"profile\"]\n        subject = \"subject\"\n        additional_claims = {\"meta\": \"data\"}\n\n        credentials = service_account.Credentials.from_service_account_info(\n            info, scopes=scopes, subject=subject, additional_claims=additional_claims\n        )\n\n        assert credentials.service_account_email == info[\"client_email\"]\n        assert credentials.project_id == info[\"project_id\"]\n        assert credentials._signer.key_id == info[\"private_key_id\"]\n        assert credentials._token_uri == info[\"token_uri\"]\n        assert credentials._scopes == scopes\n        assert credentials._subject == subject\n        assert credentials._additional_claims == additional_claims\n        assert not credentials._always_use_jwt_access\n\n    def test_from_service_account_file(self):\n        info = SERVICE_ACCOUNT_INFO.copy()\n\n        credentials = service_account.Credentials.from_service_account_file(\n            SERVICE_ACCOUNT_JSON_FILE\n        )\n\n        assert credentials.service_account_email == info[\"client_email\"]\n        assert credentials.project_id == info[\"project_id\"]\n        assert credentials._signer.key_id == info[\"private_key_id\"]\n        assert credentials._token_uri == info[\"token_uri\"]\n\n    def test_from_service_account_file_non_gdu(self):\n        info = SERVICE_ACCOUNT_INFO_NON_GDU.copy()\n\n        credentials = service_account.Credentials.from_service_account_file(\n            SERVICE_ACCOUNT_NON_GDU_JSON_FILE\n        )\n\n        assert credentials.service_account_email == info[\"client_email\"]\n        assert credentials.project_id == info[\"project_id\"]\n        assert credentials._signer.key_id == info[\"private_key_id\"]\n        assert credentials._token_uri == info[\"token_uri\"]\n        assert credentials._universe_domain == FAKE_UNIVERSE_DOMAIN\n        assert credentials._always_use_jwt_access\n\n    def test_from_service_account_file_args(self):\n        info = SERVICE_ACCOUNT_INFO.copy()\n        scopes = [\"email\", \"profile\"]\n        subject = \"subject\"\n        additional_claims = {\"meta\": \"data\"}\n\n        credentials = service_account.Credentials.from_service_account_file(\n            SERVICE_ACCOUNT_JSON_FILE,\n            subject=subject,\n            scopes=scopes,\n            additional_claims=additional_claims,\n        )\n\n        assert credentials.service_account_email == info[\"client_email\"]\n        assert credentials.project_id == info[\"project_id\"]\n        assert credentials._signer.key_id == info[\"private_key_id\"]\n        assert credentials._token_uri == info[\"token_uri\"]\n        assert credentials._scopes == scopes\n        assert credentials._subject == subject\n        assert credentials._additional_claims == additional_claims\n\n    def test_default_state(self):\n        credentials = self.make_credentials()\n        assert not credentials.valid\n        # Expiration hasn't been set yet\n        assert not credentials.expired\n        # Scopes haven't been specified yet\n        assert credentials.requires_scopes\n\n    def test_sign_bytes(self):\n        credentials = self.make_credentials()\n        to_sign = b\"123\"\n        signature = credentials.sign_bytes(to_sign)\n        assert crypt.verify_signature(to_sign, signature, PUBLIC_CERT_BYTES)\n\n    def test_signer(self):\n        credentials = self.make_credentials()\n        assert isinstance(credentials.signer, crypt.Signer)\n\n    def test_signer_email(self):\n        credentials = self.make_credentials()\n        assert credentials.signer_email == self.SERVICE_ACCOUNT_EMAIL\n\n    def test_create_scoped(self):\n        credentials = self.make_credentials()\n        scopes = [\"email\", \"profile\"]\n        credentials = credentials.with_scopes(scopes)\n        assert credentials._scopes == scopes\n\n    def test_with_claims(self):\n        credentials = self.make_credentials()\n        new_credentials = credentials.with_claims({\"meep\": \"moop\"})\n        assert new_credentials._additional_claims == {\"meep\": \"moop\"}\n\n    def test_with_quota_project(self):\n        credentials = self.make_credentials()\n        new_credentials = credentials.with_quota_project(\"new-project-456\")\n        assert new_credentials.quota_project_id == \"new-project-456\"\n        hdrs = {}\n        new_credentials.apply(hdrs, token=\"tok\")\n        assert \"x-goog-user-project\" in hdrs\n\n    def test_with_token_uri(self):\n        credentials = self.make_credentials()\n        new_token_uri = \"https://example2.com/oauth2/token\"\n        assert credentials._token_uri == self.TOKEN_URI\n        creds_with_new_token_uri = credentials.with_token_uri(new_token_uri)\n        assert creds_with_new_token_uri._token_uri == new_token_uri\n\n    def test_with_universe_domain(self):\n        credentials = self.make_credentials()\n\n        new_credentials = credentials.with_universe_domain(\"dummy_universe.com\")\n        assert new_credentials.universe_domain == \"dummy_universe.com\"\n        assert new_credentials._always_use_jwt_access\n\n        new_credentials = credentials.with_universe_domain(\"googleapis.com\")\n        assert new_credentials.universe_domain == \"googleapis.com\"\n        assert not new_credentials._always_use_jwt_access\n\n    def test__with_always_use_jwt_access(self):\n        credentials = self.make_credentials()\n        assert not credentials._always_use_jwt_access\n\n        new_credentials = credentials.with_always_use_jwt_access(True)\n        assert new_credentials._always_use_jwt_access\n\n    def test__with_always_use_jwt_access_non_default_universe_domain(self):\n        credentials = self.make_credentials(universe_domain=FAKE_UNIVERSE_DOMAIN)\n        with pytest.raises(exceptions.InvalidValue) as excinfo:\n            credentials.with_always_use_jwt_access(False)\n\n        assert excinfo.match(\n            \"always_use_jwt_access should be True for non-default universe domain\"\n        )\n\n    def test__make_authorization_grant_assertion(self):\n        credentials = self.make_credentials()\n        token = credentials._make_authorization_grant_assertion()\n        payload = jwt.decode(token, PUBLIC_CERT_BYTES)\n        assert payload[\"iss\"] == self.SERVICE_ACCOUNT_EMAIL\n        assert payload[\"aud\"] == service_account._GOOGLE_OAUTH2_TOKEN_ENDPOINT\n\n    def test__make_authorization_grant_assertion_scoped(self):\n        credentials = self.make_credentials()\n        scopes = [\"email\", \"profile\"]\n        credentials = credentials.with_scopes(scopes)\n        token = credentials._make_authorization_grant_assertion()\n        payload = jwt.decode(token, PUBLIC_CERT_BYTES)\n        assert payload[\"scope\"] == \"email profile\"\n\n    def test__make_authorization_grant_assertion_subject(self):\n        credentials = self.make_credentials()\n        subject = \"user@example.com\"\n        credentials = credentials.with_subject(subject)\n        token = credentials._make_authorization_grant_assertion()\n        payload = jwt.decode(token, PUBLIC_CERT_BYTES)\n        assert payload[\"sub\"] == subject\n\n    def test_apply_with_quota_project_id(self):\n        credentials = service_account.Credentials(\n            SIGNER,\n            self.SERVICE_ACCOUNT_EMAIL,\n            self.TOKEN_URI,\n            quota_project_id=\"quota-project-123\",\n        )\n\n        headers = {}\n        credentials.apply(headers, token=\"token\")\n\n        assert headers[\"x-goog-user-project\"] == \"quota-project-123\"\n        assert \"token\" in headers[\"authorization\"]\n\n    def test_apply_with_no_quota_project_id(self):\n        credentials = service_account.Credentials(\n            SIGNER, self.SERVICE_ACCOUNT_EMAIL, self.TOKEN_URI\n        )\n\n        headers = {}\n        credentials.apply(headers, token=\"token\")\n\n        assert \"x-goog-user-project\" not in headers\n        assert \"token\" in headers[\"authorization\"]\n\n    @mock.patch(\"google.auth.jwt.Credentials\", instance=True, autospec=True)\n    def test__create_self_signed_jwt(self, jwt):\n        credentials = service_account.Credentials(\n            SIGNER, self.SERVICE_ACCOUNT_EMAIL, self.TOKEN_URI\n        )\n\n        audience = \"https://pubsub.googleapis.com\"\n        credentials._create_self_signed_jwt(audience)\n        jwt.from_signing_credentials.assert_called_once_with(credentials, audience)\n\n    @mock.patch(\"google.auth.jwt.Credentials\", instance=True, autospec=True)\n    def test__create_self_signed_jwt_with_user_scopes(self, jwt):\n        credentials = service_account.Credentials(\n            SIGNER, self.SERVICE_ACCOUNT_EMAIL, self.TOKEN_URI, scopes=[\"foo\"]\n        )\n\n        audience = \"https://pubsub.googleapis.com\"\n        credentials._create_self_signed_jwt(audience)\n\n        # JWT should not be created if there are user-defined scopes\n        jwt.from_signing_credentials.assert_not_called()\n\n    @mock.patch(\"google.auth.jwt.Credentials\", instance=True, autospec=True)\n    def test__create_self_signed_jwt_always_use_jwt_access_with_audience(self, jwt):\n        credentials = service_account.Credentials(\n            SIGNER,\n            self.SERVICE_ACCOUNT_EMAIL,\n            self.TOKEN_URI,\n            default_scopes=[\"bar\", \"foo\"],\n            always_use_jwt_access=True,\n        )\n\n        audience = \"https://pubsub.googleapis.com\"\n        credentials._create_self_signed_jwt(audience)\n        jwt.from_signing_credentials.assert_called_once_with(credentials, audience)\n\n    @mock.patch(\"google.auth.jwt.Credentials\", instance=True, autospec=True)\n    def test__create_self_signed_jwt_always_use_jwt_access_with_audience_similar_jwt_is_reused(\n        self, jwt\n    ):\n        credentials = service_account.Credentials(\n            SIGNER,\n            self.SERVICE_ACCOUNT_EMAIL,\n            self.TOKEN_URI,\n            default_scopes=[\"bar\", \"foo\"],\n            always_use_jwt_access=True,\n        )\n\n        audience = \"https://pubsub.googleapis.com\"\n        credentials._create_self_signed_jwt(audience)\n        credentials._jwt_credentials._audience = audience\n        credentials._create_self_signed_jwt(audience)\n        jwt.from_signing_credentials.assert_called_once_with(credentials, audience)\n\n    @mock.patch(\"google.auth.jwt.Credentials\", instance=True, autospec=True)\n    def test__create_self_signed_jwt_always_use_jwt_access_with_scopes(self, jwt):\n        credentials = service_account.Credentials(\n            SIGNER,\n            self.SERVICE_ACCOUNT_EMAIL,\n            self.TOKEN_URI,\n            scopes=[\"bar\", \"foo\"],\n            always_use_jwt_access=True,\n        )\n\n        audience = \"https://pubsub.googleapis.com\"\n        credentials._create_self_signed_jwt(audience)\n        jwt.from_signing_credentials.assert_called_once_with(\n            credentials, None, additional_claims={\"scope\": \"bar foo\"}\n        )\n\n    @mock.patch(\"google.auth.jwt.Credentials\", instance=True, autospec=True)\n    def test__create_self_signed_jwt_always_use_jwt_access_with_scopes_similar_jwt_is_reused(\n        self, jwt\n    ):\n        credentials = service_account.Credentials(\n            SIGNER,\n            self.SERVICE_ACCOUNT_EMAIL,\n            self.TOKEN_URI,\n            scopes=[\"bar\", \"foo\"],\n            always_use_jwt_access=True,\n        )\n\n        audience = \"https://pubsub.googleapis.com\"\n        credentials._create_self_signed_jwt(audience)\n        credentials._jwt_credentials.additional_claims = {\"scope\": \"bar foo\"}\n        credentials._create_self_signed_jwt(audience)\n        jwt.from_signing_credentials.assert_called_once_with(\n            credentials, None, additional_claims={\"scope\": \"bar foo\"}\n        )\n\n    @mock.patch(\"google.auth.jwt.Credentials\", instance=True, autospec=True)\n    def test__create_self_signed_jwt_always_use_jwt_access_with_default_scopes(\n        self, jwt\n    ):\n        credentials = service_account.Credentials(\n            SIGNER,\n            self.SERVICE_ACCOUNT_EMAIL,\n            self.TOKEN_URI,\n            default_scopes=[\"bar\", \"foo\"],\n            always_use_jwt_access=True,\n        )\n\n        credentials._create_self_signed_jwt(None)\n        jwt.from_signing_credentials.assert_called_once_with(\n            credentials, None, additional_claims={\"scope\": \"bar foo\"}\n        )\n\n    @mock.patch(\"google.auth.jwt.Credentials\", instance=True, autospec=True)\n    def test__create_self_signed_jwt_always_use_jwt_access_with_default_scopes_similar_jwt_is_reused(\n        self, jwt\n    ):\n        credentials = service_account.Credentials(\n            SIGNER,\n            self.SERVICE_ACCOUNT_EMAIL,\n            self.TOKEN_URI,\n            default_scopes=[\"bar\", \"foo\"],\n            always_use_jwt_access=True,\n        )\n\n        credentials._create_self_signed_jwt(None)\n        credentials._jwt_credentials.additional_claims = {\"scope\": \"bar foo\"}\n        credentials._create_self_signed_jwt(None)\n        jwt.from_signing_credentials.assert_called_once_with(\n            credentials, None, additional_claims={\"scope\": \"bar foo\"}\n        )\n\n    @mock.patch(\"google.auth.jwt.Credentials\", instance=True, autospec=True)\n    def test__create_self_signed_jwt_always_use_jwt_access(self, jwt):\n        credentials = service_account.Credentials(\n            SIGNER,\n            self.SERVICE_ACCOUNT_EMAIL,\n            self.TOKEN_URI,\n            always_use_jwt_access=True,\n        )\n\n        credentials._create_self_signed_jwt(None)\n        jwt.from_signing_credentials.assert_not_called()\n\n    def test_token_usage_metrics_assertion(self):\n        credentials = service_account.Credentials(\n            SIGNER,\n            self.SERVICE_ACCOUNT_EMAIL,\n            self.TOKEN_URI,\n            always_use_jwt_access=False,\n        )\n        credentials.token = \"token\"\n        credentials.expiry = None\n\n        headers = {}\n        credentials.before_request(mock.Mock(), None, None, headers)\n        assert headers[\"authorization\"] == \"Bearer token\"\n        assert headers[\"x-goog-api-client\"] == \"cred-type/sa\"\n\n    def test_token_usage_metrics_self_signed_jwt(self):\n        credentials = service_account.Credentials(\n            SIGNER,\n            self.SERVICE_ACCOUNT_EMAIL,\n            self.TOKEN_URI,\n            always_use_jwt_access=True,\n        )\n        credentials._create_self_signed_jwt(\"foo.googleapis.com\")\n        credentials.token = \"token\"\n        credentials.expiry = None\n\n        headers = {}\n        credentials.before_request(mock.Mock(), None, None, headers)\n        assert headers[\"authorization\"] == \"Bearer token\"\n        assert headers[\"x-goog-api-client\"] == \"cred-type/jwt\"\n\n    @mock.patch(\"google.oauth2._client.jwt_grant\", autospec=True)\n    def test_refresh_success(self, jwt_grant):\n        credentials = self.make_credentials()\n        token = \"token\"\n        jwt_grant.return_value = (\n            token,\n            _helpers.utcnow() + datetime.timedelta(seconds=500),\n            {},\n        )\n        request = mock.create_autospec(transport.Request, instance=True)\n\n        # Refresh credentials\n        credentials.refresh(request)\n\n        # Check jwt grant call.\n        assert jwt_grant.called\n\n        called_request, token_uri, assertion = jwt_grant.call_args[0]\n        assert called_request == request\n        assert token_uri == credentials._token_uri\n        assert jwt.decode(assertion, PUBLIC_CERT_BYTES)\n        # No further assertion done on the token, as there are separate tests\n        # for checking the authorization grant assertion.\n\n        # Check that the credentials have the token.\n        assert credentials.token == token\n\n        # Check that the credentials are valid (have a token and are not\n        # expired)\n        assert credentials.valid\n\n    @mock.patch(\"google.oauth2._client.jwt_grant\", autospec=True)\n    def test_before_request_refreshes(self, jwt_grant):\n        credentials = self.make_credentials()\n        token = \"token\"\n        jwt_grant.return_value = (\n            token,\n            _helpers.utcnow() + datetime.timedelta(seconds=500),\n            None,\n        )\n        request = mock.create_autospec(transport.Request, instance=True)\n\n        # Credentials should start as invalid\n        assert not credentials.valid\n\n        # before_request should cause a refresh\n        credentials.before_request(request, \"GET\", \"http://example.com?a=1#3\", {})\n\n        # The refresh endpoint should've been called.\n        assert jwt_grant.called\n\n        # Credentials should now be valid.\n        assert credentials.valid\n\n    @mock.patch(\"google.auth.jwt.Credentials._make_jwt\")\n    def test_refresh_with_jwt_credentials(self, make_jwt):\n        credentials = self.make_credentials()\n        credentials._create_self_signed_jwt(\"https://pubsub.googleapis.com\")\n\n        request = mock.create_autospec(transport.Request, instance=True)\n\n        token = \"token\"\n        expiry = _helpers.utcnow() + datetime.timedelta(seconds=500)\n        make_jwt.return_value = (b\"token\", expiry)\n\n        # Credentials should start as invalid\n        assert not credentials.valid\n\n        # before_request should cause a refresh\n        credentials.before_request(request, \"GET\", \"http://example.com?a=1#3\", {})\n\n        # Credentials should now be valid.\n        assert credentials.valid\n\n        # Assert make_jwt was called\n        assert make_jwt.call_count == 1\n\n        assert credentials.token == token\n        assert credentials.expiry == expiry\n\n    def test_refresh_with_jwt_credentials_token_type_check(self):\n        credentials = self.make_credentials()\n        credentials._create_self_signed_jwt(\"https://pubsub.googleapis.com\")\n        credentials.refresh(mock.Mock())\n\n        # Credentials token should be a JWT string.\n        assert isinstance(credentials.token, str)\n        payload = jwt.decode(credentials.token, verify=False)\n        assert payload[\"aud\"] == \"https://pubsub.googleapis.com\"\n\n    @mock.patch(\"google.oauth2._client.jwt_grant\", autospec=True)\n    @mock.patch(\"google.auth.jwt.Credentials.refresh\", autospec=True)\n    def test_refresh_jwt_not_used_for_domain_wide_delegation(\n        self, self_signed_jwt_refresh, jwt_grant\n    ):\n        # Create a domain wide delegation credentials by setting the subject.\n        credentials = service_account.Credentials(\n            SIGNER,\n            self.SERVICE_ACCOUNT_EMAIL,\n            self.TOKEN_URI,\n            always_use_jwt_access=True,\n            subject=\"subject\",\n        )\n        credentials._create_self_signed_jwt(\"https://pubsub.googleapis.com\")\n        jwt_grant.return_value = (\n            \"token\",\n            _helpers.utcnow() + datetime.timedelta(seconds=500),\n            {},\n        )\n        request = mock.create_autospec(transport.Request, instance=True)\n\n        # Refresh credentials\n        credentials.refresh(request)\n\n        # Make sure we are using jwt_grant and not self signed JWT refresh\n        # method to obtain the token.\n        assert jwt_grant.called\n        assert not self_signed_jwt_refresh.called\n\n    def test_refresh_missing_jwt_credentials(self):\n        credentials = self.make_credentials()\n        credentials = credentials.with_scopes([\"foo\", \"bar\"])\n        credentials = credentials.with_always_use_jwt_access(True)\n        assert not credentials._jwt_credentials\n\n        credentials.refresh(mock.Mock())\n\n        # jwt credentials should have been automatically created with scopes\n        assert credentials._jwt_credentials is not None\n\n    def test_refresh_non_gdu_domain_wide_delegation_not_supported(self):\n        credentials = self.make_credentials(universe_domain=\"foo\")\n        credentials._subject = \"bar@example.com\"\n        credentials._create_self_signed_jwt(\"https://pubsub.googleapis.com\")\n\n        with pytest.raises(exceptions.RefreshError) as excinfo:\n            credentials.refresh(None)\n        assert excinfo.match(\"domain wide delegation is not supported\")\n\n\nclass TestIDTokenCredentials(object):\n    SERVICE_ACCOUNT_EMAIL = \"service-account@example.com\"\n    TOKEN_URI = \"https://example.com/oauth2/token\"\n    TARGET_AUDIENCE = \"https://example.com\"\n\n    @classmethod\n    def make_credentials(cls, universe_domain=DEFAULT_UNIVERSE_DOMAIN):\n        return service_account.IDTokenCredentials(\n            SIGNER,\n            cls.SERVICE_ACCOUNT_EMAIL,\n            cls.TOKEN_URI,\n            cls.TARGET_AUDIENCE,\n            universe_domain=universe_domain,\n        )\n\n    def test_constructor_no_universe_domain(self):\n        credentials = service_account.IDTokenCredentials(\n            SIGNER,\n            self.SERVICE_ACCOUNT_EMAIL,\n            self.TOKEN_URI,\n            self.TARGET_AUDIENCE,\n            universe_domain=None,\n        )\n        assert credentials._universe_domain == DEFAULT_UNIVERSE_DOMAIN\n\n    def test_from_service_account_info(self):\n        credentials = service_account.IDTokenCredentials.from_service_account_info(\n            SERVICE_ACCOUNT_INFO, target_audience=self.TARGET_AUDIENCE\n        )\n\n        assert credentials._signer.key_id == SERVICE_ACCOUNT_INFO[\"private_key_id\"]\n        assert credentials.service_account_email == SERVICE_ACCOUNT_INFO[\"client_email\"]\n        assert credentials._token_uri == SERVICE_ACCOUNT_INFO[\"token_uri\"]\n        assert credentials._target_audience == self.TARGET_AUDIENCE\n        assert not credentials._use_iam_endpoint\n\n    def test_from_service_account_info_non_gdu(self):\n        credentials = service_account.IDTokenCredentials.from_service_account_info(\n            SERVICE_ACCOUNT_INFO_NON_GDU, target_audience=self.TARGET_AUDIENCE\n        )\n\n        assert (\n            credentials._signer.key_id == SERVICE_ACCOUNT_INFO_NON_GDU[\"private_key_id\"]\n        )\n        assert (\n            credentials.service_account_email\n            == SERVICE_ACCOUNT_INFO_NON_GDU[\"client_email\"]\n        )\n        assert credentials._token_uri == SERVICE_ACCOUNT_INFO_NON_GDU[\"token_uri\"]\n        assert credentials._target_audience == self.TARGET_AUDIENCE\n        assert credentials._use_iam_endpoint\n\n    def test_from_service_account_file(self):\n        info = SERVICE_ACCOUNT_INFO.copy()\n\n        credentials = service_account.IDTokenCredentials.from_service_account_file(\n            SERVICE_ACCOUNT_JSON_FILE, target_audience=self.TARGET_AUDIENCE\n        )\n\n        assert credentials.service_account_email == info[\"client_email\"]\n        assert credentials._signer.key_id == info[\"private_key_id\"]\n        assert credentials._token_uri == info[\"token_uri\"]\n        assert credentials._target_audience == self.TARGET_AUDIENCE\n        assert not credentials._use_iam_endpoint\n\n    def test_from_service_account_file_non_gdu(self):\n        info = SERVICE_ACCOUNT_INFO_NON_GDU.copy()\n\n        credentials = service_account.IDTokenCredentials.from_service_account_file(\n            SERVICE_ACCOUNT_NON_GDU_JSON_FILE, target_audience=self.TARGET_AUDIENCE\n        )\n\n        assert credentials.service_account_email == info[\"client_email\"]\n        assert credentials._signer.key_id == info[\"private_key_id\"]\n        assert credentials._token_uri == info[\"token_uri\"]\n        assert credentials._target_audience == self.TARGET_AUDIENCE\n        assert credentials._use_iam_endpoint\n\n    def test_default_state(self):\n        credentials = self.make_credentials()\n        assert not credentials.valid\n        # Expiration hasn't been set yet\n        assert not credentials.expired\n\n    def test_sign_bytes(self):\n        credentials = self.make_credentials()\n        to_sign = b\"123\"\n        signature = credentials.sign_bytes(to_sign)\n        assert crypt.verify_signature(to_sign, signature, PUBLIC_CERT_BYTES)\n\n    def test_signer(self):\n        credentials = self.make_credentials()\n        assert isinstance(credentials.signer, crypt.Signer)\n\n    def test_signer_email(self):\n        credentials = self.make_credentials()\n        assert credentials.signer_email == self.SERVICE_ACCOUNT_EMAIL\n\n    def test_with_target_audience(self):\n        credentials = self.make_credentials()\n        new_credentials = credentials.with_target_audience(\"https://new.example.com\")\n        assert new_credentials._target_audience == \"https://new.example.com\"\n\n    def test__with_use_iam_endpoint(self):\n        credentials = self.make_credentials()\n        new_credentials = credentials._with_use_iam_endpoint(True)\n        assert new_credentials._use_iam_endpoint\n\n    def test__with_use_iam_endpoint_non_default_universe_domain(self):\n        credentials = self.make_credentials(universe_domain=FAKE_UNIVERSE_DOMAIN)\n        with pytest.raises(exceptions.InvalidValue) as excinfo:\n            credentials._with_use_iam_endpoint(False)\n\n        assert excinfo.match(\n            \"use_iam_endpoint should be True for non-default universe domain\"\n        )\n\n    def test_with_quota_project(self):\n        credentials = self.make_credentials()\n        new_credentials = credentials.with_quota_project(\"project-foo\")\n        assert new_credentials._quota_project_id == \"project-foo\"\n\n    def test_with_token_uri(self):\n        credentials = self.make_credentials()\n        new_token_uri = \"https://example2.com/oauth2/token\"\n        assert credentials._token_uri == self.TOKEN_URI\n        creds_with_new_token_uri = credentials.with_token_uri(new_token_uri)\n        assert creds_with_new_token_uri._token_uri == new_token_uri\n\n    def test__make_authorization_grant_assertion(self):\n        credentials = self.make_credentials()\n        token = credentials._make_authorization_grant_assertion()\n        payload = jwt.decode(token, PUBLIC_CERT_BYTES)\n        assert payload[\"iss\"] == self.SERVICE_ACCOUNT_EMAIL\n        assert payload[\"aud\"] == service_account._GOOGLE_OAUTH2_TOKEN_ENDPOINT\n        assert payload[\"target_audience\"] == self.TARGET_AUDIENCE\n\n    @mock.patch(\"google.oauth2._client.id_token_jwt_grant\", autospec=True)\n    def test_refresh_success(self, id_token_jwt_grant):\n        credentials = self.make_credentials()\n        token = \"token\"\n        id_token_jwt_grant.return_value = (\n            token,\n            _helpers.utcnow() + datetime.timedelta(seconds=500),\n            {},\n        )\n        request = mock.create_autospec(transport.Request, instance=True)\n\n        # Refresh credentials\n        credentials.refresh(request)\n\n        # Check jwt grant call.\n        assert id_token_jwt_grant.called\n\n        called_request, token_uri, assertion = id_token_jwt_grant.call_args[0]\n        assert called_request == request\n        assert token_uri == credentials._token_uri\n        assert jwt.decode(assertion, PUBLIC_CERT_BYTES)\n        # No further assertion done on the token, as there are separate tests\n        # for checking the authorization grant assertion.\n\n        # Check that the credentials have the token.\n        assert credentials.token == token\n\n        # Check that the credentials are valid (have a token and are not\n        # expired)\n        assert credentials.valid\n\n    @mock.patch(\n        \"google.oauth2._client.call_iam_generate_id_token_endpoint\", autospec=True\n    )\n    def test_refresh_iam_flow(self, call_iam_generate_id_token_endpoint):\n        credentials = self.make_credentials()\n        credentials._use_iam_endpoint = True\n        token = \"id_token\"\n        call_iam_generate_id_token_endpoint.return_value = (\n            token,\n            _helpers.utcnow() + datetime.timedelta(seconds=500),\n        )\n        request = mock.Mock()\n        credentials.refresh(request)\n        req, iam_endpoint, signer_email, target_audience, access_token = call_iam_generate_id_token_endpoint.call_args[\n            0\n        ]\n        assert req == request\n        assert iam_endpoint == iam._IAM_IDTOKEN_ENDPOINT\n        assert signer_email == \"service-account@example.com\"\n        assert target_audience == \"https://example.com\"\n        decoded_access_token = jwt.decode(access_token, verify=False)\n        assert decoded_access_token[\"scope\"] == \"https://www.googleapis.com/auth/iam\"\n\n    @mock.patch(\n        \"google.oauth2._client.call_iam_generate_id_token_endpoint\", autospec=True\n    )\n    def test_refresh_iam_flow_non_gdu(self, call_iam_generate_id_token_endpoint):\n        credentials = self.make_credentials(universe_domain=\"fake-universe\")\n        token = \"id_token\"\n        call_iam_generate_id_token_endpoint.return_value = (\n            token,\n            _helpers.utcnow() + datetime.timedelta(seconds=500),\n        )\n        request = mock.Mock()\n        credentials.refresh(request)\n        req, iam_endpoint, signer_email, target_audience, access_token = call_iam_generate_id_token_endpoint.call_args[\n            0\n        ]\n        assert req == request\n        assert (\n            iam_endpoint\n            == \"https://iamcredentials.fake-universe/v1/projects/-/serviceAccounts/{}:generateIdToken\"\n        )\n        assert signer_email == \"service-account@example.com\"\n        assert target_audience == \"https://example.com\"\n        decoded_access_token = jwt.decode(access_token, verify=False)\n        assert decoded_access_token[\"scope\"] == \"https://www.googleapis.com/auth/iam\"\n\n    @mock.patch(\"google.oauth2._client.id_token_jwt_grant\", autospec=True)\n    def test_before_request_refreshes(self, id_token_jwt_grant):\n        credentials = self.make_credentials()\n        token = \"token\"\n        id_token_jwt_grant.return_value = (\n            token,\n            _helpers.utcnow() + datetime.timedelta(seconds=500),\n            None,\n        )\n        request = mock.create_autospec(transport.Request, instance=True)\n\n        # Credentials should start as invalid\n        assert not credentials.valid\n\n        # before_request should cause a refresh\n        credentials.before_request(request, \"GET\", \"http://example.com?a=1#3\", {})\n\n        # The refresh endpoint should've been called.\n        assert id_token_jwt_grant.called\n\n        # Credentials should now be valid.\n        assert credentials.valid\n", "tests/oauth2/test_webauthn_types.py": "import json\n\nimport pytest  # type: ignore\n\nfrom google.oauth2 import webauthn_types\n\n\n@pytest.mark.parametrize(\n    \"test_pub_key_cred,expected_dict\",\n    [\n        (\n            webauthn_types.PublicKeyCredentialDescriptor(\n                id=\"fake_cred_id_base64\", transports=None\n            ),\n            {\"type\": \"public-key\", \"id\": \"fake_cred_id_base64\"},\n        ),\n        (\n            webauthn_types.PublicKeyCredentialDescriptor(\n                id=\"fake_cred_id_base64\", transports=[]\n            ),\n            {\"type\": \"public-key\", \"id\": \"fake_cred_id_base64\"},\n        ),\n        (\n            webauthn_types.PublicKeyCredentialDescriptor(\n                id=\"fake_cred_id_base64\", transports=[\"usb\"]\n            ),\n            {\"type\": \"public-key\", \"id\": \"fake_cred_id_base64\", \"transports\": [\"usb\"]},\n        ),\n        (\n            webauthn_types.PublicKeyCredentialDescriptor(\n                id=\"fake_cred_id_base64\", transports=[\"usb\", \"internal\"]\n            ),\n            {\n                \"type\": \"public-key\",\n                \"id\": \"fake_cred_id_base64\",\n                \"transports\": [\"usb\", \"internal\"],\n            },\n        ),\n    ],\n)\ndef test_PublicKeyCredentialDescriptor(test_pub_key_cred, expected_dict):\n    assert test_pub_key_cred.to_dict() == expected_dict\n\n\n@pytest.mark.parametrize(\n    \"test_extension_input,expected_dict\",\n    [\n        (webauthn_types.AuthenticationExtensionsClientInputs(), {}),\n        (webauthn_types.AuthenticationExtensionsClientInputs(appid=\"\"), {}),\n        (\n            webauthn_types.AuthenticationExtensionsClientInputs(appid=\"fake_appid\"),\n            {\"appid\": \"fake_appid\"},\n        ),\n    ],\n)\ndef test_AuthenticationExtensionsClientInputs(test_extension_input, expected_dict):\n    assert test_extension_input.to_dict() == expected_dict\n\n\n@pytest.mark.parametrize(\"has_allow_credentials\", [(False), (True)])\ndef test_GetRequest(has_allow_credentials):\n    allow_credentials = [\n        webauthn_types.PublicKeyCredentialDescriptor(id=\"fake_id_1\"),\n        webauthn_types.PublicKeyCredentialDescriptor(id=\"fake_id_2\"),\n    ]\n    test_get_request = webauthn_types.GetRequest(\n        origin=\"fake_origin\",\n        rpid=\"fake_rpid\",\n        challenge=\"fake_challenge\",\n        timeout_ms=123,\n        allow_credentials=allow_credentials if has_allow_credentials else None,\n        user_verification=\"preferred\",\n        extensions=webauthn_types.AuthenticationExtensionsClientInputs(\n            appid=\"fake_appid\"\n        ),\n    )\n    expected_allow_credentials = [\n        {\"type\": \"public-key\", \"id\": \"fake_id_1\"},\n        {\"type\": \"public-key\", \"id\": \"fake_id_2\"},\n    ]\n    exepcted_dict = {\n        \"type\": \"get\",\n        \"origin\": \"fake_origin\",\n        \"requestData\": {\n            \"rpid\": \"fake_rpid\",\n            \"timeout\": 123,\n            \"challenge\": \"fake_challenge\",\n            \"userVerification\": \"preferred\",\n            \"extensions\": {\"appid\": \"fake_appid\"},\n        },\n    }\n    if has_allow_credentials:\n        exepcted_dict[\"requestData\"][\"allowCredentials\"] = expected_allow_credentials\n    assert json.loads(test_get_request.to_json()) == exepcted_dict\n\n\n@pytest.mark.parametrize(\n    \"has_user_handle,has_authenticator_attachment,has_client_extension_results\",\n    [\n        (False, False, False),\n        (False, False, True),\n        (False, True, False),\n        (False, True, True),\n        (True, False, False),\n        (True, False, True),\n        (True, True, False),\n        (True, True, True),\n    ],\n)\ndef test_GetResponse(\n    has_user_handle, has_authenticator_attachment, has_client_extension_results\n):\n    input_response_data = {\n        \"type\": \"public-key\",\n        \"id\": \"fake-id\",\n        \"authenticatorAttachment\": \"cross-platform\",\n        \"clientExtensionResults\": {\"appid\": True},\n        \"response\": {\n            \"clientDataJSON\": \"fake_client_data_json_base64\",\n            \"authenticatorData\": \"fake_authenticator_data_base64\",\n            \"signature\": \"fake_signature_base64\",\n            \"userHandle\": \"fake_user_handle_base64\",\n        },\n    }\n    if not has_authenticator_attachment:\n        input_response_data.pop(\"authenticatorAttachment\")\n    if not has_client_extension_results:\n        input_response_data.pop(\"clientExtensionResults\")\n    if not has_user_handle:\n        input_response_data[\"response\"].pop(\"userHandle\")\n\n    response = webauthn_types.GetResponse.from_json(\n        json.dumps({\"type\": \"getResponse\", \"responseData\": input_response_data})\n    )\n\n    assert response.id == input_response_data[\"id\"]\n    assert response.authenticator_attachment == (\n        input_response_data[\"authenticatorAttachment\"]\n        if has_authenticator_attachment\n        else None\n    )\n    assert response.client_extension_results == (\n        input_response_data[\"clientExtensionResults\"]\n        if has_client_extension_results\n        else None\n    )\n    assert (\n        response.response.client_data_json\n        == input_response_data[\"response\"][\"clientDataJSON\"]\n    )\n    assert (\n        response.response.authenticator_data\n        == input_response_data[\"response\"][\"authenticatorData\"]\n    )\n    assert response.response.signature == input_response_data[\"response\"][\"signature\"]\n    assert response.response.user_handle == (\n        input_response_data[\"response\"][\"userHandle\"] if has_user_handle else None\n    )\n\n\n@pytest.mark.parametrize(\n    \"input_dict,expected_error\",\n    [\n        ({\"xyz_type\": \"wrong_type\"}, \"Invalid Get response type\"),\n        ({\"type\": \"wrong_type\"}, \"Invalid Get response type\"),\n        ({\"type\": \"getResponse\"}, \"Get response is empty\"),\n        (\n            {\"type\": \"getResponse\", \"error\": \"fake_get_response_error\"},\n            \"WebAuthn.get failure: fake_get_response_error\",\n        ),\n        (\n            {\"type\": \"getResponse\", \"responseData\": {\"xyz_type\": \"wrong_type\"}},\n            \"Invalid credential type\",\n        ),\n        (\n            {\"type\": \"getResponse\", \"responseData\": {\"type\": \"wrong_type\"}},\n            \"Invalid credential type\",\n        ),\n        (\n            {\n                \"type\": \"getResponse\",\n                \"responseData\": {\"type\": \"public-key\", \"response\": {}},\n            },\n            \"KeyError\",\n        ),\n        (\n            {\n                \"type\": \"getResponse\",\n                \"responseData\": {\n                    \"type\": \"public-key\",\n                    \"response\": {\"clientDataJSON\": \"fake_client_data_json_base64\"},\n                },\n            },\n            \"KeyError\",\n        ),\n        (\n            {\n                \"type\": \"getResponse\",\n                \"responseData\": {\n                    \"type\": \"public-key\",\n                    \"response\": {\n                        \"clientDataJSON\": \"fake_client_data_json_base64\",\n                        \"authenticatorData\": \"fake_authenticator_data_base64\",\n                    },\n                },\n            },\n            \"KeyError\",\n        ),\n        (\n            {\n                \"type\": \"getResponse\",\n                \"responseData\": {\n                    \"type\": \"public-key\",\n                    \"response\": {\n                        \"clientDataJSON\": \"fake_client_data_json_base64\",\n                        \"authenticatorData\": \"fake_authenticator_data_base64\",\n                        \"signature\": \"fake_signature_base64\",\n                    },\n                },\n            },\n            \"KeyError\",\n        ),\n    ],\n)\ndef test_GetResponse_error(input_dict, expected_error):\n    with pytest.raises(Exception) as excinfo:\n        webauthn_types.GetResponse.from_json(json.dumps(input_dict))\n    if expected_error == \"KeyError\":\n        assert excinfo.type is KeyError\n    else:\n        assert expected_error in str(excinfo.value)\n\n\ndef test_MalformatedJsonInput():\n    with pytest.raises(ValueError) as excinfo:\n        webauthn_types.GetResponse.from_json(\")]}\")\n    assert \"Invalid Get JSON response\" in str(excinfo.value)\n", "tests/oauth2/__init__.py": "", "tests/oauth2/test_id_token.py": "# Copyright 2014 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport json\nimport os\n\nimport mock\nimport pytest  # type: ignore\n\nfrom google.auth import environment_vars\nfrom google.auth import exceptions\nfrom google.auth import transport\nfrom google.oauth2 import id_token\nfrom google.oauth2 import service_account\n\nSERVICE_ACCOUNT_FILE = os.path.join(\n    os.path.dirname(__file__), \"../data/service_account.json\"\n)\nID_TOKEN_AUDIENCE = \"https://pubsub.googleapis.com\"\n\n\ndef make_request(status, data=None):\n    response = mock.create_autospec(transport.Response, instance=True)\n    response.status = status\n\n    if data is not None:\n        response.data = json.dumps(data).encode(\"utf-8\")\n\n    request = mock.create_autospec(transport.Request)\n    request.return_value = response\n    return request\n\n\ndef test__fetch_certs_success():\n    certs = {\"1\": \"cert\"}\n    request = make_request(200, certs)\n\n    returned_certs = id_token._fetch_certs(request, mock.sentinel.cert_url)\n\n    request.assert_called_once_with(mock.sentinel.cert_url, method=\"GET\")\n    assert returned_certs == certs\n\n\ndef test__fetch_certs_failure():\n    request = make_request(404)\n\n    with pytest.raises(exceptions.TransportError):\n        id_token._fetch_certs(request, mock.sentinel.cert_url)\n\n    request.assert_called_once_with(mock.sentinel.cert_url, method=\"GET\")\n\n\n@mock.patch(\"google.auth.jwt.decode\", autospec=True)\n@mock.patch(\"google.oauth2.id_token._fetch_certs\", autospec=True)\ndef test_verify_token(_fetch_certs, decode):\n    result = id_token.verify_token(mock.sentinel.token, mock.sentinel.request)\n\n    assert result == decode.return_value\n    _fetch_certs.assert_called_once_with(\n        mock.sentinel.request, id_token._GOOGLE_OAUTH2_CERTS_URL\n    )\n    decode.assert_called_once_with(\n        mock.sentinel.token,\n        certs=_fetch_certs.return_value,\n        audience=None,\n        clock_skew_in_seconds=0,\n    )\n\n\n@mock.patch(\"google.auth.jwt.decode\", autospec=True)\n@mock.patch(\"google.oauth2.id_token._fetch_certs\", autospec=True)\ndef test_verify_token_args(_fetch_certs, decode):\n    result = id_token.verify_token(\n        mock.sentinel.token,\n        mock.sentinel.request,\n        audience=mock.sentinel.audience,\n        certs_url=mock.sentinel.certs_url,\n    )\n\n    assert result == decode.return_value\n    _fetch_certs.assert_called_once_with(mock.sentinel.request, mock.sentinel.certs_url)\n    decode.assert_called_once_with(\n        mock.sentinel.token,\n        certs=_fetch_certs.return_value,\n        audience=mock.sentinel.audience,\n        clock_skew_in_seconds=0,\n    )\n\n\n@mock.patch(\"google.auth.jwt.decode\", autospec=True)\n@mock.patch(\"google.oauth2.id_token._fetch_certs\", autospec=True)\ndef test_verify_token_clock_skew(_fetch_certs, decode):\n    result = id_token.verify_token(\n        mock.sentinel.token,\n        mock.sentinel.request,\n        audience=mock.sentinel.audience,\n        certs_url=mock.sentinel.certs_url,\n        clock_skew_in_seconds=10,\n    )\n\n    assert result == decode.return_value\n    _fetch_certs.assert_called_once_with(mock.sentinel.request, mock.sentinel.certs_url)\n    decode.assert_called_once_with(\n        mock.sentinel.token,\n        certs=_fetch_certs.return_value,\n        audience=mock.sentinel.audience,\n        clock_skew_in_seconds=10,\n    )\n\n\n@mock.patch(\"google.oauth2.id_token.verify_token\", autospec=True)\ndef test_verify_oauth2_token(verify_token):\n    verify_token.return_value = {\"iss\": \"accounts.google.com\"}\n    result = id_token.verify_oauth2_token(\n        mock.sentinel.token, mock.sentinel.request, audience=mock.sentinel.audience\n    )\n\n    assert result == verify_token.return_value\n    verify_token.assert_called_once_with(\n        mock.sentinel.token,\n        mock.sentinel.request,\n        audience=mock.sentinel.audience,\n        certs_url=id_token._GOOGLE_OAUTH2_CERTS_URL,\n        clock_skew_in_seconds=0,\n    )\n\n\n@mock.patch(\"google.oauth2.id_token.verify_token\", autospec=True)\ndef test_verify_oauth2_token_clock_skew(verify_token):\n    verify_token.return_value = {\"iss\": \"accounts.google.com\"}\n    result = id_token.verify_oauth2_token(\n        mock.sentinel.token,\n        mock.sentinel.request,\n        audience=mock.sentinel.audience,\n        clock_skew_in_seconds=10,\n    )\n\n    assert result == verify_token.return_value\n    verify_token.assert_called_once_with(\n        mock.sentinel.token,\n        mock.sentinel.request,\n        audience=mock.sentinel.audience,\n        certs_url=id_token._GOOGLE_OAUTH2_CERTS_URL,\n        clock_skew_in_seconds=10,\n    )\n\n\n@mock.patch(\"google.oauth2.id_token.verify_token\", autospec=True)\ndef test_verify_oauth2_token_invalid_iss(verify_token):\n    verify_token.return_value = {\"iss\": \"invalid_issuer\"}\n\n    with pytest.raises(exceptions.GoogleAuthError):\n        id_token.verify_oauth2_token(\n            mock.sentinel.token, mock.sentinel.request, audience=mock.sentinel.audience\n        )\n\n\n@mock.patch(\"google.oauth2.id_token.verify_token\", autospec=True)\ndef test_verify_firebase_token(verify_token):\n    result = id_token.verify_firebase_token(\n        mock.sentinel.token, mock.sentinel.request, audience=mock.sentinel.audience\n    )\n\n    assert result == verify_token.return_value\n    verify_token.assert_called_once_with(\n        mock.sentinel.token,\n        mock.sentinel.request,\n        audience=mock.sentinel.audience,\n        certs_url=id_token._GOOGLE_APIS_CERTS_URL,\n        clock_skew_in_seconds=0,\n    )\n\n\n@mock.patch(\"google.oauth2.id_token.verify_token\", autospec=True)\ndef test_verify_firebase_token_clock_skew(verify_token):\n    result = id_token.verify_firebase_token(\n        mock.sentinel.token,\n        mock.sentinel.request,\n        audience=mock.sentinel.audience,\n        clock_skew_in_seconds=10,\n    )\n\n    assert result == verify_token.return_value\n    verify_token.assert_called_once_with(\n        mock.sentinel.token,\n        mock.sentinel.request,\n        audience=mock.sentinel.audience,\n        certs_url=id_token._GOOGLE_APIS_CERTS_URL,\n        clock_skew_in_seconds=10,\n    )\n\n\ndef test_fetch_id_token_credentials_optional_request(monkeypatch):\n    monkeypatch.delenv(environment_vars.CREDENTIALS, raising=False)\n\n    # Test a request object is created if not provided\n    with mock.patch(\"google.auth.compute_engine._metadata.ping\", return_value=True):\n        with mock.patch(\n            \"google.auth.compute_engine.IDTokenCredentials.__init__\", return_value=None\n        ):\n            with mock.patch(\n                \"google.auth.transport.requests.Request.__init__\", return_value=None\n            ) as mock_request:\n                id_token.fetch_id_token_credentials(ID_TOKEN_AUDIENCE)\n            mock_request.assert_called()\n\n\ndef test_fetch_id_token_credentials_from_metadata_server(monkeypatch):\n    monkeypatch.delenv(environment_vars.CREDENTIALS, raising=False)\n\n    mock_req = mock.Mock()\n\n    with mock.patch(\"google.auth.compute_engine._metadata.ping\", return_value=True):\n        with mock.patch(\n            \"google.auth.compute_engine.IDTokenCredentials.__init__\", return_value=None\n        ) as mock_init:\n            id_token.fetch_id_token_credentials(ID_TOKEN_AUDIENCE, request=mock_req)\n        mock_init.assert_called_once_with(\n            mock_req, ID_TOKEN_AUDIENCE, use_metadata_identity_endpoint=True\n        )\n\n\ndef test_fetch_id_token_credentials_from_explicit_cred_json_file(monkeypatch):\n    monkeypatch.setenv(environment_vars.CREDENTIALS, SERVICE_ACCOUNT_FILE)\n\n    cred = id_token.fetch_id_token_credentials(ID_TOKEN_AUDIENCE)\n    assert isinstance(cred, service_account.IDTokenCredentials)\n    assert cred._target_audience == ID_TOKEN_AUDIENCE\n\n\ndef test_fetch_id_token_credentials_no_cred_exists(monkeypatch):\n    monkeypatch.delenv(environment_vars.CREDENTIALS, raising=False)\n\n    with mock.patch(\n        \"google.auth.compute_engine._metadata.ping\",\n        side_effect=exceptions.TransportError(),\n    ):\n        with pytest.raises(exceptions.DefaultCredentialsError) as excinfo:\n            id_token.fetch_id_token_credentials(ID_TOKEN_AUDIENCE)\n        assert excinfo.match(\n            r\"Neither metadata server or valid service account credentials are found.\"\n        )\n\n    with mock.patch(\"google.auth.compute_engine._metadata.ping\", return_value=False):\n        with pytest.raises(exceptions.DefaultCredentialsError) as excinfo:\n            id_token.fetch_id_token_credentials(ID_TOKEN_AUDIENCE)\n        assert excinfo.match(\n            r\"Neither metadata server or valid service account credentials are found.\"\n        )\n\n\ndef test_fetch_id_token_credentials_invalid_cred_file_type(monkeypatch):\n    user_credentials_file = os.path.join(\n        os.path.dirname(__file__), \"../data/authorized_user.json\"\n    )\n    monkeypatch.setenv(environment_vars.CREDENTIALS, user_credentials_file)\n\n    with mock.patch(\"google.auth.compute_engine._metadata.ping\", return_value=False):\n        with pytest.raises(exceptions.DefaultCredentialsError) as excinfo:\n            id_token.fetch_id_token_credentials(ID_TOKEN_AUDIENCE)\n        assert excinfo.match(\n            r\"Neither metadata server or valid service account credentials are found.\"\n        )\n\n\ndef test_fetch_id_token_credentials_invalid_json(monkeypatch):\n    not_json_file = os.path.join(os.path.dirname(__file__), \"../data/public_cert.pem\")\n    monkeypatch.setenv(environment_vars.CREDENTIALS, not_json_file)\n\n    with pytest.raises(exceptions.DefaultCredentialsError) as excinfo:\n        id_token.fetch_id_token_credentials(ID_TOKEN_AUDIENCE)\n    assert excinfo.match(\n        r\"GOOGLE_APPLICATION_CREDENTIALS is not valid service account credentials.\"\n    )\n\n\ndef test_fetch_id_token_credentials_invalid_cred_path(monkeypatch):\n    not_json_file = os.path.join(os.path.dirname(__file__), \"../data/not_exists.json\")\n    monkeypatch.setenv(environment_vars.CREDENTIALS, not_json_file)\n\n    with pytest.raises(exceptions.DefaultCredentialsError) as excinfo:\n        id_token.fetch_id_token_credentials(ID_TOKEN_AUDIENCE)\n    assert excinfo.match(\n        r\"GOOGLE_APPLICATION_CREDENTIALS path is either not found or invalid.\"\n    )\n\n\ndef test_fetch_id_token(monkeypatch):\n    mock_cred = mock.MagicMock()\n    mock_cred.token = \"token\"\n\n    mock_req = mock.Mock()\n\n    with mock.patch(\n        \"google.oauth2.id_token.fetch_id_token_credentials\", return_value=mock_cred\n    ) as mock_fetch:\n        token = id_token.fetch_id_token(mock_req, ID_TOKEN_AUDIENCE)\n    mock_fetch.assert_called_once_with(ID_TOKEN_AUDIENCE, request=mock_req)\n    mock_cred.refresh.assert_called_once_with(mock_req)\n    assert token == \"token\"\n", "tests/oauth2/test_utils.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport json\n\nimport pytest  # type: ignore\n\nfrom google.auth import exceptions\nfrom google.oauth2 import utils\n\n\nCLIENT_ID = \"username\"\nCLIENT_SECRET = \"password\"\n# Base64 encoding of \"username:password\"\nBASIC_AUTH_ENCODING = \"dXNlcm5hbWU6cGFzc3dvcmQ=\"\n# Base64 encoding of \"username:\"\nBASIC_AUTH_ENCODING_SECRETLESS = \"dXNlcm5hbWU6\"\n\n\nclass AuthHandler(utils.OAuthClientAuthHandler):\n    def __init__(self, client_auth=None):\n        super(AuthHandler, self).__init__(client_auth)\n\n    def apply_client_authentication_options(\n        self, headers, request_body=None, bearer_token=None\n    ):\n        return super(AuthHandler, self).apply_client_authentication_options(\n            headers, request_body, bearer_token\n        )\n\n\nclass TestClientAuthentication(object):\n    @classmethod\n    def make_client_auth(cls, client_secret=None):\n        return utils.ClientAuthentication(\n            utils.ClientAuthType.basic, CLIENT_ID, client_secret\n        )\n\n    def test_initialization_with_client_secret(self):\n        client_auth = self.make_client_auth(CLIENT_SECRET)\n\n        assert client_auth.client_auth_type == utils.ClientAuthType.basic\n        assert client_auth.client_id == CLIENT_ID\n        assert client_auth.client_secret == CLIENT_SECRET\n\n    def test_initialization_no_client_secret(self):\n        client_auth = self.make_client_auth()\n\n        assert client_auth.client_auth_type == utils.ClientAuthType.basic\n        assert client_auth.client_id == CLIENT_ID\n        assert client_auth.client_secret is None\n\n\nclass TestOAuthClientAuthHandler(object):\n    CLIENT_AUTH_BASIC = utils.ClientAuthentication(\n        utils.ClientAuthType.basic, CLIENT_ID, CLIENT_SECRET\n    )\n    CLIENT_AUTH_BASIC_SECRETLESS = utils.ClientAuthentication(\n        utils.ClientAuthType.basic, CLIENT_ID\n    )\n    CLIENT_AUTH_REQUEST_BODY = utils.ClientAuthentication(\n        utils.ClientAuthType.request_body, CLIENT_ID, CLIENT_SECRET\n    )\n    CLIENT_AUTH_REQUEST_BODY_SECRETLESS = utils.ClientAuthentication(\n        utils.ClientAuthType.request_body, CLIENT_ID\n    )\n\n    @classmethod\n    def make_oauth_client_auth_handler(cls, client_auth=None):\n        return AuthHandler(client_auth)\n\n    def test_apply_client_authentication_options_none(self):\n        headers = {\"Content-Type\": \"application/json\"}\n        request_body = {\"foo\": \"bar\"}\n        auth_handler = self.make_oauth_client_auth_handler()\n\n        auth_handler.apply_client_authentication_options(headers, request_body)\n\n        assert headers == {\"Content-Type\": \"application/json\"}\n        assert request_body == {\"foo\": \"bar\"}\n\n    def test_apply_client_authentication_options_basic(self):\n        headers = {\"Content-Type\": \"application/json\"}\n        request_body = {\"foo\": \"bar\"}\n        auth_handler = self.make_oauth_client_auth_handler(self.CLIENT_AUTH_BASIC)\n\n        auth_handler.apply_client_authentication_options(headers, request_body)\n\n        assert headers == {\n            \"Content-Type\": \"application/json\",\n            \"Authorization\": \"Basic {}\".format(BASIC_AUTH_ENCODING),\n        }\n        assert request_body == {\"foo\": \"bar\"}\n\n    def test_apply_client_authentication_options_basic_nosecret(self):\n        headers = {\"Content-Type\": \"application/json\"}\n        request_body = {\"foo\": \"bar\"}\n        auth_handler = self.make_oauth_client_auth_handler(\n            self.CLIENT_AUTH_BASIC_SECRETLESS\n        )\n\n        auth_handler.apply_client_authentication_options(headers, request_body)\n\n        assert headers == {\n            \"Content-Type\": \"application/json\",\n            \"Authorization\": \"Basic {}\".format(BASIC_AUTH_ENCODING_SECRETLESS),\n        }\n        assert request_body == {\"foo\": \"bar\"}\n\n    def test_apply_client_authentication_options_request_body(self):\n        headers = {\"Content-Type\": \"application/json\"}\n        request_body = {\"foo\": \"bar\"}\n        auth_handler = self.make_oauth_client_auth_handler(\n            self.CLIENT_AUTH_REQUEST_BODY\n        )\n\n        auth_handler.apply_client_authentication_options(headers, request_body)\n\n        assert headers == {\"Content-Type\": \"application/json\"}\n        assert request_body == {\n            \"foo\": \"bar\",\n            \"client_id\": CLIENT_ID,\n            \"client_secret\": CLIENT_SECRET,\n        }\n\n    def test_apply_client_authentication_options_request_body_nosecret(self):\n        headers = {\"Content-Type\": \"application/json\"}\n        request_body = {\"foo\": \"bar\"}\n        auth_handler = self.make_oauth_client_auth_handler(\n            self.CLIENT_AUTH_REQUEST_BODY_SECRETLESS\n        )\n\n        auth_handler.apply_client_authentication_options(headers, request_body)\n\n        assert headers == {\"Content-Type\": \"application/json\"}\n        assert request_body == {\n            \"foo\": \"bar\",\n            \"client_id\": CLIENT_ID,\n            \"client_secret\": \"\",\n        }\n\n    def test_apply_client_authentication_options_request_body_no_body(self):\n        headers = {\"Content-Type\": \"application/json\"}\n        auth_handler = self.make_oauth_client_auth_handler(\n            self.CLIENT_AUTH_REQUEST_BODY\n        )\n\n        with pytest.raises(exceptions.OAuthError) as excinfo:\n            auth_handler.apply_client_authentication_options(headers)\n\n        assert excinfo.match(r\"HTTP request does not support request-body\")\n\n    def test_apply_client_authentication_options_bearer_token(self):\n        bearer_token = \"ACCESS_TOKEN\"\n        headers = {\"Content-Type\": \"application/json\"}\n        request_body = {\"foo\": \"bar\"}\n        auth_handler = self.make_oauth_client_auth_handler()\n\n        auth_handler.apply_client_authentication_options(\n            headers, request_body, bearer_token\n        )\n\n        assert headers == {\n            \"Content-Type\": \"application/json\",\n            \"Authorization\": \"Bearer {}\".format(bearer_token),\n        }\n        assert request_body == {\"foo\": \"bar\"}\n\n    def test_apply_client_authentication_options_bearer_and_basic(self):\n        bearer_token = \"ACCESS_TOKEN\"\n        headers = {\"Content-Type\": \"application/json\"}\n        request_body = {\"foo\": \"bar\"}\n        auth_handler = self.make_oauth_client_auth_handler(self.CLIENT_AUTH_BASIC)\n\n        auth_handler.apply_client_authentication_options(\n            headers, request_body, bearer_token\n        )\n\n        # Bearer token should have higher priority.\n        assert headers == {\n            \"Content-Type\": \"application/json\",\n            \"Authorization\": \"Bearer {}\".format(bearer_token),\n        }\n        assert request_body == {\"foo\": \"bar\"}\n\n    def test_apply_client_authentication_options_bearer_and_request_body(self):\n        bearer_token = \"ACCESS_TOKEN\"\n        headers = {\"Content-Type\": \"application/json\"}\n        request_body = {\"foo\": \"bar\"}\n        auth_handler = self.make_oauth_client_auth_handler(\n            self.CLIENT_AUTH_REQUEST_BODY\n        )\n\n        auth_handler.apply_client_authentication_options(\n            headers, request_body, bearer_token\n        )\n\n        # Bearer token should have higher priority.\n        assert headers == {\n            \"Content-Type\": \"application/json\",\n            \"Authorization\": \"Bearer {}\".format(bearer_token),\n        }\n        assert request_body == {\"foo\": \"bar\"}\n\n\ndef test__handle_error_response_code_only():\n    error_resp = {\"error\": \"unsupported_grant_type\"}\n    response_data = json.dumps(error_resp)\n\n    with pytest.raises(exceptions.OAuthError) as excinfo:\n        utils.handle_error_response(response_data)\n\n    assert excinfo.match(r\"Error code unsupported_grant_type\")\n\n\ndef test__handle_error_response_code_description():\n    error_resp = {\n        \"error\": \"unsupported_grant_type\",\n        \"error_description\": \"The provided grant_type is unsupported\",\n    }\n    response_data = json.dumps(error_resp)\n\n    with pytest.raises(exceptions.OAuthError) as excinfo:\n        utils.handle_error_response(response_data)\n\n    assert excinfo.match(\n        r\"Error code unsupported_grant_type: The provided grant_type is unsupported\"\n    )\n\n\ndef test__handle_error_response_code_description_uri():\n    error_resp = {\n        \"error\": \"unsupported_grant_type\",\n        \"error_description\": \"The provided grant_type is unsupported\",\n        \"error_uri\": \"https://tools.ietf.org/html/rfc6749\",\n    }\n    response_data = json.dumps(error_resp)\n\n    with pytest.raises(exceptions.OAuthError) as excinfo:\n        utils.handle_error_response(response_data)\n\n    assert excinfo.match(\n        r\"Error code unsupported_grant_type: The provided grant_type is unsupported - https://tools.ietf.org/html/rfc6749\"\n    )\n\n\ndef test__handle_error_response_non_json():\n    response_data = \"Oops, something wrong happened\"\n\n    with pytest.raises(exceptions.OAuthError) as excinfo:\n        utils.handle_error_response(response_data)\n\n    assert excinfo.match(r\"Oops, something wrong happened\")\n", "tests/compute_engine/test__metadata.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport datetime\nimport http.client as http_client\nimport importlib\nimport json\nimport os\n\nimport mock\nimport pytest  # type: ignore\n\nfrom google.auth import _helpers\nfrom google.auth import environment_vars\nfrom google.auth import exceptions\nfrom google.auth import transport\nfrom google.auth.compute_engine import _metadata\n\nPATH = \"instance/service-accounts/default\"\n\nDATA_DIR = os.path.join(os.path.dirname(__file__), \"data\")\nSMBIOS_PRODUCT_NAME_FILE = os.path.join(DATA_DIR, \"smbios_product_name\")\nSMBIOS_PRODUCT_NAME_NONEXISTENT_FILE = os.path.join(\n    DATA_DIR, \"smbios_product_name_nonexistent\"\n)\nSMBIOS_PRODUCT_NAME_NON_GOOGLE = os.path.join(\n    DATA_DIR, \"smbios_product_name_non_google\"\n)\n\nACCESS_TOKEN_REQUEST_METRICS_HEADER_VALUE = (\n    \"gl-python/3.7 auth/1.1 auth-request-type/at cred-type/mds\"\n)\nMDS_PING_METRICS_HEADER_VALUE = \"gl-python/3.7 auth/1.1 auth-request-type/mds\"\nMDS_PING_REQUEST_HEADER = {\n    \"metadata-flavor\": \"Google\",\n    \"x-goog-api-client\": MDS_PING_METRICS_HEADER_VALUE,\n}\n\n\ndef make_request(data, status=http_client.OK, headers=None, retry=False):\n    response = mock.create_autospec(transport.Response, instance=True)\n    response.status = status\n    response.data = _helpers.to_bytes(data)\n    response.headers = headers or {}\n\n    request = mock.create_autospec(transport.Request)\n    if retry:\n        request.side_effect = [exceptions.TransportError(), response]\n    else:\n        request.return_value = response\n\n    return request\n\n\ndef test_detect_gce_residency_linux_success():\n    _metadata._GCE_PRODUCT_NAME_FILE = SMBIOS_PRODUCT_NAME_FILE\n    assert _metadata.detect_gce_residency_linux()\n\n\ndef test_detect_gce_residency_linux_non_google():\n    _metadata._GCE_PRODUCT_NAME_FILE = SMBIOS_PRODUCT_NAME_NON_GOOGLE\n    assert not _metadata.detect_gce_residency_linux()\n\n\ndef test_detect_gce_residency_linux_nonexistent():\n    _metadata._GCE_PRODUCT_NAME_FILE = SMBIOS_PRODUCT_NAME_NONEXISTENT_FILE\n    assert not _metadata.detect_gce_residency_linux()\n\n\ndef test_is_on_gce_ping_success():\n    request = make_request(\"\", headers=_metadata._METADATA_HEADERS)\n    assert _metadata.is_on_gce(request)\n\n\n@mock.patch(\"os.name\", new=\"nt\")\ndef test_is_on_gce_windows_success():\n    request = make_request(\"\", headers={_metadata._METADATA_FLAVOR_HEADER: \"meep\"})\n    assert not _metadata.is_on_gce(request)\n\n\n@mock.patch(\"os.name\", new=\"posix\")\ndef test_is_on_gce_linux_success():\n    request = make_request(\"\", headers={_metadata._METADATA_FLAVOR_HEADER: \"meep\"})\n    _metadata._GCE_PRODUCT_NAME_FILE = SMBIOS_PRODUCT_NAME_FILE\n    assert _metadata.is_on_gce(request)\n\n\n@mock.patch(\"google.auth.metrics.mds_ping\", return_value=MDS_PING_METRICS_HEADER_VALUE)\ndef test_ping_success(mock_metrics_header_value):\n    request = make_request(\"\", headers=_metadata._METADATA_HEADERS)\n\n    assert _metadata.ping(request)\n\n    request.assert_called_once_with(\n        method=\"GET\",\n        url=_metadata._METADATA_IP_ROOT,\n        headers=MDS_PING_REQUEST_HEADER,\n        timeout=_metadata._METADATA_DEFAULT_TIMEOUT,\n    )\n\n\n@mock.patch(\"google.auth.metrics.mds_ping\", return_value=MDS_PING_METRICS_HEADER_VALUE)\ndef test_ping_success_retry(mock_metrics_header_value):\n    request = make_request(\"\", headers=_metadata._METADATA_HEADERS, retry=True)\n\n    assert _metadata.ping(request)\n\n    request.assert_called_with(\n        method=\"GET\",\n        url=_metadata._METADATA_IP_ROOT,\n        headers=MDS_PING_REQUEST_HEADER,\n        timeout=_metadata._METADATA_DEFAULT_TIMEOUT,\n    )\n    assert request.call_count == 2\n\n\ndef test_ping_failure_bad_flavor():\n    request = make_request(\"\", headers={_metadata._METADATA_FLAVOR_HEADER: \"meep\"})\n\n    assert not _metadata.ping(request)\n\n\ndef test_ping_failure_connection_failed():\n    request = make_request(\"\")\n    request.side_effect = exceptions.TransportError()\n\n    assert not _metadata.ping(request)\n\n\n@mock.patch(\"google.auth.metrics.mds_ping\", return_value=MDS_PING_METRICS_HEADER_VALUE)\ndef test_ping_success_custom_root(mock_metrics_header_value):\n    request = make_request(\"\", headers=_metadata._METADATA_HEADERS)\n\n    fake_ip = \"1.2.3.4\"\n    os.environ[environment_vars.GCE_METADATA_IP] = fake_ip\n    importlib.reload(_metadata)\n\n    try:\n        assert _metadata.ping(request)\n    finally:\n        del os.environ[environment_vars.GCE_METADATA_IP]\n        importlib.reload(_metadata)\n\n    request.assert_called_once_with(\n        method=\"GET\",\n        url=\"http://\" + fake_ip,\n        headers=MDS_PING_REQUEST_HEADER,\n        timeout=_metadata._METADATA_DEFAULT_TIMEOUT,\n    )\n\n\ndef test_get_success_json():\n    key, value = \"foo\", \"bar\"\n\n    data = json.dumps({key: value})\n    request = make_request(data, headers={\"content-type\": \"application/json\"})\n\n    result = _metadata.get(request, PATH)\n\n    request.assert_called_once_with(\n        method=\"GET\",\n        url=_metadata._METADATA_ROOT + PATH,\n        headers=_metadata._METADATA_HEADERS,\n    )\n    assert result[key] == value\n\n\ndef test_get_success_json_content_type_charset():\n    key, value = \"foo\", \"bar\"\n\n    data = json.dumps({key: value})\n    request = make_request(\n        data, headers={\"content-type\": \"application/json; charset=UTF-8\"}\n    )\n\n    result = _metadata.get(request, PATH)\n\n    request.assert_called_once_with(\n        method=\"GET\",\n        url=_metadata._METADATA_ROOT + PATH,\n        headers=_metadata._METADATA_HEADERS,\n    )\n    assert result[key] == value\n\n\ndef test_get_success_retry():\n    key, value = \"foo\", \"bar\"\n\n    data = json.dumps({key: value})\n    request = make_request(\n        data, headers={\"content-type\": \"application/json\"}, retry=True\n    )\n\n    result = _metadata.get(request, PATH)\n\n    request.assert_called_with(\n        method=\"GET\",\n        url=_metadata._METADATA_ROOT + PATH,\n        headers=_metadata._METADATA_HEADERS,\n    )\n    assert request.call_count == 2\n    assert result[key] == value\n\n\ndef test_get_success_text():\n    data = \"foobar\"\n    request = make_request(data, headers={\"content-type\": \"text/plain\"})\n\n    result = _metadata.get(request, PATH)\n\n    request.assert_called_once_with(\n        method=\"GET\",\n        url=_metadata._METADATA_ROOT + PATH,\n        headers=_metadata._METADATA_HEADERS,\n    )\n    assert result == data\n\n\ndef test_get_success_params():\n    data = \"foobar\"\n    request = make_request(data, headers={\"content-type\": \"text/plain\"})\n    params = {\"recursive\": \"true\"}\n\n    result = _metadata.get(request, PATH, params=params)\n\n    request.assert_called_once_with(\n        method=\"GET\",\n        url=_metadata._METADATA_ROOT + PATH + \"?recursive=true\",\n        headers=_metadata._METADATA_HEADERS,\n    )\n    assert result == data\n\n\ndef test_get_success_recursive_and_params():\n    data = \"foobar\"\n    request = make_request(data, headers={\"content-type\": \"text/plain\"})\n    params = {\"recursive\": \"false\"}\n    result = _metadata.get(request, PATH, recursive=True, params=params)\n\n    request.assert_called_once_with(\n        method=\"GET\",\n        url=_metadata._METADATA_ROOT + PATH + \"?recursive=true\",\n        headers=_metadata._METADATA_HEADERS,\n    )\n    assert result == data\n\n\ndef test_get_success_recursive():\n    data = \"foobar\"\n    request = make_request(data, headers={\"content-type\": \"text/plain\"})\n\n    result = _metadata.get(request, PATH, recursive=True)\n\n    request.assert_called_once_with(\n        method=\"GET\",\n        url=_metadata._METADATA_ROOT + PATH + \"?recursive=true\",\n        headers=_metadata._METADATA_HEADERS,\n    )\n    assert result == data\n\n\ndef test_get_success_custom_root_new_variable():\n    request = make_request(\"{}\", headers={\"content-type\": \"application/json\"})\n\n    fake_root = \"another.metadata.service\"\n    os.environ[environment_vars.GCE_METADATA_HOST] = fake_root\n    importlib.reload(_metadata)\n\n    try:\n        _metadata.get(request, PATH)\n    finally:\n        del os.environ[environment_vars.GCE_METADATA_HOST]\n        importlib.reload(_metadata)\n\n    request.assert_called_once_with(\n        method=\"GET\",\n        url=\"http://{}/computeMetadata/v1/{}\".format(fake_root, PATH),\n        headers=_metadata._METADATA_HEADERS,\n    )\n\n\ndef test_get_success_custom_root_old_variable():\n    request = make_request(\"{}\", headers={\"content-type\": \"application/json\"})\n\n    fake_root = \"another.metadata.service\"\n    os.environ[environment_vars.GCE_METADATA_ROOT] = fake_root\n    importlib.reload(_metadata)\n\n    try:\n        _metadata.get(request, PATH)\n    finally:\n        del os.environ[environment_vars.GCE_METADATA_ROOT]\n        importlib.reload(_metadata)\n\n    request.assert_called_once_with(\n        method=\"GET\",\n        url=\"http://{}/computeMetadata/v1/{}\".format(fake_root, PATH),\n        headers=_metadata._METADATA_HEADERS,\n    )\n\n\ndef test_get_failure():\n    request = make_request(\"Metadata error\", status=http_client.NOT_FOUND)\n\n    with pytest.raises(exceptions.TransportError) as excinfo:\n        _metadata.get(request, PATH)\n\n    assert excinfo.match(r\"Metadata error\")\n\n    request.assert_called_once_with(\n        method=\"GET\",\n        url=_metadata._METADATA_ROOT + PATH,\n        headers=_metadata._METADATA_HEADERS,\n    )\n\n\ndef test_get_return_none_for_not_found_error():\n    request = make_request(\"Metadata error\", status=http_client.NOT_FOUND)\n\n    assert _metadata.get(request, PATH, return_none_for_not_found_error=True) is None\n\n    request.assert_called_once_with(\n        method=\"GET\",\n        url=_metadata._METADATA_ROOT + PATH,\n        headers=_metadata._METADATA_HEADERS,\n    )\n\n\ndef test_get_failure_connection_failed():\n    request = make_request(\"\")\n    request.side_effect = exceptions.TransportError()\n\n    with pytest.raises(exceptions.TransportError) as excinfo:\n        _metadata.get(request, PATH)\n\n    assert excinfo.match(r\"Compute Engine Metadata server unavailable\")\n\n    request.assert_called_with(\n        method=\"GET\",\n        url=_metadata._METADATA_ROOT + PATH,\n        headers=_metadata._METADATA_HEADERS,\n    )\n    assert request.call_count == 5\n\n\ndef test_get_failure_bad_json():\n    request = make_request(\"{\", headers={\"content-type\": \"application/json\"})\n\n    with pytest.raises(exceptions.TransportError) as excinfo:\n        _metadata.get(request, PATH)\n\n    assert excinfo.match(r\"invalid JSON\")\n\n    request.assert_called_once_with(\n        method=\"GET\",\n        url=_metadata._METADATA_ROOT + PATH,\n        headers=_metadata._METADATA_HEADERS,\n    )\n\n\ndef test_get_project_id():\n    project = \"example-project\"\n    request = make_request(project, headers={\"content-type\": \"text/plain\"})\n\n    project_id = _metadata.get_project_id(request)\n\n    request.assert_called_once_with(\n        method=\"GET\",\n        url=_metadata._METADATA_ROOT + \"project/project-id\",\n        headers=_metadata._METADATA_HEADERS,\n    )\n    assert project_id == project\n\n\ndef test_get_universe_domain_success():\n    request = make_request(\n        \"fake_universe_domain\", headers={\"content-type\": \"text/plain\"}\n    )\n\n    universe_domain = _metadata.get_universe_domain(request)\n\n    request.assert_called_once_with(\n        method=\"GET\",\n        url=_metadata._METADATA_ROOT + \"universe/universe_domain\",\n        headers=_metadata._METADATA_HEADERS,\n    )\n    assert universe_domain == \"fake_universe_domain\"\n\n\ndef test_get_universe_domain_success_empty_response():\n    request = make_request(\"\", headers={\"content-type\": \"text/plain\"})\n\n    universe_domain = _metadata.get_universe_domain(request)\n\n    request.assert_called_once_with(\n        method=\"GET\",\n        url=_metadata._METADATA_ROOT + \"universe/universe_domain\",\n        headers=_metadata._METADATA_HEADERS,\n    )\n    assert universe_domain == \"googleapis.com\"\n\n\ndef test_get_universe_domain_not_found():\n    # Test that if the universe domain endpoint returns 404 error, we should\n    # use googleapis.com as the universe domain\n    request = make_request(\"not found\", status=http_client.NOT_FOUND)\n\n    universe_domain = _metadata.get_universe_domain(request)\n\n    request.assert_called_once_with(\n        method=\"GET\",\n        url=_metadata._METADATA_ROOT + \"universe/universe_domain\",\n        headers=_metadata._METADATA_HEADERS,\n    )\n    assert universe_domain == \"googleapis.com\"\n\n\ndef test_get_universe_domain_other_error():\n    # Test that if the universe domain endpoint returns an error other than 404\n    # we should throw the error\n    request = make_request(\"unauthorized\", status=http_client.UNAUTHORIZED)\n\n    with pytest.raises(exceptions.TransportError) as excinfo:\n        _metadata.get_universe_domain(request)\n\n    assert excinfo.match(r\"unauthorized\")\n\n    request.assert_called_once_with(\n        method=\"GET\",\n        url=_metadata._METADATA_ROOT + \"universe/universe_domain\",\n        headers=_metadata._METADATA_HEADERS,\n    )\n\n\n@mock.patch(\n    \"google.auth.metrics.token_request_access_token_mds\",\n    return_value=ACCESS_TOKEN_REQUEST_METRICS_HEADER_VALUE,\n)\n@mock.patch(\"google.auth._helpers.utcnow\", return_value=datetime.datetime.min)\ndef test_get_service_account_token(utcnow, mock_metrics_header_value):\n    ttl = 500\n    request = make_request(\n        json.dumps({\"access_token\": \"token\", \"expires_in\": ttl}),\n        headers={\"content-type\": \"application/json\"},\n    )\n\n    token, expiry = _metadata.get_service_account_token(request)\n\n    request.assert_called_once_with(\n        method=\"GET\",\n        url=_metadata._METADATA_ROOT + PATH + \"/token\",\n        headers={\n            \"metadata-flavor\": \"Google\",\n            \"x-goog-api-client\": ACCESS_TOKEN_REQUEST_METRICS_HEADER_VALUE,\n        },\n    )\n    assert token == \"token\"\n    assert expiry == utcnow() + datetime.timedelta(seconds=ttl)\n\n\n@mock.patch(\n    \"google.auth.metrics.token_request_access_token_mds\",\n    return_value=ACCESS_TOKEN_REQUEST_METRICS_HEADER_VALUE,\n)\n@mock.patch(\"google.auth._helpers.utcnow\", return_value=datetime.datetime.min)\ndef test_get_service_account_token_with_scopes_list(utcnow, mock_metrics_header_value):\n    ttl = 500\n    request = make_request(\n        json.dumps({\"access_token\": \"token\", \"expires_in\": ttl}),\n        headers={\"content-type\": \"application/json\"},\n    )\n\n    token, expiry = _metadata.get_service_account_token(request, scopes=[\"foo\", \"bar\"])\n\n    request.assert_called_once_with(\n        method=\"GET\",\n        url=_metadata._METADATA_ROOT + PATH + \"/token\" + \"?scopes=foo%2Cbar\",\n        headers={\n            \"metadata-flavor\": \"Google\",\n            \"x-goog-api-client\": ACCESS_TOKEN_REQUEST_METRICS_HEADER_VALUE,\n        },\n    )\n    assert token == \"token\"\n    assert expiry == utcnow() + datetime.timedelta(seconds=ttl)\n\n\n@mock.patch(\n    \"google.auth.metrics.token_request_access_token_mds\",\n    return_value=ACCESS_TOKEN_REQUEST_METRICS_HEADER_VALUE,\n)\n@mock.patch(\"google.auth._helpers.utcnow\", return_value=datetime.datetime.min)\ndef test_get_service_account_token_with_scopes_string(\n    utcnow, mock_metrics_header_value\n):\n    ttl = 500\n    request = make_request(\n        json.dumps({\"access_token\": \"token\", \"expires_in\": ttl}),\n        headers={\"content-type\": \"application/json\"},\n    )\n\n    token, expiry = _metadata.get_service_account_token(request, scopes=\"foo,bar\")\n\n    request.assert_called_once_with(\n        method=\"GET\",\n        url=_metadata._METADATA_ROOT + PATH + \"/token\" + \"?scopes=foo%2Cbar\",\n        headers={\n            \"metadata-flavor\": \"Google\",\n            \"x-goog-api-client\": ACCESS_TOKEN_REQUEST_METRICS_HEADER_VALUE,\n        },\n    )\n    assert token == \"token\"\n    assert expiry == utcnow() + datetime.timedelta(seconds=ttl)\n\n\ndef test_get_service_account_info():\n    key, value = \"foo\", \"bar\"\n    request = make_request(\n        json.dumps({key: value}), headers={\"content-type\": \"application/json\"}\n    )\n\n    info = _metadata.get_service_account_info(request)\n\n    request.assert_called_once_with(\n        method=\"GET\",\n        url=_metadata._METADATA_ROOT + PATH + \"/?recursive=true\",\n        headers=_metadata._METADATA_HEADERS,\n    )\n\n    assert info[key] == value\n", "tests/compute_engine/test_credentials.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport base64\nimport datetime\n\nimport mock\nimport pytest  # type: ignore\nimport responses  # type: ignore\n\nfrom google.auth import _helpers\nfrom google.auth import exceptions\nfrom google.auth import jwt\nfrom google.auth import transport\nfrom google.auth.compute_engine import credentials\nfrom google.auth.transport import requests\n\nSAMPLE_ID_TOKEN_EXP = 1584393400\n\n# header: {\"alg\": \"RS256\", \"typ\": \"JWT\", \"kid\": \"1\"}\n# payload: {\"iss\": \"issuer\", \"iat\": 1584393348, \"sub\": \"subject\",\n#   \"exp\": 1584393400,\"aud\": \"audience\"}\nSAMPLE_ID_TOKEN = (\n    b\"eyJhbGciOiAiUlMyNTYiLCAidHlwIjogIkpXVCIsICJraWQiOiAiMSJ9.\"\n    b\"eyJpc3MiOiAiaXNzdWVyIiwgImlhdCI6IDE1ODQzOTMzNDgsICJzdWIiO\"\n    b\"iAic3ViamVjdCIsICJleHAiOiAxNTg0MzkzNDAwLCAiYXVkIjogImF1ZG\"\n    b\"llbmNlIn0.\"\n    b\"OquNjHKhTmlgCk361omRo18F_uY-7y0f_AmLbzW062Q1Zr61HAwHYP5FM\"\n    b\"316CK4_0cH8MUNGASsvZc3VqXAqub6PUTfhemH8pFEwBdAdG0LhrNkU0H\"\n    b\"WN1YpT55IiQ31esLdL5q-qDsOPpNZJUti1y1lAreM5nIn2srdWzGXGs4i\"\n    b\"TRQsn0XkNUCL4RErpciXmjfhMrPkcAjKA-mXQm2fa4jmTlEZFqFmUlym1\"\n    b\"ozJ0yf5grjN6AslN4OGvAv1pS-_Ko_pGBS6IQtSBC6vVKCUuBfaqNjykg\"\n    b\"bsxbLa6Fp0SYeYwO8ifEnkRvasVpc1WTQqfRB2JCj5pTBDzJpIpFCMmnQ\"\n)\n\nACCESS_TOKEN_REQUEST_METRICS_HEADER_VALUE = (\n    \"gl-python/3.7 auth/1.1 auth-request-type/at cred-type/mds\"\n)\nID_TOKEN_REQUEST_METRICS_HEADER_VALUE = (\n    \"gl-python/3.7 auth/1.1 auth-request-type/it cred-type/mds\"\n)\n\nFAKE_SERVICE_ACCOUNT_EMAIL = \"foo@bar.com\"\nFAKE_QUOTA_PROJECT_ID = \"fake-quota-project\"\nFAKE_SCOPES = [\"scope1\", \"scope2\"]\nFAKE_DEFAULT_SCOPES = [\"scope3\", \"scope4\"]\nFAKE_UNIVERSE_DOMAIN = \"fake-universe-domain\"\n\n\nclass TestCredentials(object):\n    credentials = None\n    credentials_with_all_fields = None\n\n    @pytest.fixture(autouse=True)\n    def credentials_fixture(self):\n        self.credentials = credentials.Credentials()\n        self.credentials_with_all_fields = credentials.Credentials(\n            service_account_email=FAKE_SERVICE_ACCOUNT_EMAIL,\n            quota_project_id=FAKE_QUOTA_PROJECT_ID,\n            scopes=FAKE_SCOPES,\n            default_scopes=FAKE_DEFAULT_SCOPES,\n            universe_domain=FAKE_UNIVERSE_DOMAIN,\n        )\n\n    def test_default_state(self):\n        assert not self.credentials.valid\n        # Expiration hasn't been set yet\n        assert not self.credentials.expired\n        # Scopes are needed\n        assert self.credentials.requires_scopes\n        # Service account email hasn't been populated\n        assert self.credentials.service_account_email == \"default\"\n        # No quota project\n        assert not self.credentials._quota_project_id\n        # Universe domain is the default and not cached\n        assert self.credentials._universe_domain == \"googleapis.com\"\n        assert not self.credentials._universe_domain_cached\n\n    @mock.patch(\n        \"google.auth._helpers.utcnow\",\n        return_value=datetime.datetime.min + _helpers.REFRESH_THRESHOLD,\n    )\n    @mock.patch(\"google.auth.compute_engine._metadata.get\", autospec=True)\n    def test_refresh_success(self, get, utcnow):\n        get.side_effect = [\n            {\n                # First request is for sevice account info.\n                \"email\": \"service-account@example.com\",\n                \"scopes\": [\"one\", \"two\"],\n            },\n            {\n                # Second request is for the token.\n                \"access_token\": \"token\",\n                \"expires_in\": 500,\n            },\n        ]\n\n        # Refresh credentials\n        self.credentials.refresh(None)\n\n        # Check that the credentials have the token and proper expiration\n        assert self.credentials.token == \"token\"\n        assert self.credentials.expiry == (utcnow() + datetime.timedelta(seconds=500))\n\n        # Check the credential info\n        assert self.credentials.service_account_email == \"service-account@example.com\"\n        assert self.credentials._scopes == [\"one\", \"two\"]\n\n        # Check that the credentials are valid (have a token and are not\n        # expired)\n        assert self.credentials.valid\n\n    @mock.patch(\n        \"google.auth.metrics.token_request_access_token_mds\",\n        return_value=ACCESS_TOKEN_REQUEST_METRICS_HEADER_VALUE,\n    )\n    @mock.patch(\n        \"google.auth._helpers.utcnow\",\n        return_value=datetime.datetime.min + _helpers.REFRESH_THRESHOLD,\n    )\n    @mock.patch(\"google.auth.compute_engine._metadata.get\", autospec=True)\n    def test_refresh_success_with_scopes(self, get, utcnow, mock_metrics_header_value):\n        get.side_effect = [\n            {\n                # First request is for sevice account info.\n                \"email\": \"service-account@example.com\",\n                \"scopes\": [\"one\", \"two\"],\n            },\n            {\n                # Second request is for the token.\n                \"access_token\": \"token\",\n                \"expires_in\": 500,\n            },\n        ]\n\n        # Refresh credentials\n        scopes = [\"three\", \"four\"]\n        self.credentials = self.credentials.with_scopes(scopes)\n        self.credentials.refresh(None)\n\n        # Check that the credentials have the token and proper expiration\n        assert self.credentials.token == \"token\"\n        assert self.credentials.expiry == (utcnow() + datetime.timedelta(seconds=500))\n\n        # Check the credential info\n        assert self.credentials.service_account_email == \"service-account@example.com\"\n        assert self.credentials._scopes == scopes\n\n        # Check that the credentials are valid (have a token and are not\n        # expired)\n        assert self.credentials.valid\n\n        kwargs = get.call_args[1]\n        assert kwargs[\"params\"] == {\"scopes\": \"three,four\"}\n        assert kwargs[\"headers\"] == {\n            \"x-goog-api-client\": ACCESS_TOKEN_REQUEST_METRICS_HEADER_VALUE\n        }\n\n    @mock.patch(\"google.auth.compute_engine._metadata.get\", autospec=True)\n    def test_refresh_error(self, get):\n        get.side_effect = exceptions.TransportError(\"http error\")\n\n        with pytest.raises(exceptions.RefreshError) as excinfo:\n            self.credentials.refresh(None)\n\n        assert excinfo.match(r\"http error\")\n\n    @mock.patch(\"google.auth.compute_engine._metadata.get\", autospec=True)\n    def test_before_request_refreshes(self, get):\n        get.side_effect = [\n            {\n                # First request is for sevice account info.\n                \"email\": \"service-account@example.com\",\n                \"scopes\": \"one two\",\n            },\n            {\n                # Second request is for the token.\n                \"access_token\": \"token\",\n                \"expires_in\": 500,\n            },\n        ]\n\n        # Credentials should start as invalid\n        assert not self.credentials.valid\n\n        # before_request should cause a refresh\n        request = mock.create_autospec(transport.Request, instance=True)\n        self.credentials.before_request(request, \"GET\", \"http://example.com?a=1#3\", {})\n\n        # The refresh endpoint should've been called.\n        assert get.called\n\n        # Credentials should now be valid.\n        assert self.credentials.valid\n\n    def test_with_quota_project(self):\n        creds = self.credentials_with_all_fields.with_quota_project(\"project-foo\")\n\n        assert creds._quota_project_id == \"project-foo\"\n        assert creds._service_account_email == FAKE_SERVICE_ACCOUNT_EMAIL\n        assert creds._scopes == FAKE_SCOPES\n        assert creds._default_scopes == FAKE_DEFAULT_SCOPES\n        assert creds.universe_domain == FAKE_UNIVERSE_DOMAIN\n        assert creds._universe_domain_cached\n\n    def test_with_scopes(self):\n        scopes = [\"one\", \"two\"]\n        creds = self.credentials_with_all_fields.with_scopes(scopes)\n\n        assert creds._scopes == scopes\n        assert creds._quota_project_id == FAKE_QUOTA_PROJECT_ID\n        assert creds._service_account_email == FAKE_SERVICE_ACCOUNT_EMAIL\n        assert creds._default_scopes is None\n        assert creds.universe_domain == FAKE_UNIVERSE_DOMAIN\n        assert creds._universe_domain_cached\n\n    def test_with_universe_domain(self):\n        creds = self.credentials_with_all_fields.with_universe_domain(\"universe_domain\")\n\n        assert creds._scopes == FAKE_SCOPES\n        assert creds._quota_project_id == FAKE_QUOTA_PROJECT_ID\n        assert creds._service_account_email == FAKE_SERVICE_ACCOUNT_EMAIL\n        assert creds._default_scopes == FAKE_DEFAULT_SCOPES\n        assert creds.universe_domain == \"universe_domain\"\n        assert creds._universe_domain_cached\n\n    def test_token_usage_metrics(self):\n        self.credentials.token = \"token\"\n        self.credentials.expiry = None\n\n        headers = {}\n        self.credentials.before_request(mock.Mock(), None, None, headers)\n        assert headers[\"authorization\"] == \"Bearer token\"\n        assert headers[\"x-goog-api-client\"] == \"cred-type/mds\"\n\n    @mock.patch(\n        \"google.auth.compute_engine._metadata.get_universe_domain\",\n        return_value=\"fake_universe_domain\",\n    )\n    def test_universe_domain(self, get_universe_domain):\n        # Check the default state\n        assert not self.credentials._universe_domain_cached\n        assert self.credentials._universe_domain == \"googleapis.com\"\n\n        # calling the universe_domain property should trigger a call to\n        # get_universe_domain to fetch the value. The value should be cached.\n        assert self.credentials.universe_domain == \"fake_universe_domain\"\n        assert self.credentials._universe_domain == \"fake_universe_domain\"\n        assert self.credentials._universe_domain_cached\n        get_universe_domain.assert_called_once()\n\n        # calling the universe_domain property the second time should use the\n        # cached value instead of calling get_universe_domain\n        assert self.credentials.universe_domain == \"fake_universe_domain\"\n        get_universe_domain.assert_called_once()\n\n    @mock.patch(\"google.auth.compute_engine._metadata.get_universe_domain\")\n    def test_user_provided_universe_domain(self, get_universe_domain):\n        assert self.credentials_with_all_fields.universe_domain == FAKE_UNIVERSE_DOMAIN\n        assert self.credentials_with_all_fields._universe_domain_cached\n\n        # Since user provided universe_domain, we will not call the universe\n        # domain endpoint.\n        get_universe_domain.assert_not_called()\n\n\nclass TestIDTokenCredentials(object):\n    credentials = None\n\n    @mock.patch(\"google.auth.compute_engine._metadata.get\", autospec=True)\n    def test_default_state(self, get):\n        get.side_effect = [\n            {\"email\": \"service-account@example.com\", \"scope\": [\"one\", \"two\"]}\n        ]\n\n        request = mock.create_autospec(transport.Request, instance=True)\n        self.credentials = credentials.IDTokenCredentials(\n            request=request, target_audience=\"https://example.com\"\n        )\n\n        assert not self.credentials.valid\n        # Expiration hasn't been set yet\n        assert not self.credentials.expired\n        # Service account email hasn't been populated\n        assert self.credentials.service_account_email == \"service-account@example.com\"\n        # Signer is initialized\n        assert self.credentials.signer\n        assert self.credentials.signer_email == \"service-account@example.com\"\n        # No quota project\n        assert not self.credentials._quota_project_id\n\n    @mock.patch(\n        \"google.auth._helpers.utcnow\",\n        return_value=datetime.datetime.utcfromtimestamp(0),\n    )\n    @mock.patch(\"google.auth.compute_engine._metadata.get\", autospec=True)\n    @mock.patch(\"google.auth.iam.Signer.sign\", autospec=True)\n    def test_make_authorization_grant_assertion(self, sign, get, utcnow):\n        get.side_effect = [\n            {\"email\": \"service-account@example.com\", \"scopes\": [\"one\", \"two\"]}\n        ]\n        sign.side_effect = [b\"signature\"]\n\n        request = mock.create_autospec(transport.Request, instance=True)\n        self.credentials = credentials.IDTokenCredentials(\n            request=request, target_audience=\"https://audience.com\"\n        )\n\n        # Generate authorization grant:\n        token = self.credentials._make_authorization_grant_assertion()\n        payload = jwt.decode(token, verify=False)\n\n        # The JWT token signature is 'signature' encoded in base 64:\n        assert token.endswith(b\".c2lnbmF0dXJl\")\n\n        # Check that the credentials have the token and proper expiration\n        assert payload == {\n            \"aud\": \"https://www.googleapis.com/oauth2/v4/token\",\n            \"exp\": 3600,\n            \"iat\": 0,\n            \"iss\": \"service-account@example.com\",\n            \"target_audience\": \"https://audience.com\",\n        }\n\n    @mock.patch(\n        \"google.auth._helpers.utcnow\",\n        return_value=datetime.datetime.utcfromtimestamp(0),\n    )\n    @mock.patch(\"google.auth.compute_engine._metadata.get\", autospec=True)\n    @mock.patch(\"google.auth.iam.Signer.sign\", autospec=True)\n    def test_with_service_account(self, sign, get, utcnow):\n        sign.side_effect = [b\"signature\"]\n\n        request = mock.create_autospec(transport.Request, instance=True)\n        self.credentials = credentials.IDTokenCredentials(\n            request=request,\n            target_audience=\"https://audience.com\",\n            service_account_email=\"service-account@other.com\",\n        )\n\n        # Generate authorization grant:\n        token = self.credentials._make_authorization_grant_assertion()\n        payload = jwt.decode(token, verify=False)\n\n        # The JWT token signature is 'signature' encoded in base 64:\n        assert token.endswith(b\".c2lnbmF0dXJl\")\n\n        # Check that the credentials have the token and proper expiration\n        assert payload == {\n            \"aud\": \"https://www.googleapis.com/oauth2/v4/token\",\n            \"exp\": 3600,\n            \"iat\": 0,\n            \"iss\": \"service-account@other.com\",\n            \"target_audience\": \"https://audience.com\",\n        }\n\n    @mock.patch(\n        \"google.auth._helpers.utcnow\",\n        return_value=datetime.datetime.utcfromtimestamp(0),\n    )\n    @mock.patch(\"google.auth.compute_engine._metadata.get\", autospec=True)\n    @mock.patch(\"google.auth.iam.Signer.sign\", autospec=True)\n    def test_additional_claims(self, sign, get, utcnow):\n        get.side_effect = [\n            {\"email\": \"service-account@example.com\", \"scopes\": [\"one\", \"two\"]}\n        ]\n        sign.side_effect = [b\"signature\"]\n\n        request = mock.create_autospec(transport.Request, instance=True)\n        self.credentials = credentials.IDTokenCredentials(\n            request=request,\n            target_audience=\"https://audience.com\",\n            additional_claims={\"foo\": \"bar\"},\n        )\n\n        # Generate authorization grant:\n        token = self.credentials._make_authorization_grant_assertion()\n        payload = jwt.decode(token, verify=False)\n\n        # The JWT token signature is 'signature' encoded in base 64:\n        assert token.endswith(b\".c2lnbmF0dXJl\")\n\n        # Check that the credentials have the token and proper expiration\n        assert payload == {\n            \"aud\": \"https://www.googleapis.com/oauth2/v4/token\",\n            \"exp\": 3600,\n            \"iat\": 0,\n            \"iss\": \"service-account@example.com\",\n            \"target_audience\": \"https://audience.com\",\n            \"foo\": \"bar\",\n        }\n\n    def test_token_uri(self):\n        request = mock.create_autospec(transport.Request, instance=True)\n\n        self.credentials = credentials.IDTokenCredentials(\n            request=request,\n            signer=mock.Mock(),\n            service_account_email=\"foo@example.com\",\n            target_audience=\"https://audience.com\",\n        )\n        assert self.credentials._token_uri == credentials._DEFAULT_TOKEN_URI\n\n        self.credentials = credentials.IDTokenCredentials(\n            request=request,\n            signer=mock.Mock(),\n            service_account_email=\"foo@example.com\",\n            target_audience=\"https://audience.com\",\n            token_uri=\"https://example.com/token\",\n        )\n        assert self.credentials._token_uri == \"https://example.com/token\"\n\n    @mock.patch(\n        \"google.auth._helpers.utcnow\",\n        return_value=datetime.datetime.utcfromtimestamp(0),\n    )\n    @mock.patch(\"google.auth.compute_engine._metadata.get\", autospec=True)\n    @mock.patch(\"google.auth.iam.Signer.sign\", autospec=True)\n    def test_with_target_audience(self, sign, get, utcnow):\n        get.side_effect = [\n            {\"email\": \"service-account@example.com\", \"scopes\": [\"one\", \"two\"]}\n        ]\n        sign.side_effect = [b\"signature\"]\n\n        request = mock.create_autospec(transport.Request, instance=True)\n        self.credentials = credentials.IDTokenCredentials(\n            request=request, target_audience=\"https://audience.com\"\n        )\n        self.credentials = self.credentials.with_target_audience(\"https://actually.not\")\n\n        # Generate authorization grant:\n        token = self.credentials._make_authorization_grant_assertion()\n        payload = jwt.decode(token, verify=False)\n\n        # The JWT token signature is 'signature' encoded in base 64:\n        assert token.endswith(b\".c2lnbmF0dXJl\")\n\n        # Check that the credentials have the token and proper expiration\n        assert payload == {\n            \"aud\": \"https://www.googleapis.com/oauth2/v4/token\",\n            \"exp\": 3600,\n            \"iat\": 0,\n            \"iss\": \"service-account@example.com\",\n            \"target_audience\": \"https://actually.not\",\n        }\n\n        # Check that the signer have been initialized with a Request object\n        assert isinstance(self.credentials._signer._request, transport.Request)\n\n    @responses.activate\n    def test_with_target_audience_integration(self):\n        \"\"\" Test that it is possible to refresh credentials\n        generated from `with_target_audience`.\n\n        Instead of mocking the methods, the HTTP responses\n        have been mocked.\n        \"\"\"\n\n        # mock information about credentials\n        responses.add(\n            responses.GET,\n            \"http://metadata.google.internal/computeMetadata/v1/instance/\"\n            \"service-accounts/default/?recursive=true\",\n            status=200,\n            content_type=\"application/json\",\n            json={\n                \"scopes\": \"email\",\n                \"email\": \"service-account@example.com\",\n                \"aliases\": [\"default\"],\n            },\n        )\n\n        # mock token for credentials\n        responses.add(\n            responses.GET,\n            \"http://metadata.google.internal/computeMetadata/v1/instance/\"\n            \"service-accounts/service-account@example.com/token\",\n            status=200,\n            content_type=\"application/json\",\n            json={\n                \"access_token\": \"some-token\",\n                \"expires_in\": 3210,\n                \"token_type\": \"Bearer\",\n            },\n        )\n\n        # mock sign blob endpoint\n        signature = base64.b64encode(b\"some-signature\").decode(\"utf-8\")\n        responses.add(\n            responses.POST,\n            \"https://iamcredentials.googleapis.com/v1/projects/-/\"\n            \"serviceAccounts/service-account@example.com:signBlob\",\n            status=200,\n            content_type=\"application/json\",\n            json={\"keyId\": \"some-key-id\", \"signedBlob\": signature},\n        )\n\n        id_token = \"{}.{}.{}\".format(\n            base64.b64encode(b'{\"some\":\"some\"}').decode(\"utf-8\"),\n            base64.b64encode(b'{\"exp\": 3210}').decode(\"utf-8\"),\n            base64.b64encode(b\"token\").decode(\"utf-8\"),\n        )\n\n        # mock id token endpoint\n        responses.add(\n            responses.POST,\n            \"https://www.googleapis.com/oauth2/v4/token\",\n            status=200,\n            content_type=\"application/json\",\n            json={\"id_token\": id_token, \"expiry\": 3210},\n        )\n\n        self.credentials = credentials.IDTokenCredentials(\n            request=requests.Request(),\n            service_account_email=\"service-account@example.com\",\n            target_audience=\"https://audience.com\",\n        )\n\n        self.credentials = self.credentials.with_target_audience(\"https://actually.not\")\n\n        self.credentials.refresh(requests.Request())\n\n        assert self.credentials.token is not None\n\n    @mock.patch(\n        \"google.auth._helpers.utcnow\",\n        return_value=datetime.datetime.utcfromtimestamp(0),\n    )\n    @mock.patch(\"google.auth.compute_engine._metadata.get\", autospec=True)\n    @mock.patch(\"google.auth.iam.Signer.sign\", autospec=True)\n    def test_with_quota_project(self, sign, get, utcnow):\n        get.side_effect = [\n            {\"email\": \"service-account@example.com\", \"scopes\": [\"one\", \"two\"]}\n        ]\n        sign.side_effect = [b\"signature\"]\n\n        request = mock.create_autospec(transport.Request, instance=True)\n        self.credentials = credentials.IDTokenCredentials(\n            request=request, target_audience=\"https://audience.com\"\n        )\n        self.credentials = self.credentials.with_quota_project(\"project-foo\")\n\n        assert self.credentials._quota_project_id == \"project-foo\"\n\n        # Generate authorization grant:\n        token = self.credentials._make_authorization_grant_assertion()\n        payload = jwt.decode(token, verify=False)\n\n        # The JWT token signature is 'signature' encoded in base 64:\n        assert token.endswith(b\".c2lnbmF0dXJl\")\n\n        # Check that the credentials have the token and proper expiration\n        assert payload == {\n            \"aud\": \"https://www.googleapis.com/oauth2/v4/token\",\n            \"exp\": 3600,\n            \"iat\": 0,\n            \"iss\": \"service-account@example.com\",\n            \"target_audience\": \"https://audience.com\",\n        }\n\n        # Check that the signer have been initialized with a Request object\n        assert isinstance(self.credentials._signer._request, transport.Request)\n\n    @mock.patch(\n        \"google.auth._helpers.utcnow\",\n        return_value=datetime.datetime.utcfromtimestamp(0),\n    )\n    @mock.patch(\"google.auth.compute_engine._metadata.get\", autospec=True)\n    @mock.patch(\"google.auth.iam.Signer.sign\", autospec=True)\n    def test_with_token_uri(self, sign, get, utcnow):\n        get.side_effect = [\n            {\"email\": \"service-account@example.com\", \"scopes\": [\"one\", \"two\"]}\n        ]\n        sign.side_effect = [b\"signature\"]\n\n        request = mock.create_autospec(transport.Request, instance=True)\n        self.credentials = credentials.IDTokenCredentials(\n            request=request,\n            target_audience=\"https://audience.com\",\n            token_uri=\"http://xyz.com\",\n        )\n        assert self.credentials._token_uri == \"http://xyz.com\"\n        creds_with_token_uri = self.credentials.with_token_uri(\"http://example.com\")\n        assert creds_with_token_uri._token_uri == \"http://example.com\"\n\n    @mock.patch(\n        \"google.auth._helpers.utcnow\",\n        return_value=datetime.datetime.utcfromtimestamp(0),\n    )\n    @mock.patch(\"google.auth.compute_engine._metadata.get\", autospec=True)\n    @mock.patch(\"google.auth.iam.Signer.sign\", autospec=True)\n    def test_with_token_uri_exception(self, sign, get, utcnow):\n        get.side_effect = [\n            {\"email\": \"service-account@example.com\", \"scopes\": [\"one\", \"two\"]}\n        ]\n        sign.side_effect = [b\"signature\"]\n\n        request = mock.create_autospec(transport.Request, instance=True)\n        self.credentials = credentials.IDTokenCredentials(\n            request=request,\n            target_audience=\"https://audience.com\",\n            use_metadata_identity_endpoint=True,\n        )\n        assert self.credentials._token_uri is None\n        with pytest.raises(ValueError):\n            self.credentials.with_token_uri(\"http://example.com\")\n\n    @responses.activate\n    def test_with_quota_project_integration(self):\n        \"\"\" Test that it is possible to refresh credentials\n        generated from `with_quota_project`.\n\n        Instead of mocking the methods, the HTTP responses\n        have been mocked.\n        \"\"\"\n\n        # mock information about credentials\n        responses.add(\n            responses.GET,\n            \"http://metadata.google.internal/computeMetadata/v1/instance/\"\n            \"service-accounts/default/?recursive=true\",\n            status=200,\n            content_type=\"application/json\",\n            json={\n                \"scopes\": \"email\",\n                \"email\": \"service-account@example.com\",\n                \"aliases\": [\"default\"],\n            },\n        )\n\n        # mock token for credentials\n        responses.add(\n            responses.GET,\n            \"http://metadata.google.internal/computeMetadata/v1/instance/\"\n            \"service-accounts/service-account@example.com/token\",\n            status=200,\n            content_type=\"application/json\",\n            json={\n                \"access_token\": \"some-token\",\n                \"expires_in\": 3210,\n                \"token_type\": \"Bearer\",\n            },\n        )\n\n        # mock sign blob endpoint\n        signature = base64.b64encode(b\"some-signature\").decode(\"utf-8\")\n        responses.add(\n            responses.POST,\n            \"https://iamcredentials.googleapis.com/v1/projects/-/\"\n            \"serviceAccounts/service-account@example.com:signBlob\",\n            status=200,\n            content_type=\"application/json\",\n            json={\"keyId\": \"some-key-id\", \"signedBlob\": signature},\n        )\n\n        id_token = \"{}.{}.{}\".format(\n            base64.b64encode(b'{\"some\":\"some\"}').decode(\"utf-8\"),\n            base64.b64encode(b'{\"exp\": 3210}').decode(\"utf-8\"),\n            base64.b64encode(b\"token\").decode(\"utf-8\"),\n        )\n\n        # mock id token endpoint\n        responses.add(\n            responses.POST,\n            \"https://www.googleapis.com/oauth2/v4/token\",\n            status=200,\n            content_type=\"application/json\",\n            json={\"id_token\": id_token, \"expiry\": 3210},\n        )\n\n        self.credentials = credentials.IDTokenCredentials(\n            request=requests.Request(),\n            service_account_email=\"service-account@example.com\",\n            target_audience=\"https://audience.com\",\n        )\n\n        self.credentials = self.credentials.with_quota_project(\"project-foo\")\n\n        self.credentials.refresh(requests.Request())\n\n        assert self.credentials.token is not None\n        assert self.credentials._quota_project_id == \"project-foo\"\n\n    @mock.patch(\n        \"google.auth._helpers.utcnow\",\n        return_value=datetime.datetime.utcfromtimestamp(0),\n    )\n    @mock.patch(\"google.auth.compute_engine._metadata.get\", autospec=True)\n    @mock.patch(\"google.auth.iam.Signer.sign\", autospec=True)\n    @mock.patch(\"google.oauth2._client.id_token_jwt_grant\", autospec=True)\n    def test_refresh_success(self, id_token_jwt_grant, sign, get, utcnow):\n        get.side_effect = [\n            {\"email\": \"service-account@example.com\", \"scopes\": [\"one\", \"two\"]}\n        ]\n        sign.side_effect = [b\"signature\"]\n        id_token_jwt_grant.side_effect = [\n            (\"idtoken\", datetime.datetime.utcfromtimestamp(3600), {})\n        ]\n\n        request = mock.create_autospec(transport.Request, instance=True)\n        self.credentials = credentials.IDTokenCredentials(\n            request=request, target_audience=\"https://audience.com\"\n        )\n\n        # Refresh credentials\n        self.credentials.refresh(None)\n\n        # Check that the credentials have the token and proper expiration\n        assert self.credentials.token == \"idtoken\"\n        assert self.credentials.expiry == (datetime.datetime.utcfromtimestamp(3600))\n\n        # Check the credential info\n        assert self.credentials.service_account_email == \"service-account@example.com\"\n\n        # Check that the credentials are valid (have a token and are not\n        # expired)\n        assert self.credentials.valid\n\n    @mock.patch(\n        \"google.auth._helpers.utcnow\",\n        return_value=datetime.datetime.utcfromtimestamp(0),\n    )\n    @mock.patch(\"google.auth.compute_engine._metadata.get\", autospec=True)\n    @mock.patch(\"google.auth.iam.Signer.sign\", autospec=True)\n    def test_refresh_error(self, sign, get, utcnow):\n        get.side_effect = [\n            {\"email\": \"service-account@example.com\", \"scopes\": [\"one\", \"two\"]}\n        ]\n        sign.side_effect = [b\"signature\"]\n\n        request = mock.create_autospec(transport.Request, instance=True)\n        response = mock.Mock()\n        response.data = b'{\"error\": \"http error\"}'\n        response.status = 404  # Throw a 404 so the request is not retried.\n        request.side_effect = [response]\n\n        self.credentials = credentials.IDTokenCredentials(\n            request=request, target_audience=\"https://audience.com\"\n        )\n\n        with pytest.raises(exceptions.RefreshError) as excinfo:\n            self.credentials.refresh(request)\n\n        assert excinfo.match(r\"http error\")\n\n    @mock.patch(\n        \"google.auth._helpers.utcnow\",\n        return_value=datetime.datetime.utcfromtimestamp(0),\n    )\n    @mock.patch(\"google.auth.compute_engine._metadata.get\", autospec=True)\n    @mock.patch(\"google.auth.iam.Signer.sign\", autospec=True)\n    @mock.patch(\"google.oauth2._client.id_token_jwt_grant\", autospec=True)\n    def test_before_request_refreshes(self, id_token_jwt_grant, sign, get, utcnow):\n        get.side_effect = [\n            {\"email\": \"service-account@example.com\", \"scopes\": \"one two\"}\n        ]\n        sign.side_effect = [b\"signature\"]\n        id_token_jwt_grant.side_effect = [\n            (\"idtoken\", datetime.datetime.utcfromtimestamp(3600), {})\n        ]\n\n        request = mock.create_autospec(transport.Request, instance=True)\n        self.credentials = credentials.IDTokenCredentials(\n            request=request, target_audience=\"https://audience.com\"\n        )\n\n        # Credentials should start as invalid\n        assert not self.credentials.valid\n\n        # before_request should cause a refresh\n        request = mock.create_autospec(transport.Request, instance=True)\n        self.credentials.before_request(request, \"GET\", \"http://example.com?a=1#3\", {})\n\n        # The refresh endpoint should've been called.\n        assert get.called\n\n        # Credentials should now be valid.\n        assert self.credentials.valid\n\n    @mock.patch(\"google.auth.compute_engine._metadata.get\", autospec=True)\n    @mock.patch(\"google.auth.iam.Signer.sign\", autospec=True)\n    def test_sign_bytes(self, sign, get):\n        get.side_effect = [\n            {\"email\": \"service-account@example.com\", \"scopes\": [\"one\", \"two\"]}\n        ]\n        sign.side_effect = [b\"signature\"]\n\n        request = mock.create_autospec(transport.Request, instance=True)\n        response = mock.Mock()\n        response.data = b'{\"signature\": \"c2lnbmF0dXJl\"}'\n        response.status = 200\n        request.side_effect = [response]\n\n        self.credentials = credentials.IDTokenCredentials(\n            request=request, target_audience=\"https://audience.com\"\n        )\n\n        # Generate authorization grant:\n        signature = self.credentials.sign_bytes(b\"some bytes\")\n\n        # The JWT token signature is 'signature' encoded in base 64:\n        assert signature == b\"signature\"\n\n    @mock.patch(\n        \"google.auth.metrics.token_request_id_token_mds\",\n        return_value=ID_TOKEN_REQUEST_METRICS_HEADER_VALUE,\n    )\n    @mock.patch(\n        \"google.auth.compute_engine._metadata.get_service_account_info\", autospec=True\n    )\n    @mock.patch(\"google.auth.compute_engine._metadata.get\", autospec=True)\n    def test_get_id_token_from_metadata(\n        self, get, get_service_account_info, mock_metrics_header_value\n    ):\n        get.return_value = SAMPLE_ID_TOKEN\n        get_service_account_info.return_value = {\"email\": \"foo@example.com\"}\n\n        cred = credentials.IDTokenCredentials(\n            mock.Mock(), \"audience\", use_metadata_identity_endpoint=True\n        )\n        cred.refresh(request=mock.Mock())\n\n        assert get.call_args.kwargs[\"headers\"] == {\n            \"x-goog-api-client\": ID_TOKEN_REQUEST_METRICS_HEADER_VALUE\n        }\n\n        assert cred.token == SAMPLE_ID_TOKEN\n        assert cred.expiry == datetime.datetime.utcfromtimestamp(SAMPLE_ID_TOKEN_EXP)\n        assert cred._use_metadata_identity_endpoint\n        assert cred._signer is None\n        assert cred._token_uri is None\n        assert cred._service_account_email == \"foo@example.com\"\n        assert cred._target_audience == \"audience\"\n        with pytest.raises(ValueError):\n            cred.sign_bytes(b\"bytes\")\n\n    @mock.patch(\n        \"google.auth.compute_engine._metadata.get_service_account_info\", autospec=True\n    )\n    def test_with_target_audience_for_metadata(self, get_service_account_info):\n        get_service_account_info.return_value = {\"email\": \"foo@example.com\"}\n\n        cred = credentials.IDTokenCredentials(\n            mock.Mock(), \"audience\", use_metadata_identity_endpoint=True\n        )\n        cred = cred.with_target_audience(\"new_audience\")\n\n        assert cred._target_audience == \"new_audience\"\n        assert cred._use_metadata_identity_endpoint\n        assert cred._signer is None\n        assert cred._token_uri is None\n        assert cred._service_account_email == \"foo@example.com\"\n\n    @mock.patch(\n        \"google.auth.compute_engine._metadata.get_service_account_info\", autospec=True\n    )\n    def test_id_token_with_quota_project(self, get_service_account_info):\n        get_service_account_info.return_value = {\"email\": \"foo@example.com\"}\n\n        cred = credentials.IDTokenCredentials(\n            mock.Mock(), \"audience\", use_metadata_identity_endpoint=True\n        )\n        cred = cred.with_quota_project(\"project-foo\")\n\n        assert cred._quota_project_id == \"project-foo\"\n        assert cred._use_metadata_identity_endpoint\n        assert cred._signer is None\n        assert cred._token_uri is None\n        assert cred._service_account_email == \"foo@example.com\"\n\n    @mock.patch(\n        \"google.auth.compute_engine._metadata.get_service_account_info\", autospec=True\n    )\n    @mock.patch(\"google.auth.compute_engine._metadata.get\", autospec=True)\n    def test_invalid_id_token_from_metadata(self, get, get_service_account_info):\n        get.return_value = \"invalid_id_token\"\n        get_service_account_info.return_value = {\"email\": \"foo@example.com\"}\n\n        cred = credentials.IDTokenCredentials(\n            mock.Mock(), \"audience\", use_metadata_identity_endpoint=True\n        )\n\n        with pytest.raises(ValueError):\n            cred.refresh(request=mock.Mock())\n\n    @mock.patch(\n        \"google.auth.compute_engine._metadata.get_service_account_info\", autospec=True\n    )\n    @mock.patch(\"google.auth.compute_engine._metadata.get\", autospec=True)\n    def test_transport_error_from_metadata(self, get, get_service_account_info):\n        get.side_effect = exceptions.TransportError(\"transport error\")\n        get_service_account_info.return_value = {\"email\": \"foo@example.com\"}\n\n        cred = credentials.IDTokenCredentials(\n            mock.Mock(), \"audience\", use_metadata_identity_endpoint=True\n        )\n\n        with pytest.raises(exceptions.RefreshError) as excinfo:\n            cred.refresh(request=mock.Mock())\n        assert excinfo.match(r\"transport error\")\n\n    def test_get_id_token_from_metadata_constructor(self):\n        with pytest.raises(ValueError):\n            credentials.IDTokenCredentials(\n                mock.Mock(),\n                \"audience\",\n                use_metadata_identity_endpoint=True,\n                token_uri=\"token_uri\",\n            )\n        with pytest.raises(ValueError):\n            credentials.IDTokenCredentials(\n                mock.Mock(),\n                \"audience\",\n                use_metadata_identity_endpoint=True,\n                signer=mock.Mock(),\n            )\n        with pytest.raises(ValueError):\n            credentials.IDTokenCredentials(\n                mock.Mock(),\n                \"audience\",\n                use_metadata_identity_endpoint=True,\n                additional_claims={\"key\", \"value\"},\n            )\n        with pytest.raises(ValueError):\n            credentials.IDTokenCredentials(\n                mock.Mock(),\n                \"audience\",\n                use_metadata_identity_endpoint=True,\n                service_account_email=\"foo@example.com\",\n            )\n", "tests/compute_engine/__init__.py": "", "tests/crypt/test_es256.py": "# Copyright 2016 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport base64\nimport json\nimport os\nimport pickle\n\nfrom cryptography.hazmat.primitives.asymmetric import ec\nimport pytest  # type: ignore\n\nfrom google.auth import _helpers\nfrom google.auth.crypt import base\nfrom google.auth.crypt import es256\n\n\nDATA_DIR = os.path.join(os.path.dirname(__file__), \"..\", \"data\")\n\n# To generate es256_privatekey.pem, es256_privatekey.pub, and\n# es256_public_cert.pem:\n#   $ openssl ecparam -genkey -name prime256v1 -noout -out es256_privatekey.pem\n#   $ openssl ec -in es256-private-key.pem -pubout -out es256-publickey.pem\n#   $ openssl req -new -x509 -key es256_privatekey.pem -out \\\n#   >     es256_public_cert.pem\n\nwith open(os.path.join(DATA_DIR, \"es256_privatekey.pem\"), \"rb\") as fh:\n    PRIVATE_KEY_BYTES = fh.read()\n    PKCS1_KEY_BYTES = PRIVATE_KEY_BYTES\n\nwith open(os.path.join(DATA_DIR, \"es256_publickey.pem\"), \"rb\") as fh:\n    PUBLIC_KEY_BYTES = fh.read()\n\nwith open(os.path.join(DATA_DIR, \"es256_public_cert.pem\"), \"rb\") as fh:\n    PUBLIC_CERT_BYTES = fh.read()\n\nSERVICE_ACCOUNT_JSON_FILE = os.path.join(DATA_DIR, \"es256_service_account.json\")\n\nwith open(SERVICE_ACCOUNT_JSON_FILE, \"rb\") as fh:\n    SERVICE_ACCOUNT_INFO = json.load(fh)\n\n\nclass TestES256Verifier(object):\n    def test_verify_success(self):\n        to_sign = b\"foo\"\n        signer = es256.ES256Signer.from_string(PRIVATE_KEY_BYTES)\n        actual_signature = signer.sign(to_sign)\n\n        verifier = es256.ES256Verifier.from_string(PUBLIC_KEY_BYTES)\n        assert verifier.verify(to_sign, actual_signature)\n\n    def test_verify_unicode_success(self):\n        to_sign = u\"foo\"\n        signer = es256.ES256Signer.from_string(PRIVATE_KEY_BYTES)\n        actual_signature = signer.sign(to_sign)\n\n        verifier = es256.ES256Verifier.from_string(PUBLIC_KEY_BYTES)\n        assert verifier.verify(to_sign, actual_signature)\n\n    def test_verify_failure(self):\n        verifier = es256.ES256Verifier.from_string(PUBLIC_KEY_BYTES)\n        bad_signature1 = b\"\"\n        assert not verifier.verify(b\"foo\", bad_signature1)\n        bad_signature2 = b\"a\"\n        assert not verifier.verify(b\"foo\", bad_signature2)\n\n    def test_verify_failure_with_wrong_raw_signature(self):\n        to_sign = b\"foo\"\n\n        # This signature has a wrong \"r\" value in the \"(r,s)\" raw signature.\n        wrong_signature = base64.urlsafe_b64decode(\n            b\"m7oaRxUDeYqjZ8qiMwo0PZLTMZWKJLFQREpqce1StMIa_yXQQ-C5WgeIRHW7OqlYSDL0XbUrj_uAw9i-QhfOJQ==\"\n        )\n\n        verifier = es256.ES256Verifier.from_string(PUBLIC_KEY_BYTES)\n        assert not verifier.verify(to_sign, wrong_signature)\n\n    def test_from_string_pub_key(self):\n        verifier = es256.ES256Verifier.from_string(PUBLIC_KEY_BYTES)\n        assert isinstance(verifier, es256.ES256Verifier)\n        assert isinstance(verifier._pubkey, ec.EllipticCurvePublicKey)\n\n    def test_from_string_pub_key_unicode(self):\n        public_key = _helpers.from_bytes(PUBLIC_KEY_BYTES)\n        verifier = es256.ES256Verifier.from_string(public_key)\n        assert isinstance(verifier, es256.ES256Verifier)\n        assert isinstance(verifier._pubkey, ec.EllipticCurvePublicKey)\n\n    def test_from_string_pub_cert(self):\n        verifier = es256.ES256Verifier.from_string(PUBLIC_CERT_BYTES)\n        assert isinstance(verifier, es256.ES256Verifier)\n        assert isinstance(verifier._pubkey, ec.EllipticCurvePublicKey)\n\n    def test_from_string_pub_cert_unicode(self):\n        public_cert = _helpers.from_bytes(PUBLIC_CERT_BYTES)\n        verifier = es256.ES256Verifier.from_string(public_cert)\n        assert isinstance(verifier, es256.ES256Verifier)\n        assert isinstance(verifier._pubkey, ec.EllipticCurvePublicKey)\n\n\nclass TestES256Signer(object):\n    def test_from_string_pkcs1(self):\n        signer = es256.ES256Signer.from_string(PKCS1_KEY_BYTES)\n        assert isinstance(signer, es256.ES256Signer)\n        assert isinstance(signer._key, ec.EllipticCurvePrivateKey)\n\n    def test_from_string_pkcs1_unicode(self):\n        key_bytes = _helpers.from_bytes(PKCS1_KEY_BYTES)\n        signer = es256.ES256Signer.from_string(key_bytes)\n        assert isinstance(signer, es256.ES256Signer)\n        assert isinstance(signer._key, ec.EllipticCurvePrivateKey)\n\n    def test_from_string_bogus_key(self):\n        key_bytes = \"bogus-key\"\n        with pytest.raises(ValueError):\n            es256.ES256Signer.from_string(key_bytes)\n\n    def test_from_service_account_info(self):\n        signer = es256.ES256Signer.from_service_account_info(SERVICE_ACCOUNT_INFO)\n\n        assert signer.key_id == SERVICE_ACCOUNT_INFO[base._JSON_FILE_PRIVATE_KEY_ID]\n        assert isinstance(signer._key, ec.EllipticCurvePrivateKey)\n\n    def test_from_service_account_info_missing_key(self):\n        with pytest.raises(ValueError) as excinfo:\n            es256.ES256Signer.from_service_account_info({})\n\n        assert excinfo.match(base._JSON_FILE_PRIVATE_KEY)\n\n    def test_from_service_account_file(self):\n        signer = es256.ES256Signer.from_service_account_file(SERVICE_ACCOUNT_JSON_FILE)\n\n        assert signer.key_id == SERVICE_ACCOUNT_INFO[base._JSON_FILE_PRIVATE_KEY_ID]\n        assert isinstance(signer._key, ec.EllipticCurvePrivateKey)\n\n    def test_pickle(self):\n        signer = es256.ES256Signer.from_service_account_file(SERVICE_ACCOUNT_JSON_FILE)\n\n        assert signer.key_id == SERVICE_ACCOUNT_INFO[base._JSON_FILE_PRIVATE_KEY_ID]\n        assert isinstance(signer._key, ec.EllipticCurvePrivateKey)\n\n        pickled_signer = pickle.dumps(signer)\n        signer = pickle.loads(pickled_signer)\n\n        assert signer.key_id == SERVICE_ACCOUNT_INFO[base._JSON_FILE_PRIVATE_KEY_ID]\n        assert isinstance(signer._key, ec.EllipticCurvePrivateKey)\n", "tests/crypt/test__cryptography_rsa.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport json\nimport os\nimport pickle\n\nfrom cryptography.hazmat.primitives.asymmetric import rsa\nimport pytest  # type: ignore\n\nfrom google.auth import _helpers\nfrom google.auth.crypt import _cryptography_rsa\nfrom google.auth.crypt import base\n\n\nDATA_DIR = os.path.join(os.path.dirname(__file__), \"..\", \"data\")\n\n# To generate privatekey.pem, privatekey.pub, and public_cert.pem:\n#   $ openssl req -new -newkey rsa:1024 -x509 -nodes -out public_cert.pem \\\n#   >    -keyout privatekey.pem\n#   $ openssl rsa -in privatekey.pem -pubout -out privatekey.pub\n\nwith open(os.path.join(DATA_DIR, \"privatekey.pem\"), \"rb\") as fh:\n    PRIVATE_KEY_BYTES = fh.read()\n    PKCS1_KEY_BYTES = PRIVATE_KEY_BYTES\n\nwith open(os.path.join(DATA_DIR, \"privatekey.pub\"), \"rb\") as fh:\n    PUBLIC_KEY_BYTES = fh.read()\n\nwith open(os.path.join(DATA_DIR, \"public_cert.pem\"), \"rb\") as fh:\n    PUBLIC_CERT_BYTES = fh.read()\n\n# To generate pem_from_pkcs12.pem and privatekey.p12:\n#   $ openssl pkcs12 -export -out privatekey.p12 -inkey privatekey.pem \\\n#   >    -in public_cert.pem\n#   $ openssl pkcs12 -in privatekey.p12 -nocerts -nodes \\\n#   >   -out pem_from_pkcs12.pem\n\nwith open(os.path.join(DATA_DIR, \"pem_from_pkcs12.pem\"), \"rb\") as fh:\n    PKCS8_KEY_BYTES = fh.read()\n\nwith open(os.path.join(DATA_DIR, \"privatekey.p12\"), \"rb\") as fh:\n    PKCS12_KEY_BYTES = fh.read()\n\n# The service account JSON file can be generated from the Google Cloud Console.\nSERVICE_ACCOUNT_JSON_FILE = os.path.join(DATA_DIR, \"service_account.json\")\n\nwith open(SERVICE_ACCOUNT_JSON_FILE, \"rb\") as fh:\n    SERVICE_ACCOUNT_INFO = json.load(fh)\n\n\nclass TestRSAVerifier(object):\n    def test_verify_success(self):\n        to_sign = b\"foo\"\n        signer = _cryptography_rsa.RSASigner.from_string(PRIVATE_KEY_BYTES)\n        actual_signature = signer.sign(to_sign)\n\n        verifier = _cryptography_rsa.RSAVerifier.from_string(PUBLIC_KEY_BYTES)\n        assert verifier.verify(to_sign, actual_signature)\n\n    def test_verify_unicode_success(self):\n        to_sign = u\"foo\"\n        signer = _cryptography_rsa.RSASigner.from_string(PRIVATE_KEY_BYTES)\n        actual_signature = signer.sign(to_sign)\n\n        verifier = _cryptography_rsa.RSAVerifier.from_string(PUBLIC_KEY_BYTES)\n        assert verifier.verify(to_sign, actual_signature)\n\n    def test_verify_failure(self):\n        verifier = _cryptography_rsa.RSAVerifier.from_string(PUBLIC_KEY_BYTES)\n        bad_signature1 = b\"\"\n        assert not verifier.verify(b\"foo\", bad_signature1)\n        bad_signature2 = b\"a\"\n        assert not verifier.verify(b\"foo\", bad_signature2)\n\n    def test_from_string_pub_key(self):\n        verifier = _cryptography_rsa.RSAVerifier.from_string(PUBLIC_KEY_BYTES)\n        assert isinstance(verifier, _cryptography_rsa.RSAVerifier)\n        assert isinstance(verifier._pubkey, rsa.RSAPublicKey)\n\n    def test_from_string_pub_key_unicode(self):\n        public_key = _helpers.from_bytes(PUBLIC_KEY_BYTES)\n        verifier = _cryptography_rsa.RSAVerifier.from_string(public_key)\n        assert isinstance(verifier, _cryptography_rsa.RSAVerifier)\n        assert isinstance(verifier._pubkey, rsa.RSAPublicKey)\n\n    def test_from_string_pub_cert(self):\n        verifier = _cryptography_rsa.RSAVerifier.from_string(PUBLIC_CERT_BYTES)\n        assert isinstance(verifier, _cryptography_rsa.RSAVerifier)\n        assert isinstance(verifier._pubkey, rsa.RSAPublicKey)\n\n    def test_from_string_pub_cert_unicode(self):\n        public_cert = _helpers.from_bytes(PUBLIC_CERT_BYTES)\n        verifier = _cryptography_rsa.RSAVerifier.from_string(public_cert)\n        assert isinstance(verifier, _cryptography_rsa.RSAVerifier)\n        assert isinstance(verifier._pubkey, rsa.RSAPublicKey)\n\n\nclass TestRSASigner(object):\n    def test_from_string_pkcs1(self):\n        signer = _cryptography_rsa.RSASigner.from_string(PKCS1_KEY_BYTES)\n        assert isinstance(signer, _cryptography_rsa.RSASigner)\n        assert isinstance(signer._key, rsa.RSAPrivateKey)\n\n    def test_from_string_pkcs1_unicode(self):\n        key_bytes = _helpers.from_bytes(PKCS1_KEY_BYTES)\n        signer = _cryptography_rsa.RSASigner.from_string(key_bytes)\n        assert isinstance(signer, _cryptography_rsa.RSASigner)\n        assert isinstance(signer._key, rsa.RSAPrivateKey)\n\n    def test_from_string_pkcs8(self):\n        signer = _cryptography_rsa.RSASigner.from_string(PKCS8_KEY_BYTES)\n        assert isinstance(signer, _cryptography_rsa.RSASigner)\n        assert isinstance(signer._key, rsa.RSAPrivateKey)\n\n    def test_from_string_pkcs8_unicode(self):\n        key_bytes = _helpers.from_bytes(PKCS8_KEY_BYTES)\n        signer = _cryptography_rsa.RSASigner.from_string(key_bytes)\n        assert isinstance(signer, _cryptography_rsa.RSASigner)\n        assert isinstance(signer._key, rsa.RSAPrivateKey)\n\n    def test_from_string_pkcs12(self):\n        with pytest.raises(ValueError):\n            _cryptography_rsa.RSASigner.from_string(PKCS12_KEY_BYTES)\n\n    def test_from_string_bogus_key(self):\n        key_bytes = \"bogus-key\"\n        with pytest.raises(ValueError):\n            _cryptography_rsa.RSASigner.from_string(key_bytes)\n\n    def test_from_service_account_info(self):\n        signer = _cryptography_rsa.RSASigner.from_service_account_info(\n            SERVICE_ACCOUNT_INFO\n        )\n\n        assert signer.key_id == SERVICE_ACCOUNT_INFO[base._JSON_FILE_PRIVATE_KEY_ID]\n        assert isinstance(signer._key, rsa.RSAPrivateKey)\n\n    def test_from_service_account_info_missing_key(self):\n        with pytest.raises(ValueError) as excinfo:\n            _cryptography_rsa.RSASigner.from_service_account_info({})\n\n        assert excinfo.match(base._JSON_FILE_PRIVATE_KEY)\n\n    def test_from_service_account_file(self):\n        signer = _cryptography_rsa.RSASigner.from_service_account_file(\n            SERVICE_ACCOUNT_JSON_FILE\n        )\n\n        assert signer.key_id == SERVICE_ACCOUNT_INFO[base._JSON_FILE_PRIVATE_KEY_ID]\n        assert isinstance(signer._key, rsa.RSAPrivateKey)\n\n    def test_pickle(self):\n        signer = _cryptography_rsa.RSASigner.from_service_account_file(\n            SERVICE_ACCOUNT_JSON_FILE\n        )\n\n        assert signer.key_id == SERVICE_ACCOUNT_INFO[base._JSON_FILE_PRIVATE_KEY_ID]\n        assert isinstance(signer._key, rsa.RSAPrivateKey)\n\n        pickled_signer = pickle.dumps(signer)\n        signer = pickle.loads(pickled_signer)\n\n        assert signer.key_id == SERVICE_ACCOUNT_INFO[base._JSON_FILE_PRIVATE_KEY_ID]\n        assert isinstance(signer._key, rsa.RSAPrivateKey)\n", "tests/crypt/test__python_rsa.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport io\nimport json\nimport os\n\nimport mock\nfrom pyasn1_modules import pem  # type: ignore\nimport pytest  # type: ignore\nimport rsa  # type: ignore\n\nfrom google.auth import _helpers\nfrom google.auth.crypt import _python_rsa\nfrom google.auth.crypt import base\n\n\nDATA_DIR = os.path.join(os.path.dirname(__file__), \"..\", \"data\")\n\n# To generate privatekey.pem, privatekey.pub, and public_cert.pem:\n#   $ openssl req -new -newkey rsa:1024 -x509 -nodes -out public_cert.pem \\\n#   >    -keyout privatekey.pem\n#   $ openssl rsa -in privatekey.pem -pubout -out privatekey.pub\n\nwith open(os.path.join(DATA_DIR, \"privatekey.pem\"), \"rb\") as fh:\n    PRIVATE_KEY_BYTES = fh.read()\n    PKCS1_KEY_BYTES = PRIVATE_KEY_BYTES\n\nwith open(os.path.join(DATA_DIR, \"privatekey.pub\"), \"rb\") as fh:\n    PUBLIC_KEY_BYTES = fh.read()\n\nwith open(os.path.join(DATA_DIR, \"public_cert.pem\"), \"rb\") as fh:\n    PUBLIC_CERT_BYTES = fh.read()\n\n# To generate pem_from_pkcs12.pem and privatekey.p12:\n#   $ openssl pkcs12 -export -out privatekey.p12 -inkey privatekey.pem \\\n#   >    -in public_cert.pem\n#   $ openssl pkcs12 -in privatekey.p12 -nocerts -nodes \\\n#   >   -out pem_from_pkcs12.pem\n\nwith open(os.path.join(DATA_DIR, \"pem_from_pkcs12.pem\"), \"rb\") as fh:\n    PKCS8_KEY_BYTES = fh.read()\n\nwith open(os.path.join(DATA_DIR, \"privatekey.p12\"), \"rb\") as fh:\n    PKCS12_KEY_BYTES = fh.read()\n\n# The service account JSON file can be generated from the Google Cloud Console.\nSERVICE_ACCOUNT_JSON_FILE = os.path.join(DATA_DIR, \"service_account.json\")\n\nwith open(SERVICE_ACCOUNT_JSON_FILE, \"rb\") as fh:\n    SERVICE_ACCOUNT_INFO = json.load(fh)\n\n\nclass TestRSAVerifier(object):\n    def test_verify_success(self):\n        to_sign = b\"foo\"\n        signer = _python_rsa.RSASigner.from_string(PRIVATE_KEY_BYTES)\n        actual_signature = signer.sign(to_sign)\n\n        verifier = _python_rsa.RSAVerifier.from_string(PUBLIC_KEY_BYTES)\n        assert verifier.verify(to_sign, actual_signature)\n\n    def test_verify_unicode_success(self):\n        to_sign = u\"foo\"\n        signer = _python_rsa.RSASigner.from_string(PRIVATE_KEY_BYTES)\n        actual_signature = signer.sign(to_sign)\n\n        verifier = _python_rsa.RSAVerifier.from_string(PUBLIC_KEY_BYTES)\n        assert verifier.verify(to_sign, actual_signature)\n\n    def test_verify_failure(self):\n        verifier = _python_rsa.RSAVerifier.from_string(PUBLIC_KEY_BYTES)\n        bad_signature1 = b\"\"\n        assert not verifier.verify(b\"foo\", bad_signature1)\n        bad_signature2 = b\"a\"\n        assert not verifier.verify(b\"foo\", bad_signature2)\n\n    def test_from_string_pub_key(self):\n        verifier = _python_rsa.RSAVerifier.from_string(PUBLIC_KEY_BYTES)\n        assert isinstance(verifier, _python_rsa.RSAVerifier)\n        assert isinstance(verifier._pubkey, rsa.key.PublicKey)\n\n    def test_from_string_pub_key_unicode(self):\n        public_key = _helpers.from_bytes(PUBLIC_KEY_BYTES)\n        verifier = _python_rsa.RSAVerifier.from_string(public_key)\n        assert isinstance(verifier, _python_rsa.RSAVerifier)\n        assert isinstance(verifier._pubkey, rsa.key.PublicKey)\n\n    def test_from_string_pub_cert(self):\n        verifier = _python_rsa.RSAVerifier.from_string(PUBLIC_CERT_BYTES)\n        assert isinstance(verifier, _python_rsa.RSAVerifier)\n        assert isinstance(verifier._pubkey, rsa.key.PublicKey)\n\n    def test_from_string_pub_cert_unicode(self):\n        public_cert = _helpers.from_bytes(PUBLIC_CERT_BYTES)\n        verifier = _python_rsa.RSAVerifier.from_string(public_cert)\n        assert isinstance(verifier, _python_rsa.RSAVerifier)\n        assert isinstance(verifier._pubkey, rsa.key.PublicKey)\n\n    def test_from_string_pub_cert_failure(self):\n        cert_bytes = PUBLIC_CERT_BYTES\n        true_der = rsa.pem.load_pem(cert_bytes, \"CERTIFICATE\")\n        load_pem_patch = mock.patch(\n            \"rsa.pem.load_pem\", return_value=true_der + b\"extra\", autospec=True\n        )\n\n        with load_pem_patch as load_pem:\n            with pytest.raises(ValueError):\n                _python_rsa.RSAVerifier.from_string(cert_bytes)\n            load_pem.assert_called_once_with(cert_bytes, \"CERTIFICATE\")\n\n\nclass TestRSASigner(object):\n    def test_from_string_pkcs1(self):\n        signer = _python_rsa.RSASigner.from_string(PKCS1_KEY_BYTES)\n        assert isinstance(signer, _python_rsa.RSASigner)\n        assert isinstance(signer._key, rsa.key.PrivateKey)\n\n    def test_from_string_pkcs1_unicode(self):\n        key_bytes = _helpers.from_bytes(PKCS1_KEY_BYTES)\n        signer = _python_rsa.RSASigner.from_string(key_bytes)\n        assert isinstance(signer, _python_rsa.RSASigner)\n        assert isinstance(signer._key, rsa.key.PrivateKey)\n\n    def test_from_string_pkcs8(self):\n        signer = _python_rsa.RSASigner.from_string(PKCS8_KEY_BYTES)\n        assert isinstance(signer, _python_rsa.RSASigner)\n        assert isinstance(signer._key, rsa.key.PrivateKey)\n\n    def test_from_string_pkcs8_extra_bytes(self):\n        key_bytes = PKCS8_KEY_BYTES\n        _, pem_bytes = pem.readPemBlocksFromFile(\n            io.StringIO(_helpers.from_bytes(key_bytes)), _python_rsa._PKCS8_MARKER\n        )\n\n        key_info, remaining = None, \"extra\"\n        decode_patch = mock.patch(\n            \"pyasn1.codec.der.decoder.decode\",\n            return_value=(key_info, remaining),\n            autospec=True,\n        )\n\n        with decode_patch as decode:\n            with pytest.raises(ValueError):\n                _python_rsa.RSASigner.from_string(key_bytes)\n            # Verify mock was called.\n            decode.assert_called_once_with(pem_bytes, asn1Spec=_python_rsa._PKCS8_SPEC)\n\n    def test_from_string_pkcs8_unicode(self):\n        key_bytes = _helpers.from_bytes(PKCS8_KEY_BYTES)\n        signer = _python_rsa.RSASigner.from_string(key_bytes)\n        assert isinstance(signer, _python_rsa.RSASigner)\n        assert isinstance(signer._key, rsa.key.PrivateKey)\n\n    def test_from_string_pkcs12(self):\n        with pytest.raises(ValueError):\n            _python_rsa.RSASigner.from_string(PKCS12_KEY_BYTES)\n\n    def test_from_string_bogus_key(self):\n        key_bytes = \"bogus-key\"\n        with pytest.raises(ValueError):\n            _python_rsa.RSASigner.from_string(key_bytes)\n\n    def test_from_service_account_info(self):\n        signer = _python_rsa.RSASigner.from_service_account_info(SERVICE_ACCOUNT_INFO)\n\n        assert signer.key_id == SERVICE_ACCOUNT_INFO[base._JSON_FILE_PRIVATE_KEY_ID]\n        assert isinstance(signer._key, rsa.key.PrivateKey)\n\n    def test_from_service_account_info_missing_key(self):\n        with pytest.raises(ValueError) as excinfo:\n            _python_rsa.RSASigner.from_service_account_info({})\n\n        assert excinfo.match(base._JSON_FILE_PRIVATE_KEY)\n\n    def test_from_service_account_file(self):\n        signer = _python_rsa.RSASigner.from_service_account_file(\n            SERVICE_ACCOUNT_JSON_FILE\n        )\n\n        assert signer.key_id == SERVICE_ACCOUNT_INFO[base._JSON_FILE_PRIVATE_KEY_ID]\n        assert isinstance(signer._key, rsa.key.PrivateKey)\n", "tests/crypt/__init__.py": "", "tests/crypt/test_crypt.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport os\n\nfrom google.auth import crypt\n\n\nDATA_DIR = os.path.join(os.path.dirname(__file__), \"..\", \"data\")\n\n# To generate privatekey.pem, privatekey.pub, and public_cert.pem:\n#   $ openssl req -new -newkey rsa:1024 -x509 -nodes -out public_cert.pem \\\n#   >    -keyout privatekey.pem\n#   $ openssl rsa -in privatekey.pem -pubout -out privatekey.pub\n\nwith open(os.path.join(DATA_DIR, \"privatekey.pem\"), \"rb\") as fh:\n    PRIVATE_KEY_BYTES = fh.read()\n\nwith open(os.path.join(DATA_DIR, \"public_cert.pem\"), \"rb\") as fh:\n    PUBLIC_CERT_BYTES = fh.read()\n\n# To generate other_cert.pem:\n#   $ openssl req -new -newkey rsa:1024 -x509 -nodes -out other_cert.pem\n\nwith open(os.path.join(DATA_DIR, \"other_cert.pem\"), \"rb\") as fh:\n    OTHER_CERT_BYTES = fh.read()\n\n\ndef test_verify_signature():\n    to_sign = b\"foo\"\n    signer = crypt.RSASigner.from_string(PRIVATE_KEY_BYTES)\n    signature = signer.sign(to_sign)\n\n    assert crypt.verify_signature(to_sign, signature, PUBLIC_CERT_BYTES)\n\n    # List of certs\n    assert crypt.verify_signature(\n        to_sign, signature, [OTHER_CERT_BYTES, PUBLIC_CERT_BYTES]\n    )\n\n\ndef test_verify_signature_failure():\n    to_sign = b\"foo\"\n    signer = crypt.RSASigner.from_string(PRIVATE_KEY_BYTES)\n    signature = signer.sign(to_sign)\n\n    assert not crypt.verify_signature(to_sign, signature, OTHER_CERT_BYTES)\n", "tests/transport/test__mtls_helper.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport os\nimport re\n\nimport mock\nfrom OpenSSL import crypto\nimport pytest  # type: ignore\n\nfrom google.auth import exceptions\nfrom google.auth.transport import _mtls_helper\n\nCONTEXT_AWARE_METADATA = {\"cert_provider_command\": [\"some command\"]}\n\nENCRYPTED_EC_PRIVATE_KEY = b\"\"\"-----BEGIN ENCRYPTED PRIVATE KEY-----\nMIHkME8GCSqGSIb3DQEFDTBCMCkGCSqGSIb3DQEFDDAcBAgl2/yVgs1h3QICCAAw\nDAYIKoZIhvcNAgkFADAVBgkrBgEEAZdVAQIECJk2GRrvxOaJBIGQXIBnMU4wmciT\nuA6yD8q0FxuIzjG7E2S6tc5VRgSbhRB00eBO3jWmO2pBybeQW+zVioDcn50zp2ts\nwYErWC+LCm1Zg3r+EGnT1E1GgNoODbVQ3AEHlKh1CGCYhEovxtn3G+Fjh7xOBrNB\nsaVVeDb4tHD4tMkiVVUBrUcTZPndP73CtgyGHYEphasYPzEz3+AU\n-----END ENCRYPTED PRIVATE KEY-----\"\"\"\n\nEC_PUBLIC_KEY = b\"\"\"-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEvCNi1NoDY1oMqPHIgXI8RBbTYGi/\nbrEjbre1nSiQW11xRTJbVeETdsuP0EAu2tG3PcRhhwDfeJ8zXREgTBurNw==\n-----END PUBLIC KEY-----\"\"\"\n\nPASSPHRASE = b\"\"\"-----BEGIN PASSPHRASE-----\npassword\n-----END PASSPHRASE-----\"\"\"\nPASSPHRASE_VALUE = b\"password\"\n\n\ndef check_cert_and_key(content, expected_cert, expected_key):\n    success = True\n\n    cert_match = re.findall(_mtls_helper._CERT_REGEX, content)\n    success = success and len(cert_match) == 1 and cert_match[0] == expected_cert\n\n    key_match = re.findall(_mtls_helper._KEY_REGEX, content)\n    success = success and len(key_match) == 1 and key_match[0] == expected_key\n\n    return success\n\n\nclass TestCertAndKeyRegex(object):\n    def test_cert_and_key(self):\n        # Test single cert and single key\n        check_cert_and_key(\n            pytest.public_cert_bytes + pytest.private_key_bytes,\n            pytest.public_cert_bytes,\n            pytest.private_key_bytes,\n        )\n        check_cert_and_key(\n            pytest.private_key_bytes + pytest.public_cert_bytes,\n            pytest.public_cert_bytes,\n            pytest.private_key_bytes,\n        )\n\n        # Test cert chain and single key\n        check_cert_and_key(\n            pytest.public_cert_bytes\n            + pytest.public_cert_bytes\n            + pytest.private_key_bytes,\n            pytest.public_cert_bytes + pytest.public_cert_bytes,\n            pytest.private_key_bytes,\n        )\n        check_cert_and_key(\n            pytest.private_key_bytes\n            + pytest.public_cert_bytes\n            + pytest.public_cert_bytes,\n            pytest.public_cert_bytes + pytest.public_cert_bytes,\n            pytest.private_key_bytes,\n        )\n\n    def test_key(self):\n        # Create some fake keys for regex check.\n        KEY = b\"\"\"-----BEGIN PRIVATE KEY-----\n        MIIBCgKCAQEA4ej0p7bQ7L/r4rVGUz9RN4VQWoej1Bg1mYWIDYslvKrk1gpj7wZg\n        /fy3ZpsL7WqgsZS7Q+0VRK8gKfqkxg5OYQIDAQAB\n        -----END PRIVATE KEY-----\"\"\"\n        RSA_KEY = b\"\"\"-----BEGIN RSA PRIVATE KEY-----\n        MIIBCgKCAQEA4ej0p7bQ7L/r4rVGUz9RN4VQWoej1Bg1mYWIDYslvKrk1gpj7wZg\n        /fy3ZpsL7WqgsZS7Q+0VRK8gKfqkxg5OYQIDAQAB\n        -----END RSA PRIVATE KEY-----\"\"\"\n        EC_KEY = b\"\"\"-----BEGIN EC PRIVATE KEY-----\n        MIIBCgKCAQEA4ej0p7bQ7L/r4rVGUz9RN4VQWoej1Bg1mYWIDYslvKrk1gpj7wZg\n        /fy3ZpsL7WqgsZS7Q+0VRK8gKfqkxg5OYQIDAQAB\n        -----END EC PRIVATE KEY-----\"\"\"\n\n        check_cert_and_key(\n            pytest.public_cert_bytes + KEY, pytest.public_cert_bytes, KEY\n        )\n        check_cert_and_key(\n            pytest.public_cert_bytes + RSA_KEY, pytest.public_cert_bytes, RSA_KEY\n        )\n        check_cert_and_key(\n            pytest.public_cert_bytes + EC_KEY, pytest.public_cert_bytes, EC_KEY\n        )\n\n\nclass TestCheckaMetadataPath(object):\n    def test_success(self):\n        metadata_path = os.path.join(pytest.data_dir, \"context_aware_metadata.json\")\n        returned_path = _mtls_helper._check_dca_metadata_path(metadata_path)\n        assert returned_path is not None\n\n    def test_failure(self):\n        metadata_path = os.path.join(pytest.data_dir, \"not_exists.json\")\n        returned_path = _mtls_helper._check_dca_metadata_path(metadata_path)\n        assert returned_path is None\n\n\nclass TestReadMetadataFile(object):\n    def test_success(self):\n        metadata_path = os.path.join(pytest.data_dir, \"context_aware_metadata.json\")\n        metadata = _mtls_helper._load_json_file(metadata_path)\n\n        assert \"cert_provider_command\" in metadata\n\n    def test_file_not_json(self):\n        # read a file which is not json format.\n        metadata_path = os.path.join(pytest.data_dir, \"privatekey.pem\")\n        with pytest.raises(exceptions.ClientCertError):\n            _mtls_helper._load_json_file(metadata_path)\n\n\nclass TestRunCertProviderCommand(object):\n    def create_mock_process(self, output, error):\n        # There are two steps to execute a script with subprocess.Popen.\n        # (1) process = subprocess.Popen([comannds])\n        # (2) stdout, stderr = process.communicate()\n        # This function creates a mock process which can be returned by a mock\n        # subprocess.Popen. The mock process returns the given output and error\n        # when mock_process.communicate() is called.\n        mock_process = mock.Mock()\n        attrs = {\"communicate.return_value\": (output, error), \"returncode\": 0}\n        mock_process.configure_mock(**attrs)\n        return mock_process\n\n    @mock.patch(\"subprocess.Popen\", autospec=True)\n    def test_success(self, mock_popen):\n        mock_popen.return_value = self.create_mock_process(\n            pytest.public_cert_bytes + pytest.private_key_bytes, b\"\"\n        )\n        cert, key, passphrase = _mtls_helper._run_cert_provider_command([\"command\"])\n        assert cert == pytest.public_cert_bytes\n        assert key == pytest.private_key_bytes\n        assert passphrase is None\n\n        mock_popen.return_value = self.create_mock_process(\n            pytest.public_cert_bytes + ENCRYPTED_EC_PRIVATE_KEY + PASSPHRASE, b\"\"\n        )\n        cert, key, passphrase = _mtls_helper._run_cert_provider_command(\n            [\"command\"], expect_encrypted_key=True\n        )\n        assert cert == pytest.public_cert_bytes\n        assert key == ENCRYPTED_EC_PRIVATE_KEY\n        assert passphrase == PASSPHRASE_VALUE\n\n    @mock.patch(\"subprocess.Popen\", autospec=True)\n    def test_success_with_cert_chain(self, mock_popen):\n        PUBLIC_CERT_CHAIN_BYTES = pytest.public_cert_bytes + pytest.public_cert_bytes\n        mock_popen.return_value = self.create_mock_process(\n            PUBLIC_CERT_CHAIN_BYTES + pytest.private_key_bytes, b\"\"\n        )\n        cert, key, passphrase = _mtls_helper._run_cert_provider_command([\"command\"])\n        assert cert == PUBLIC_CERT_CHAIN_BYTES\n        assert key == pytest.private_key_bytes\n        assert passphrase is None\n\n        mock_popen.return_value = self.create_mock_process(\n            PUBLIC_CERT_CHAIN_BYTES + ENCRYPTED_EC_PRIVATE_KEY + PASSPHRASE, b\"\"\n        )\n        cert, key, passphrase = _mtls_helper._run_cert_provider_command(\n            [\"command\"], expect_encrypted_key=True\n        )\n        assert cert == PUBLIC_CERT_CHAIN_BYTES\n        assert key == ENCRYPTED_EC_PRIVATE_KEY\n        assert passphrase == PASSPHRASE_VALUE\n\n    @mock.patch(\"subprocess.Popen\", autospec=True)\n    def test_missing_cert(self, mock_popen):\n        mock_popen.return_value = self.create_mock_process(\n            pytest.private_key_bytes, b\"\"\n        )\n        with pytest.raises(exceptions.ClientCertError):\n            _mtls_helper._run_cert_provider_command([\"command\"])\n\n        mock_popen.return_value = self.create_mock_process(\n            ENCRYPTED_EC_PRIVATE_KEY + PASSPHRASE, b\"\"\n        )\n        with pytest.raises(exceptions.ClientCertError):\n            _mtls_helper._run_cert_provider_command(\n                [\"command\"], expect_encrypted_key=True\n            )\n\n    @mock.patch(\"subprocess.Popen\", autospec=True)\n    def test_missing_key(self, mock_popen):\n        mock_popen.return_value = self.create_mock_process(\n            pytest.public_cert_bytes, b\"\"\n        )\n        with pytest.raises(exceptions.ClientCertError):\n            _mtls_helper._run_cert_provider_command([\"command\"])\n\n        mock_popen.return_value = self.create_mock_process(\n            pytest.public_cert_bytes + PASSPHRASE, b\"\"\n        )\n        with pytest.raises(exceptions.ClientCertError):\n            _mtls_helper._run_cert_provider_command(\n                [\"command\"], expect_encrypted_key=True\n            )\n\n    @mock.patch(\"subprocess.Popen\", autospec=True)\n    def test_missing_passphrase(self, mock_popen):\n        mock_popen.return_value = self.create_mock_process(\n            pytest.public_cert_bytes + ENCRYPTED_EC_PRIVATE_KEY, b\"\"\n        )\n        with pytest.raises(exceptions.ClientCertError):\n            _mtls_helper._run_cert_provider_command(\n                [\"command\"], expect_encrypted_key=True\n            )\n\n    @mock.patch(\"subprocess.Popen\", autospec=True)\n    def test_passphrase_not_expected(self, mock_popen):\n        mock_popen.return_value = self.create_mock_process(\n            pytest.public_cert_bytes + pytest.private_key_bytes + PASSPHRASE, b\"\"\n        )\n        with pytest.raises(exceptions.ClientCertError):\n            _mtls_helper._run_cert_provider_command([\"command\"])\n\n    @mock.patch(\"subprocess.Popen\", autospec=True)\n    def test_encrypted_key_expected(self, mock_popen):\n        mock_popen.return_value = self.create_mock_process(\n            pytest.public_cert_bytes + pytest.private_key_bytes + PASSPHRASE, b\"\"\n        )\n        with pytest.raises(exceptions.ClientCertError):\n            _mtls_helper._run_cert_provider_command(\n                [\"command\"], expect_encrypted_key=True\n            )\n\n    @mock.patch(\"subprocess.Popen\", autospec=True)\n    def test_unencrypted_key_expected(self, mock_popen):\n        mock_popen.return_value = self.create_mock_process(\n            pytest.public_cert_bytes + ENCRYPTED_EC_PRIVATE_KEY, b\"\"\n        )\n        with pytest.raises(exceptions.ClientCertError):\n            _mtls_helper._run_cert_provider_command([\"command\"])\n\n    @mock.patch(\"subprocess.Popen\", autospec=True)\n    def test_cert_provider_returns_error(self, mock_popen):\n        mock_popen.return_value = self.create_mock_process(b\"\", b\"some error\")\n        mock_popen.return_value.returncode = 1\n        with pytest.raises(exceptions.ClientCertError):\n            _mtls_helper._run_cert_provider_command([\"command\"])\n\n    @mock.patch(\"subprocess.Popen\", autospec=True)\n    def test_popen_raise_exception(self, mock_popen):\n        mock_popen.side_effect = OSError()\n        with pytest.raises(exceptions.ClientCertError):\n            _mtls_helper._run_cert_provider_command([\"command\"])\n\n\nclass TestGetClientSslCredentials(object):\n    @mock.patch(\n        \"google.auth.transport._mtls_helper._run_cert_provider_command\", autospec=True\n    )\n    @mock.patch(\"google.auth.transport._mtls_helper._load_json_file\", autospec=True)\n    @mock.patch(\n        \"google.auth.transport._mtls_helper._check_dca_metadata_path\", autospec=True\n    )\n    def test_success(\n        self,\n        mock_check_dca_metadata_path,\n        mock_load_json_file,\n        mock_run_cert_provider_command,\n    ):\n        mock_check_dca_metadata_path.return_value = True\n        mock_load_json_file.return_value = {\"cert_provider_command\": [\"command\"]}\n        mock_run_cert_provider_command.return_value = (b\"cert\", b\"key\", None)\n        has_cert, cert, key, passphrase = _mtls_helper.get_client_ssl_credentials()\n        assert has_cert\n        assert cert == b\"cert\"\n        assert key == b\"key\"\n        assert passphrase is None\n\n    @mock.patch(\n        \"google.auth.transport._mtls_helper._check_dca_metadata_path\", autospec=True\n    )\n    def test_success_without_metadata(self, mock_check_dca_metadata_path):\n        mock_check_dca_metadata_path.return_value = False\n        has_cert, cert, key, passphrase = _mtls_helper.get_client_ssl_credentials()\n        assert not has_cert\n        assert cert is None\n        assert key is None\n        assert passphrase is None\n\n    @mock.patch(\n        \"google.auth.transport._mtls_helper._run_cert_provider_command\", autospec=True\n    )\n    @mock.patch(\"google.auth.transport._mtls_helper._load_json_file\", autospec=True)\n    @mock.patch(\n        \"google.auth.transport._mtls_helper._check_dca_metadata_path\", autospec=True\n    )\n    def test_success_with_encrypted_key(\n        self,\n        mock_check_dca_metadata_path,\n        mock_load_json_file,\n        mock_run_cert_provider_command,\n    ):\n        mock_check_dca_metadata_path.return_value = True\n        mock_load_json_file.return_value = {\"cert_provider_command\": [\"command\"]}\n        mock_run_cert_provider_command.return_value = (b\"cert\", b\"key\", b\"passphrase\")\n        has_cert, cert, key, passphrase = _mtls_helper.get_client_ssl_credentials(\n            generate_encrypted_key=True\n        )\n        assert has_cert\n        assert cert == b\"cert\"\n        assert key == b\"key\"\n        assert passphrase == b\"passphrase\"\n        mock_run_cert_provider_command.assert_called_once_with(\n            [\"command\", \"--with_passphrase\"], expect_encrypted_key=True\n        )\n\n    @mock.patch(\"google.auth.transport._mtls_helper._load_json_file\", autospec=True)\n    @mock.patch(\n        \"google.auth.transport._mtls_helper._check_dca_metadata_path\", autospec=True\n    )\n    def test_missing_cert_command(\n        self, mock_check_dca_metadata_path, mock_load_json_file\n    ):\n        mock_check_dca_metadata_path.return_value = True\n        mock_load_json_file.return_value = {}\n        with pytest.raises(exceptions.ClientCertError):\n            _mtls_helper.get_client_ssl_credentials()\n\n    @mock.patch(\n        \"google.auth.transport._mtls_helper._run_cert_provider_command\", autospec=True\n    )\n    @mock.patch(\"google.auth.transport._mtls_helper._load_json_file\", autospec=True)\n    @mock.patch(\n        \"google.auth.transport._mtls_helper._check_dca_metadata_path\", autospec=True\n    )\n    def test_customize_context_aware_metadata_path(\n        self,\n        mock_check_dca_metadata_path,\n        mock_load_json_file,\n        mock_run_cert_provider_command,\n    ):\n        context_aware_metadata_path = \"/path/to/metata/data\"\n        mock_check_dca_metadata_path.return_value = context_aware_metadata_path\n        mock_load_json_file.return_value = {\"cert_provider_command\": [\"command\"]}\n        mock_run_cert_provider_command.return_value = (b\"cert\", b\"key\", None)\n\n        has_cert, cert, key, passphrase = _mtls_helper.get_client_ssl_credentials(\n            context_aware_metadata_path=context_aware_metadata_path\n        )\n\n        assert has_cert\n        assert cert == b\"cert\"\n        assert key == b\"key\"\n        assert passphrase is None\n        mock_check_dca_metadata_path.assert_called_with(context_aware_metadata_path)\n        mock_load_json_file.assert_called_with(context_aware_metadata_path)\n\n\nclass TestGetWorkloadCertAndKey(object):\n    @mock.patch(\"google.auth.transport._mtls_helper._load_json_file\", autospec=True)\n    @mock.patch(\n        \"google.auth.transport._mtls_helper._get_cert_config_path\", autospec=True\n    )\n    @mock.patch(\n        \"google.auth.transport._mtls_helper._read_cert_and_key_files\", autospec=True\n    )\n    def test_success(\n        self,\n        mock_read_cert_and_key_files,\n        mock_get_cert_config_path,\n        mock_load_json_file,\n    ):\n        cert_config_path = \"/path/to/cert\"\n        mock_get_cert_config_path.return_value = \"/path/to/cert\"\n        mock_load_json_file.return_value = {\n            \"cert_configs\": {\n                \"workload\": {\"cert_path\": \"cert/path\", \"key_path\": \"key/path\"}\n            }\n        }\n        mock_read_cert_and_key_files.return_value = (\n            pytest.public_cert_bytes,\n            pytest.private_key_bytes,\n        )\n\n        actual_cert, actual_key = _mtls_helper._get_workload_cert_and_key(\n            cert_config_path\n        )\n        assert actual_cert == pytest.public_cert_bytes\n        assert actual_key == pytest.private_key_bytes\n\n    @mock.patch(\n        \"google.auth.transport._mtls_helper._get_cert_config_path\", autospec=True\n    )\n    def test_file_not_found_returns_none(self, mock_get_cert_config_path):\n        mock_get_cert_config_path.return_value = None\n\n        actual_cert, actual_key = _mtls_helper._get_workload_cert_and_key()\n        assert actual_cert is None\n        assert actual_key is None\n\n    @mock.patch(\"google.auth.transport._mtls_helper._load_json_file\", autospec=True)\n    @mock.patch(\n        \"google.auth.transport._mtls_helper._get_cert_config_path\", autospec=True\n    )\n    def test_no_cert_configs(self, mock_get_cert_config_path, mock_load_json_file):\n        mock_get_cert_config_path.return_value = \"/path/to/cert\"\n        mock_load_json_file.return_value = {}\n\n        with pytest.raises(exceptions.ClientCertError):\n            _mtls_helper._get_workload_cert_and_key(\"\")\n\n    @mock.patch(\"google.auth.transport._mtls_helper._load_json_file\", autospec=True)\n    @mock.patch(\n        \"google.auth.transport._mtls_helper._get_cert_config_path\", autospec=True\n    )\n    def test_no_workload(self, mock_get_cert_config_path, mock_load_json_file):\n        mock_get_cert_config_path.return_value = \"/path/to/cert\"\n        mock_load_json_file.return_value = {\"cert_configs\": {}}\n\n        with pytest.raises(exceptions.ClientCertError):\n            _mtls_helper._get_workload_cert_and_key(\"\")\n\n    @mock.patch(\"google.auth.transport._mtls_helper._load_json_file\", autospec=True)\n    @mock.patch(\n        \"google.auth.transport._mtls_helper._get_cert_config_path\", autospec=True\n    )\n    def test_no_cert_file(self, mock_get_cert_config_path, mock_load_json_file):\n        mock_get_cert_config_path.return_value = \"/path/to/cert\"\n        mock_load_json_file.return_value = {\n            \"cert_configs\": {\"workload\": {\"key_path\": \"path/to/key\"}}\n        }\n\n        with pytest.raises(exceptions.ClientCertError):\n            _mtls_helper._get_workload_cert_and_key(\"\")\n\n    @mock.patch(\"google.auth.transport._mtls_helper._load_json_file\", autospec=True)\n    @mock.patch(\n        \"google.auth.transport._mtls_helper._get_cert_config_path\", autospec=True\n    )\n    def test_no_key_file(self, mock_get_cert_config_path, mock_load_json_file):\n        mock_get_cert_config_path.return_value = \"/path/to/cert\"\n        mock_load_json_file.return_value = {\n            \"cert_configs\": {\"workload\": {\"cert_path\": \"path/to/key\"}}\n        }\n\n        with pytest.raises(exceptions.ClientCertError):\n            _mtls_helper._get_workload_cert_and_key(\"\")\n\n\nclass TestReadCertAndKeyFile(object):\n    def test_success(self):\n        cert_path = os.path.join(pytest.data_dir, \"public_cert.pem\")\n        key_path = os.path.join(pytest.data_dir, \"privatekey.pem\")\n\n        actual_cert, actual_key = _mtls_helper._read_cert_and_key_files(\n            cert_path, key_path\n        )\n        assert actual_cert == pytest.public_cert_bytes\n        assert actual_key == pytest.private_key_bytes\n\n    def test_no_cert_file(self):\n        cert_path = \"fake/file/path\"\n        key_path = os.path.join(pytest.data_dir, \"privatekey.pem\")\n        with pytest.raises(FileNotFoundError):\n            _mtls_helper._read_cert_and_key_files(cert_path, key_path)\n\n    def test_no_key_file(self):\n        cert_path = os.path.join(pytest.data_dir, \"public_cert.pem\")\n        key_path = \"fake/file/path\"\n        with pytest.raises(FileNotFoundError):\n            _mtls_helper._read_cert_and_key_files(cert_path, key_path)\n\n    def test_invalid_cert_file(self):\n        cert_path = os.path.join(pytest.data_dir, \"service_account.json\")\n        key_path = os.path.join(pytest.data_dir, \"privatekey.pem\")\n        with pytest.raises(exceptions.ClientCertError):\n            _mtls_helper._read_cert_and_key_files(cert_path, key_path)\n\n    def test_invalid_key_file(self):\n        cert_path = os.path.join(pytest.data_dir, \"public_cert.pem\")\n        key_path = os.path.join(pytest.data_dir, \"public_cert.pem\")\n        with pytest.raises(exceptions.ClientCertError):\n            _mtls_helper._read_cert_and_key_files(cert_path, key_path)\n\n\nclass TestGetCertConfigPath(object):\n    def test_success_with_override(self):\n        config_path = os.path.join(pytest.data_dir, \"service_account.json\")\n        returned_path = _mtls_helper._get_cert_config_path(config_path)\n        assert returned_path == config_path\n\n    def test_override_does_not_exist(self):\n        config_path = \"fake/file/path\"\n        returned_path = _mtls_helper._get_cert_config_path(config_path)\n        assert returned_path is None\n\n    @mock.patch.dict(os.environ, {\"GOOGLE_API_CERTIFICATE_CONFIG\": \"\"})\n    @mock.patch(\"os.path.exists\", autospec=True)\n    def test_default(self, mock_path_exists):\n        mock_path_exists.return_value = True\n        returned_path = _mtls_helper._get_cert_config_path()\n        expected_path = os.path.expanduser(\n            _mtls_helper._CERTIFICATE_CONFIGURATION_DEFAULT_PATH\n        )\n        assert returned_path == expected_path\n\n    @mock.patch.dict(\n        os.environ, {\"GOOGLE_API_CERTIFICATE_CONFIG\": \"path/to/config/file\"}\n    )\n    @mock.patch(\"os.path.exists\", autospec=True)\n    def test_env_variable(self, mock_path_exists):\n        mock_path_exists.return_value = True\n        returned_path = _mtls_helper._get_cert_config_path()\n        expected_path = \"path/to/config/file\"\n        assert returned_path == expected_path\n\n    @mock.patch.dict(os.environ, {\"GOOGLE_API_CERTIFICATE_CONFIG\": \"\"})\n    @mock.patch(\"os.path.exists\", autospec=True)\n    def test_env_variable_file_does_not_exist(self, mock_path_exists):\n        mock_path_exists.return_value = False\n        returned_path = _mtls_helper._get_cert_config_path()\n        assert returned_path is None\n\n    @mock.patch.dict(\n        os.environ, {\"GOOGLE_API_CERTIFICATE_CONFIG\": \"path/to/config/file\"}\n    )\n    @mock.patch(\"os.path.exists\", autospec=True)\n    def test_default_file_does_not_exist(self, mock_path_exists):\n        mock_path_exists.return_value = False\n        returned_path = _mtls_helper._get_cert_config_path()\n        assert returned_path is None\n\n\nclass TestGetClientCertAndKey(object):\n    def test_callback_success(self):\n        callback = mock.Mock()\n        callback.return_value = (pytest.public_cert_bytes, pytest.private_key_bytes)\n\n        found_cert_key, cert, key = _mtls_helper.get_client_cert_and_key(callback)\n        assert found_cert_key\n        assert cert == pytest.public_cert_bytes\n        assert key == pytest.private_key_bytes\n\n    @mock.patch(\n        \"google.auth.transport._mtls_helper.get_client_ssl_credentials\", autospec=True\n    )\n    def test_use_metadata(self, mock_get_client_ssl_credentials):\n        mock_get_client_ssl_credentials.return_value = (\n            True,\n            pytest.public_cert_bytes,\n            pytest.private_key_bytes,\n            None,\n        )\n\n        found_cert_key, cert, key = _mtls_helper.get_client_cert_and_key()\n        assert found_cert_key\n        assert cert == pytest.public_cert_bytes\n        assert key == pytest.private_key_bytes\n\n\nclass TestDecryptPrivateKey(object):\n    def test_success(self):\n        decrypted_key = _mtls_helper.decrypt_private_key(\n            ENCRYPTED_EC_PRIVATE_KEY, PASSPHRASE_VALUE\n        )\n        private_key = crypto.load_privatekey(crypto.FILETYPE_PEM, decrypted_key)\n        public_key = crypto.load_publickey(crypto.FILETYPE_PEM, EC_PUBLIC_KEY)\n        x509 = crypto.X509()\n        x509.set_pubkey(public_key)\n\n        # Test the decrypted key works by signing and verification.\n        signature = crypto.sign(private_key, b\"data\", \"sha256\")\n        crypto.verify(x509, signature, b\"data\", \"sha256\")\n\n    def test_crypto_error(self):\n        with pytest.raises(crypto.Error):\n            _mtls_helper.decrypt_private_key(\n                ENCRYPTED_EC_PRIVATE_KEY, b\"wrong_password\"\n            )\n", "tests/transport/test__http_client.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport pytest  # type: ignore\n\nfrom google.auth import exceptions\nimport google.auth.transport._http_client\nfrom tests.transport import compliance\n\n\nclass TestRequestResponse(compliance.RequestResponseTests):\n    def make_request(self):\n        return google.auth.transport._http_client.Request()\n\n    def test_non_http(self):\n        request = self.make_request()\n        with pytest.raises(exceptions.TransportError) as excinfo:\n            request(url=\"https://{}\".format(compliance.NXDOMAIN), method=\"GET\")\n\n        assert excinfo.match(\"https\")\n", "tests/transport/test_grpc.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport datetime\nimport os\nimport time\n\nimport mock\nimport pytest  # type: ignore\n\nfrom google.auth import _helpers\nfrom google.auth import credentials\nfrom google.auth import environment_vars\nfrom google.auth import exceptions\nfrom google.auth import transport\nfrom google.oauth2 import service_account\n\ntry:\n    # pylint: disable=ungrouped-imports\n    import grpc  # type: ignore\n    import google.auth.transport.grpc\n\n    HAS_GRPC = True\nexcept ImportError:  # pragma: NO COVER\n    HAS_GRPC = False\n\nDATA_DIR = os.path.join(os.path.dirname(__file__), \"..\", \"data\")\nMETADATA_PATH = os.path.join(DATA_DIR, \"context_aware_metadata.json\")\nwith open(os.path.join(DATA_DIR, \"privatekey.pem\"), \"rb\") as fh:\n    PRIVATE_KEY_BYTES = fh.read()\nwith open(os.path.join(DATA_DIR, \"public_cert.pem\"), \"rb\") as fh:\n    PUBLIC_CERT_BYTES = fh.read()\n\npytestmark = pytest.mark.skipif(not HAS_GRPC, reason=\"gRPC is unavailable.\")\n\n\nclass CredentialsStub(credentials.Credentials):\n    def __init__(self, token=\"token\"):\n        super(CredentialsStub, self).__init__()\n        self.token = token\n        self.expiry = None\n\n    def refresh(self, request):\n        self.token += \"1\"\n\n    def with_quota_project(self, quota_project_id):\n        raise NotImplementedError()\n\n\nclass TestAuthMetadataPlugin(object):\n    def test_call_no_refresh(self):\n        credentials = CredentialsStub()\n        request = mock.create_autospec(transport.Request)\n\n        plugin = google.auth.transport.grpc.AuthMetadataPlugin(credentials, request)\n\n        context = mock.create_autospec(grpc.AuthMetadataContext, instance=True)\n        context.method_name = mock.sentinel.method_name\n        context.service_url = mock.sentinel.service_url\n        callback = mock.create_autospec(grpc.AuthMetadataPluginCallback)\n\n        plugin(context, callback)\n\n        time.sleep(2)\n\n        callback.assert_called_once_with(\n            [(\"authorization\", \"Bearer {}\".format(credentials.token))], None\n        )\n\n    def test_call_refresh(self):\n        credentials = CredentialsStub()\n        credentials.expiry = datetime.datetime.min + _helpers.REFRESH_THRESHOLD\n        request = mock.create_autospec(transport.Request)\n\n        plugin = google.auth.transport.grpc.AuthMetadataPlugin(credentials, request)\n\n        context = mock.create_autospec(grpc.AuthMetadataContext, instance=True)\n        context.method_name = mock.sentinel.method_name\n        context.service_url = mock.sentinel.service_url\n        callback = mock.create_autospec(grpc.AuthMetadataPluginCallback)\n\n        plugin(context, callback)\n\n        time.sleep(2)\n\n        assert credentials.token == \"token1\"\n        callback.assert_called_once_with(\n            [(\"authorization\", \"Bearer {}\".format(credentials.token))], None\n        )\n\n    def test__get_authorization_headers_with_service_account(self):\n        credentials = mock.create_autospec(service_account.Credentials)\n        request = mock.create_autospec(transport.Request)\n\n        plugin = google.auth.transport.grpc.AuthMetadataPlugin(credentials, request)\n\n        context = mock.create_autospec(grpc.AuthMetadataContext, instance=True)\n        context.method_name = \"methodName\"\n        context.service_url = \"https://pubsub.googleapis.com/methodName\"\n\n        plugin._get_authorization_headers(context)\n\n        credentials._create_self_signed_jwt.assert_called_once_with(None)\n\n    def test__get_authorization_headers_with_service_account_and_default_host(self):\n        credentials = mock.create_autospec(service_account.Credentials)\n        request = mock.create_autospec(transport.Request)\n\n        default_host = \"pubsub.googleapis.com\"\n        plugin = google.auth.transport.grpc.AuthMetadataPlugin(\n            credentials, request, default_host=default_host\n        )\n\n        context = mock.create_autospec(grpc.AuthMetadataContext, instance=True)\n        context.method_name = \"methodName\"\n        context.service_url = \"https://pubsub.googleapis.com/methodName\"\n\n        plugin._get_authorization_headers(context)\n\n        credentials._create_self_signed_jwt.assert_called_once_with(\n            \"https://{}/\".format(default_host)\n        )\n\n\n@mock.patch(\n    \"google.auth.transport._mtls_helper.get_client_ssl_credentials\", autospec=True\n)\n@mock.patch(\"grpc.composite_channel_credentials\", autospec=True)\n@mock.patch(\"grpc.metadata_call_credentials\", autospec=True)\n@mock.patch(\"grpc.ssl_channel_credentials\", autospec=True)\n@mock.patch(\"grpc.secure_channel\", autospec=True)\nclass TestSecureAuthorizedChannel(object):\n    @mock.patch(\"google.auth.transport._mtls_helper._load_json_file\", autospec=True)\n    @mock.patch(\n        \"google.auth.transport._mtls_helper._check_dca_metadata_path\", autospec=True\n    )\n    def test_secure_authorized_channel_adc(\n        self,\n        check_dca_metadata_path,\n        load_json_file,\n        secure_channel,\n        ssl_channel_credentials,\n        metadata_call_credentials,\n        composite_channel_credentials,\n        get_client_ssl_credentials,\n    ):\n        credentials = CredentialsStub()\n        request = mock.create_autospec(transport.Request)\n        target = \"example.com:80\"\n\n        # Mock the context aware metadata and client cert/key so mTLS SSL channel\n        # will be used.\n        check_dca_metadata_path.return_value = METADATA_PATH\n        load_json_file.return_value = {\"cert_provider_command\": [\"some command\"]}\n        get_client_ssl_credentials.return_value = (\n            True,\n            PUBLIC_CERT_BYTES,\n            PRIVATE_KEY_BYTES,\n            None,\n        )\n\n        channel = None\n        with mock.patch.dict(\n            os.environ, {environment_vars.GOOGLE_API_USE_CLIENT_CERTIFICATE: \"true\"}\n        ):\n            channel = google.auth.transport.grpc.secure_authorized_channel(\n                credentials, request, target, options=mock.sentinel.options\n            )\n\n        # Check the auth plugin construction.\n        auth_plugin = metadata_call_credentials.call_args[0][0]\n        assert isinstance(auth_plugin, google.auth.transport.grpc.AuthMetadataPlugin)\n        assert auth_plugin._credentials == credentials\n        assert auth_plugin._request == request\n\n        # Check the ssl channel call.\n        ssl_channel_credentials.assert_called_once_with(\n            certificate_chain=PUBLIC_CERT_BYTES, private_key=PRIVATE_KEY_BYTES\n        )\n\n        # Check the composite credentials call.\n        composite_channel_credentials.assert_called_once_with(\n            ssl_channel_credentials.return_value, metadata_call_credentials.return_value\n        )\n\n        # Check the channel call.\n        secure_channel.assert_called_once_with(\n            target,\n            composite_channel_credentials.return_value,\n            options=mock.sentinel.options,\n        )\n        assert channel == secure_channel.return_value\n\n    @mock.patch(\"google.auth.transport.grpc.SslCredentials\", autospec=True)\n    def test_secure_authorized_channel_adc_without_client_cert_env(\n        self,\n        ssl_credentials_adc_method,\n        secure_channel,\n        ssl_channel_credentials,\n        metadata_call_credentials,\n        composite_channel_credentials,\n        get_client_ssl_credentials,\n    ):\n        # Test client cert won't be used if GOOGLE_API_USE_CLIENT_CERTIFICATE\n        # environment variable is not set.\n        credentials = CredentialsStub()\n        request = mock.create_autospec(transport.Request)\n        target = \"example.com:80\"\n\n        channel = google.auth.transport.grpc.secure_authorized_channel(\n            credentials, request, target, options=mock.sentinel.options\n        )\n\n        # Check the auth plugin construction.\n        auth_plugin = metadata_call_credentials.call_args[0][0]\n        assert isinstance(auth_plugin, google.auth.transport.grpc.AuthMetadataPlugin)\n        assert auth_plugin._credentials == credentials\n        assert auth_plugin._request == request\n\n        # Check the ssl channel call.\n        ssl_channel_credentials.assert_called_once()\n        ssl_credentials_adc_method.assert_not_called()\n\n        # Check the composite credentials call.\n        composite_channel_credentials.assert_called_once_with(\n            ssl_channel_credentials.return_value, metadata_call_credentials.return_value\n        )\n\n        # Check the channel call.\n        secure_channel.assert_called_once_with(\n            target,\n            composite_channel_credentials.return_value,\n            options=mock.sentinel.options,\n        )\n        assert channel == secure_channel.return_value\n\n    def test_secure_authorized_channel_explicit_ssl(\n        self,\n        secure_channel,\n        ssl_channel_credentials,\n        metadata_call_credentials,\n        composite_channel_credentials,\n        get_client_ssl_credentials,\n    ):\n        credentials = mock.Mock()\n        request = mock.Mock()\n        target = \"example.com:80\"\n        ssl_credentials = mock.Mock()\n\n        google.auth.transport.grpc.secure_authorized_channel(\n            credentials, request, target, ssl_credentials=ssl_credentials\n        )\n\n        # Since explicit SSL credentials are provided, get_client_ssl_credentials\n        # shouldn't be called.\n        assert not get_client_ssl_credentials.called\n\n        # Check the ssl channel call.\n        assert not ssl_channel_credentials.called\n\n        # Check the composite credentials call.\n        composite_channel_credentials.assert_called_once_with(\n            ssl_credentials, metadata_call_credentials.return_value\n        )\n\n    def test_secure_authorized_channel_mutual_exclusive(\n        self,\n        secure_channel,\n        ssl_channel_credentials,\n        metadata_call_credentials,\n        composite_channel_credentials,\n        get_client_ssl_credentials,\n    ):\n        credentials = mock.Mock()\n        request = mock.Mock()\n        target = \"example.com:80\"\n        ssl_credentials = mock.Mock()\n        client_cert_callback = mock.Mock()\n\n        with pytest.raises(ValueError):\n            google.auth.transport.grpc.secure_authorized_channel(\n                credentials,\n                request,\n                target,\n                ssl_credentials=ssl_credentials,\n                client_cert_callback=client_cert_callback,\n            )\n\n    def test_secure_authorized_channel_with_client_cert_callback_success(\n        self,\n        secure_channel,\n        ssl_channel_credentials,\n        metadata_call_credentials,\n        composite_channel_credentials,\n        get_client_ssl_credentials,\n    ):\n        credentials = mock.Mock()\n        request = mock.Mock()\n        target = \"example.com:80\"\n        client_cert_callback = mock.Mock()\n        client_cert_callback.return_value = (PUBLIC_CERT_BYTES, PRIVATE_KEY_BYTES)\n\n        with mock.patch.dict(\n            os.environ, {environment_vars.GOOGLE_API_USE_CLIENT_CERTIFICATE: \"true\"}\n        ):\n            google.auth.transport.grpc.secure_authorized_channel(\n                credentials, request, target, client_cert_callback=client_cert_callback\n            )\n\n        client_cert_callback.assert_called_once()\n\n        # Check we are using the cert and key provided by client_cert_callback.\n        ssl_channel_credentials.assert_called_once_with(\n            certificate_chain=PUBLIC_CERT_BYTES, private_key=PRIVATE_KEY_BYTES\n        )\n\n        # Check the composite credentials call.\n        composite_channel_credentials.assert_called_once_with(\n            ssl_channel_credentials.return_value, metadata_call_credentials.return_value\n        )\n\n    @mock.patch(\"google.auth.transport._mtls_helper._load_json_file\", autospec=True)\n    @mock.patch(\n        \"google.auth.transport._mtls_helper._check_dca_metadata_path\", autospec=True\n    )\n    def test_secure_authorized_channel_with_client_cert_callback_failure(\n        self,\n        check_dca_metadata_path,\n        load_json_file,\n        secure_channel,\n        ssl_channel_credentials,\n        metadata_call_credentials,\n        composite_channel_credentials,\n        get_client_ssl_credentials,\n    ):\n        credentials = mock.Mock()\n        request = mock.Mock()\n        target = \"example.com:80\"\n\n        client_cert_callback = mock.Mock()\n        client_cert_callback.side_effect = Exception(\"callback exception\")\n\n        with pytest.raises(Exception) as excinfo:\n            with mock.patch.dict(\n                os.environ, {environment_vars.GOOGLE_API_USE_CLIENT_CERTIFICATE: \"true\"}\n            ):\n                google.auth.transport.grpc.secure_authorized_channel(\n                    credentials,\n                    request,\n                    target,\n                    client_cert_callback=client_cert_callback,\n                )\n\n        assert str(excinfo.value) == \"callback exception\"\n\n    def test_secure_authorized_channel_cert_callback_without_client_cert_env(\n        self,\n        secure_channel,\n        ssl_channel_credentials,\n        metadata_call_credentials,\n        composite_channel_credentials,\n        get_client_ssl_credentials,\n    ):\n        # Test client cert won't be used if GOOGLE_API_USE_CLIENT_CERTIFICATE\n        # environment variable is not set.\n        credentials = mock.Mock()\n        request = mock.Mock()\n        target = \"example.com:80\"\n        client_cert_callback = mock.Mock()\n\n        google.auth.transport.grpc.secure_authorized_channel(\n            credentials, request, target, client_cert_callback=client_cert_callback\n        )\n\n        # Check client_cert_callback is not called because GOOGLE_API_USE_CLIENT_CERTIFICATE\n        # is not set.\n        client_cert_callback.assert_not_called()\n\n        ssl_channel_credentials.assert_called_once()\n\n        # Check the composite credentials call.\n        composite_channel_credentials.assert_called_once_with(\n            ssl_channel_credentials.return_value, metadata_call_credentials.return_value\n        )\n\n\n@mock.patch(\"grpc.ssl_channel_credentials\", autospec=True)\n@mock.patch(\n    \"google.auth.transport._mtls_helper.get_client_ssl_credentials\", autospec=True\n)\n@mock.patch(\"google.auth.transport._mtls_helper._load_json_file\", autospec=True)\n@mock.patch(\n    \"google.auth.transport._mtls_helper._check_dca_metadata_path\", autospec=True\n)\nclass TestSslCredentials(object):\n    def test_no_context_aware_metadata(\n        self,\n        mock_check_dca_metadata_path,\n        mock_load_json_file,\n        mock_get_client_ssl_credentials,\n        mock_ssl_channel_credentials,\n    ):\n        # Mock that the metadata file doesn't exist.\n        mock_check_dca_metadata_path.return_value = None\n\n        with mock.patch.dict(\n            os.environ, {environment_vars.GOOGLE_API_USE_CLIENT_CERTIFICATE: \"true\"}\n        ):\n            ssl_credentials = google.auth.transport.grpc.SslCredentials()\n\n        # Since no context aware metadata is found, we wouldn't call\n        # get_client_ssl_credentials, and the SSL channel credentials created is\n        # non mTLS.\n        assert ssl_credentials.ssl_credentials is not None\n        assert not ssl_credentials.is_mtls\n        mock_get_client_ssl_credentials.assert_not_called()\n        mock_ssl_channel_credentials.assert_called_once_with()\n\n    def test_get_client_ssl_credentials_failure(\n        self,\n        mock_check_dca_metadata_path,\n        mock_load_json_file,\n        mock_get_client_ssl_credentials,\n        mock_ssl_channel_credentials,\n    ):\n        mock_check_dca_metadata_path.return_value = METADATA_PATH\n        mock_load_json_file.return_value = {\"cert_provider_command\": [\"some command\"]}\n\n        # Mock that client cert and key are not loaded and exception is raised.\n        mock_get_client_ssl_credentials.side_effect = exceptions.ClientCertError()\n\n        with pytest.raises(exceptions.MutualTLSChannelError):\n            with mock.patch.dict(\n                os.environ, {environment_vars.GOOGLE_API_USE_CLIENT_CERTIFICATE: \"true\"}\n            ):\n                assert google.auth.transport.grpc.SslCredentials().ssl_credentials\n\n    def test_get_client_ssl_credentials_success(\n        self,\n        mock_check_dca_metadata_path,\n        mock_load_json_file,\n        mock_get_client_ssl_credentials,\n        mock_ssl_channel_credentials,\n    ):\n        mock_check_dca_metadata_path.return_value = METADATA_PATH\n        mock_load_json_file.return_value = {\"cert_provider_command\": [\"some command\"]}\n        mock_get_client_ssl_credentials.return_value = (\n            True,\n            PUBLIC_CERT_BYTES,\n            PRIVATE_KEY_BYTES,\n            None,\n        )\n\n        with mock.patch.dict(\n            os.environ, {environment_vars.GOOGLE_API_USE_CLIENT_CERTIFICATE: \"true\"}\n        ):\n            ssl_credentials = google.auth.transport.grpc.SslCredentials()\n\n        assert ssl_credentials.ssl_credentials is not None\n        assert ssl_credentials.is_mtls\n        mock_get_client_ssl_credentials.assert_called_once()\n        mock_ssl_channel_credentials.assert_called_once_with(\n            certificate_chain=PUBLIC_CERT_BYTES, private_key=PRIVATE_KEY_BYTES\n        )\n\n    def test_get_client_ssl_credentials_without_client_cert_env(\n        self,\n        mock_check_dca_metadata_path,\n        mock_load_json_file,\n        mock_get_client_ssl_credentials,\n        mock_ssl_channel_credentials,\n    ):\n        # Test client cert won't be used if GOOGLE_API_USE_CLIENT_CERTIFICATE is not set.\n        ssl_credentials = google.auth.transport.grpc.SslCredentials()\n\n        assert ssl_credentials.ssl_credentials is not None\n        assert not ssl_credentials.is_mtls\n        mock_check_dca_metadata_path.assert_not_called()\n        mock_load_json_file.assert_not_called()\n        mock_get_client_ssl_credentials.assert_not_called()\n        mock_ssl_channel_credentials.assert_called_once()\n", "tests/transport/test_mtls.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport mock\nimport pytest  # type: ignore\n\nfrom google.auth import exceptions\nfrom google.auth.transport import mtls\n\n\n@mock.patch(\n    \"google.auth.transport._mtls_helper._check_dca_metadata_path\", autospec=True\n)\ndef test_has_default_client_cert_source(check_dca_metadata_path):\n    check_dca_metadata_path.return_value = mock.Mock()\n    assert mtls.has_default_client_cert_source()\n\n    check_dca_metadata_path.return_value = None\n    assert not mtls.has_default_client_cert_source()\n\n\n@mock.patch(\"google.auth.transport._mtls_helper.get_client_cert_and_key\", autospec=True)\n@mock.patch(\"google.auth.transport.mtls.has_default_client_cert_source\", autospec=True)\ndef test_default_client_cert_source(\n    has_default_client_cert_source, get_client_cert_and_key\n):\n    # Test default client cert source doesn't exist.\n    has_default_client_cert_source.return_value = False\n    with pytest.raises(exceptions.MutualTLSChannelError):\n        mtls.default_client_cert_source()\n\n    # The following tests will assume default client cert source exists.\n    has_default_client_cert_source.return_value = True\n\n    # Test good callback.\n    get_client_cert_and_key.return_value = (True, b\"cert\", b\"key\")\n    callback = mtls.default_client_cert_source()\n    assert callback() == (b\"cert\", b\"key\")\n\n    # Test bad callback which throws exception.\n    get_client_cert_and_key.side_effect = ValueError()\n    callback = mtls.default_client_cert_source()\n    with pytest.raises(exceptions.MutualTLSChannelError):\n        callback()\n\n\n@mock.patch(\n    \"google.auth.transport._mtls_helper.get_client_ssl_credentials\", autospec=True\n)\n@mock.patch(\"google.auth.transport.mtls.has_default_client_cert_source\", autospec=True)\ndef test_default_client_encrypted_cert_source(\n    has_default_client_cert_source, get_client_ssl_credentials\n):\n    # Test default client cert source doesn't exist.\n    has_default_client_cert_source.return_value = False\n    with pytest.raises(exceptions.MutualTLSChannelError):\n        mtls.default_client_encrypted_cert_source(\"cert_path\", \"key_path\")\n\n    # The following tests will assume default client cert source exists.\n    has_default_client_cert_source.return_value = True\n\n    # Test good callback.\n    get_client_ssl_credentials.return_value = (True, b\"cert\", b\"key\", b\"passphrase\")\n    callback = mtls.default_client_encrypted_cert_source(\"cert_path\", \"key_path\")\n    with mock.patch(\"{}.open\".format(__name__), return_value=mock.MagicMock()):\n        assert callback() == (\"cert_path\", \"key_path\", b\"passphrase\")\n\n    # Test bad callback which throws exception.\n    get_client_ssl_credentials.side_effect = exceptions.ClientCertError()\n    callback = mtls.default_client_encrypted_cert_source(\"cert_path\", \"key_path\")\n    with pytest.raises(exceptions.MutualTLSChannelError):\n        callback()\n", "tests/transport/test_requests.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport datetime\nimport functools\nimport http.client as http_client\nimport os\nimport sys\n\nimport freezegun\nimport mock\nimport OpenSSL\nimport pytest  # type: ignore\nimport requests\nimport requests.adapters\n\nfrom google.auth import environment_vars\nfrom google.auth import exceptions\nimport google.auth.credentials\nimport google.auth.transport._custom_tls_signer\nimport google.auth.transport._mtls_helper\nimport google.auth.transport.requests\nfrom google.oauth2 import service_account\nfrom tests.transport import compliance\n\n\n@pytest.fixture\ndef frozen_time():\n    with freezegun.freeze_time(\"1970-01-01 00:00:00\", tick=False) as frozen:\n        yield frozen\n\n\nclass TestRequestResponse(compliance.RequestResponseTests):\n    def make_request(self):\n        return google.auth.transport.requests.Request()\n\n    def test_timeout(self):\n        http = mock.create_autospec(requests.Session, instance=True)\n        request = google.auth.transport.requests.Request(http)\n        request(url=\"http://example.com\", method=\"GET\", timeout=5)\n\n        assert http.request.call_args[1][\"timeout\"] == 5\n\n    def test_session_closed_on_del(self):\n        http = mock.create_autospec(requests.Session, instance=True)\n        request = google.auth.transport.requests.Request(http)\n        request.__del__()\n        http.close.assert_called_with()\n\n        http = mock.create_autospec(requests.Session, instance=True)\n        http.close.side_effect = TypeError(\"test injected TypeError\")\n        request = google.auth.transport.requests.Request(http)\n        request.__del__()\n        http.close.assert_called_with()\n\n\nclass TestTimeoutGuard(object):\n    def make_guard(self, *args, **kwargs):\n        return google.auth.transport.requests.TimeoutGuard(*args, **kwargs)\n\n    def test_tracks_elapsed_time_w_numeric_timeout(self, frozen_time):\n        with self.make_guard(timeout=10) as guard:\n            frozen_time.tick(delta=datetime.timedelta(seconds=3.8))\n        assert guard.remaining_timeout == 6.2\n\n    def test_tracks_elapsed_time_w_tuple_timeout(self, frozen_time):\n        with self.make_guard(timeout=(16, 19)) as guard:\n            frozen_time.tick(delta=datetime.timedelta(seconds=3.8))\n        assert guard.remaining_timeout == (12.2, 15.2)\n\n    def test_noop_if_no_timeout(self, frozen_time):\n        with self.make_guard(timeout=None) as guard:\n            frozen_time.tick(delta=datetime.timedelta(days=3650))\n        # NOTE: no timeout error raised, despite years have passed\n        assert guard.remaining_timeout is None\n\n    def test_timeout_error_w_numeric_timeout(self, frozen_time):\n        with pytest.raises(requests.exceptions.Timeout):\n            with self.make_guard(timeout=10) as guard:\n                frozen_time.tick(delta=datetime.timedelta(seconds=10.001))\n        assert guard.remaining_timeout == pytest.approx(-0.001)\n\n    def test_timeout_error_w_tuple_timeout(self, frozen_time):\n        with pytest.raises(requests.exceptions.Timeout):\n            with self.make_guard(timeout=(11, 10)) as guard:\n                frozen_time.tick(delta=datetime.timedelta(seconds=10.001))\n        assert guard.remaining_timeout == pytest.approx((0.999, -0.001))\n\n    def test_custom_timeout_error_type(self, frozen_time):\n        class FooError(Exception):\n            pass\n\n        with pytest.raises(FooError):\n            with self.make_guard(timeout=1, timeout_error_type=FooError):\n                frozen_time.tick(delta=datetime.timedelta(seconds=2))\n\n    def test_lets_suite_errors_bubble_up(self, frozen_time):\n        with pytest.raises(IndexError):\n            with self.make_guard(timeout=1):\n                [1, 2, 3][3]\n\n\nclass CredentialsStub(google.auth.credentials.Credentials):\n    def __init__(self, token=\"token\"):\n        super(CredentialsStub, self).__init__()\n        self.token = token\n\n    def apply(self, headers, token=None):\n        headers[\"authorization\"] = self.token\n\n    def before_request(self, request, method, url, headers):\n        self.apply(headers)\n\n    def refresh(self, request):\n        self.token += \"1\"\n\n    def with_quota_project(self, quota_project_id):\n        raise NotImplementedError()\n\n\nclass TimeTickCredentialsStub(CredentialsStub):\n    \"\"\"Credentials that spend some (mocked) time when refreshing a token.\"\"\"\n\n    def __init__(self, time_tick, token=\"token\"):\n        self._time_tick = time_tick\n        super(TimeTickCredentialsStub, self).__init__(token=token)\n\n    def refresh(self, request):\n        self._time_tick()\n        super(TimeTickCredentialsStub, self).refresh(requests)\n\n\nclass AdapterStub(requests.adapters.BaseAdapter):\n    def __init__(self, responses, headers=None):\n        super(AdapterStub, self).__init__()\n        self.responses = responses\n        self.requests = []\n        self.headers = headers or {}\n\n    def send(self, request, **kwargs):\n        # pylint: disable=arguments-differ\n        # request is the only required argument here and the only argument\n        # we care about.\n        self.requests.append(request)\n        return self.responses.pop(0)\n\n    def close(self):  # pragma: NO COVER\n        # pylint wants this to be here because it's abstract in the base\n        # class, but requests never actually calls it.\n        return\n\n\nclass TimeTickAdapterStub(AdapterStub):\n    \"\"\"Adapter that spends some (mocked) time when making a request.\"\"\"\n\n    def __init__(self, time_tick, responses, headers=None):\n        self._time_tick = time_tick\n        super(TimeTickAdapterStub, self).__init__(responses, headers=headers)\n\n    def send(self, request, **kwargs):\n        self._time_tick()\n        return super(TimeTickAdapterStub, self).send(request, **kwargs)\n\n\nclass TestMutualTlsAdapter(object):\n    @mock.patch.object(requests.adapters.HTTPAdapter, \"init_poolmanager\")\n    @mock.patch.object(requests.adapters.HTTPAdapter, \"proxy_manager_for\")\n    def test_success(self, mock_proxy_manager_for, mock_init_poolmanager):\n        adapter = google.auth.transport.requests._MutualTlsAdapter(\n            pytest.public_cert_bytes, pytest.private_key_bytes\n        )\n\n        adapter.init_poolmanager()\n        mock_init_poolmanager.assert_called_with(ssl_context=adapter._ctx_poolmanager)\n\n        adapter.proxy_manager_for()\n        mock_proxy_manager_for.assert_called_with(ssl_context=adapter._ctx_proxymanager)\n\n    def test_invalid_cert_or_key(self):\n        with pytest.raises(OpenSSL.crypto.Error):\n            google.auth.transport.requests._MutualTlsAdapter(\n                b\"invalid cert\", b\"invalid key\"\n            )\n\n    @mock.patch.dict(\"sys.modules\", {\"OpenSSL.crypto\": None})\n    def test_import_error(self):\n        with pytest.raises(ImportError):\n            google.auth.transport.requests._MutualTlsAdapter(\n                pytest.public_cert_bytes, pytest.private_key_bytes\n            )\n\n\ndef make_response(status=http_client.OK, data=None):\n    response = requests.Response()\n    response.status_code = status\n    response._content = data\n    return response\n\n\nclass TestAuthorizedSession(object):\n    TEST_URL = \"http://example.com/\"\n\n    def test_constructor(self):\n        authed_session = google.auth.transport.requests.AuthorizedSession(\n            mock.sentinel.credentials\n        )\n\n        assert authed_session.credentials == mock.sentinel.credentials\n\n    def test_constructor_with_auth_request(self):\n        http = mock.create_autospec(requests.Session)\n        auth_request = google.auth.transport.requests.Request(http)\n\n        authed_session = google.auth.transport.requests.AuthorizedSession(\n            mock.sentinel.credentials, auth_request=auth_request\n        )\n\n        assert authed_session._auth_request is auth_request\n\n    def test_request_default_timeout(self):\n        credentials = mock.Mock(wraps=CredentialsStub())\n        response = make_response()\n        adapter = AdapterStub([response])\n\n        authed_session = google.auth.transport.requests.AuthorizedSession(credentials)\n        authed_session.mount(self.TEST_URL, adapter)\n\n        patcher = mock.patch(\"google.auth.transport.requests.requests.Session.request\")\n        with patcher as patched_request:\n            authed_session.request(\"GET\", self.TEST_URL)\n\n        expected_timeout = google.auth.transport.requests._DEFAULT_TIMEOUT\n        assert patched_request.call_args[1][\"timeout\"] == expected_timeout\n\n    def test_request_no_refresh(self):\n        credentials = mock.Mock(wraps=CredentialsStub())\n        response = make_response()\n        adapter = AdapterStub([response])\n\n        authed_session = google.auth.transport.requests.AuthorizedSession(credentials)\n        authed_session.mount(self.TEST_URL, adapter)\n\n        result = authed_session.request(\"GET\", self.TEST_URL)\n\n        assert response == result\n        assert credentials.before_request.called\n        assert not credentials.refresh.called\n        assert len(adapter.requests) == 1\n        assert adapter.requests[0].url == self.TEST_URL\n        assert adapter.requests[0].headers[\"authorization\"] == \"token\"\n\n    def test_request_refresh(self):\n        credentials = mock.Mock(wraps=CredentialsStub())\n        final_response = make_response(status=http_client.OK)\n        # First request will 401, second request will succeed.\n        adapter = AdapterStub(\n            [make_response(status=http_client.UNAUTHORIZED), final_response]\n        )\n\n        authed_session = google.auth.transport.requests.AuthorizedSession(\n            credentials, refresh_timeout=60\n        )\n        authed_session.mount(self.TEST_URL, adapter)\n\n        result = authed_session.request(\"GET\", self.TEST_URL)\n\n        assert result == final_response\n        assert credentials.before_request.call_count == 2\n        assert credentials.refresh.called\n        assert len(adapter.requests) == 2\n\n        assert adapter.requests[0].url == self.TEST_URL\n        assert adapter.requests[0].headers[\"authorization\"] == \"token\"\n\n        assert adapter.requests[1].url == self.TEST_URL\n        assert adapter.requests[1].headers[\"authorization\"] == \"token1\"\n\n    def test_request_max_allowed_time_timeout_error(self, frozen_time):\n        tick_one_second = functools.partial(\n            frozen_time.tick, delta=datetime.timedelta(seconds=1.0)\n        )\n\n        credentials = mock.Mock(\n            wraps=TimeTickCredentialsStub(time_tick=tick_one_second)\n        )\n        adapter = TimeTickAdapterStub(\n            time_tick=tick_one_second, responses=[make_response(status=http_client.OK)]\n        )\n\n        authed_session = google.auth.transport.requests.AuthorizedSession(credentials)\n        authed_session.mount(self.TEST_URL, adapter)\n\n        # Because a request takes a full mocked second, max_allowed_time shorter\n        # than that will cause a timeout error.\n        with pytest.raises(requests.exceptions.Timeout):\n            authed_session.request(\"GET\", self.TEST_URL, max_allowed_time=0.9)\n\n    def test_request_max_allowed_time_w_transport_timeout_no_error(self, frozen_time):\n        tick_one_second = functools.partial(\n            frozen_time.tick, delta=datetime.timedelta(seconds=1.0)\n        )\n\n        credentials = mock.Mock(\n            wraps=TimeTickCredentialsStub(time_tick=tick_one_second)\n        )\n        adapter = TimeTickAdapterStub(\n            time_tick=tick_one_second,\n            responses=[\n                make_response(status=http_client.UNAUTHORIZED),\n                make_response(status=http_client.OK),\n            ],\n        )\n\n        authed_session = google.auth.transport.requests.AuthorizedSession(credentials)\n        authed_session.mount(self.TEST_URL, adapter)\n\n        # A short configured transport timeout does not affect max_allowed_time.\n        # The latter is not adjusted to it and is only concerned with the actual\n        # execution time. The call below should thus not raise a timeout error.\n        authed_session.request(\"GET\", self.TEST_URL, timeout=0.5, max_allowed_time=3.1)\n\n    def test_request_max_allowed_time_w_refresh_timeout_no_error(self, frozen_time):\n        tick_one_second = functools.partial(\n            frozen_time.tick, delta=datetime.timedelta(seconds=1.0)\n        )\n\n        credentials = mock.Mock(\n            wraps=TimeTickCredentialsStub(time_tick=tick_one_second)\n        )\n        adapter = TimeTickAdapterStub(\n            time_tick=tick_one_second,\n            responses=[\n                make_response(status=http_client.UNAUTHORIZED),\n                make_response(status=http_client.OK),\n            ],\n        )\n\n        authed_session = google.auth.transport.requests.AuthorizedSession(\n            credentials, refresh_timeout=1.1\n        )\n        authed_session.mount(self.TEST_URL, adapter)\n\n        # A short configured refresh timeout does not affect max_allowed_time.\n        # The latter is not adjusted to it and is only concerned with the actual\n        # execution time. The call below should thus not raise a timeout error\n        # (and `timeout` does not come into play either, as it's very long).\n        authed_session.request(\"GET\", self.TEST_URL, timeout=60, max_allowed_time=3.1)\n\n    def test_request_timeout_w_refresh_timeout_timeout_error(self, frozen_time):\n        tick_one_second = functools.partial(\n            frozen_time.tick, delta=datetime.timedelta(seconds=1.0)\n        )\n\n        credentials = mock.Mock(\n            wraps=TimeTickCredentialsStub(time_tick=tick_one_second)\n        )\n        adapter = TimeTickAdapterStub(\n            time_tick=tick_one_second,\n            responses=[\n                make_response(status=http_client.UNAUTHORIZED),\n                make_response(status=http_client.OK),\n            ],\n        )\n\n        authed_session = google.auth.transport.requests.AuthorizedSession(\n            credentials, refresh_timeout=100\n        )\n        authed_session.mount(self.TEST_URL, adapter)\n\n        # An UNAUTHORIZED response triggers a refresh (an extra request), thus\n        # the final request that otherwise succeeds results in a timeout error\n        # (all three requests together last 3 mocked seconds).\n        with pytest.raises(requests.exceptions.Timeout):\n            authed_session.request(\n                \"GET\", self.TEST_URL, timeout=60, max_allowed_time=2.9\n            )\n\n    def test_authorized_session_without_default_host(self):\n        credentials = mock.create_autospec(service_account.Credentials)\n\n        authed_session = google.auth.transport.requests.AuthorizedSession(credentials)\n\n        authed_session.credentials._create_self_signed_jwt.assert_called_once_with(None)\n\n    def test_authorized_session_with_default_host(self):\n        default_host = \"pubsub.googleapis.com\"\n        credentials = mock.create_autospec(service_account.Credentials)\n\n        authed_session = google.auth.transport.requests.AuthorizedSession(\n            credentials, default_host=default_host\n        )\n\n        authed_session.credentials._create_self_signed_jwt.assert_called_once_with(\n            \"https://{}/\".format(default_host)\n        )\n\n    def test_configure_mtls_channel_with_callback(self):\n        mock_callback = mock.Mock()\n        mock_callback.return_value = (\n            pytest.public_cert_bytes,\n            pytest.private_key_bytes,\n        )\n\n        auth_session = google.auth.transport.requests.AuthorizedSession(\n            credentials=mock.Mock()\n        )\n        with mock.patch.dict(\n            os.environ, {environment_vars.GOOGLE_API_USE_CLIENT_CERTIFICATE: \"true\"}\n        ):\n            auth_session.configure_mtls_channel(mock_callback)\n\n        assert auth_session.is_mtls\n        assert isinstance(\n            auth_session.adapters[\"https://\"],\n            google.auth.transport.requests._MutualTlsAdapter,\n        )\n\n    @mock.patch(\n        \"google.auth.transport._mtls_helper.get_client_cert_and_key\", autospec=True\n    )\n    def test_configure_mtls_channel_with_metadata(self, mock_get_client_cert_and_key):\n        mock_get_client_cert_and_key.return_value = (\n            True,\n            pytest.public_cert_bytes,\n            pytest.private_key_bytes,\n        )\n\n        auth_session = google.auth.transport.requests.AuthorizedSession(\n            credentials=mock.Mock()\n        )\n        with mock.patch.dict(\n            os.environ, {environment_vars.GOOGLE_API_USE_CLIENT_CERTIFICATE: \"true\"}\n        ):\n            auth_session.configure_mtls_channel()\n\n        assert auth_session.is_mtls\n        assert isinstance(\n            auth_session.adapters[\"https://\"],\n            google.auth.transport.requests._MutualTlsAdapter,\n        )\n\n    @mock.patch.object(google.auth.transport.requests._MutualTlsAdapter, \"__init__\")\n    @mock.patch(\n        \"google.auth.transport._mtls_helper.get_client_cert_and_key\", autospec=True\n    )\n    def test_configure_mtls_channel_non_mtls(\n        self, mock_get_client_cert_and_key, mock_adapter_ctor\n    ):\n        mock_get_client_cert_and_key.return_value = (False, None, None)\n\n        auth_session = google.auth.transport.requests.AuthorizedSession(\n            credentials=mock.Mock()\n        )\n        with mock.patch.dict(\n            os.environ, {environment_vars.GOOGLE_API_USE_CLIENT_CERTIFICATE: \"true\"}\n        ):\n            auth_session.configure_mtls_channel()\n\n        assert not auth_session.is_mtls\n\n        # Assert _MutualTlsAdapter constructor is not called.\n        mock_adapter_ctor.assert_not_called()\n\n    @mock.patch(\n        \"google.auth.transport._mtls_helper.get_client_cert_and_key\", autospec=True\n    )\n    def test_configure_mtls_channel_exceptions(self, mock_get_client_cert_and_key):\n        mock_get_client_cert_and_key.side_effect = exceptions.ClientCertError()\n\n        auth_session = google.auth.transport.requests.AuthorizedSession(\n            credentials=mock.Mock()\n        )\n        with pytest.raises(exceptions.MutualTLSChannelError):\n            with mock.patch.dict(\n                os.environ, {environment_vars.GOOGLE_API_USE_CLIENT_CERTIFICATE: \"true\"}\n            ):\n                auth_session.configure_mtls_channel()\n\n        mock_get_client_cert_and_key.return_value = (False, None, None)\n        with mock.patch.dict(\"sys.modules\"):\n            sys.modules[\"OpenSSL\"] = None\n            with pytest.raises(exceptions.MutualTLSChannelError):\n                with mock.patch.dict(\n                    os.environ,\n                    {environment_vars.GOOGLE_API_USE_CLIENT_CERTIFICATE: \"true\"},\n                ):\n                    auth_session.configure_mtls_channel()\n\n    @mock.patch(\n        \"google.auth.transport._mtls_helper.get_client_cert_and_key\", autospec=True\n    )\n    def test_configure_mtls_channel_without_client_cert_env(\n        self, get_client_cert_and_key\n    ):\n        # Test client cert won't be used if GOOGLE_API_USE_CLIENT_CERTIFICATE\n        # environment variable is not set.\n        auth_session = google.auth.transport.requests.AuthorizedSession(\n            credentials=mock.Mock()\n        )\n\n        auth_session.configure_mtls_channel()\n        assert not auth_session.is_mtls\n        get_client_cert_and_key.assert_not_called()\n\n        mock_callback = mock.Mock()\n        auth_session.configure_mtls_channel(mock_callback)\n        assert not auth_session.is_mtls\n        mock_callback.assert_not_called()\n\n    def test_close_wo_passed_in_auth_request(self):\n        authed_session = google.auth.transport.requests.AuthorizedSession(\n            mock.sentinel.credentials\n        )\n        authed_session._auth_request_session = mock.Mock(spec=[\"close\"])\n\n        authed_session.close()\n\n        authed_session._auth_request_session.close.assert_called_once_with()\n\n    def test_close_w_passed_in_auth_request(self):\n        http = mock.create_autospec(requests.Session)\n        auth_request = google.auth.transport.requests.Request(http)\n        authed_session = google.auth.transport.requests.AuthorizedSession(\n            mock.sentinel.credentials, auth_request=auth_request\n        )\n\n        authed_session.close()  # no raise\n\n\nclass TestMutualTlsOffloadAdapter(object):\n    @mock.patch.object(requests.adapters.HTTPAdapter, \"init_poolmanager\")\n    @mock.patch.object(requests.adapters.HTTPAdapter, \"proxy_manager_for\")\n    @mock.patch.object(\n        google.auth.transport._custom_tls_signer.CustomTlsSigner, \"load_libraries\"\n    )\n    @mock.patch.object(\n        google.auth.transport._custom_tls_signer.CustomTlsSigner,\n        \"attach_to_ssl_context\",\n    )\n    def test_success(\n        self,\n        mock_attach_to_ssl_context,\n        mock_load_libraries,\n        mock_proxy_manager_for,\n        mock_init_poolmanager,\n    ):\n        enterprise_cert_file_path = \"/path/to/enterprise/cert/json\"\n        adapter = google.auth.transport.requests._MutualTlsOffloadAdapter(\n            enterprise_cert_file_path\n        )\n\n        mock_load_libraries.assert_called_once()\n        assert mock_attach_to_ssl_context.call_count == 2\n\n        adapter.init_poolmanager()\n        mock_init_poolmanager.assert_called_with(ssl_context=adapter._ctx_poolmanager)\n\n        adapter.proxy_manager_for()\n        mock_proxy_manager_for.assert_called_with(ssl_context=adapter._ctx_proxymanager)\n\n    @mock.patch.object(requests.adapters.HTTPAdapter, \"init_poolmanager\")\n    @mock.patch.object(requests.adapters.HTTPAdapter, \"proxy_manager_for\")\n    @mock.patch.object(\n        google.auth.transport._custom_tls_signer.CustomTlsSigner, \"should_use_provider\"\n    )\n    @mock.patch.object(\n        google.auth.transport._custom_tls_signer.CustomTlsSigner, \"load_libraries\"\n    )\n    @mock.patch.object(\n        google.auth.transport._custom_tls_signer.CustomTlsSigner,\n        \"attach_to_ssl_context\",\n    )\n    def test_success_should_use_provider(\n        self,\n        mock_attach_to_ssl_context,\n        mock_load_libraries,\n        mock_should_use_provider,\n        mock_proxy_manager_for,\n        mock_init_poolmanager,\n    ):\n        enterprise_cert_file_path = \"/path/to/enterprise/cert/json\"\n        adapter = google.auth.transport.requests._MutualTlsOffloadAdapter(\n            enterprise_cert_file_path\n        )\n\n        mock_should_use_provider.side_effect = True\n        mock_load_libraries.assert_called_once()\n        assert mock_attach_to_ssl_context.call_count == 2\n\n        adapter.init_poolmanager()\n        mock_init_poolmanager.assert_called_with(ssl_context=adapter._ctx_poolmanager)\n\n        adapter.proxy_manager_for()\n        mock_proxy_manager_for.assert_called_with(ssl_context=adapter._ctx_proxymanager)\n", "tests/transport/test__custom_tls_signer.py": "# Copyright 2022 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport base64\nimport ctypes\nimport os\n\nimport mock\nimport pytest  # type: ignore\nfrom requests.packages.urllib3.util.ssl_ import create_urllib3_context  # type: ignore\nimport urllib3.contrib.pyopenssl  # type: ignore\n\nfrom google.auth import exceptions\nfrom google.auth.transport import _custom_tls_signer\n\nurllib3.contrib.pyopenssl.inject_into_urllib3()\n\nFAKE_ENTERPRISE_CERT_FILE_PATH = \"/path/to/enterprise/cert/file\"\nENTERPRISE_CERT_FILE = os.path.join(\n    os.path.dirname(__file__), \"../data/enterprise_cert_valid.json\"\n)\nENTERPRISE_CERT_FILE_PROVIDER = os.path.join(\n    os.path.dirname(__file__), \"../data/enterprise_cert_valid_provider.json\"\n)\nINVALID_ENTERPRISE_CERT_FILE = os.path.join(\n    os.path.dirname(__file__), \"../data/enterprise_cert_invalid.json\"\n)\n\n\ndef test_load_provider_lib():\n    with mock.patch(\"ctypes.CDLL\", return_value=mock.MagicMock()):\n        _custom_tls_signer.load_provider_lib(\"/path/to/provider/lib\")\n\n\ndef test_load_offload_lib():\n    with mock.patch(\"ctypes.CDLL\", return_value=mock.MagicMock()):\n        lib = _custom_tls_signer.load_offload_lib(\"/path/to/offload/lib\")\n\n    assert lib.ConfigureSslContext.argtypes == [\n        _custom_tls_signer.SIGN_CALLBACK_CTYPE,\n        ctypes.c_char_p,\n        ctypes.c_void_p,\n    ]\n    assert lib.ConfigureSslContext.restype == ctypes.c_int\n\n\ndef test_load_signer_lib():\n    with mock.patch(\"ctypes.CDLL\", return_value=mock.MagicMock()):\n        lib = _custom_tls_signer.load_signer_lib(\"/path/to/signer/lib\")\n\n    assert lib.SignForPython.restype == ctypes.c_int\n    assert lib.SignForPython.argtypes == [\n        ctypes.c_char_p,\n        ctypes.c_char_p,\n        ctypes.c_int,\n        ctypes.c_char_p,\n        ctypes.c_int,\n    ]\n\n    assert lib.GetCertPemForPython.restype == ctypes.c_int\n    assert lib.GetCertPemForPython.argtypes == [\n        ctypes.c_char_p,\n        ctypes.c_char_p,\n        ctypes.c_int,\n    ]\n\n\ndef test__compute_sha256_digest():\n    to_be_signed = ctypes.create_string_buffer(b\"foo\")\n    sig = _custom_tls_signer._compute_sha256_digest(to_be_signed, 4)\n\n    assert (\n        base64.b64encode(sig).decode() == \"RG5gyEH8CAAh3lxgbt2PLPAHPO8p6i9+cn5dqHfUUYM=\"\n    )\n\n\ndef test_get_sign_callback():\n    # mock signer lib's SignForPython function\n    mock_sig_len = 10\n    mock_signer_lib = mock.MagicMock()\n    mock_signer_lib.SignForPython.return_value = mock_sig_len\n\n    # create a sign callback. The callback calls signer lib's SignForPython method\n    sign_callback = _custom_tls_signer.get_sign_callback(\n        mock_signer_lib, FAKE_ENTERPRISE_CERT_FILE_PATH\n    )\n\n    # mock the parameters used to call the sign callback\n    to_be_signed = ctypes.POINTER(ctypes.c_ubyte)()\n    to_be_signed_len = 4\n    returned_sig_array = ctypes.c_ubyte()\n    mock_sig_array = ctypes.byref(returned_sig_array)\n    returned_sign_len = ctypes.c_ulong()\n    mock_sig_len_array = ctypes.byref(returned_sign_len)\n\n    # call the callback, make sure the signature len is returned via mock_sig_len_array[0]\n    assert sign_callback(\n        mock_sig_array, mock_sig_len_array, to_be_signed, to_be_signed_len\n    )\n    assert returned_sign_len.value == mock_sig_len\n\n\ndef test_get_sign_callback_failed_to_sign():\n    # mock signer lib's SignForPython function. Set the sig len to be 0 to\n    # indicate the signing failed.\n    mock_sig_len = 0\n    mock_signer_lib = mock.MagicMock()\n    mock_signer_lib.SignForPython.return_value = mock_sig_len\n\n    # create a sign callback. The callback calls signer lib's SignForPython method\n    sign_callback = _custom_tls_signer.get_sign_callback(\n        mock_signer_lib, FAKE_ENTERPRISE_CERT_FILE_PATH\n    )\n\n    # mock the parameters used to call the sign callback\n    to_be_signed = ctypes.POINTER(ctypes.c_ubyte)()\n    to_be_signed_len = 4\n    returned_sig_array = ctypes.c_ubyte()\n    mock_sig_array = ctypes.byref(returned_sig_array)\n    returned_sign_len = ctypes.c_ulong()\n    mock_sig_len_array = ctypes.byref(returned_sign_len)\n    sign_callback(mock_sig_array, mock_sig_len_array, to_be_signed, to_be_signed_len)\n\n    # sign callback should return 0\n    assert not sign_callback(\n        mock_sig_array, mock_sig_len_array, to_be_signed, to_be_signed_len\n    )\n\n\ndef test_get_cert_no_cert():\n    # mock signer lib's GetCertPemForPython function to return 0 to indicts\n    # the cert doesn't exit (cert len = 0)\n    mock_signer_lib = mock.MagicMock()\n    mock_signer_lib.GetCertPemForPython.return_value = 0\n\n    # call the get cert method\n    with pytest.raises(exceptions.MutualTLSChannelError) as excinfo:\n        _custom_tls_signer.get_cert(mock_signer_lib, FAKE_ENTERPRISE_CERT_FILE_PATH)\n\n    assert excinfo.match(\"failed to get certificate\")\n\n\ndef test_get_cert():\n    # mock signer lib's GetCertPemForPython function\n    mock_cert_len = 10\n    mock_signer_lib = mock.MagicMock()\n    mock_signer_lib.GetCertPemForPython.return_value = mock_cert_len\n\n    # call the get cert method\n    mock_cert = _custom_tls_signer.get_cert(\n        mock_signer_lib, FAKE_ENTERPRISE_CERT_FILE_PATH\n    )\n\n    # make sure the signer lib's GetCertPemForPython is called twice, and the\n    # mock_cert has length mock_cert_len\n    assert mock_signer_lib.GetCertPemForPython.call_count == 2\n    assert len(mock_cert) == mock_cert_len\n\n\ndef test_custom_tls_signer():\n    offload_lib = mock.MagicMock()\n    signer_lib = mock.MagicMock()\n\n    # Test load_libraries method\n    with mock.patch(\n        \"google.auth.transport._custom_tls_signer.load_signer_lib\"\n    ) as load_signer_lib:\n        with mock.patch(\n            \"google.auth.transport._custom_tls_signer.load_offload_lib\"\n        ) as load_offload_lib:\n            load_offload_lib.return_value = offload_lib\n            load_signer_lib.return_value = signer_lib\n            with mock.patch(\n                \"google.auth.transport._custom_tls_signer.get_cert\"\n            ) as get_cert:\n                with mock.patch(\n                    \"google.auth.transport._custom_tls_signer.get_sign_callback\"\n                ) as get_sign_callback:\n                    get_cert.return_value = b\"mock_cert\"\n                    signer_object = _custom_tls_signer.CustomTlsSigner(\n                        ENTERPRISE_CERT_FILE\n                    )\n                    signer_object.load_libraries()\n                    signer_object.attach_to_ssl_context(create_urllib3_context())\n                    get_cert.assert_called_once()\n                    get_sign_callback.assert_called_once()\n                    offload_lib.ConfigureSslContext.assert_called_once()\n    assert not signer_object.should_use_provider()\n    assert signer_object._enterprise_cert_file_path == ENTERPRISE_CERT_FILE\n    assert signer_object._offload_lib == offload_lib\n    assert signer_object._signer_lib == signer_lib\n    load_signer_lib.assert_called_with(\"/path/to/signer/lib\")\n    load_offload_lib.assert_called_with(\"/path/to/offload/lib\")\n\n\ndef test_custom_tls_signer_provider():\n    provider_lib = mock.MagicMock()\n\n    # Test load_libraries method\n    with mock.patch(\n        \"google.auth.transport._custom_tls_signer.load_provider_lib\"\n    ) as load_provider_lib:\n        load_provider_lib.return_value = provider_lib\n        signer_object = _custom_tls_signer.CustomTlsSigner(\n            ENTERPRISE_CERT_FILE_PROVIDER\n        )\n        signer_object.load_libraries()\n        signer_object.attach_to_ssl_context(mock.MagicMock())\n\n    assert signer_object.should_use_provider()\n    assert signer_object._enterprise_cert_file_path == ENTERPRISE_CERT_FILE_PROVIDER\n    assert signer_object._provider_lib == provider_lib\n    load_provider_lib.assert_called_with(\"/path/to/provider/lib\")\n\n\ndef test_custom_tls_signer_failed_to_load_libraries():\n    with pytest.raises(exceptions.MutualTLSChannelError) as excinfo:\n        signer_object = _custom_tls_signer.CustomTlsSigner(INVALID_ENTERPRISE_CERT_FILE)\n        signer_object.load_libraries()\n    assert excinfo.match(\"enterprise cert file is invalid\")\n\n\ndef test_custom_tls_signer_failed_to_attach():\n    with pytest.raises(exceptions.MutualTLSChannelError) as excinfo:\n        signer_object = _custom_tls_signer.CustomTlsSigner(ENTERPRISE_CERT_FILE)\n        signer_object._offload_lib = mock.MagicMock()\n        signer_object._signer_lib = mock.MagicMock()\n        signer_object._sign_callback = mock.MagicMock()\n        signer_object._cert = b\"mock cert\"\n        signer_object._offload_lib.ConfigureSslContext.return_value = False\n        signer_object.attach_to_ssl_context(mock.MagicMock())\n    assert excinfo.match(\"failed to configure ECP Offload SSL context\")\n\n\ndef test_custom_tls_signer_failed_to_attach_provider():\n    with pytest.raises(exceptions.MutualTLSChannelError) as excinfo:\n        signer_object = _custom_tls_signer.CustomTlsSigner(\n            ENTERPRISE_CERT_FILE_PROVIDER\n        )\n        signer_object._provider_lib = mock.MagicMock()\n        signer_object._provider_lib.ECP_attach_to_ctx.return_value = False\n        signer_object.attach_to_ssl_context(mock.MagicMock())\n    assert excinfo.match(\"failed to configure ECP Provider SSL context\")\n\n\ndef test_custom_tls_signer_failed_to_attach_no_libs():\n    with pytest.raises(exceptions.MutualTLSChannelError) as excinfo:\n        signer_object = _custom_tls_signer.CustomTlsSigner(ENTERPRISE_CERT_FILE)\n        signer_object._offload_lib = None\n        signer_object._signer_lib = None\n        signer_object.attach_to_ssl_context(mock.MagicMock())\n    assert excinfo.match(\"Invalid ECP configuration.\")\n", "tests/transport/test_urllib3.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport http.client as http_client\nimport os\nimport sys\n\nimport mock\nimport OpenSSL\nimport pytest  # type: ignore\nimport urllib3  # type: ignore\n\nfrom google.auth import environment_vars\nfrom google.auth import exceptions\nimport google.auth.credentials\nimport google.auth.transport._mtls_helper\nimport google.auth.transport.urllib3\nfrom google.oauth2 import service_account\nfrom tests.transport import compliance\n\n\nclass TestRequestResponse(compliance.RequestResponseTests):\n    def make_request(self):\n        http = urllib3.PoolManager()\n        return google.auth.transport.urllib3.Request(http)\n\n    def test_timeout(self):\n        http = mock.create_autospec(urllib3.PoolManager)\n        request = google.auth.transport.urllib3.Request(http)\n        request(url=\"http://example.com\", method=\"GET\", timeout=5)\n\n        assert http.request.call_args[1][\"timeout\"] == 5\n\n\ndef test__make_default_http_with_certifi():\n    http = google.auth.transport.urllib3._make_default_http()\n    assert \"cert_reqs\" in http.connection_pool_kw\n\n\n@mock.patch.object(google.auth.transport.urllib3, \"certifi\", new=None)\ndef test__make_default_http_without_certifi():\n    http = google.auth.transport.urllib3._make_default_http()\n    assert \"cert_reqs\" not in http.connection_pool_kw\n\n\nclass CredentialsStub(google.auth.credentials.Credentials):\n    def __init__(self, token=\"token\"):\n        super(CredentialsStub, self).__init__()\n        self.token = token\n\n    def apply(self, headers, token=None):\n        headers[\"authorization\"] = self.token\n\n    def before_request(self, request, method, url, headers):\n        self.apply(headers)\n\n    def refresh(self, request):\n        self.token += \"1\"\n\n    def with_quota_project(self, quota_project_id):\n        raise NotImplementedError()\n\n\nclass HttpStub(object):\n    def __init__(self, responses, headers=None):\n        self.responses = responses\n        self.requests = []\n        self.headers = headers or {}\n\n    def urlopen(self, method, url, body=None, headers=None, **kwargs):\n        self.requests.append((method, url, body, headers, kwargs))\n        return self.responses.pop(0)\n\n    def clear(self):\n        pass\n\n\nclass ResponseStub(object):\n    def __init__(self, status=http_client.OK, data=None):\n        self.status = status\n        self.data = data\n\n\nclass TestMakeMutualTlsHttp(object):\n    def test_success(self):\n        http = google.auth.transport.urllib3._make_mutual_tls_http(\n            pytest.public_cert_bytes, pytest.private_key_bytes\n        )\n        assert isinstance(http, urllib3.PoolManager)\n\n    def test_crypto_error(self):\n        with pytest.raises(OpenSSL.crypto.Error):\n            google.auth.transport.urllib3._make_mutual_tls_http(\n                b\"invalid cert\", b\"invalid key\"\n            )\n\n    @mock.patch.dict(\"sys.modules\", {\"OpenSSL.crypto\": None})\n    def test_import_error(self):\n        with pytest.raises(ImportError):\n            google.auth.transport.urllib3._make_mutual_tls_http(\n                pytest.public_cert_bytes, pytest.private_key_bytes\n            )\n\n\nclass TestAuthorizedHttp(object):\n    TEST_URL = \"http://example.com\"\n\n    def test_authed_http_defaults(self):\n        authed_http = google.auth.transport.urllib3.AuthorizedHttp(\n            mock.sentinel.credentials\n        )\n\n        assert authed_http.credentials == mock.sentinel.credentials\n        assert isinstance(authed_http.http, urllib3.PoolManager)\n\n    def test_urlopen_no_refresh(self):\n        credentials = mock.Mock(wraps=CredentialsStub())\n        response = ResponseStub()\n        http = HttpStub([response])\n\n        authed_http = google.auth.transport.urllib3.AuthorizedHttp(\n            credentials, http=http\n        )\n\n        result = authed_http.urlopen(\"GET\", self.TEST_URL)\n\n        assert result == response\n        assert credentials.before_request.called\n        assert not credentials.refresh.called\n        assert http.requests == [\n            (\"GET\", self.TEST_URL, None, {\"authorization\": \"token\"}, {})\n        ]\n\n    def test_urlopen_refresh(self):\n        credentials = mock.Mock(wraps=CredentialsStub())\n        final_response = ResponseStub(status=http_client.OK)\n        # First request will 401, second request will succeed.\n        http = HttpStub([ResponseStub(status=http_client.UNAUTHORIZED), final_response])\n\n        authed_http = google.auth.transport.urllib3.AuthorizedHttp(\n            credentials, http=http\n        )\n\n        authed_http = authed_http.urlopen(\"GET\", \"http://example.com\")\n\n        assert authed_http == final_response\n        assert credentials.before_request.call_count == 2\n        assert credentials.refresh.called\n        assert http.requests == [\n            (\"GET\", self.TEST_URL, None, {\"authorization\": \"token\"}, {}),\n            (\"GET\", self.TEST_URL, None, {\"authorization\": \"token1\"}, {}),\n        ]\n\n    def test_urlopen_no_default_host(self):\n        credentials = mock.create_autospec(service_account.Credentials)\n\n        authed_http = google.auth.transport.urllib3.AuthorizedHttp(credentials)\n\n        authed_http.credentials._create_self_signed_jwt.assert_called_once_with(None)\n\n    def test_urlopen_with_default_host(self):\n        default_host = \"pubsub.googleapis.com\"\n        credentials = mock.create_autospec(service_account.Credentials)\n\n        authed_http = google.auth.transport.urllib3.AuthorizedHttp(\n            credentials, default_host=default_host\n        )\n\n        authed_http.credentials._create_self_signed_jwt.assert_called_once_with(\n            \"https://{}/\".format(default_host)\n        )\n\n    def test_proxies(self):\n        http = mock.create_autospec(urllib3.PoolManager)\n        authed_http = google.auth.transport.urllib3.AuthorizedHttp(None, http=http)\n\n        with authed_http:\n            pass\n\n        assert http.__enter__.called\n        assert http.__exit__.called\n\n        authed_http.headers = mock.sentinel.headers\n        assert authed_http.headers == http.headers\n\n    @mock.patch(\"google.auth.transport.urllib3._make_mutual_tls_http\", autospec=True)\n    def test_configure_mtls_channel_with_callback(self, mock_make_mutual_tls_http):\n        callback = mock.Mock()\n        callback.return_value = (pytest.public_cert_bytes, pytest.private_key_bytes)\n\n        authed_http = google.auth.transport.urllib3.AuthorizedHttp(\n            credentials=mock.Mock(), http=mock.Mock()\n        )\n\n        with pytest.warns(UserWarning):\n            with mock.patch.dict(\n                os.environ, {environment_vars.GOOGLE_API_USE_CLIENT_CERTIFICATE: \"true\"}\n            ):\n                is_mtls = authed_http.configure_mtls_channel(callback)\n\n        assert is_mtls\n        mock_make_mutual_tls_http.assert_called_once_with(\n            cert=pytest.public_cert_bytes, key=pytest.private_key_bytes\n        )\n\n    @mock.patch(\"google.auth.transport.urllib3._make_mutual_tls_http\", autospec=True)\n    @mock.patch(\n        \"google.auth.transport._mtls_helper.get_client_cert_and_key\", autospec=True\n    )\n    def test_configure_mtls_channel_with_metadata(\n        self, mock_get_client_cert_and_key, mock_make_mutual_tls_http\n    ):\n        authed_http = google.auth.transport.urllib3.AuthorizedHttp(\n            credentials=mock.Mock()\n        )\n\n        mock_get_client_cert_and_key.return_value = (\n            True,\n            pytest.public_cert_bytes,\n            pytest.private_key_bytes,\n        )\n        with mock.patch.dict(\n            os.environ, {environment_vars.GOOGLE_API_USE_CLIENT_CERTIFICATE: \"true\"}\n        ):\n            is_mtls = authed_http.configure_mtls_channel()\n\n        assert is_mtls\n        mock_get_client_cert_and_key.assert_called_once()\n        mock_make_mutual_tls_http.assert_called_once_with(\n            cert=pytest.public_cert_bytes, key=pytest.private_key_bytes\n        )\n\n    @mock.patch(\"google.auth.transport.urllib3._make_mutual_tls_http\", autospec=True)\n    @mock.patch(\n        \"google.auth.transport._mtls_helper.get_client_cert_and_key\", autospec=True\n    )\n    def test_configure_mtls_channel_non_mtls(\n        self, mock_get_client_cert_and_key, mock_make_mutual_tls_http\n    ):\n        authed_http = google.auth.transport.urllib3.AuthorizedHttp(\n            credentials=mock.Mock()\n        )\n\n        mock_get_client_cert_and_key.return_value = (False, None, None)\n        with mock.patch.dict(\n            os.environ, {environment_vars.GOOGLE_API_USE_CLIENT_CERTIFICATE: \"true\"}\n        ):\n            is_mtls = authed_http.configure_mtls_channel()\n\n        assert not is_mtls\n        mock_get_client_cert_and_key.assert_called_once()\n        mock_make_mutual_tls_http.assert_not_called()\n\n    @mock.patch(\n        \"google.auth.transport._mtls_helper.get_client_cert_and_key\", autospec=True\n    )\n    def test_configure_mtls_channel_exceptions(self, mock_get_client_cert_and_key):\n        authed_http = google.auth.transport.urllib3.AuthorizedHttp(\n            credentials=mock.Mock()\n        )\n\n        mock_get_client_cert_and_key.side_effect = exceptions.ClientCertError()\n        with pytest.raises(exceptions.MutualTLSChannelError):\n            with mock.patch.dict(\n                os.environ, {environment_vars.GOOGLE_API_USE_CLIENT_CERTIFICATE: \"true\"}\n            ):\n                authed_http.configure_mtls_channel()\n\n        mock_get_client_cert_and_key.return_value = (False, None, None)\n        with mock.patch.dict(\"sys.modules\"):\n            sys.modules[\"OpenSSL\"] = None\n            with pytest.raises(exceptions.MutualTLSChannelError):\n                with mock.patch.dict(\n                    os.environ,\n                    {environment_vars.GOOGLE_API_USE_CLIENT_CERTIFICATE: \"true\"},\n                ):\n                    authed_http.configure_mtls_channel()\n\n    @mock.patch(\n        \"google.auth.transport._mtls_helper.get_client_cert_and_key\", autospec=True\n    )\n    def test_configure_mtls_channel_without_client_cert_env(\n        self, get_client_cert_and_key\n    ):\n        callback = mock.Mock()\n\n        authed_http = google.auth.transport.urllib3.AuthorizedHttp(\n            credentials=mock.Mock(), http=mock.Mock()\n        )\n\n        # Test the callback is not called if GOOGLE_API_USE_CLIENT_CERTIFICATE is not set.\n        is_mtls = authed_http.configure_mtls_channel(callback)\n        assert not is_mtls\n        callback.assert_not_called()\n\n        # Test ADC client cert is not used if GOOGLE_API_USE_CLIENT_CERTIFICATE is not set.\n        is_mtls = authed_http.configure_mtls_channel(callback)\n        assert not is_mtls\n        get_client_cert_and_key.assert_not_called()\n\n    def test_clear_pool_on_del(self):\n        http = mock.create_autospec(urllib3.PoolManager)\n        authed_http = google.auth.transport.urllib3.AuthorizedHttp(\n            mock.sentinel.credentials, http=http\n        )\n        authed_http.__del__()\n        http.clear.assert_called_with()\n\n        authed_http.http = None\n        authed_http.__del__()\n        # Expect it to not crash\n", "tests/transport/compliance.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport http.client as http_client\nimport time\n\nimport flask  # type: ignore\nimport pytest  # type: ignore\nfrom pytest_localserver.http import WSGIServer  # type: ignore\n\nfrom google.auth import exceptions\n\n# .invalid will never resolve, see https://tools.ietf.org/html/rfc2606\nNXDOMAIN = \"test.invalid\"\n\n\nclass RequestResponseTests(object):\n    @pytest.fixture(scope=\"module\")\n    def server(self):\n        \"\"\"Provides a test HTTP server.\n\n        The test server is automatically created before\n        a test and destroyed at the end. The server is serving a test\n        application that can be used to verify requests.\n        \"\"\"\n        app = flask.Flask(__name__)\n        app.debug = True\n\n        # pylint: disable=unused-variable\n        # (pylint thinks the flask routes are unusued.)\n        @app.route(\"/basic\")\n        def index():\n            header_value = flask.request.headers.get(\"x-test-header\", \"value\")\n            headers = {\"X-Test-Header\": header_value}\n            return \"Basic Content\", http_client.OK, headers\n\n        @app.route(\"/server_error\")\n        def server_error():\n            return \"Error\", http_client.INTERNAL_SERVER_ERROR\n\n        @app.route(\"/wait\")\n        def wait():\n            time.sleep(3)\n            return \"Waited\"\n\n        # pylint: enable=unused-variable\n\n        server = WSGIServer(application=app.wsgi_app)\n        server.start()\n        yield server\n        server.stop()\n\n    def test_request_basic(self, server):\n        request = self.make_request()\n        response = request(url=server.url + \"/basic\", method=\"GET\")\n\n        assert response.status == http_client.OK\n        assert response.headers[\"x-test-header\"] == \"value\"\n        assert response.data == b\"Basic Content\"\n\n    def test_request_with_timeout_success(self, server):\n        request = self.make_request()\n        response = request(url=server.url + \"/basic\", method=\"GET\", timeout=2)\n\n        assert response.status == http_client.OK\n        assert response.headers[\"x-test-header\"] == \"value\"\n        assert response.data == b\"Basic Content\"\n\n    def test_request_with_timeout_failure(self, server):\n        request = self.make_request()\n\n        with pytest.raises(exceptions.TransportError):\n            request(url=server.url + \"/wait\", method=\"GET\", timeout=1)\n\n    def test_request_headers(self, server):\n        request = self.make_request()\n        response = request(\n            url=server.url + \"/basic\",\n            method=\"GET\",\n            headers={\"x-test-header\": \"hello world\"},\n        )\n\n        assert response.status == http_client.OK\n        assert response.headers[\"x-test-header\"] == \"hello world\"\n        assert response.data == b\"Basic Content\"\n\n    def test_request_error(self, server):\n        request = self.make_request()\n        response = request(url=server.url + \"/server_error\", method=\"GET\")\n\n        assert response.status == http_client.INTERNAL_SERVER_ERROR\n        assert response.data == b\"Error\"\n\n    def test_connection_error(self):\n        request = self.make_request()\n        with pytest.raises(exceptions.TransportError):\n            request(url=\"http://{}\".format(NXDOMAIN), method=\"GET\")\n", "tests/transport/__init__.py": "", "google/oauth2/service_account.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Service Accounts: JSON Web Token (JWT) Profile for OAuth 2.0\n\nThis module implements the JWT Profile for OAuth 2.0 Authorization Grants\nas defined by `RFC 7523`_ with particular support for how this RFC is\nimplemented in Google's infrastructure. Google refers to these credentials\nas *Service Accounts*.\n\nService accounts are used for server-to-server communication, such as\ninteractions between a web application server and a Google service. The\nservice account belongs to your application instead of to an individual end\nuser. In contrast to other OAuth 2.0 profiles, no users are involved and your\napplication \"acts\" as the service account.\n\nTypically an application uses a service account when the application uses\nGoogle APIs to work with its own data rather than a user's data. For example,\nan application that uses Google Cloud Datastore for data persistence would use\na service account to authenticate its calls to the Google Cloud Datastore API.\nHowever, an application that needs to access a user's Drive documents would\nuse the normal OAuth 2.0 profile.\n\nAdditionally, Google Apps domain administrators can grant service accounts\n`domain-wide delegation`_ authority to access user data on behalf of users in\nthe domain.\n\nThis profile uses a JWT to acquire an OAuth 2.0 access token. The JWT is used\nin place of the usual authorization token returned during the standard\nOAuth 2.0 Authorization Code grant. The JWT is only used for this purpose, as\nthe acquired access token is used as the bearer token when making requests\nusing these credentials.\n\nThis profile differs from normal OAuth 2.0 profile because no user consent\nstep is required. The use of the private key allows this profile to assert\nidentity directly.\n\nThis profile also differs from the :mod:`google.auth.jwt` authentication\nbecause the JWT credentials use the JWT directly as the bearer token. This\nprofile instead only uses the JWT to obtain an OAuth 2.0 access token. The\nobtained OAuth 2.0 access token is used as the bearer token.\n\nDomain-wide delegation\n----------------------\n\nDomain-wide delegation allows a service account to access user data on\nbehalf of any user in a Google Apps domain without consent from the user.\nFor example, an application that uses the Google Calendar API to add events to\nthe calendars of all users in a Google Apps domain would use a service account\nto access the Google Calendar API on behalf of users.\n\nThe Google Apps administrator must explicitly authorize the service account to\ndo this. This authorization step is referred to as \"delegating domain-wide\nauthority\" to a service account.\n\nYou can use domain-wise delegation by creating a set of credentials with a\nspecific subject using :meth:`~Credentials.with_subject`.\n\n.. _RFC 7523: https://tools.ietf.org/html/rfc7523\n\"\"\"\n\nimport copy\nimport datetime\n\nfrom google.auth import _helpers\nfrom google.auth import _service_account_info\nfrom google.auth import credentials\nfrom google.auth import exceptions\nfrom google.auth import iam\nfrom google.auth import jwt\nfrom google.auth import metrics\nfrom google.oauth2 import _client\n\n_DEFAULT_TOKEN_LIFETIME_SECS = 3600  # 1 hour in seconds\n_GOOGLE_OAUTH2_TOKEN_ENDPOINT = \"https://oauth2.googleapis.com/token\"\n\n\nclass Credentials(\n    credentials.Signing,\n    credentials.Scoped,\n    credentials.CredentialsWithQuotaProject,\n    credentials.CredentialsWithTokenUri,\n):\n    \"\"\"Service account credentials\n\n    Usually, you'll create these credentials with one of the helper\n    constructors. To create credentials using a Google service account\n    private key JSON file::\n\n        credentials = service_account.Credentials.from_service_account_file(\n            'service-account.json')\n\n    Or if you already have the service account file loaded::\n\n        service_account_info = json.load(open('service_account.json'))\n        credentials = service_account.Credentials.from_service_account_info(\n            service_account_info)\n\n    Both helper methods pass on arguments to the constructor, so you can\n    specify additional scopes and a subject if necessary::\n\n        credentials = service_account.Credentials.from_service_account_file(\n            'service-account.json',\n            scopes=['email'],\n            subject='user@example.com')\n\n    The credentials are considered immutable. If you want to modify the scopes\n    or the subject used for delegation, use :meth:`with_scopes` or\n    :meth:`with_subject`::\n\n        scoped_credentials = credentials.with_scopes(['email'])\n        delegated_credentials = credentials.with_subject(subject)\n\n    To add a quota project, use :meth:`with_quota_project`::\n\n        credentials = credentials.with_quota_project('myproject-123')\n    \"\"\"\n\n    def __init__(\n        self,\n        signer,\n        service_account_email,\n        token_uri,\n        scopes=None,\n        default_scopes=None,\n        subject=None,\n        project_id=None,\n        quota_project_id=None,\n        additional_claims=None,\n        always_use_jwt_access=False,\n        universe_domain=credentials.DEFAULT_UNIVERSE_DOMAIN,\n        trust_boundary=None,\n    ):\n        \"\"\"\n        Args:\n            signer (google.auth.crypt.Signer): The signer used to sign JWTs.\n            service_account_email (str): The service account's email.\n            scopes (Sequence[str]): User-defined scopes to request during the\n                authorization grant.\n            default_scopes (Sequence[str]): Default scopes passed by a\n                Google client library. Use 'scopes' for user-defined scopes.\n            token_uri (str): The OAuth 2.0 Token URI.\n            subject (str): For domain-wide delegation, the email address of the\n                user to for which to request delegated access.\n            project_id  (str): Project ID associated with the service account\n                credential.\n            quota_project_id (Optional[str]): The project ID used for quota and\n                billing.\n            additional_claims (Mapping[str, str]): Any additional claims for\n                the JWT assertion used in the authorization grant.\n            always_use_jwt_access (Optional[bool]): Whether self signed JWT should\n                be always used.\n            universe_domain (str): The universe domain. The default\n                universe domain is googleapis.com. For default value self\n                signed jwt is used for token refresh.\n            trust_boundary (str): String representation of trust boundary meta.\n\n        .. note:: Typically one of the helper constructors\n            :meth:`from_service_account_file` or\n            :meth:`from_service_account_info` are used instead of calling the\n            constructor directly.\n        \"\"\"\n        super(Credentials, self).__init__()\n\n        self._scopes = scopes\n        self._default_scopes = default_scopes\n        self._signer = signer\n        self._service_account_email = service_account_email\n        self._subject = subject\n        self._project_id = project_id\n        self._quota_project_id = quota_project_id\n        self._token_uri = token_uri\n        self._always_use_jwt_access = always_use_jwt_access\n        self._universe_domain = universe_domain or credentials.DEFAULT_UNIVERSE_DOMAIN\n\n        if universe_domain != credentials.DEFAULT_UNIVERSE_DOMAIN:\n            self._always_use_jwt_access = True\n\n        self._jwt_credentials = None\n\n        if additional_claims is not None:\n            self._additional_claims = additional_claims\n        else:\n            self._additional_claims = {}\n        self._trust_boundary = {\"locations\": [], \"encoded_locations\": \"0x0\"}\n\n    @classmethod\n    def _from_signer_and_info(cls, signer, info, **kwargs):\n        \"\"\"Creates a Credentials instance from a signer and service account\n        info.\n\n        Args:\n            signer (google.auth.crypt.Signer): The signer used to sign JWTs.\n            info (Mapping[str, str]): The service account info.\n            kwargs: Additional arguments to pass to the constructor.\n\n        Returns:\n            google.auth.jwt.Credentials: The constructed credentials.\n\n        Raises:\n            ValueError: If the info is not in the expected format.\n        \"\"\"\n        return cls(\n            signer,\n            service_account_email=info[\"client_email\"],\n            token_uri=info[\"token_uri\"],\n            project_id=info.get(\"project_id\"),\n            universe_domain=info.get(\n                \"universe_domain\", credentials.DEFAULT_UNIVERSE_DOMAIN\n            ),\n            trust_boundary=info.get(\"trust_boundary\"),\n            **kwargs\n        )\n\n    @classmethod\n    def from_service_account_info(cls, info, **kwargs):\n        \"\"\"Creates a Credentials instance from parsed service account info.\n\n        Args:\n            info (Mapping[str, str]): The service account info in Google\n                format.\n            kwargs: Additional arguments to pass to the constructor.\n\n        Returns:\n            google.auth.service_account.Credentials: The constructed\n                credentials.\n\n        Raises:\n            ValueError: If the info is not in the expected format.\n        \"\"\"\n        signer = _service_account_info.from_dict(\n            info, require=[\"client_email\", \"token_uri\"]\n        )\n        return cls._from_signer_and_info(signer, info, **kwargs)\n\n    @classmethod\n    def from_service_account_file(cls, filename, **kwargs):\n        \"\"\"Creates a Credentials instance from a service account json file.\n\n        Args:\n            filename (str): The path to the service account json file.\n            kwargs: Additional arguments to pass to the constructor.\n\n        Returns:\n            google.auth.service_account.Credentials: The constructed\n                credentials.\n        \"\"\"\n        info, signer = _service_account_info.from_filename(\n            filename, require=[\"client_email\", \"token_uri\"]\n        )\n        return cls._from_signer_and_info(signer, info, **kwargs)\n\n    @property\n    def service_account_email(self):\n        \"\"\"The service account email.\"\"\"\n        return self._service_account_email\n\n    @property\n    def project_id(self):\n        \"\"\"Project ID associated with this credential.\"\"\"\n        return self._project_id\n\n    @property\n    def requires_scopes(self):\n        \"\"\"Checks if the credentials requires scopes.\n\n        Returns:\n            bool: True if there are no scopes set otherwise False.\n        \"\"\"\n        return True if not self._scopes else False\n\n    def _make_copy(self):\n        cred = self.__class__(\n            self._signer,\n            service_account_email=self._service_account_email,\n            scopes=copy.copy(self._scopes),\n            default_scopes=copy.copy(self._default_scopes),\n            token_uri=self._token_uri,\n            subject=self._subject,\n            project_id=self._project_id,\n            quota_project_id=self._quota_project_id,\n            additional_claims=self._additional_claims.copy(),\n            always_use_jwt_access=self._always_use_jwt_access,\n            universe_domain=self._universe_domain,\n        )\n        return cred\n\n    @_helpers.copy_docstring(credentials.Scoped)\n    def with_scopes(self, scopes, default_scopes=None):\n        cred = self._make_copy()\n        cred._scopes = scopes\n        cred._default_scopes = default_scopes\n        return cred\n\n    def with_always_use_jwt_access(self, always_use_jwt_access):\n        \"\"\"Create a copy of these credentials with the specified always_use_jwt_access value.\n\n        Args:\n            always_use_jwt_access (bool): Whether always use self signed JWT or not.\n\n        Returns:\n            google.auth.service_account.Credentials: A new credentials\n                instance.\n        Raises:\n            google.auth.exceptions.InvalidValue: If the universe domain is not\n                default and always_use_jwt_access is False.\n        \"\"\"\n        cred = self._make_copy()\n        if (\n            cred._universe_domain != credentials.DEFAULT_UNIVERSE_DOMAIN\n            and not always_use_jwt_access\n        ):\n            raise exceptions.InvalidValue(\n                \"always_use_jwt_access should be True for non-default universe domain\"\n            )\n        cred._always_use_jwt_access = always_use_jwt_access\n        return cred\n\n    @_helpers.copy_docstring(credentials.CredentialsWithUniverseDomain)\n    def with_universe_domain(self, universe_domain):\n        cred = self._make_copy()\n        cred._universe_domain = universe_domain\n        if universe_domain != credentials.DEFAULT_UNIVERSE_DOMAIN:\n            cred._always_use_jwt_access = True\n        return cred\n\n    def with_subject(self, subject):\n        \"\"\"Create a copy of these credentials with the specified subject.\n\n        Args:\n            subject (str): The subject claim.\n\n        Returns:\n            google.auth.service_account.Credentials: A new credentials\n                instance.\n        \"\"\"\n        cred = self._make_copy()\n        cred._subject = subject\n        return cred\n\n    def with_claims(self, additional_claims):\n        \"\"\"Returns a copy of these credentials with modified claims.\n\n        Args:\n            additional_claims (Mapping[str, str]): Any additional claims for\n                the JWT payload. This will be merged with the current\n                additional claims.\n\n        Returns:\n            google.auth.service_account.Credentials: A new credentials\n                instance.\n        \"\"\"\n        new_additional_claims = copy.deepcopy(self._additional_claims)\n        new_additional_claims.update(additional_claims or {})\n        cred = self._make_copy()\n        cred._additional_claims = new_additional_claims\n        return cred\n\n    @_helpers.copy_docstring(credentials.CredentialsWithQuotaProject)\n    def with_quota_project(self, quota_project_id):\n        cred = self._make_copy()\n        cred._quota_project_id = quota_project_id\n        return cred\n\n    @_helpers.copy_docstring(credentials.CredentialsWithTokenUri)\n    def with_token_uri(self, token_uri):\n        cred = self._make_copy()\n        cred._token_uri = token_uri\n        return cred\n\n    def _make_authorization_grant_assertion(self):\n        \"\"\"Create the OAuth 2.0 assertion.\n\n        This assertion is used during the OAuth 2.0 grant to acquire an\n        access token.\n\n        Returns:\n            bytes: The authorization grant assertion.\n        \"\"\"\n        now = _helpers.utcnow()\n        lifetime = datetime.timedelta(seconds=_DEFAULT_TOKEN_LIFETIME_SECS)\n        expiry = now + lifetime\n\n        payload = {\n            \"iat\": _helpers.datetime_to_secs(now),\n            \"exp\": _helpers.datetime_to_secs(expiry),\n            # The issuer must be the service account email.\n            \"iss\": self._service_account_email,\n            # The audience must be the auth token endpoint's URI\n            \"aud\": _GOOGLE_OAUTH2_TOKEN_ENDPOINT,\n            \"scope\": _helpers.scopes_to_string(self._scopes or ()),\n        }\n\n        payload.update(self._additional_claims)\n\n        # The subject can be a user email for domain-wide delegation.\n        if self._subject:\n            payload.setdefault(\"sub\", self._subject)\n\n        token = jwt.encode(self._signer, payload)\n\n        return token\n\n    def _use_self_signed_jwt(self):\n        # Since domain wide delegation doesn't work with self signed JWT. If\n        # subject exists, then we should not use self signed JWT.\n        return self._subject is None and self._jwt_credentials is not None\n\n    def _metric_header_for_usage(self):\n        if self._use_self_signed_jwt():\n            return metrics.CRED_TYPE_SA_JWT\n        return metrics.CRED_TYPE_SA_ASSERTION\n\n    @_helpers.copy_docstring(credentials.Credentials)\n    def refresh(self, request):\n        if self._always_use_jwt_access and not self._jwt_credentials:\n            # If self signed jwt should be used but jwt credential is not\n            # created, try to create one with scopes\n            self._create_self_signed_jwt(None)\n\n        if (\n            self._universe_domain != credentials.DEFAULT_UNIVERSE_DOMAIN\n            and self._subject\n        ):\n            raise exceptions.RefreshError(\n                \"domain wide delegation is not supported for non-default universe domain\"\n            )\n\n        if self._use_self_signed_jwt():\n            self._jwt_credentials.refresh(request)\n            self.token = self._jwt_credentials.token.decode()\n            self.expiry = self._jwt_credentials.expiry\n        else:\n            assertion = self._make_authorization_grant_assertion()\n            access_token, expiry, _ = _client.jwt_grant(\n                request, self._token_uri, assertion\n            )\n            self.token = access_token\n            self.expiry = expiry\n\n    def _create_self_signed_jwt(self, audience):\n        \"\"\"Create a self-signed JWT from the credentials if requirements are met.\n\n        Args:\n            audience (str): The service URL. ``https://[API_ENDPOINT]/``\n        \"\"\"\n        # https://google.aip.dev/auth/4111\n        if self._always_use_jwt_access:\n            if self._scopes:\n                additional_claims = {\"scope\": \" \".join(self._scopes)}\n                if (\n                    self._jwt_credentials is None\n                    or self._jwt_credentials.additional_claims != additional_claims\n                ):\n                    self._jwt_credentials = jwt.Credentials.from_signing_credentials(\n                        self, None, additional_claims=additional_claims\n                    )\n            elif audience:\n                if (\n                    self._jwt_credentials is None\n                    or self._jwt_credentials._audience != audience\n                ):\n\n                    self._jwt_credentials = jwt.Credentials.from_signing_credentials(\n                        self, audience\n                    )\n            elif self._default_scopes:\n                additional_claims = {\"scope\": \" \".join(self._default_scopes)}\n                if (\n                    self._jwt_credentials is None\n                    or additional_claims != self._jwt_credentials.additional_claims\n                ):\n                    self._jwt_credentials = jwt.Credentials.from_signing_credentials(\n                        self, None, additional_claims=additional_claims\n                    )\n        elif not self._scopes and audience:\n            self._jwt_credentials = jwt.Credentials.from_signing_credentials(\n                self, audience\n            )\n\n    @_helpers.copy_docstring(credentials.Signing)\n    def sign_bytes(self, message):\n        return self._signer.sign(message)\n\n    @property  # type: ignore\n    @_helpers.copy_docstring(credentials.Signing)\n    def signer(self):\n        return self._signer\n\n    @property  # type: ignore\n    @_helpers.copy_docstring(credentials.Signing)\n    def signer_email(self):\n        return self._service_account_email\n\n\nclass IDTokenCredentials(\n    credentials.Signing,\n    credentials.CredentialsWithQuotaProject,\n    credentials.CredentialsWithTokenUri,\n):\n    \"\"\"Open ID Connect ID Token-based service account credentials.\n\n    These credentials are largely similar to :class:`.Credentials`, but instead\n    of using an OAuth 2.0 Access Token as the bearer token, they use an Open\n    ID Connect ID Token as the bearer token. These credentials are useful when\n    communicating to services that require ID Tokens and can not accept access\n    tokens.\n\n    Usually, you'll create these credentials with one of the helper\n    constructors. To create credentials using a Google service account\n    private key JSON file::\n\n        credentials = (\n            service_account.IDTokenCredentials.from_service_account_file(\n                'service-account.json'))\n\n\n    Or if you already have the service account file loaded::\n\n        service_account_info = json.load(open('service_account.json'))\n        credentials = (\n            service_account.IDTokenCredentials.from_service_account_info(\n                service_account_info))\n\n\n    Both helper methods pass on arguments to the constructor, so you can\n    specify additional scopes and a subject if necessary::\n\n        credentials = (\n            service_account.IDTokenCredentials.from_service_account_file(\n                'service-account.json',\n                scopes=['email'],\n                subject='user@example.com'))\n\n\n    The credentials are considered immutable. If you want to modify the scopes\n    or the subject used for delegation, use :meth:`with_scopes` or\n    :meth:`with_subject`::\n\n        scoped_credentials = credentials.with_scopes(['email'])\n        delegated_credentials = credentials.with_subject(subject)\n\n    \"\"\"\n\n    def __init__(\n        self,\n        signer,\n        service_account_email,\n        token_uri,\n        target_audience,\n        additional_claims=None,\n        quota_project_id=None,\n        universe_domain=credentials.DEFAULT_UNIVERSE_DOMAIN,\n    ):\n        \"\"\"\n        Args:\n            signer (google.auth.crypt.Signer): The signer used to sign JWTs.\n            service_account_email (str): The service account's email.\n            token_uri (str): The OAuth 2.0 Token URI.\n            target_audience (str): The intended audience for these credentials,\n                used when requesting the ID Token. The ID Token's ``aud`` claim\n                will be set to this string.\n            additional_claims (Mapping[str, str]): Any additional claims for\n                the JWT assertion used in the authorization grant.\n            quota_project_id (Optional[str]): The project ID used for quota and billing.\n            universe_domain (str): The universe domain. The default\n                universe domain is googleapis.com. For default value IAM ID\n                token endponint is used for token refresh. Note that\n                iam.serviceAccountTokenCreator role is required to use the IAM\n                endpoint.\n        .. note:: Typically one of the helper constructors\n            :meth:`from_service_account_file` or\n            :meth:`from_service_account_info` are used instead of calling the\n            constructor directly.\n        \"\"\"\n        super(IDTokenCredentials, self).__init__()\n        self._signer = signer\n        self._service_account_email = service_account_email\n        self._token_uri = token_uri\n        self._target_audience = target_audience\n        self._quota_project_id = quota_project_id\n        self._use_iam_endpoint = False\n\n        if not universe_domain:\n            self._universe_domain = credentials.DEFAULT_UNIVERSE_DOMAIN\n        else:\n            self._universe_domain = universe_domain\n        self._iam_id_token_endpoint = iam._IAM_IDTOKEN_ENDPOINT.replace(\n            \"googleapis.com\", self._universe_domain\n        )\n\n        if self._universe_domain != credentials.DEFAULT_UNIVERSE_DOMAIN:\n            self._use_iam_endpoint = True\n\n        if additional_claims is not None:\n            self._additional_claims = additional_claims\n        else:\n            self._additional_claims = {}\n\n    @classmethod\n    def _from_signer_and_info(cls, signer, info, **kwargs):\n        \"\"\"Creates a credentials instance from a signer and service account\n        info.\n\n        Args:\n            signer (google.auth.crypt.Signer): The signer used to sign JWTs.\n            info (Mapping[str, str]): The service account info.\n            kwargs: Additional arguments to pass to the constructor.\n\n        Returns:\n            google.auth.jwt.IDTokenCredentials: The constructed credentials.\n\n        Raises:\n            ValueError: If the info is not in the expected format.\n        \"\"\"\n        kwargs.setdefault(\"service_account_email\", info[\"client_email\"])\n        kwargs.setdefault(\"token_uri\", info[\"token_uri\"])\n        if \"universe_domain\" in info:\n            kwargs[\"universe_domain\"] = info[\"universe_domain\"]\n        return cls(signer, **kwargs)\n\n    @classmethod\n    def from_service_account_info(cls, info, **kwargs):\n        \"\"\"Creates a credentials instance from parsed service account info.\n\n        Args:\n            info (Mapping[str, str]): The service account info in Google\n                format.\n            kwargs: Additional arguments to pass to the constructor.\n\n        Returns:\n            google.auth.service_account.IDTokenCredentials: The constructed\n                credentials.\n\n        Raises:\n            ValueError: If the info is not in the expected format.\n        \"\"\"\n        signer = _service_account_info.from_dict(\n            info, require=[\"client_email\", \"token_uri\"]\n        )\n        return cls._from_signer_and_info(signer, info, **kwargs)\n\n    @classmethod\n    def from_service_account_file(cls, filename, **kwargs):\n        \"\"\"Creates a credentials instance from a service account json file.\n\n        Args:\n            filename (str): The path to the service account json file.\n            kwargs: Additional arguments to pass to the constructor.\n\n        Returns:\n            google.auth.service_account.IDTokenCredentials: The constructed\n                credentials.\n        \"\"\"\n        info, signer = _service_account_info.from_filename(\n            filename, require=[\"client_email\", \"token_uri\"]\n        )\n        return cls._from_signer_and_info(signer, info, **kwargs)\n\n    def _make_copy(self):\n        cred = self.__class__(\n            self._signer,\n            service_account_email=self._service_account_email,\n            token_uri=self._token_uri,\n            target_audience=self._target_audience,\n            additional_claims=self._additional_claims.copy(),\n            quota_project_id=self.quota_project_id,\n            universe_domain=self._universe_domain,\n        )\n        # _use_iam_endpoint is not exposed in the constructor\n        cred._use_iam_endpoint = self._use_iam_endpoint\n        return cred\n\n    def with_target_audience(self, target_audience):\n        \"\"\"Create a copy of these credentials with the specified target\n        audience.\n\n        Args:\n            target_audience (str): The intended audience for these credentials,\n            used when requesting the ID Token.\n\n        Returns:\n            google.auth.service_account.IDTokenCredentials: A new credentials\n                instance.\n        \"\"\"\n        cred = self._make_copy()\n        cred._target_audience = target_audience\n        return cred\n\n    def _with_use_iam_endpoint(self, use_iam_endpoint):\n        \"\"\"Create a copy of these credentials with the use_iam_endpoint value.\n\n        Args:\n            use_iam_endpoint (bool): If True, IAM generateIdToken endpoint will\n                be used instead of the token_uri. Note that\n                iam.serviceAccountTokenCreator role is required to use the IAM\n                endpoint. The default value is False. This feature is currently\n                experimental and subject to change without notice.\n\n        Returns:\n            google.auth.service_account.IDTokenCredentials: A new credentials\n                instance.\n        Raises:\n            google.auth.exceptions.InvalidValue: If the universe domain is not\n                default and use_iam_endpoint is False.\n        \"\"\"\n        cred = self._make_copy()\n        if (\n            cred._universe_domain != credentials.DEFAULT_UNIVERSE_DOMAIN\n            and not use_iam_endpoint\n        ):\n            raise exceptions.InvalidValue(\n                \"use_iam_endpoint should be True for non-default universe domain\"\n            )\n        cred._use_iam_endpoint = use_iam_endpoint\n        return cred\n\n    @_helpers.copy_docstring(credentials.CredentialsWithQuotaProject)\n    def with_quota_project(self, quota_project_id):\n        cred = self._make_copy()\n        cred._quota_project_id = quota_project_id\n        return cred\n\n    @_helpers.copy_docstring(credentials.CredentialsWithTokenUri)\n    def with_token_uri(self, token_uri):\n        cred = self._make_copy()\n        cred._token_uri = token_uri\n        return cred\n\n    def _make_authorization_grant_assertion(self):\n        \"\"\"Create the OAuth 2.0 assertion.\n\n        This assertion is used during the OAuth 2.0 grant to acquire an\n        ID token.\n\n        Returns:\n            bytes: The authorization grant assertion.\n        \"\"\"\n        now = _helpers.utcnow()\n        lifetime = datetime.timedelta(seconds=_DEFAULT_TOKEN_LIFETIME_SECS)\n        expiry = now + lifetime\n\n        payload = {\n            \"iat\": _helpers.datetime_to_secs(now),\n            \"exp\": _helpers.datetime_to_secs(expiry),\n            # The issuer must be the service account email.\n            \"iss\": self.service_account_email,\n            # The audience must be the auth token endpoint's URI\n            \"aud\": _GOOGLE_OAUTH2_TOKEN_ENDPOINT,\n            # The target audience specifies which service the ID token is\n            # intended for.\n            \"target_audience\": self._target_audience,\n        }\n\n        payload.update(self._additional_claims)\n\n        token = jwt.encode(self._signer, payload)\n\n        return token\n\n    def _refresh_with_iam_endpoint(self, request):\n        \"\"\"Use IAM generateIdToken endpoint to obtain an ID token.\n\n        It works as follows:\n\n        1. First we create a self signed jwt with\n        https://www.googleapis.com/auth/iam being the scope.\n\n        2. Next we use the self signed jwt as the access token, and make a POST\n        request to IAM generateIdToken endpoint. The request body is:\n            {\n                \"audience\": self._target_audience,\n                \"includeEmail\": \"true\",\n                \"useEmailAzp\": \"true\",\n            }\n\n        If the request is succesfully, it will return {\"token\":\"the ID token\"},\n        and we can extract the ID token and compute its expiry.\n        \"\"\"\n        jwt_credentials = jwt.Credentials.from_signing_credentials(\n            self,\n            None,\n            additional_claims={\"scope\": \"https://www.googleapis.com/auth/iam\"},\n        )\n        jwt_credentials.refresh(request)\n        self.token, self.expiry = _client.call_iam_generate_id_token_endpoint(\n            request,\n            self._iam_id_token_endpoint,\n            self.signer_email,\n            self._target_audience,\n            jwt_credentials.token.decode(),\n        )\n\n    @_helpers.copy_docstring(credentials.Credentials)\n    def refresh(self, request):\n        if self._use_iam_endpoint:\n            self._refresh_with_iam_endpoint(request)\n        else:\n            assertion = self._make_authorization_grant_assertion()\n            access_token, expiry, _ = _client.id_token_jwt_grant(\n                request, self._token_uri, assertion\n            )\n            self.token = access_token\n            self.expiry = expiry\n\n    @property\n    def service_account_email(self):\n        \"\"\"The service account email.\"\"\"\n        return self._service_account_email\n\n    @_helpers.copy_docstring(credentials.Signing)\n    def sign_bytes(self, message):\n        return self._signer.sign(message)\n\n    @property  # type: ignore\n    @_helpers.copy_docstring(credentials.Signing)\n    def signer(self):\n        return self._signer\n\n    @property  # type: ignore\n    @_helpers.copy_docstring(credentials.Signing)\n    def signer_email(self):\n        return self._service_account_email\n", "google/oauth2/_credentials_async.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"OAuth 2.0 Async Credentials.\n\nThis module provides credentials based on OAuth 2.0 access and refresh tokens.\nThese credentials usually access resources on behalf of a user (resource\nowner).\n\nSpecifically, this is intended to use access tokens acquired using the\n`Authorization Code grant`_ and can refresh those tokens using a\noptional `refresh token`_.\n\nObtaining the initial access and refresh token is outside of the scope of this\nmodule. Consult `rfc6749 section 4.1`_ for complete details on the\nAuthorization Code grant flow.\n\n.. _Authorization Code grant: https://tools.ietf.org/html/rfc6749#section-1.3.1\n.. _refresh token: https://tools.ietf.org/html/rfc6749#section-6\n.. _rfc6749 section 4.1: https://tools.ietf.org/html/rfc6749#section-4.1\n\"\"\"\n\nfrom google.auth import _credentials_async as credentials\nfrom google.auth import _helpers\nfrom google.auth import exceptions\nfrom google.oauth2 import _reauth_async as reauth\nfrom google.oauth2 import credentials as oauth2_credentials\n\n\nclass Credentials(oauth2_credentials.Credentials):\n    \"\"\"Credentials using OAuth 2.0 access and refresh tokens.\n\n    The credentials are considered immutable. If you want to modify the\n    quota project, use :meth:`with_quota_project` or ::\n\n        credentials = credentials.with_quota_project('myproject-123)\n    \"\"\"\n\n    @_helpers.copy_docstring(credentials.Credentials)\n    async def refresh(self, request):\n        if (\n            self._refresh_token is None\n            or self._token_uri is None\n            or self._client_id is None\n            or self._client_secret is None\n        ):\n            raise exceptions.RefreshError(\n                \"The credentials do not contain the necessary fields need to \"\n                \"refresh the access token. You must specify refresh_token, \"\n                \"token_uri, client_id, and client_secret.\"\n            )\n\n        (\n            access_token,\n            refresh_token,\n            expiry,\n            grant_response,\n            rapt_token,\n        ) = await reauth.refresh_grant(\n            request,\n            self._token_uri,\n            self._refresh_token,\n            self._client_id,\n            self._client_secret,\n            scopes=self._scopes,\n            rapt_token=self._rapt_token,\n            enable_reauth_refresh=self._enable_reauth_refresh,\n        )\n\n        self.token = access_token\n        self.expiry = expiry\n        self._refresh_token = refresh_token\n        self._id_token = grant_response.get(\"id_token\")\n        self._rapt_token = rapt_token\n\n        if self._scopes and \"scope\" in grant_response:\n            requested_scopes = frozenset(self._scopes)\n            granted_scopes = frozenset(grant_response[\"scope\"].split())\n            scopes_requested_but_not_granted = requested_scopes - granted_scopes\n            if scopes_requested_but_not_granted:\n                raise exceptions.RefreshError(\n                    \"Not all requested scopes were granted by the \"\n                    \"authorization server, missing scopes {}.\".format(\n                        \", \".join(scopes_requested_but_not_granted)\n                    )\n                )\n\n    @_helpers.copy_docstring(credentials.Credentials)\n    async def before_request(self, request, method, url, headers):\n        if not self.valid:\n            await self.refresh(request)\n        self.apply(headers)\n\n\nclass UserAccessTokenCredentials(oauth2_credentials.UserAccessTokenCredentials):\n    \"\"\"Access token credentials for user account.\n\n    Obtain the access token for a given user account or the current active\n    user account with the ``gcloud auth print-access-token`` command.\n\n    Args:\n        account (Optional[str]): Account to get the access token for. If not\n            specified, the current active account will be used.\n        quota_project_id (Optional[str]): The project ID used for quota\n            and billing.\n\n    \"\"\"\n", "google/oauth2/webauthn_handler.py": "import abc\nimport os\nimport struct\nimport subprocess\n\nfrom google.auth import exceptions\nfrom google.oauth2.webauthn_types import GetRequest, GetResponse\n\n\nclass WebAuthnHandler(abc.ABC):\n    @abc.abstractmethod\n    def is_available(self) -> bool:\n        \"\"\"Check whether this WebAuthn handler is available\"\"\"\n        raise NotImplementedError(\"is_available method must be implemented\")\n\n    @abc.abstractmethod\n    def get(self, get_request: GetRequest) -> GetResponse:\n        \"\"\"WebAuthn get (assertion)\"\"\"\n        raise NotImplementedError(\"get method must be implemented\")\n\n\nclass PluginHandler(WebAuthnHandler):\n    \"\"\"Offloads WebAuthn get reqeust to a pluggable command-line tool.\n\n    Offloads WebAuthn get to a plugin which takes the form of a\n    command-line tool. The command-line tool is configurable via the\n    PluginHandler._ENV_VAR environment variable.\n\n    The WebAuthn plugin should implement the following interface:\n\n    Communication occurs over stdin/stdout, and messages are both sent and\n    received in the form:\n\n    [4 bytes - payload size (little-endian)][variable bytes - json payload]\n    \"\"\"\n\n    _ENV_VAR = \"GOOGLE_AUTH_WEBAUTHN_PLUGIN\"\n\n    def is_available(self) -> bool:\n        try:\n            self._find_plugin()\n        except Exception:\n            return False\n        else:\n            return True\n\n    def get(self, get_request: GetRequest) -> GetResponse:\n        request_json = get_request.to_json()\n        cmd = self._find_plugin()\n        response_json = self._call_plugin(cmd, request_json)\n        return GetResponse.from_json(response_json)\n\n    def _call_plugin(self, cmd: str, input_json: str) -> str:\n        # Calculate length of input\n        input_length = len(input_json)\n        length_bytes_le = struct.pack(\"<I\", input_length)\n        request = length_bytes_le + input_json.encode()\n\n        # Call plugin\n        process_result = subprocess.run(\n            [cmd], input=request, capture_output=True, check=True\n        )\n\n        # Check length of response\n        response_len_le = process_result.stdout[:4]\n        response_len = struct.unpack(\"<I\", response_len_le)[0]\n        response = process_result.stdout[4:]\n        if response_len != len(response):\n            raise exceptions.MalformedError(\n                \"Plugin response length {} does not match data {}\".format(\n                    response_len, len(response)\n                )\n            )\n        return response.decode()\n\n    def _find_plugin(self) -> str:\n        plugin_cmd = os.environ.get(PluginHandler._ENV_VAR)\n        if plugin_cmd is None:\n            raise exceptions.InvalidResource(\n                \"{} env var is not set\".format(PluginHandler._ENV_VAR)\n            )\n        return plugin_cmd\n", "google/oauth2/utils.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"OAuth 2.0 Utilities.\n\nThis module provides implementations for various OAuth 2.0 utilities.\nThis includes `OAuth error handling`_ and\n`Client authentication for OAuth flows`_.\n\nOAuth error handling\n--------------------\nThis will define interfaces for handling OAuth related error responses as\nstated in `RFC 6749 section 5.2`_.\nThis will include a common function to convert these HTTP error responses to a\n:class:`google.auth.exceptions.OAuthError` exception.\n\n\nClient authentication for OAuth flows\n-------------------------------------\nWe introduce an interface for defining client authentication credentials based\non `RFC 6749 section 2.3.1`_. This will expose the following\ncapabilities:\n\n    * Ability to support basic authentication via request header.\n    * Ability to support bearer token authentication via request header.\n    * Ability to support client ID / secret authentication via request body.\n\n.. _RFC 6749 section 2.3.1: https://tools.ietf.org/html/rfc6749#section-2.3.1\n.. _RFC 6749 section 5.2: https://tools.ietf.org/html/rfc6749#section-5.2\n\"\"\"\n\nimport abc\nimport base64\nimport enum\nimport json\n\nfrom google.auth import exceptions\n\n\n# OAuth client authentication based on\n# https://tools.ietf.org/html/rfc6749#section-2.3.\nclass ClientAuthType(enum.Enum):\n    basic = 1\n    request_body = 2\n\n\nclass ClientAuthentication(object):\n    \"\"\"Defines the client authentication credentials for basic and request-body\n    types based on https://tools.ietf.org/html/rfc6749#section-2.3.1.\n    \"\"\"\n\n    def __init__(self, client_auth_type, client_id, client_secret=None):\n        \"\"\"Instantiates a client authentication object containing the client ID\n        and secret credentials for basic and response-body auth.\n\n        Args:\n            client_auth_type (google.oauth2.oauth_utils.ClientAuthType): The\n                client authentication type.\n            client_id (str): The client ID.\n            client_secret (Optional[str]): The client secret.\n        \"\"\"\n        self.client_auth_type = client_auth_type\n        self.client_id = client_id\n        self.client_secret = client_secret\n\n\nclass OAuthClientAuthHandler(metaclass=abc.ABCMeta):\n    \"\"\"Abstract class for handling client authentication in OAuth-based\n    operations.\n    \"\"\"\n\n    def __init__(self, client_authentication=None):\n        \"\"\"Instantiates an OAuth client authentication handler.\n\n        Args:\n            client_authentication (Optional[google.oauth2.utils.ClientAuthentication]):\n                The OAuth client authentication credentials if available.\n        \"\"\"\n        super(OAuthClientAuthHandler, self).__init__()\n        self._client_authentication = client_authentication\n\n    def apply_client_authentication_options(\n        self, headers, request_body=None, bearer_token=None\n    ):\n        \"\"\"Applies client authentication on the OAuth request's headers or POST\n        body.\n\n        Args:\n            headers (Mapping[str, str]): The HTTP request header.\n            request_body (Optional[Mapping[str, str]]): The HTTP request body\n                dictionary. For requests that do not support request body, this\n                is None and will be ignored.\n            bearer_token (Optional[str]): The optional bearer token.\n        \"\"\"\n        # Inject authenticated header.\n        self._inject_authenticated_headers(headers, bearer_token)\n        # Inject authenticated request body.\n        if bearer_token is None:\n            self._inject_authenticated_request_body(request_body)\n\n    def _inject_authenticated_headers(self, headers, bearer_token=None):\n        if bearer_token is not None:\n            headers[\"Authorization\"] = \"Bearer %s\" % bearer_token\n        elif (\n            self._client_authentication is not None\n            and self._client_authentication.client_auth_type is ClientAuthType.basic\n        ):\n            username = self._client_authentication.client_id\n            password = self._client_authentication.client_secret or \"\"\n\n            credentials = base64.b64encode(\n                (\"%s:%s\" % (username, password)).encode()\n            ).decode()\n            headers[\"Authorization\"] = \"Basic %s\" % credentials\n\n    def _inject_authenticated_request_body(self, request_body):\n        if (\n            self._client_authentication is not None\n            and self._client_authentication.client_auth_type\n            is ClientAuthType.request_body\n        ):\n            if request_body is None:\n                raise exceptions.OAuthError(\n                    \"HTTP request does not support request-body\"\n                )\n            else:\n                request_body[\"client_id\"] = self._client_authentication.client_id\n                request_body[\"client_secret\"] = (\n                    self._client_authentication.client_secret or \"\"\n                )\n\n\ndef handle_error_response(response_body):\n    \"\"\"Translates an error response from an OAuth operation into an\n    OAuthError exception.\n\n    Args:\n        response_body (str): The decoded response data.\n\n    Raises:\n        google.auth.exceptions.OAuthError\n    \"\"\"\n    try:\n        error_components = []\n        error_data = json.loads(response_body)\n\n        error_components.append(\"Error code {}\".format(error_data[\"error\"]))\n        if \"error_description\" in error_data:\n            error_components.append(\": {}\".format(error_data[\"error_description\"]))\n        if \"error_uri\" in error_data:\n            error_components.append(\" - {}\".format(error_data[\"error_uri\"]))\n        error_details = \"\".join(error_components)\n    # If no details could be extracted, use the response data.\n    except (KeyError, ValueError):\n        error_details = response_body\n\n    raise exceptions.OAuthError(error_details, response_body)\n", "google/oauth2/sts.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"OAuth 2.0 Token Exchange Spec.\n\nThis module defines a token exchange utility based on the `OAuth 2.0 Token\nExchange`_ spec. This will be mainly used to exchange external credentials\nfor GCP access tokens in workload identity pools to access Google APIs.\n\nThe implementation will support various types of client authentication as\nallowed in the spec.\n\nA deviation on the spec will be for additional Google specific options that\ncannot be easily mapped to parameters defined in the RFC.\n\nThe returned dictionary response will be based on the `rfc8693 section 2.2.1`_\nspec JSON response.\n\n.. _OAuth 2.0 Token Exchange: https://tools.ietf.org/html/rfc8693\n.. _rfc8693 section 2.2.1: https://tools.ietf.org/html/rfc8693#section-2.2.1\n\"\"\"\n\nimport http.client as http_client\nimport json\nimport urllib\n\nfrom google.oauth2 import utils\n\n\n_URLENCODED_HEADERS = {\"Content-Type\": \"application/x-www-form-urlencoded\"}\n\n\nclass Client(utils.OAuthClientAuthHandler):\n    \"\"\"Implements the OAuth 2.0 token exchange spec based on\n    https://tools.ietf.org/html/rfc8693.\n    \"\"\"\n\n    def __init__(self, token_exchange_endpoint, client_authentication=None):\n        \"\"\"Initializes an STS client instance.\n\n        Args:\n            token_exchange_endpoint (str): The token exchange endpoint.\n            client_authentication (Optional(google.oauth2.oauth2_utils.ClientAuthentication)):\n                The optional OAuth client authentication credentials if available.\n        \"\"\"\n        super(Client, self).__init__(client_authentication)\n        self._token_exchange_endpoint = token_exchange_endpoint\n\n    def _make_request(self, request, headers, request_body):\n        # Initialize request headers.\n        request_headers = _URLENCODED_HEADERS.copy()\n\n        # Inject additional headers.\n        if headers:\n            for k, v in dict(headers).items():\n                request_headers[k] = v\n\n        # Apply OAuth client authentication.\n        self.apply_client_authentication_options(request_headers, request_body)\n\n        # Execute request.\n        response = request(\n            url=self._token_exchange_endpoint,\n            method=\"POST\",\n            headers=request_headers,\n            body=urllib.parse.urlencode(request_body).encode(\"utf-8\"),\n        )\n\n        response_body = (\n            response.data.decode(\"utf-8\")\n            if hasattr(response.data, \"decode\")\n            else response.data\n        )\n\n        # If non-200 response received, translate to OAuthError exception.\n        if response.status != http_client.OK:\n            utils.handle_error_response(response_body)\n\n        response_data = json.loads(response_body)\n\n        # Return successful response.\n        return response_data\n\n    def exchange_token(\n        self,\n        request,\n        grant_type,\n        subject_token,\n        subject_token_type,\n        resource=None,\n        audience=None,\n        scopes=None,\n        requested_token_type=None,\n        actor_token=None,\n        actor_token_type=None,\n        additional_options=None,\n        additional_headers=None,\n    ):\n        \"\"\"Exchanges the provided token for another type of token based on the\n        rfc8693 spec.\n\n        Args:\n            request (google.auth.transport.Request): A callable used to make\n                HTTP requests.\n            grant_type (str): The OAuth 2.0 token exchange grant type.\n            subject_token (str): The OAuth 2.0 token exchange subject token.\n            subject_token_type (str): The OAuth 2.0 token exchange subject token type.\n            resource (Optional[str]): The optional OAuth 2.0 token exchange resource field.\n            audience (Optional[str]): The optional OAuth 2.0 token exchange audience field.\n            scopes (Optional[Sequence[str]]): The optional list of scopes to use.\n            requested_token_type (Optional[str]): The optional OAuth 2.0 token exchange requested\n                token type.\n            actor_token (Optional[str]): The optional OAuth 2.0 token exchange actor token.\n            actor_token_type (Optional[str]): The optional OAuth 2.0 token exchange actor token type.\n            additional_options (Optional[Mapping[str, str]]): The optional additional\n                non-standard Google specific options.\n            additional_headers (Optional[Mapping[str, str]]): The optional additional\n                headers to pass to the token exchange endpoint.\n\n        Returns:\n            Mapping[str, str]: The token exchange JSON-decoded response data containing\n                the requested token and its expiration time.\n\n        Raises:\n            google.auth.exceptions.OAuthError: If the token endpoint returned\n                an error.\n        \"\"\"\n        # Initialize request body.\n        request_body = {\n            \"grant_type\": grant_type,\n            \"resource\": resource,\n            \"audience\": audience,\n            \"scope\": \" \".join(scopes or []),\n            \"requested_token_type\": requested_token_type,\n            \"subject_token\": subject_token,\n            \"subject_token_type\": subject_token_type,\n            \"actor_token\": actor_token,\n            \"actor_token_type\": actor_token_type,\n            \"options\": None,\n        }\n        # Add additional non-standard options.\n        if additional_options:\n            request_body[\"options\"] = urllib.parse.quote(json.dumps(additional_options))\n        # Remove empty fields in request body.\n        for k, v in dict(request_body).items():\n            if v is None or v == \"\":\n                del request_body[k]\n\n        return self._make_request(request, additional_headers, request_body)\n\n    def refresh_token(self, request, refresh_token):\n        \"\"\"Exchanges a refresh token for an access token based on the\n        RFC6749 spec.\n\n        Args:\n            request (google.auth.transport.Request): A callable used to make\n                HTTP requests.\n            subject_token (str): The OAuth 2.0 refresh token.\n        \"\"\"\n\n        return self._make_request(\n            request,\n            None,\n            {\"grant_type\": \"refresh_token\", \"refresh_token\": refresh_token},\n        )\n", "google/oauth2/id_token.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Google ID Token helpers.\n\nProvides support for verifying `OpenID Connect ID Tokens`_, especially ones\ngenerated by Google infrastructure.\n\nTo parse and verify an ID Token issued by Google's OAuth 2.0 authorization\nserver use :func:`verify_oauth2_token`. To verify an ID Token issued by\nFirebase, use :func:`verify_firebase_token`.\n\nA general purpose ID Token verifier is available as :func:`verify_token`.\n\nExample::\n\n    from google.oauth2 import id_token\n    from google.auth.transport import requests\n\n    request = requests.Request()\n\n    id_info = id_token.verify_oauth2_token(\n        token, request, 'my-client-id.example.com')\n\n    userid = id_info['sub']\n\nBy default, this will re-fetch certificates for each verification. Because\nGoogle's public keys are only changed infrequently (on the order of once per\nday), you may wish to take advantage of caching to reduce latency and the\npotential for network errors. This can be accomplished using an external\nlibrary like `CacheControl`_ to create a cache-aware\n:class:`google.auth.transport.Request`::\n\n    import cachecontrol\n    import google.auth.transport.requests\n    import requests\n\n    session = requests.session()\n    cached_session = cachecontrol.CacheControl(session)\n    request = google.auth.transport.requests.Request(session=cached_session)\n\n.. _OpenID Connect ID Tokens:\n    http://openid.net/specs/openid-connect-core-1_0.html#IDToken\n.. _CacheControl: https://cachecontrol.readthedocs.io\n\"\"\"\n\nimport http.client as http_client\nimport json\nimport os\n\nfrom google.auth import environment_vars\nfrom google.auth import exceptions\nfrom google.auth import jwt\n\n\n# The URL that provides public certificates for verifying ID tokens issued\n# by Google's OAuth 2.0 authorization server.\n_GOOGLE_OAUTH2_CERTS_URL = \"https://www.googleapis.com/oauth2/v1/certs\"\n\n# The URL that provides public certificates for verifying ID tokens issued\n# by Firebase and the Google APIs infrastructure\n_GOOGLE_APIS_CERTS_URL = (\n    \"https://www.googleapis.com/robot/v1/metadata/x509\"\n    \"/securetoken@system.gserviceaccount.com\"\n)\n\n_GOOGLE_ISSUERS = [\"accounts.google.com\", \"https://accounts.google.com\"]\n\n\ndef _fetch_certs(request, certs_url):\n    \"\"\"Fetches certificates.\n\n    Google-style cerificate endpoints return JSON in the format of\n    ``{'key id': 'x509 certificate'}``.\n\n    Args:\n        request (google.auth.transport.Request): The object used to make\n            HTTP requests.\n        certs_url (str): The certificate endpoint URL.\n\n    Returns:\n        Mapping[str, str]: A mapping of public key ID to x.509 certificate\n            data.\n    \"\"\"\n    response = request(certs_url, method=\"GET\")\n\n    if response.status != http_client.OK:\n        raise exceptions.TransportError(\n            \"Could not fetch certificates at {}\".format(certs_url)\n        )\n\n    return json.loads(response.data.decode(\"utf-8\"))\n\n\ndef verify_token(\n    id_token,\n    request,\n    audience=None,\n    certs_url=_GOOGLE_OAUTH2_CERTS_URL,\n    clock_skew_in_seconds=0,\n):\n    \"\"\"Verifies an ID token and returns the decoded token.\n\n    Args:\n        id_token (Union[str, bytes]): The encoded token.\n        request (google.auth.transport.Request): The object used to make\n            HTTP requests.\n        audience (str or list): The audience or audiences that this token is\n            intended for. If None then the audience is not verified.\n        certs_url (str): The URL that specifies the certificates to use to\n            verify the token. This URL should return JSON in the format of\n            ``{'key id': 'x509 certificate'}``.\n        clock_skew_in_seconds (int): The clock skew used for `iat` and `exp`\n            validation.\n\n    Returns:\n        Mapping[str, Any]: The decoded token.\n    \"\"\"\n    certs = _fetch_certs(request, certs_url)\n\n    return jwt.decode(\n        id_token,\n        certs=certs,\n        audience=audience,\n        clock_skew_in_seconds=clock_skew_in_seconds,\n    )\n\n\ndef verify_oauth2_token(id_token, request, audience=None, clock_skew_in_seconds=0):\n    \"\"\"Verifies an ID Token issued by Google's OAuth 2.0 authorization server.\n\n    Args:\n        id_token (Union[str, bytes]): The encoded token.\n        request (google.auth.transport.Request): The object used to make\n            HTTP requests.\n        audience (str): The audience that this token is intended for. This is\n            typically your application's OAuth 2.0 client ID. If None then the\n            audience is not verified.\n        clock_skew_in_seconds (int): The clock skew used for `iat` and `exp`\n            validation.\n\n    Returns:\n        Mapping[str, Any]: The decoded token.\n\n    Raises:\n        exceptions.GoogleAuthError: If the issuer is invalid.\n        ValueError: If token verification fails\n    \"\"\"\n    idinfo = verify_token(\n        id_token,\n        request,\n        audience=audience,\n        certs_url=_GOOGLE_OAUTH2_CERTS_URL,\n        clock_skew_in_seconds=clock_skew_in_seconds,\n    )\n\n    if idinfo[\"iss\"] not in _GOOGLE_ISSUERS:\n        raise exceptions.GoogleAuthError(\n            \"Wrong issuer. 'iss' should be one of the following: {}\".format(\n                _GOOGLE_ISSUERS\n            )\n        )\n\n    return idinfo\n\n\ndef verify_firebase_token(id_token, request, audience=None, clock_skew_in_seconds=0):\n    \"\"\"Verifies an ID Token issued by Firebase Authentication.\n\n    Args:\n        id_token (Union[str, bytes]): The encoded token.\n        request (google.auth.transport.Request): The object used to make\n            HTTP requests.\n        audience (str): The audience that this token is intended for. This is\n            typically your Firebase application ID. If None then the audience\n            is not verified.\n        clock_skew_in_seconds (int): The clock skew used for `iat` and `exp`\n            validation.\n\n    Returns:\n        Mapping[str, Any]: The decoded token.\n    \"\"\"\n    return verify_token(\n        id_token,\n        request,\n        audience=audience,\n        certs_url=_GOOGLE_APIS_CERTS_URL,\n        clock_skew_in_seconds=clock_skew_in_seconds,\n    )\n\n\ndef fetch_id_token_credentials(audience, request=None):\n    \"\"\"Create the ID Token credentials from the current environment.\n\n    This function acquires ID token from the environment in the following order.\n    See https://google.aip.dev/auth/4110.\n\n    1. If the environment variable ``GOOGLE_APPLICATION_CREDENTIALS`` is set\n       to the path of a valid service account JSON file, then ID token is\n       acquired using this service account credentials.\n    2. If the application is running in Compute Engine, App Engine or Cloud Run,\n       then the ID token are obtained from the metadata server.\n    3. If metadata server doesn't exist and no valid service account credentials\n       are found, :class:`~google.auth.exceptions.DefaultCredentialsError` will\n       be raised.\n\n    Example::\n\n        import google.oauth2.id_token\n        import google.auth.transport.requests\n\n        request = google.auth.transport.requests.Request()\n        target_audience = \"https://pubsub.googleapis.com\"\n\n        # Create ID token credentials.\n        credentials = google.oauth2.id_token.fetch_id_token_credentials(target_audience, request=request)\n\n        # Refresh the credential to obtain an ID token.\n        credentials.refresh(request)\n\n        id_token = credentials.token\n        id_token_expiry = credentials.expiry\n\n    Args:\n        audience (str): The audience that this ID token is intended for.\n        request (Optional[google.auth.transport.Request]): A callable used to make\n            HTTP requests. A request object will be created if not provided.\n\n    Returns:\n        google.auth.credentials.Credentials: The ID token credentials.\n\n    Raises:\n        ~google.auth.exceptions.DefaultCredentialsError:\n            If metadata server doesn't exist and no valid service account\n            credentials are found.\n    \"\"\"\n    # 1. Try to get credentials from the GOOGLE_APPLICATION_CREDENTIALS environment\n    # variable.\n    credentials_filename = os.environ.get(environment_vars.CREDENTIALS)\n    if credentials_filename:\n        if not (\n            os.path.exists(credentials_filename)\n            and os.path.isfile(credentials_filename)\n        ):\n            raise exceptions.DefaultCredentialsError(\n                \"GOOGLE_APPLICATION_CREDENTIALS path is either not found or invalid.\"\n            )\n\n        try:\n            with open(credentials_filename, \"r\") as f:\n                from google.oauth2 import service_account\n\n                info = json.load(f)\n                if info.get(\"type\") == \"service_account\":\n                    return service_account.IDTokenCredentials.from_service_account_info(\n                        info, target_audience=audience\n                    )\n        except ValueError as caught_exc:\n            new_exc = exceptions.DefaultCredentialsError(\n                \"GOOGLE_APPLICATION_CREDENTIALS is not valid service account credentials.\",\n                caught_exc,\n            )\n            raise new_exc from caught_exc\n\n    # 2. Try to fetch ID token from metada server if it exists. The code\n    # works for GAE and Cloud Run metadata server as well.\n    try:\n        from google.auth import compute_engine\n        from google.auth.compute_engine import _metadata\n\n        # Create a request object if not provided.\n        if not request:\n            import google.auth.transport.requests\n\n            request = google.auth.transport.requests.Request()\n\n        if _metadata.ping(request):\n            return compute_engine.IDTokenCredentials(\n                request, audience, use_metadata_identity_endpoint=True\n            )\n    except (ImportError, exceptions.TransportError):\n        pass\n\n    raise exceptions.DefaultCredentialsError(\n        \"Neither metadata server or valid service account credentials are found.\"\n    )\n\n\ndef fetch_id_token(request, audience):\n    \"\"\"Fetch the ID Token from the current environment.\n\n    This function acquires ID token from the environment in the following order.\n    See https://google.aip.dev/auth/4110.\n\n    1. If the environment variable ``GOOGLE_APPLICATION_CREDENTIALS`` is set\n       to the path of a valid service account JSON file, then ID token is\n       acquired using this service account credentials.\n    2. If the application is running in Compute Engine, App Engine or Cloud Run,\n       then the ID token are obtained from the metadata server.\n    3. If metadata server doesn't exist and no valid service account credentials\n       are found, :class:`~google.auth.exceptions.DefaultCredentialsError` will\n       be raised.\n\n    Example::\n\n        import google.oauth2.id_token\n        import google.auth.transport.requests\n\n        request = google.auth.transport.requests.Request()\n        target_audience = \"https://pubsub.googleapis.com\"\n\n        id_token = google.oauth2.id_token.fetch_id_token(request, target_audience)\n\n    Args:\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests.\n        audience (str): The audience that this ID token is intended for.\n\n    Returns:\n        str: The ID token.\n\n    Raises:\n        ~google.auth.exceptions.DefaultCredentialsError:\n            If metadata server doesn't exist and no valid service account\n            credentials are found.\n    \"\"\"\n    id_token_credentials = fetch_id_token_credentials(audience, request=request)\n    id_token_credentials.refresh(request)\n    return id_token_credentials.token\n", "google/oauth2/reauth.py": "# Copyright 2021 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"A module that provides functions for handling rapt authentication.\n\nReauth is a process of obtaining additional authentication (such as password,\nsecurity token, etc.) while refreshing OAuth 2.0 credentials for a user.\n\nCredentials that use the Reauth flow must have the reauth scope,\n``https://www.googleapis.com/auth/accounts.reauth``.\n\nThis module provides a high-level function for executing the Reauth process,\n:func:`refresh_grant`, and lower-level helpers for doing the individual\nsteps of the reauth process.\n\nThose steps are:\n\n1. Obtaining a list of challenges from the reauth server.\n2. Running through each challenge and sending the result back to the reauth\n   server.\n3. Refreshing the access token using the returned rapt token.\n\"\"\"\n\nimport sys\n\nfrom google.auth import exceptions\nfrom google.auth import metrics\nfrom google.oauth2 import _client\nfrom google.oauth2 import challenges\n\n\n_REAUTH_SCOPE = \"https://www.googleapis.com/auth/accounts.reauth\"\n_REAUTH_API = \"https://reauth.googleapis.com/v2/sessions\"\n\n_REAUTH_NEEDED_ERROR = \"invalid_grant\"\n_REAUTH_NEEDED_ERROR_INVALID_RAPT = \"invalid_rapt\"\n_REAUTH_NEEDED_ERROR_RAPT_REQUIRED = \"rapt_required\"\n\n_AUTHENTICATED = \"AUTHENTICATED\"\n_CHALLENGE_REQUIRED = \"CHALLENGE_REQUIRED\"\n_CHALLENGE_PENDING = \"CHALLENGE_PENDING\"\n\n\n# Override this global variable to set custom max number of rounds of reauth\n# challenges should be run.\nRUN_CHALLENGE_RETRY_LIMIT = 5\n\n\ndef is_interactive():\n    \"\"\"Check if we are in an interractive environment.\n\n    Override this function with a different logic if you are using this library\n    outside a CLI.\n\n    If the rapt token needs refreshing, the user needs to answer the challenges.\n    If the user is not in an interractive environment, the challenges can not\n    be answered and we just wait for timeout for no reason.\n\n    Returns:\n        bool: True if is interactive environment, False otherwise.\n    \"\"\"\n\n    return sys.stdin.isatty()\n\n\ndef _get_challenges(\n    request, supported_challenge_types, access_token, requested_scopes=None\n):\n    \"\"\"Does initial request to reauth API to get the challenges.\n\n    Args:\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests.\n        supported_challenge_types (Sequence[str]): list of challenge names\n            supported by the manager.\n        access_token (str): Access token with reauth scopes.\n        requested_scopes (Optional(Sequence[str])): Authorized scopes for the credentials.\n\n    Returns:\n        dict: The response from the reauth API.\n    \"\"\"\n    body = {\"supportedChallengeTypes\": supported_challenge_types}\n    if requested_scopes:\n        body[\"oauthScopesForDomainPolicyLookup\"] = requested_scopes\n    metrics_header = {metrics.API_CLIENT_HEADER: metrics.reauth_start()}\n\n    return _client._token_endpoint_request(\n        request,\n        _REAUTH_API + \":start\",\n        body,\n        access_token=access_token,\n        use_json=True,\n        headers=metrics_header,\n    )\n\n\ndef _send_challenge_result(\n    request, session_id, challenge_id, client_input, access_token\n):\n    \"\"\"Attempt to refresh access token by sending next challenge result.\n\n    Args:\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests.\n        session_id (str): session id returned by the initial reauth call.\n        challenge_id (str): challenge id returned by the initial reauth call.\n        client_input: dict with a challenge-specific client input. For example:\n            ``{'credential': password}`` for password challenge.\n        access_token (str): Access token with reauth scopes.\n\n    Returns:\n        dict: The response from the reauth API.\n    \"\"\"\n    body = {\n        \"sessionId\": session_id,\n        \"challengeId\": challenge_id,\n        \"action\": \"RESPOND\",\n        \"proposalResponse\": client_input,\n    }\n    metrics_header = {metrics.API_CLIENT_HEADER: metrics.reauth_continue()}\n\n    return _client._token_endpoint_request(\n        request,\n        _REAUTH_API + \"/{}:continue\".format(session_id),\n        body,\n        access_token=access_token,\n        use_json=True,\n        headers=metrics_header,\n    )\n\n\ndef _run_next_challenge(msg, request, access_token):\n    \"\"\"Get the next challenge from msg and run it.\n\n    Args:\n        msg (dict): Reauth API response body (either from the initial request to\n            https://reauth.googleapis.com/v2/sessions:start or from sending the\n            previous challenge response to\n            https://reauth.googleapis.com/v2/sessions/id:continue)\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests.\n        access_token (str): reauth access token\n\n    Returns:\n        dict: The response from the reauth API.\n\n    Raises:\n        google.auth.exceptions.ReauthError: if reauth failed.\n    \"\"\"\n    for challenge in msg[\"challenges\"]:\n        if challenge[\"status\"] != \"READY\":\n            # Skip non-activated challenges.\n            continue\n        c = challenges.AVAILABLE_CHALLENGES.get(challenge[\"challengeType\"], None)\n        if not c:\n            raise exceptions.ReauthFailError(\n                \"Unsupported challenge type {0}. Supported types: {1}\".format(\n                    challenge[\"challengeType\"],\n                    \",\".join(list(challenges.AVAILABLE_CHALLENGES.keys())),\n                )\n            )\n        if not c.is_locally_eligible:\n            raise exceptions.ReauthFailError(\n                \"Challenge {0} is not locally eligible\".format(\n                    challenge[\"challengeType\"]\n                )\n            )\n        client_input = c.obtain_challenge_input(challenge)\n        if not client_input:\n            return None\n        return _send_challenge_result(\n            request,\n            msg[\"sessionId\"],\n            challenge[\"challengeId\"],\n            client_input,\n            access_token,\n        )\n    return None\n\n\ndef _obtain_rapt(request, access_token, requested_scopes):\n    \"\"\"Given an http request method and reauth access token, get rapt token.\n\n    Args:\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests.\n        access_token (str): reauth access token\n        requested_scopes (Sequence[str]): scopes required by the client application\n\n    Returns:\n        str: The rapt token.\n\n    Raises:\n        google.auth.exceptions.ReauthError: if reauth failed\n    \"\"\"\n    msg = _get_challenges(\n        request,\n        list(challenges.AVAILABLE_CHALLENGES.keys()),\n        access_token,\n        requested_scopes,\n    )\n\n    if msg[\"status\"] == _AUTHENTICATED:\n        return msg[\"encodedProofOfReauthToken\"]\n\n    for _ in range(0, RUN_CHALLENGE_RETRY_LIMIT):\n        if not (\n            msg[\"status\"] == _CHALLENGE_REQUIRED or msg[\"status\"] == _CHALLENGE_PENDING\n        ):\n            raise exceptions.ReauthFailError(\n                \"Reauthentication challenge failed due to API error: {}\".format(\n                    msg[\"status\"]\n                )\n            )\n\n        if not is_interactive():\n            raise exceptions.ReauthFailError(\n                \"Reauthentication challenge could not be answered because you are not\"\n                \" in an interactive session.\"\n            )\n\n        msg = _run_next_challenge(msg, request, access_token)\n\n        if not msg:\n            raise exceptions.ReauthFailError(\"Failed to obtain rapt token.\")\n        if msg[\"status\"] == _AUTHENTICATED:\n            return msg[\"encodedProofOfReauthToken\"]\n\n    # If we got here it means we didn't get authenticated.\n    raise exceptions.ReauthFailError(\"Failed to obtain rapt token.\")\n\n\ndef get_rapt_token(\n    request, client_id, client_secret, refresh_token, token_uri, scopes=None\n):\n    \"\"\"Given an http request method and refresh_token, get rapt token.\n\n    Args:\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests.\n        client_id (str): client id to get access token for reauth scope.\n        client_secret (str): client secret for the client_id\n        refresh_token (str): refresh token to refresh access token\n        token_uri (str): uri to refresh access token\n        scopes (Optional(Sequence[str])): scopes required by the client application\n\n    Returns:\n        str: The rapt token.\n    Raises:\n        google.auth.exceptions.RefreshError: If reauth failed.\n    \"\"\"\n    sys.stderr.write(\"Reauthentication required.\\n\")\n\n    # Get access token for reauth.\n    access_token, _, _, _ = _client.refresh_grant(\n        request=request,\n        client_id=client_id,\n        client_secret=client_secret,\n        refresh_token=refresh_token,\n        token_uri=token_uri,\n        scopes=[_REAUTH_SCOPE],\n    )\n\n    # Get rapt token from reauth API.\n    rapt_token = _obtain_rapt(request, access_token, requested_scopes=scopes)\n    sys.stderr.write(\"Reauthentication successful.\\n\")\n\n    return rapt_token\n\n\ndef refresh_grant(\n    request,\n    token_uri,\n    refresh_token,\n    client_id,\n    client_secret,\n    scopes=None,\n    rapt_token=None,\n    enable_reauth_refresh=False,\n):\n    \"\"\"Implements the reauthentication flow.\n\n    Args:\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests.\n        token_uri (str): The OAuth 2.0 authorizations server's token endpoint\n            URI.\n        refresh_token (str): The refresh token to use to get a new access\n            token.\n        client_id (str): The OAuth 2.0 application's client ID.\n        client_secret (str): The Oauth 2.0 appliaction's client secret.\n        scopes (Optional(Sequence[str])): Scopes to request. If present, all\n            scopes must be authorized for the refresh token. Useful if refresh\n            token has a wild card scope (e.g.\n            'https://www.googleapis.com/auth/any-api').\n        rapt_token (Optional(str)): The rapt token for reauth.\n        enable_reauth_refresh (Optional[bool]): Whether reauth refresh flow\n            should be used. The default value is False. This option is for\n            gcloud only, other users should use the default value.\n\n    Returns:\n        Tuple[str, Optional[str], Optional[datetime], Mapping[str, str], str]: The\n            access token, new refresh token, expiration, the additional data\n            returned by the token endpoint, and the rapt token.\n\n    Raises:\n        google.auth.exceptions.RefreshError: If the token endpoint returned\n            an error.\n    \"\"\"\n    body = {\n        \"grant_type\": _client._REFRESH_GRANT_TYPE,\n        \"client_id\": client_id,\n        \"client_secret\": client_secret,\n        \"refresh_token\": refresh_token,\n    }\n    if scopes:\n        body[\"scope\"] = \" \".join(scopes)\n    if rapt_token:\n        body[\"rapt\"] = rapt_token\n    metrics_header = {metrics.API_CLIENT_HEADER: metrics.token_request_user()}\n\n    response_status_ok, response_data, retryable_error = _client._token_endpoint_request_no_throw(\n        request, token_uri, body, headers=metrics_header\n    )\n\n    if not response_status_ok and isinstance(response_data, str):\n        raise exceptions.RefreshError(response_data, retryable=False)\n\n    if (\n        not response_status_ok\n        and response_data.get(\"error\") == _REAUTH_NEEDED_ERROR\n        and (\n            response_data.get(\"error_subtype\") == _REAUTH_NEEDED_ERROR_INVALID_RAPT\n            or response_data.get(\"error_subtype\") == _REAUTH_NEEDED_ERROR_RAPT_REQUIRED\n        )\n    ):\n        if not enable_reauth_refresh:\n            raise exceptions.RefreshError(\n                \"Reauthentication is needed. Please run `gcloud auth application-default login` to reauthenticate.\"\n            )\n\n        rapt_token = get_rapt_token(\n            request, client_id, client_secret, refresh_token, token_uri, scopes=scopes\n        )\n        body[\"rapt\"] = rapt_token\n        (\n            response_status_ok,\n            response_data,\n            retryable_error,\n        ) = _client._token_endpoint_request_no_throw(\n            request, token_uri, body, headers=metrics_header\n        )\n\n    if not response_status_ok:\n        _client._handle_error_response(response_data, retryable_error)\n    return _client._handle_refresh_grant_response(response_data, refresh_token) + (\n        rapt_token,\n    )\n", "google/oauth2/gdch_credentials.py": "# Copyright 2022 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Experimental GDCH credentials support.\n\"\"\"\n\nimport datetime\n\nfrom google.auth import _helpers\nfrom google.auth import _service_account_info\nfrom google.auth import credentials\nfrom google.auth import exceptions\nfrom google.auth import jwt\nfrom google.oauth2 import _client\n\n\nTOKEN_EXCHANGE_TYPE = \"urn:ietf:params:oauth:token-type:token-exchange\"\nACCESS_TOKEN_TOKEN_TYPE = \"urn:ietf:params:oauth:token-type:access_token\"\nSERVICE_ACCOUNT_TOKEN_TYPE = \"urn:k8s:params:oauth:token-type:serviceaccount\"\nJWT_LIFETIME = datetime.timedelta(seconds=3600)  # 1 hour\n\n\nclass ServiceAccountCredentials(credentials.Credentials):\n    \"\"\"Credentials for GDCH (`Google Distributed Cloud Hosted`_) for service\n    account users.\n\n    .. _Google Distributed Cloud Hosted:\n        https://cloud.google.com/blog/topics/hybrid-cloud/\\\n            announcing-google-distributed-cloud-edge-and-hosted\n\n    To create a GDCH service account credential, first create a JSON file of\n    the following format::\n\n        {\n            \"type\": \"gdch_service_account\",\n            \"format_version\": \"1\",\n            \"project\": \"<project name>\",\n            \"private_key_id\": \"<key id>\",\n            \"private_key\": \"-----BEGIN EC PRIVATE KEY-----\\n<key bytes>\\n-----END EC PRIVATE KEY-----\\n\",\n            \"name\": \"<service identity name>\",\n            \"ca_cert_path\": \"<CA cert path>\",\n            \"token_uri\": \"https://service-identity.<Domain>/authenticate\"\n        }\n\n    The \"format_version\" field stands for the format of the JSON file. For now\n    it is always \"1\". The `private_key_id` and `private_key` is used for signing.\n    The `ca_cert_path` is used for token server TLS certificate verification.\n\n    After the JSON file is created, set `GOOGLE_APPLICATION_CREDENTIALS` environment\n    variable to the JSON file path, then use the following code to create the\n    credential::\n\n        import google.auth\n\n        credential, _ = google.auth.default()\n        credential = credential.with_gdch_audience(\"<the audience>\")\n\n    We can also create the credential directly::\n\n        from google.oauth import gdch_credentials\n\n        credential = gdch_credentials.ServiceAccountCredentials.from_service_account_file(\"<the json file path>\")\n        credential = credential.with_gdch_audience(\"<the audience>\")\n\n    The token is obtained in the following way. This class first creates a\n    self signed JWT. It uses the `name` value as the `iss` and `sub` claim, and\n    the `token_uri` as the `aud` claim, and signs the JWT with the `private_key`.\n    It then sends the JWT to the `token_uri` to exchange a final token for\n    `audience`.\n    \"\"\"\n\n    def __init__(\n        self, signer, service_identity_name, project, audience, token_uri, ca_cert_path\n    ):\n        \"\"\"\n        Args:\n            signer (google.auth.crypt.Signer): The signer used to sign JWTs.\n            service_identity_name (str): The service identity name. It will be\n                used as the `iss` and `sub` claim in the self signed JWT.\n            project (str): The project.\n            audience (str): The audience for the final token.\n            token_uri (str): The token server uri.\n            ca_cert_path (str): The CA cert path for token server side TLS\n                certificate verification. If the token server uses well known\n                CA, then this parameter can be `None`.\n        \"\"\"\n        super(ServiceAccountCredentials, self).__init__()\n        self._signer = signer\n        self._service_identity_name = service_identity_name\n        self._project = project\n        self._audience = audience\n        self._token_uri = token_uri\n        self._ca_cert_path = ca_cert_path\n\n    def _create_jwt(self):\n        now = _helpers.utcnow()\n        expiry = now + JWT_LIFETIME\n        iss_sub_value = \"system:serviceaccount:{}:{}\".format(\n            self._project, self._service_identity_name\n        )\n\n        payload = {\n            \"iss\": iss_sub_value,\n            \"sub\": iss_sub_value,\n            \"aud\": self._token_uri,\n            \"iat\": _helpers.datetime_to_secs(now),\n            \"exp\": _helpers.datetime_to_secs(expiry),\n        }\n\n        return _helpers.from_bytes(jwt.encode(self._signer, payload))\n\n    @_helpers.copy_docstring(credentials.Credentials)\n    def refresh(self, request):\n        import google.auth.transport.requests\n\n        if not isinstance(request, google.auth.transport.requests.Request):\n            raise exceptions.RefreshError(\n                \"For GDCH service account credentials, request must be a google.auth.transport.requests.Request object\"\n            )\n\n        # Create a self signed JWT, and do token exchange.\n        jwt_token = self._create_jwt()\n        request_body = {\n            \"grant_type\": TOKEN_EXCHANGE_TYPE,\n            \"audience\": self._audience,\n            \"requested_token_type\": ACCESS_TOKEN_TOKEN_TYPE,\n            \"subject_token\": jwt_token,\n            \"subject_token_type\": SERVICE_ACCOUNT_TOKEN_TYPE,\n        }\n        response_data = _client._token_endpoint_request(\n            request,\n            self._token_uri,\n            request_body,\n            access_token=None,\n            use_json=True,\n            verify=self._ca_cert_path,\n        )\n\n        self.token, _, self.expiry, _ = _client._handle_refresh_grant_response(\n            response_data, None\n        )\n\n    def with_gdch_audience(self, audience):\n        \"\"\"Create a copy of GDCH credentials with the specified audience.\n\n        Args:\n            audience (str): The intended audience for GDCH credentials.\n        \"\"\"\n        return self.__class__(\n            self._signer,\n            self._service_identity_name,\n            self._project,\n            audience,\n            self._token_uri,\n            self._ca_cert_path,\n        )\n\n    @classmethod\n    def _from_signer_and_info(cls, signer, info):\n        \"\"\"Creates a Credentials instance from a signer and service account\n        info.\n\n        Args:\n            signer (google.auth.crypt.Signer): The signer used to sign JWTs.\n            info (Mapping[str, str]): The service account info.\n\n        Returns:\n            google.oauth2.gdch_credentials.ServiceAccountCredentials: The constructed\n                credentials.\n\n        Raises:\n            ValueError: If the info is not in the expected format.\n        \"\"\"\n        if info[\"format_version\"] != \"1\":\n            raise ValueError(\"Only format version 1 is supported\")\n\n        return cls(\n            signer,\n            info[\"name\"],  # service_identity_name\n            info[\"project\"],\n            None,  # audience\n            info[\"token_uri\"],\n            info.get(\"ca_cert_path\", None),\n        )\n\n    @classmethod\n    def from_service_account_info(cls, info):\n        \"\"\"Creates a Credentials instance from parsed service account info.\n\n        Args:\n            info (Mapping[str, str]): The service account info in Google\n                format.\n            kwargs: Additional arguments to pass to the constructor.\n\n        Returns:\n            google.oauth2.gdch_credentials.ServiceAccountCredentials: The constructed\n                credentials.\n\n        Raises:\n            ValueError: If the info is not in the expected format.\n        \"\"\"\n        signer = _service_account_info.from_dict(\n            info,\n            require=[\n                \"format_version\",\n                \"private_key_id\",\n                \"private_key\",\n                \"name\",\n                \"project\",\n                \"token_uri\",\n            ],\n            use_rsa_signer=False,\n        )\n        return cls._from_signer_and_info(signer, info)\n\n    @classmethod\n    def from_service_account_file(cls, filename):\n        \"\"\"Creates a Credentials instance from a service account json file.\n\n        Args:\n            filename (str): The path to the service account json file.\n            kwargs: Additional arguments to pass to the constructor.\n\n        Returns:\n            google.oauth2.gdch_credentials.ServiceAccountCredentials: The constructed\n                credentials.\n        \"\"\"\n        info, signer = _service_account_info.from_filename(\n            filename,\n            require=[\n                \"format_version\",\n                \"private_key_id\",\n                \"private_key\",\n                \"name\",\n                \"project\",\n                \"token_uri\",\n            ],\n            use_rsa_signer=False,\n        )\n        return cls._from_signer_and_info(signer, info)\n", "google/oauth2/credentials.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"OAuth 2.0 Credentials.\n\nThis module provides credentials based on OAuth 2.0 access and refresh tokens.\nThese credentials usually access resources on behalf of a user (resource\nowner).\n\nSpecifically, this is intended to use access tokens acquired using the\n`Authorization Code grant`_ and can refresh those tokens using a\noptional `refresh token`_.\n\nObtaining the initial access and refresh token is outside of the scope of this\nmodule. Consult `rfc6749 section 4.1`_ for complete details on the\nAuthorization Code grant flow.\n\n.. _Authorization Code grant: https://tools.ietf.org/html/rfc6749#section-1.3.1\n.. _refresh token: https://tools.ietf.org/html/rfc6749#section-6\n.. _rfc6749 section 4.1: https://tools.ietf.org/html/rfc6749#section-4.1\n\"\"\"\n\nfrom datetime import datetime\nimport io\nimport json\nimport logging\nimport warnings\n\nfrom google.auth import _cloud_sdk\nfrom google.auth import _helpers\nfrom google.auth import credentials\nfrom google.auth import exceptions\nfrom google.auth import metrics\nfrom google.oauth2 import reauth\n\n_LOGGER = logging.getLogger(__name__)\n\n\n# The Google OAuth 2.0 token endpoint. Used for authorized user credentials.\n_GOOGLE_OAUTH2_TOKEN_ENDPOINT = \"https://oauth2.googleapis.com/token\"\n\n\nclass Credentials(credentials.ReadOnlyScoped, credentials.CredentialsWithQuotaProject):\n    \"\"\"Credentials using OAuth 2.0 access and refresh tokens.\n\n    The credentials are considered immutable except the tokens and the token\n    expiry, which are updated after refresh. If you want to modify the quota\n    project, use :meth:`with_quota_project` or ::\n\n        credentials = credentials.with_quota_project('myproject-123')\n\n    Reauth is disabled by default. To enable reauth, set the\n    `enable_reauth_refresh` parameter to True in the constructor. Note that\n    reauth feature is intended for gcloud to use only.\n    If reauth is enabled, `pyu2f` dependency has to be installed in order to use security\n    key reauth feature. Dependency can be installed via `pip install pyu2f` or `pip install\n    google-auth[reauth]`.\n    \"\"\"\n\n    def __init__(\n        self,\n        token,\n        refresh_token=None,\n        id_token=None,\n        token_uri=None,\n        client_id=None,\n        client_secret=None,\n        scopes=None,\n        default_scopes=None,\n        quota_project_id=None,\n        expiry=None,\n        rapt_token=None,\n        refresh_handler=None,\n        enable_reauth_refresh=False,\n        granted_scopes=None,\n        trust_boundary=None,\n        universe_domain=credentials.DEFAULT_UNIVERSE_DOMAIN,\n        account=None,\n    ):\n        \"\"\"\n        Args:\n            token (Optional(str)): The OAuth 2.0 access token. Can be None\n                if refresh information is provided.\n            refresh_token (str): The OAuth 2.0 refresh token. If specified,\n                credentials can be refreshed.\n            id_token (str): The Open ID Connect ID Token.\n            token_uri (str): The OAuth 2.0 authorization server's token\n                endpoint URI. Must be specified for refresh, can be left as\n                None if the token can not be refreshed.\n            client_id (str): The OAuth 2.0 client ID. Must be specified for\n                refresh, can be left as None if the token can not be refreshed.\n            client_secret(str): The OAuth 2.0 client secret. Must be specified\n                for refresh, can be left as None if the token can not be\n                refreshed.\n            scopes (Sequence[str]): The scopes used to obtain authorization.\n                This parameter is used by :meth:`has_scopes`. OAuth 2.0\n                credentials can not request additional scopes after\n                authorization. The scopes must be derivable from the refresh\n                token if refresh information is provided (e.g. The refresh\n                token scopes are a superset of this or contain a wild card\n                scope like 'https://www.googleapis.com/auth/any-api').\n            default_scopes (Sequence[str]): Default scopes passed by a\n                Google client library. Use 'scopes' for user-defined scopes.\n            quota_project_id (Optional[str]): The project ID used for quota and billing.\n                This project may be different from the project used to\n                create the credentials.\n            rapt_token (Optional[str]): The reauth Proof Token.\n            refresh_handler (Optional[Callable[[google.auth.transport.Request, Sequence[str]], [str, datetime]]]):\n                A callable which takes in the HTTP request callable and the list of\n                OAuth scopes and when called returns an access token string for the\n                requested scopes and its expiry datetime. This is useful when no\n                refresh tokens are provided and tokens are obtained by calling\n                some external process on demand. It is particularly useful for\n                retrieving downscoped tokens from a token broker.\n            enable_reauth_refresh (Optional[bool]): Whether reauth refresh flow\n                should be used. This flag is for gcloud to use only.\n            granted_scopes (Optional[Sequence[str]]): The scopes that were consented/granted by the user.\n                This could be different from the requested scopes and it could be empty if granted\n                and requested scopes were same.\n            trust_boundary (str): String representation of trust boundary meta.\n            universe_domain (Optional[str]): The universe domain. The default\n                universe domain is googleapis.com.\n            account (Optional[str]): The account associated with the credential.\n        \"\"\"\n        super(Credentials, self).__init__()\n        self.token = token\n        self.expiry = expiry\n        self._refresh_token = refresh_token\n        self._id_token = id_token\n        self._scopes = scopes\n        self._default_scopes = default_scopes\n        self._granted_scopes = granted_scopes\n        self._token_uri = token_uri\n        self._client_id = client_id\n        self._client_secret = client_secret\n        self._quota_project_id = quota_project_id\n        self._rapt_token = rapt_token\n        self.refresh_handler = refresh_handler\n        self._enable_reauth_refresh = enable_reauth_refresh\n        self._trust_boundary = trust_boundary\n        self._universe_domain = universe_domain or credentials.DEFAULT_UNIVERSE_DOMAIN\n        self._account = account or \"\"\n\n    def __getstate__(self):\n        \"\"\"A __getstate__ method must exist for the __setstate__ to be called\n        This is identical to the default implementation.\n        See https://docs.python.org/3.7/library/pickle.html#object.__setstate__\n        \"\"\"\n        state_dict = self.__dict__.copy()\n        # Remove _refresh_handler function as there are limitations pickling and\n        # unpickling certain callables (lambda, functools.partial instances)\n        # because they need to be importable.\n        # Instead, the refresh_handler setter should be used to repopulate this.\n        if \"_refresh_handler\" in state_dict:\n            del state_dict[\"_refresh_handler\"]\n\n        if \"_refresh_worker\" in state_dict:\n            del state_dict[\"_refresh_worker\"]\n        return state_dict\n\n    def __setstate__(self, d):\n        \"\"\"Credentials pickled with older versions of the class do not have\n        all the attributes.\"\"\"\n        self.token = d.get(\"token\")\n        self.expiry = d.get(\"expiry\")\n        self._refresh_token = d.get(\"_refresh_token\")\n        self._id_token = d.get(\"_id_token\")\n        self._scopes = d.get(\"_scopes\")\n        self._default_scopes = d.get(\"_default_scopes\")\n        self._granted_scopes = d.get(\"_granted_scopes\")\n        self._token_uri = d.get(\"_token_uri\")\n        self._client_id = d.get(\"_client_id\")\n        self._client_secret = d.get(\"_client_secret\")\n        self._quota_project_id = d.get(\"_quota_project_id\")\n        self._rapt_token = d.get(\"_rapt_token\")\n        self._enable_reauth_refresh = d.get(\"_enable_reauth_refresh\")\n        self._trust_boundary = d.get(\"_trust_boundary\")\n        self._universe_domain = (\n            d.get(\"_universe_domain\") or credentials.DEFAULT_UNIVERSE_DOMAIN\n        )\n        # The refresh_handler setter should be used to repopulate this.\n        self._refresh_handler = None\n        self._refresh_worker = None\n        self._use_non_blocking_refresh = d.get(\"_use_non_blocking_refresh\", False)\n        self._account = d.get(\"_account\", \"\")\n\n    @property\n    def refresh_token(self):\n        \"\"\"Optional[str]: The OAuth 2.0 refresh token.\"\"\"\n        return self._refresh_token\n\n    @property\n    def scopes(self):\n        \"\"\"Optional[str]: The OAuth 2.0 permission scopes.\"\"\"\n        return self._scopes\n\n    @property\n    def granted_scopes(self):\n        \"\"\"Optional[Sequence[str]]: The OAuth 2.0 permission scopes that were granted by the user.\"\"\"\n        return self._granted_scopes\n\n    @property\n    def token_uri(self):\n        \"\"\"Optional[str]: The OAuth 2.0 authorization server's token endpoint\n        URI.\"\"\"\n        return self._token_uri\n\n    @property\n    def id_token(self):\n        \"\"\"Optional[str]: The Open ID Connect ID Token.\n\n        Depending on the authorization server and the scopes requested, this\n        may be populated when credentials are obtained and updated when\n        :meth:`refresh` is called. This token is a JWT. It can be verified\n        and decoded using :func:`google.oauth2.id_token.verify_oauth2_token`.\n        \"\"\"\n        return self._id_token\n\n    @property\n    def client_id(self):\n        \"\"\"Optional[str]: The OAuth 2.0 client ID.\"\"\"\n        return self._client_id\n\n    @property\n    def client_secret(self):\n        \"\"\"Optional[str]: The OAuth 2.0 client secret.\"\"\"\n        return self._client_secret\n\n    @property\n    def requires_scopes(self):\n        \"\"\"False: OAuth 2.0 credentials have their scopes set when\n        the initial token is requested and can not be changed.\"\"\"\n        return False\n\n    @property\n    def rapt_token(self):\n        \"\"\"Optional[str]: The reauth Proof Token.\"\"\"\n        return self._rapt_token\n\n    @property\n    def refresh_handler(self):\n        \"\"\"Returns the refresh handler if available.\n\n        Returns:\n           Optional[Callable[[google.auth.transport.Request, Sequence[str]], [str, datetime]]]:\n               The current refresh handler.\n        \"\"\"\n        return self._refresh_handler\n\n    @refresh_handler.setter\n    def refresh_handler(self, value):\n        \"\"\"Updates the current refresh handler.\n\n        Args:\n            value (Optional[Callable[[google.auth.transport.Request, Sequence[str]], [str, datetime]]]):\n                The updated value of the refresh handler.\n\n        Raises:\n            TypeError: If the value is not a callable or None.\n        \"\"\"\n        if not callable(value) and value is not None:\n            raise TypeError(\"The provided refresh_handler is not a callable or None.\")\n        self._refresh_handler = value\n\n    @property\n    def account(self):\n        \"\"\"str: The user account associated with the credential. If the account is unknown an empty string is returned.\"\"\"\n        return self._account\n\n    @_helpers.copy_docstring(credentials.CredentialsWithQuotaProject)\n    def with_quota_project(self, quota_project_id):\n\n        return self.__class__(\n            self.token,\n            refresh_token=self.refresh_token,\n            id_token=self.id_token,\n            token_uri=self.token_uri,\n            client_id=self.client_id,\n            client_secret=self.client_secret,\n            scopes=self.scopes,\n            default_scopes=self.default_scopes,\n            granted_scopes=self.granted_scopes,\n            quota_project_id=quota_project_id,\n            rapt_token=self.rapt_token,\n            enable_reauth_refresh=self._enable_reauth_refresh,\n            trust_boundary=self._trust_boundary,\n            universe_domain=self._universe_domain,\n            account=self._account,\n        )\n\n    @_helpers.copy_docstring(credentials.CredentialsWithTokenUri)\n    def with_token_uri(self, token_uri):\n\n        return self.__class__(\n            self.token,\n            refresh_token=self.refresh_token,\n            id_token=self.id_token,\n            token_uri=token_uri,\n            client_id=self.client_id,\n            client_secret=self.client_secret,\n            scopes=self.scopes,\n            default_scopes=self.default_scopes,\n            granted_scopes=self.granted_scopes,\n            quota_project_id=self.quota_project_id,\n            rapt_token=self.rapt_token,\n            enable_reauth_refresh=self._enable_reauth_refresh,\n            trust_boundary=self._trust_boundary,\n            universe_domain=self._universe_domain,\n            account=self._account,\n        )\n\n    def with_account(self, account):\n        \"\"\"Returns a copy of these credentials with a modified account.\n\n        Args:\n            account (str): The account to set\n\n        Returns:\n            google.oauth2.credentials.Credentials: A new credentials instance.\n        \"\"\"\n\n        return self.__class__(\n            self.token,\n            refresh_token=self.refresh_token,\n            id_token=self.id_token,\n            token_uri=self._token_uri,\n            client_id=self.client_id,\n            client_secret=self.client_secret,\n            scopes=self.scopes,\n            default_scopes=self.default_scopes,\n            granted_scopes=self.granted_scopes,\n            quota_project_id=self.quota_project_id,\n            rapt_token=self.rapt_token,\n            enable_reauth_refresh=self._enable_reauth_refresh,\n            trust_boundary=self._trust_boundary,\n            universe_domain=self._universe_domain,\n            account=account,\n        )\n\n    @_helpers.copy_docstring(credentials.CredentialsWithUniverseDomain)\n    def with_universe_domain(self, universe_domain):\n\n        return self.__class__(\n            self.token,\n            refresh_token=self.refresh_token,\n            id_token=self.id_token,\n            token_uri=self._token_uri,\n            client_id=self.client_id,\n            client_secret=self.client_secret,\n            scopes=self.scopes,\n            default_scopes=self.default_scopes,\n            granted_scopes=self.granted_scopes,\n            quota_project_id=self.quota_project_id,\n            rapt_token=self.rapt_token,\n            enable_reauth_refresh=self._enable_reauth_refresh,\n            trust_boundary=self._trust_boundary,\n            universe_domain=universe_domain,\n            account=self._account,\n        )\n\n    def _metric_header_for_usage(self):\n        return metrics.CRED_TYPE_USER\n\n    @_helpers.copy_docstring(credentials.Credentials)\n    def refresh(self, request):\n        if self._universe_domain != credentials.DEFAULT_UNIVERSE_DOMAIN:\n            raise exceptions.RefreshError(\n                \"User credential refresh is only supported in the default \"\n                \"googleapis.com universe domain, but the current universe \"\n                \"domain is {}. If you created the credential with an access \"\n                \"token, it's likely that the provided token is expired now, \"\n                \"please update your code with a valid token.\".format(\n                    self._universe_domain\n                )\n            )\n\n        scopes = self._scopes if self._scopes is not None else self._default_scopes\n        # Use refresh handler if available and no refresh token is\n        # available. This is useful in general when tokens are obtained by calling\n        # some external process on demand. It is particularly useful for retrieving\n        # downscoped tokens from a token broker.\n        if self._refresh_token is None and self.refresh_handler:\n            token, expiry = self.refresh_handler(request, scopes=scopes)\n            # Validate returned data.\n            if not isinstance(token, str):\n                raise exceptions.RefreshError(\n                    \"The refresh_handler returned token is not a string.\"\n                )\n            if not isinstance(expiry, datetime):\n                raise exceptions.RefreshError(\n                    \"The refresh_handler returned expiry is not a datetime object.\"\n                )\n            if _helpers.utcnow() >= expiry - _helpers.REFRESH_THRESHOLD:\n                raise exceptions.RefreshError(\n                    \"The credentials returned by the refresh_handler are \"\n                    \"already expired.\"\n                )\n            self.token = token\n            self.expiry = expiry\n            return\n\n        if (\n            self._refresh_token is None\n            or self._token_uri is None\n            or self._client_id is None\n            or self._client_secret is None\n        ):\n            raise exceptions.RefreshError(\n                \"The credentials do not contain the necessary fields need to \"\n                \"refresh the access token. You must specify refresh_token, \"\n                \"token_uri, client_id, and client_secret.\"\n            )\n\n        (\n            access_token,\n            refresh_token,\n            expiry,\n            grant_response,\n            rapt_token,\n        ) = reauth.refresh_grant(\n            request,\n            self._token_uri,\n            self._refresh_token,\n            self._client_id,\n            self._client_secret,\n            scopes=scopes,\n            rapt_token=self._rapt_token,\n            enable_reauth_refresh=self._enable_reauth_refresh,\n        )\n\n        self.token = access_token\n        self.expiry = expiry\n        self._refresh_token = refresh_token\n        self._id_token = grant_response.get(\"id_token\")\n        self._rapt_token = rapt_token\n\n        if scopes and \"scope\" in grant_response:\n            requested_scopes = frozenset(scopes)\n            self._granted_scopes = grant_response[\"scope\"].split()\n            granted_scopes = frozenset(self._granted_scopes)\n            scopes_requested_but_not_granted = requested_scopes - granted_scopes\n            if scopes_requested_but_not_granted:\n                # User might be presented with unbundled scopes at the time of\n                # consent. So it is a valid scenario to not have all the requested\n                # scopes as part of granted scopes but log a warning in case the\n                # developer wants to debug the scenario.\n                _LOGGER.warning(\n                    \"Not all requested scopes were granted by the \"\n                    \"authorization server, missing scopes {}.\".format(\n                        \", \".join(scopes_requested_but_not_granted)\n                    )\n                )\n\n    @classmethod\n    def from_authorized_user_info(cls, info, scopes=None):\n        \"\"\"Creates a Credentials instance from parsed authorized user info.\n\n        Args:\n            info (Mapping[str, str]): The authorized user info in Google\n                format.\n            scopes (Sequence[str]): Optional list of scopes to include in the\n                credentials.\n\n        Returns:\n            google.oauth2.credentials.Credentials: The constructed\n                credentials.\n\n        Raises:\n            ValueError: If the info is not in the expected format.\n        \"\"\"\n        keys_needed = set((\"refresh_token\", \"client_id\", \"client_secret\"))\n        missing = keys_needed.difference(info.keys())\n\n        if missing:\n            raise ValueError(\n                \"Authorized user info was not in the expected format, missing \"\n                \"fields {}.\".format(\", \".join(missing))\n            )\n\n        # access token expiry (datetime obj); auto-expire if not saved\n        expiry = info.get(\"expiry\")\n        if expiry:\n            expiry = datetime.strptime(\n                expiry.rstrip(\"Z\").split(\".\")[0], \"%Y-%m-%dT%H:%M:%S\"\n            )\n        else:\n            expiry = _helpers.utcnow() - _helpers.REFRESH_THRESHOLD\n\n        # process scopes, which needs to be a seq\n        if scopes is None and \"scopes\" in info:\n            scopes = info.get(\"scopes\")\n            if isinstance(scopes, str):\n                scopes = scopes.split(\" \")\n\n        return cls(\n            token=info.get(\"token\"),\n            refresh_token=info.get(\"refresh_token\"),\n            token_uri=_GOOGLE_OAUTH2_TOKEN_ENDPOINT,  # always overrides\n            scopes=scopes,\n            client_id=info.get(\"client_id\"),\n            client_secret=info.get(\"client_secret\"),\n            quota_project_id=info.get(\"quota_project_id\"),  # may not exist\n            expiry=expiry,\n            rapt_token=info.get(\"rapt_token\"),  # may not exist\n            trust_boundary=info.get(\"trust_boundary\"),  # may not exist\n            universe_domain=info.get(\"universe_domain\"),  # may not exist\n            account=info.get(\"account\", \"\"),  # may not exist\n        )\n\n    @classmethod\n    def from_authorized_user_file(cls, filename, scopes=None):\n        \"\"\"Creates a Credentials instance from an authorized user json file.\n\n        Args:\n            filename (str): The path to the authorized user json file.\n            scopes (Sequence[str]): Optional list of scopes to include in the\n                credentials.\n\n        Returns:\n            google.oauth2.credentials.Credentials: The constructed\n                credentials.\n\n        Raises:\n            ValueError: If the file is not in the expected format.\n        \"\"\"\n        with io.open(filename, \"r\", encoding=\"utf-8\") as json_file:\n            data = json.load(json_file)\n            return cls.from_authorized_user_info(data, scopes)\n\n    def to_json(self, strip=None):\n        \"\"\"Utility function that creates a JSON representation of a Credentials\n        object.\n\n        Args:\n            strip (Sequence[str]): Optional list of members to exclude from the\n                                   generated JSON.\n\n        Returns:\n            str: A JSON representation of this instance. When converted into\n            a dictionary, it can be passed to from_authorized_user_info()\n            to create a new credential instance.\n        \"\"\"\n        prep = {\n            \"token\": self.token,\n            \"refresh_token\": self.refresh_token,\n            \"token_uri\": self.token_uri,\n            \"client_id\": self.client_id,\n            \"client_secret\": self.client_secret,\n            \"scopes\": self.scopes,\n            \"rapt_token\": self.rapt_token,\n            \"universe_domain\": self._universe_domain,\n            \"account\": self._account,\n        }\n        if self.expiry:  # flatten expiry timestamp\n            prep[\"expiry\"] = self.expiry.isoformat() + \"Z\"\n\n        # Remove empty entries (those which are None)\n        prep = {k: v for k, v in prep.items() if v is not None}\n\n        # Remove entries that explicitely need to be removed\n        if strip is not None:\n            prep = {k: v for k, v in prep.items() if k not in strip}\n\n        return json.dumps(prep)\n\n\nclass UserAccessTokenCredentials(credentials.CredentialsWithQuotaProject):\n    \"\"\"Access token credentials for user account.\n\n    Obtain the access token for a given user account or the current active\n    user account with the ``gcloud auth print-access-token`` command.\n\n    Args:\n        account (Optional[str]): Account to get the access token for. If not\n            specified, the current active account will be used.\n        quota_project_id (Optional[str]): The project ID used for quota\n            and billing.\n    \"\"\"\n\n    def __init__(self, account=None, quota_project_id=None):\n        warnings.warn(\n            \"UserAccessTokenCredentials is deprecated, please use \"\n            \"google.oauth2.credentials.Credentials instead. To use \"\n            \"that credential type, simply run \"\n            \"`gcloud auth application-default login` and let the \"\n            \"client libraries pick up the application default credentials.\"\n        )\n        super(UserAccessTokenCredentials, self).__init__()\n        self._account = account\n        self._quota_project_id = quota_project_id\n\n    def with_account(self, account):\n        \"\"\"Create a new instance with the given account.\n\n        Args:\n            account (str): Account to get the access token for.\n\n        Returns:\n            google.oauth2.credentials.UserAccessTokenCredentials: The created\n                credentials with the given account.\n        \"\"\"\n        return self.__class__(account=account, quota_project_id=self._quota_project_id)\n\n    @_helpers.copy_docstring(credentials.CredentialsWithQuotaProject)\n    def with_quota_project(self, quota_project_id):\n        return self.__class__(account=self._account, quota_project_id=quota_project_id)\n\n    def refresh(self, request):\n        \"\"\"Refreshes the access token.\n\n        Args:\n            request (google.auth.transport.Request): This argument is required\n                by the base class interface but not used in this implementation,\n                so just set it to `None`.\n\n        Raises:\n            google.auth.exceptions.UserAccessTokenError: If the access token\n                refresh failed.\n        \"\"\"\n        self.token = _cloud_sdk.get_auth_access_token(self._account)\n\n    @_helpers.copy_docstring(credentials.Credentials)\n    def before_request(self, request, method, url, headers):\n        self.refresh(request)\n        self.apply(headers)\n", "google/oauth2/_client.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"OAuth 2.0 client.\n\nThis is a client for interacting with an OAuth 2.0 authorization server's\ntoken endpoint.\n\nFor more information about the token endpoint, see\n`Section 3.1 of rfc6749`_\n\n.. _Section 3.1 of rfc6749: https://tools.ietf.org/html/rfc6749#section-3.2\n\"\"\"\n\nimport datetime\nimport http.client as http_client\nimport json\nimport urllib\n\nfrom google.auth import _exponential_backoff\nfrom google.auth import _helpers\nfrom google.auth import exceptions\nfrom google.auth import jwt\nfrom google.auth import metrics\nfrom google.auth import transport\n\n_URLENCODED_CONTENT_TYPE = \"application/x-www-form-urlencoded\"\n_JSON_CONTENT_TYPE = \"application/json\"\n_JWT_GRANT_TYPE = \"urn:ietf:params:oauth:grant-type:jwt-bearer\"\n_REFRESH_GRANT_TYPE = \"refresh_token\"\n\n\ndef _handle_error_response(response_data, retryable_error):\n    \"\"\"Translates an error response into an exception.\n\n    Args:\n        response_data (Mapping | str): The decoded response data.\n        retryable_error Optional[bool]: A boolean indicating if an error is retryable.\n            Defaults to False.\n\n    Raises:\n        google.auth.exceptions.RefreshError: The errors contained in response_data.\n    \"\"\"\n\n    retryable_error = retryable_error if retryable_error else False\n\n    if isinstance(response_data, str):\n        raise exceptions.RefreshError(response_data, retryable=retryable_error)\n    try:\n        error_details = \"{}: {}\".format(\n            response_data[\"error\"], response_data.get(\"error_description\")\n        )\n    # If no details could be extracted, use the response data.\n    except (KeyError, ValueError):\n        error_details = json.dumps(response_data)\n\n    raise exceptions.RefreshError(\n        error_details, response_data, retryable=retryable_error\n    )\n\n\ndef _can_retry(status_code, response_data):\n    \"\"\"Checks if a request can be retried by inspecting the status code\n    and response body of the request.\n\n    Args:\n        status_code (int): The response status code.\n        response_data (Mapping | str): The decoded response data.\n\n    Returns:\n      bool: True if the response is retryable. False otherwise.\n    \"\"\"\n    if status_code in transport.DEFAULT_RETRYABLE_STATUS_CODES:\n        return True\n\n    try:\n        # For a failed response, response_body could be a string\n        error_desc = response_data.get(\"error_description\") or \"\"\n        error_code = response_data.get(\"error\") or \"\"\n\n        if not isinstance(error_code, str) or not isinstance(error_desc, str):\n            return False\n\n        # Per Oauth 2.0 RFC https://www.rfc-editor.org/rfc/rfc6749.html#section-4.1.2.1\n        # This is needed because a redirect will not return a 500 status code.\n        retryable_error_descriptions = {\n            \"internal_failure\",\n            \"server_error\",\n            \"temporarily_unavailable\",\n        }\n\n        if any(e in retryable_error_descriptions for e in (error_code, error_desc)):\n            return True\n\n    except AttributeError:\n        pass\n\n    return False\n\n\ndef _parse_expiry(response_data):\n    \"\"\"Parses the expiry field from a response into a datetime.\n\n    Args:\n        response_data (Mapping): The JSON-parsed response data.\n\n    Returns:\n        Optional[datetime]: The expiration or ``None`` if no expiration was\n            specified.\n    \"\"\"\n    expires_in = response_data.get(\"expires_in\", None)\n\n    if expires_in is not None:\n        # Some services do not respect the OAUTH2.0 RFC and send expires_in as a\n        # JSON String.\n        if isinstance(expires_in, str):\n            expires_in = int(expires_in)\n\n        return _helpers.utcnow() + datetime.timedelta(seconds=expires_in)\n    else:\n        return None\n\n\ndef _token_endpoint_request_no_throw(\n    request,\n    token_uri,\n    body,\n    access_token=None,\n    use_json=False,\n    can_retry=True,\n    headers=None,\n    **kwargs\n):\n    \"\"\"Makes a request to the OAuth 2.0 authorization server's token endpoint.\n    This function doesn't throw on response errors.\n\n    Args:\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests.\n        token_uri (str): The OAuth 2.0 authorizations server's token endpoint\n            URI.\n        body (Mapping[str, str]): The parameters to send in the request body.\n        access_token (Optional(str)): The access token needed to make the request.\n        use_json (Optional(bool)): Use urlencoded format or json format for the\n            content type. The default value is False.\n        can_retry (bool): Enable or disable request retry behavior.\n        headers (Optional[Mapping[str, str]]): The headers for the request.\n        kwargs: Additional arguments passed on to the request method. The\n            kwargs will be passed to `requests.request` method, see:\n            https://docs.python-requests.org/en/latest/api/#requests.request.\n            For example, you can use `cert=(\"cert_pem_path\", \"key_pem_path\")`\n            to set up client side SSL certificate, and use\n            `verify=\"ca_bundle_path\"` to set up the CA certificates for sever\n            side SSL certificate verification.\n\n    Returns:\n        Tuple(bool, Mapping[str, str], Optional[bool]): A boolean indicating\n          if the request is successful, a mapping for the JSON-decoded response\n          data and in the case of an error a boolean indicating if the error\n          is retryable.\n    \"\"\"\n    if use_json:\n        headers_to_use = {\"Content-Type\": _JSON_CONTENT_TYPE}\n        body = json.dumps(body).encode(\"utf-8\")\n    else:\n        headers_to_use = {\"Content-Type\": _URLENCODED_CONTENT_TYPE}\n        body = urllib.parse.urlencode(body).encode(\"utf-8\")\n\n    if access_token:\n        headers_to_use[\"Authorization\"] = \"Bearer {}\".format(access_token)\n\n    if headers:\n        headers_to_use.update(headers)\n\n    def _perform_request():\n        response = request(\n            method=\"POST\", url=token_uri, headers=headers_to_use, body=body, **kwargs\n        )\n        response_body = (\n            response.data.decode(\"utf-8\")\n            if hasattr(response.data, \"decode\")\n            else response.data\n        )\n        response_data = \"\"\n        try:\n            # response_body should be a JSON\n            response_data = json.loads(response_body)\n        except ValueError:\n            response_data = response_body\n\n        if response.status == http_client.OK:\n            return True, response_data, None\n\n        retryable_error = _can_retry(\n            status_code=response.status, response_data=response_data\n        )\n\n        return False, response_data, retryable_error\n\n    request_succeeded, response_data, retryable_error = _perform_request()\n\n    if request_succeeded or not retryable_error or not can_retry:\n        return request_succeeded, response_data, retryable_error\n\n    retries = _exponential_backoff.ExponentialBackoff()\n    for _ in retries:\n        request_succeeded, response_data, retryable_error = _perform_request()\n        if request_succeeded or not retryable_error:\n            return request_succeeded, response_data, retryable_error\n\n    return False, response_data, retryable_error\n\n\ndef _token_endpoint_request(\n    request,\n    token_uri,\n    body,\n    access_token=None,\n    use_json=False,\n    can_retry=True,\n    headers=None,\n    **kwargs\n):\n    \"\"\"Makes a request to the OAuth 2.0 authorization server's token endpoint.\n\n    Args:\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests.\n        token_uri (str): The OAuth 2.0 authorizations server's token endpoint\n            URI.\n        body (Mapping[str, str]): The parameters to send in the request body.\n        access_token (Optional(str)): The access token needed to make the request.\n        use_json (Optional(bool)): Use urlencoded format or json format for the\n            content type. The default value is False.\n        can_retry (bool): Enable or disable request retry behavior.\n        headers (Optional[Mapping[str, str]]): The headers for the request.\n        kwargs: Additional arguments passed on to the request method. The\n            kwargs will be passed to `requests.request` method, see:\n            https://docs.python-requests.org/en/latest/api/#requests.request.\n            For example, you can use `cert=(\"cert_pem_path\", \"key_pem_path\")`\n            to set up client side SSL certificate, and use\n            `verify=\"ca_bundle_path\"` to set up the CA certificates for sever\n            side SSL certificate verification.\n\n    Returns:\n        Mapping[str, str]: The JSON-decoded response data.\n\n    Raises:\n        google.auth.exceptions.RefreshError: If the token endpoint returned\n            an error.\n    \"\"\"\n\n    response_status_ok, response_data, retryable_error = _token_endpoint_request_no_throw(\n        request,\n        token_uri,\n        body,\n        access_token=access_token,\n        use_json=use_json,\n        can_retry=can_retry,\n        headers=headers,\n        **kwargs\n    )\n    if not response_status_ok:\n        _handle_error_response(response_data, retryable_error)\n    return response_data\n\n\ndef jwt_grant(request, token_uri, assertion, can_retry=True):\n    \"\"\"Implements the JWT Profile for OAuth 2.0 Authorization Grants.\n\n    For more details, see `rfc7523 section 4`_.\n\n    Args:\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests.\n        token_uri (str): The OAuth 2.0 authorizations server's token endpoint\n            URI.\n        assertion (str): The OAuth 2.0 assertion.\n        can_retry (bool): Enable or disable request retry behavior.\n\n    Returns:\n        Tuple[str, Optional[datetime], Mapping[str, str]]: The access token,\n            expiration, and additional data returned by the token endpoint.\n\n    Raises:\n        google.auth.exceptions.RefreshError: If the token endpoint returned\n            an error.\n\n    .. _rfc7523 section 4: https://tools.ietf.org/html/rfc7523#section-4\n    \"\"\"\n    body = {\"assertion\": assertion, \"grant_type\": _JWT_GRANT_TYPE}\n\n    response_data = _token_endpoint_request(\n        request,\n        token_uri,\n        body,\n        can_retry=can_retry,\n        headers={\n            metrics.API_CLIENT_HEADER: metrics.token_request_access_token_sa_assertion()\n        },\n    )\n\n    try:\n        access_token = response_data[\"access_token\"]\n    except KeyError as caught_exc:\n        new_exc = exceptions.RefreshError(\n            \"No access token in response.\", response_data, retryable=False\n        )\n        raise new_exc from caught_exc\n\n    expiry = _parse_expiry(response_data)\n\n    return access_token, expiry, response_data\n\n\ndef call_iam_generate_id_token_endpoint(\n    request, iam_id_token_endpoint, signer_email, audience, access_token\n):\n    \"\"\"Call iam.generateIdToken endpoint to get ID token.\n\n    Args:\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests.\n        iam_id_token_endpoint (str): The IAM ID token endpoint to use.\n        signer_email (str): The signer email used to form the IAM\n            generateIdToken endpoint.\n        audience (str): The audience for the ID token.\n        access_token (str): The access token used to call the IAM endpoint.\n\n    Returns:\n        Tuple[str, datetime]: The ID token and expiration.\n    \"\"\"\n    body = {\"audience\": audience, \"includeEmail\": \"true\", \"useEmailAzp\": \"true\"}\n\n    response_data = _token_endpoint_request(\n        request,\n        iam_id_token_endpoint.format(signer_email),\n        body,\n        access_token=access_token,\n        use_json=True,\n    )\n\n    try:\n        id_token = response_data[\"token\"]\n    except KeyError as caught_exc:\n        new_exc = exceptions.RefreshError(\n            \"No ID token in response.\", response_data, retryable=False\n        )\n        raise new_exc from caught_exc\n\n    payload = jwt.decode(id_token, verify=False)\n    expiry = datetime.datetime.utcfromtimestamp(payload[\"exp\"])\n\n    return id_token, expiry\n\n\ndef id_token_jwt_grant(request, token_uri, assertion, can_retry=True):\n    \"\"\"Implements the JWT Profile for OAuth 2.0 Authorization Grants, but\n    requests an OpenID Connect ID Token instead of an access token.\n\n    This is a variant on the standard JWT Profile that is currently unique\n    to Google. This was added for the benefit of authenticating to services\n    that require ID Tokens instead of access tokens or JWT bearer tokens.\n\n    Args:\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests.\n        token_uri (str): The OAuth 2.0 authorization server's token endpoint\n            URI.\n        assertion (str): JWT token signed by a service account. The token's\n            payload must include a ``target_audience`` claim.\n        can_retry (bool): Enable or disable request retry behavior.\n\n    Returns:\n        Tuple[str, Optional[datetime], Mapping[str, str]]:\n            The (encoded) Open ID Connect ID Token, expiration, and additional\n            data returned by the endpoint.\n\n    Raises:\n        google.auth.exceptions.RefreshError: If the token endpoint returned\n            an error.\n    \"\"\"\n    body = {\"assertion\": assertion, \"grant_type\": _JWT_GRANT_TYPE}\n\n    response_data = _token_endpoint_request(\n        request,\n        token_uri,\n        body,\n        can_retry=can_retry,\n        headers={\n            metrics.API_CLIENT_HEADER: metrics.token_request_id_token_sa_assertion()\n        },\n    )\n\n    try:\n        id_token = response_data[\"id_token\"]\n    except KeyError as caught_exc:\n        new_exc = exceptions.RefreshError(\n            \"No ID token in response.\", response_data, retryable=False\n        )\n        raise new_exc from caught_exc\n\n    payload = jwt.decode(id_token, verify=False)\n    expiry = datetime.datetime.utcfromtimestamp(payload[\"exp\"])\n\n    return id_token, expiry, response_data\n\n\ndef _handle_refresh_grant_response(response_data, refresh_token):\n    \"\"\"Extract tokens from refresh grant response.\n\n    Args:\n        response_data (Mapping[str, str]): Refresh grant response data.\n        refresh_token (str): Current refresh token.\n\n    Returns:\n        Tuple[str, str, Optional[datetime], Mapping[str, str]]: The access token,\n            refresh token, expiration, and additional data returned by the token\n            endpoint. If response_data doesn't have refresh token, then the current\n            refresh token will be returned.\n\n    Raises:\n        google.auth.exceptions.RefreshError: If the token endpoint returned\n            an error.\n    \"\"\"\n    try:\n        access_token = response_data[\"access_token\"]\n    except KeyError as caught_exc:\n        new_exc = exceptions.RefreshError(\n            \"No access token in response.\", response_data, retryable=False\n        )\n        raise new_exc from caught_exc\n\n    refresh_token = response_data.get(\"refresh_token\", refresh_token)\n    expiry = _parse_expiry(response_data)\n\n    return access_token, refresh_token, expiry, response_data\n\n\ndef refresh_grant(\n    request,\n    token_uri,\n    refresh_token,\n    client_id,\n    client_secret,\n    scopes=None,\n    rapt_token=None,\n    can_retry=True,\n):\n    \"\"\"Implements the OAuth 2.0 refresh token grant.\n\n    For more details, see `rfc678 section 6`_.\n\n    Args:\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests.\n        token_uri (str): The OAuth 2.0 authorizations server's token endpoint\n            URI.\n        refresh_token (str): The refresh token to use to get a new access\n            token.\n        client_id (str): The OAuth 2.0 application's client ID.\n        client_secret (str): The Oauth 2.0 appliaction's client secret.\n        scopes (Optional(Sequence[str])): Scopes to request. If present, all\n            scopes must be authorized for the refresh token. Useful if refresh\n            token has a wild card scope (e.g.\n            'https://www.googleapis.com/auth/any-api').\n        rapt_token (Optional(str)): The reauth Proof Token.\n        can_retry (bool): Enable or disable request retry behavior.\n\n    Returns:\n        Tuple[str, str, Optional[datetime], Mapping[str, str]]: The access\n            token, new or current refresh token, expiration, and additional data\n            returned by the token endpoint.\n\n    Raises:\n        google.auth.exceptions.RefreshError: If the token endpoint returned\n            an error.\n\n    .. _rfc6748 section 6: https://tools.ietf.org/html/rfc6749#section-6\n    \"\"\"\n    body = {\n        \"grant_type\": _REFRESH_GRANT_TYPE,\n        \"client_id\": client_id,\n        \"client_secret\": client_secret,\n        \"refresh_token\": refresh_token,\n    }\n    if scopes:\n        body[\"scope\"] = \" \".join(scopes)\n    if rapt_token:\n        body[\"rapt\"] = rapt_token\n\n    response_data = _token_endpoint_request(\n        request, token_uri, body, can_retry=can_retry\n    )\n    return _handle_refresh_grant_response(response_data, refresh_token)\n", "google/oauth2/_id_token_async.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Google ID Token helpers.\n\nProvides support for verifying `OpenID Connect ID Tokens`_, especially ones\ngenerated by Google infrastructure.\n\nTo parse and verify an ID Token issued by Google's OAuth 2.0 authorization\nserver use :func:`verify_oauth2_token`. To verify an ID Token issued by\nFirebase, use :func:`verify_firebase_token`.\n\nA general purpose ID Token verifier is available as :func:`verify_token`.\n\nExample::\n\n    from google.oauth2 import _id_token_async\n    from google.auth.transport import aiohttp_requests\n\n    request = aiohttp_requests.Request()\n\n    id_info = await _id_token_async.verify_oauth2_token(\n        token, request, 'my-client-id.example.com')\n\n    if id_info['iss'] != 'https://accounts.google.com':\n        raise ValueError('Wrong issuer.')\n\n    userid = id_info['sub']\n\nBy default, this will re-fetch certificates for each verification. Because\nGoogle's public keys are only changed infrequently (on the order of once per\nday), you may wish to take advantage of caching to reduce latency and the\npotential for network errors. This can be accomplished using an external\nlibrary like `CacheControl`_ to create a cache-aware\n:class:`google.auth.transport.Request`::\n\n    import cachecontrol\n    import google.auth.transport.requests\n    import requests\n\n    session = requests.session()\n    cached_session = cachecontrol.CacheControl(session)\n    request = google.auth.transport.requests.Request(session=cached_session)\n\n.. _OpenID Connect ID Token:\n    http://openid.net/specs/openid-connect-core-1_0.html#IDToken\n.. _CacheControl: https://cachecontrol.readthedocs.io\n\"\"\"\n\nimport http.client as http_client\nimport json\nimport os\n\nfrom google.auth import environment_vars\nfrom google.auth import exceptions\nfrom google.auth import jwt\nfrom google.auth.transport import requests\nfrom google.oauth2 import id_token as sync_id_token\n\n\nasync def _fetch_certs(request, certs_url):\n    \"\"\"Fetches certificates.\n\n    Google-style cerificate endpoints return JSON in the format of\n    ``{'key id': 'x509 certificate'}``.\n\n    Args:\n        request (google.auth.transport.Request): The object used to make\n            HTTP requests. This must be an aiohttp request.\n        certs_url (str): The certificate endpoint URL.\n\n    Returns:\n        Mapping[str, str]: A mapping of public key ID to x.509 certificate\n            data.\n    \"\"\"\n    response = await request(certs_url, method=\"GET\")\n\n    if response.status != http_client.OK:\n        raise exceptions.TransportError(\n            \"Could not fetch certificates at {}\".format(certs_url)\n        )\n\n    data = await response.content()\n\n    return json.loads(data)\n\n\nasync def verify_token(\n    id_token,\n    request,\n    audience=None,\n    certs_url=sync_id_token._GOOGLE_OAUTH2_CERTS_URL,\n    clock_skew_in_seconds=0,\n):\n    \"\"\"Verifies an ID token and returns the decoded token.\n\n    Args:\n        id_token (Union[str, bytes]): The encoded token.\n        request (google.auth.transport.Request): The object used to make\n            HTTP requests. This must be an aiohttp request.\n        audience (str): The audience that this token is intended for. If None\n            then the audience is not verified.\n        certs_url (str): The URL that specifies the certificates to use to\n            verify the token. This URL should return JSON in the format of\n            ``{'key id': 'x509 certificate'}``.\n        clock_skew_in_seconds (int): The clock skew used for `iat` and `exp`\n            validation.\n\n    Returns:\n        Mapping[str, Any]: The decoded token.\n    \"\"\"\n    certs = await _fetch_certs(request, certs_url)\n\n    return jwt.decode(\n        id_token,\n        certs=certs,\n        audience=audience,\n        clock_skew_in_seconds=clock_skew_in_seconds,\n    )\n\n\nasync def verify_oauth2_token(\n    id_token, request, audience=None, clock_skew_in_seconds=0\n):\n    \"\"\"Verifies an ID Token issued by Google's OAuth 2.0 authorization server.\n\n    Args:\n        id_token (Union[str, bytes]): The encoded token.\n        request (google.auth.transport.Request): The object used to make\n            HTTP requests. This must be an aiohttp request.\n        audience (str): The audience that this token is intended for. This is\n            typically your application's OAuth 2.0 client ID. If None then the\n            audience is not verified.\n        clock_skew_in_seconds (int): The clock skew used for `iat` and `exp`\n            validation.\n\n    Returns:\n        Mapping[str, Any]: The decoded token.\n\n    Raises:\n        exceptions.GoogleAuthError: If the issuer is invalid.\n    \"\"\"\n    idinfo = await verify_token(\n        id_token,\n        request,\n        audience=audience,\n        certs_url=sync_id_token._GOOGLE_OAUTH2_CERTS_URL,\n        clock_skew_in_seconds=clock_skew_in_seconds,\n    )\n\n    if idinfo[\"iss\"] not in sync_id_token._GOOGLE_ISSUERS:\n        raise exceptions.GoogleAuthError(\n            \"Wrong issuer. 'iss' should be one of the following: {}\".format(\n                sync_id_token._GOOGLE_ISSUERS\n            )\n        )\n\n    return idinfo\n\n\nasync def verify_firebase_token(\n    id_token, request, audience=None, clock_skew_in_seconds=0\n):\n    \"\"\"Verifies an ID Token issued by Firebase Authentication.\n\n    Args:\n        id_token (Union[str, bytes]): The encoded token.\n        request (google.auth.transport.Request): The object used to make\n            HTTP requests. This must be an aiohttp request.\n        audience (str): The audience that this token is intended for. This is\n            typically your Firebase application ID. If None then the audience\n            is not verified.\n        clock_skew_in_seconds (int): The clock skew used for `iat` and `exp`\n            validation.\n\n    Returns:\n        Mapping[str, Any]: The decoded token.\n    \"\"\"\n    return await verify_token(\n        id_token,\n        request,\n        audience=audience,\n        certs_url=sync_id_token._GOOGLE_APIS_CERTS_URL,\n        clock_skew_in_seconds=clock_skew_in_seconds,\n    )\n\n\nasync def fetch_id_token(request, audience):\n    \"\"\"Fetch the ID Token from the current environment.\n\n    This function acquires ID token from the environment in the following order.\n    See https://google.aip.dev/auth/4110.\n\n    1. If the environment variable ``GOOGLE_APPLICATION_CREDENTIALS`` is set\n       to the path of a valid service account JSON file, then ID token is\n       acquired using this service account credentials.\n    2. If the application is running in Compute Engine, App Engine or Cloud Run,\n       then the ID token are obtained from the metadata server.\n    3. If metadata server doesn't exist and no valid service account credentials\n       are found, :class:`~google.auth.exceptions.DefaultCredentialsError` will\n       be raised.\n\n    Example::\n\n        import google.oauth2._id_token_async\n        import google.auth.transport.aiohttp_requests\n\n        request = google.auth.transport.aiohttp_requests.Request()\n        target_audience = \"https://pubsub.googleapis.com\"\n\n        id_token = await google.oauth2._id_token_async.fetch_id_token(request, target_audience)\n\n    Args:\n        request (google.auth.transport.aiohttp_requests.Request): A callable used to make\n            HTTP requests.\n        audience (str): The audience that this ID token is intended for.\n\n    Returns:\n        str: The ID token.\n\n    Raises:\n        ~google.auth.exceptions.DefaultCredentialsError:\n            If metadata server doesn't exist and no valid service account\n            credentials are found.\n    \"\"\"\n    # 1. Try to get credentials from the GOOGLE_APPLICATION_CREDENTIALS environment\n    # variable.\n    credentials_filename = os.environ.get(environment_vars.CREDENTIALS)\n    if credentials_filename:\n        if not (\n            os.path.exists(credentials_filename)\n            and os.path.isfile(credentials_filename)\n        ):\n            raise exceptions.DefaultCredentialsError(\n                \"GOOGLE_APPLICATION_CREDENTIALS path is either not found or invalid.\"\n            )\n\n        try:\n            with open(credentials_filename, \"r\") as f:\n                from google.oauth2 import _service_account_async as service_account\n\n                info = json.load(f)\n                if info.get(\"type\") == \"service_account\":\n                    credentials = service_account.IDTokenCredentials.from_service_account_info(\n                        info, target_audience=audience\n                    )\n                    await credentials.refresh(request)\n                    return credentials.token\n        except ValueError as caught_exc:\n            new_exc = exceptions.DefaultCredentialsError(\n                \"GOOGLE_APPLICATION_CREDENTIALS is not valid service account credentials.\",\n                caught_exc,\n            )\n            raise new_exc from caught_exc\n\n    # 2. Try to fetch ID token from metada server if it exists. The code works\n    # for GAE and Cloud Run metadata server as well.\n    try:\n        from google.auth import compute_engine\n        from google.auth.compute_engine import _metadata\n\n        request_new = requests.Request()\n        if _metadata.ping(request_new):\n            credentials = compute_engine.IDTokenCredentials(\n                request_new, audience, use_metadata_identity_endpoint=True\n            )\n            credentials.refresh(request_new)\n            return credentials.token\n    except (ImportError, exceptions.TransportError):\n        pass\n\n    raise exceptions.DefaultCredentialsError(\n        \"Neither metadata server or valid service account credentials are found.\"\n    )\n", "google/oauth2/_service_account_async.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Service Accounts: JSON Web Token (JWT) Profile for OAuth 2.0\n\nNOTE: This file adds asynchronous refresh methods to both credentials\nclasses, and therefore async/await syntax is required when calling this\nmethod when using service account credentials with asynchronous functionality.\nOtherwise, all other methods are inherited from the regular service account\ncredentials file google.oauth2.service_account\n\n\"\"\"\n\nfrom google.auth import _credentials_async as credentials_async\nfrom google.auth import _helpers\nfrom google.oauth2 import _client_async\nfrom google.oauth2 import service_account\n\n\nclass Credentials(\n    service_account.Credentials, credentials_async.Scoped, credentials_async.Credentials\n):\n    \"\"\"Service account credentials\n\n    Usually, you'll create these credentials with one of the helper\n    constructors. To create credentials using a Google service account\n    private key JSON file::\n\n        credentials = _service_account_async.Credentials.from_service_account_file(\n            'service-account.json')\n\n    Or if you already have the service account file loaded::\n\n        service_account_info = json.load(open('service_account.json'))\n        credentials = _service_account_async.Credentials.from_service_account_info(\n            service_account_info)\n\n    Both helper methods pass on arguments to the constructor, so you can\n    specify additional scopes and a subject if necessary::\n\n        credentials = _service_account_async.Credentials.from_service_account_file(\n            'service-account.json',\n            scopes=['email'],\n            subject='user@example.com')\n\n    The credentials are considered immutable. If you want to modify the scopes\n    or the subject used for delegation, use :meth:`with_scopes` or\n    :meth:`with_subject`::\n\n        scoped_credentials = credentials.with_scopes(['email'])\n        delegated_credentials = credentials.with_subject(subject)\n\n    To add a quota project, use :meth:`with_quota_project`::\n\n        credentials = credentials.with_quota_project('myproject-123')\n    \"\"\"\n\n    @_helpers.copy_docstring(credentials_async.Credentials)\n    async def refresh(self, request):\n        assertion = self._make_authorization_grant_assertion()\n        access_token, expiry, _ = await _client_async.jwt_grant(\n            request, self._token_uri, assertion\n        )\n        self.token = access_token\n        self.expiry = expiry\n\n\nclass IDTokenCredentials(\n    service_account.IDTokenCredentials,\n    credentials_async.Signing,\n    credentials_async.Credentials,\n):\n    \"\"\"Open ID Connect ID Token-based service account credentials.\n\n    These credentials are largely similar to :class:`.Credentials`, but instead\n    of using an OAuth 2.0 Access Token as the bearer token, they use an Open\n    ID Connect ID Token as the bearer token. These credentials are useful when\n    communicating to services that require ID Tokens and can not accept access\n    tokens.\n\n    Usually, you'll create these credentials with one of the helper\n    constructors. To create credentials using a Google service account\n    private key JSON file::\n\n        credentials = (\n            _service_account_async.IDTokenCredentials.from_service_account_file(\n                'service-account.json'))\n\n    Or if you already have the service account file loaded::\n\n        service_account_info = json.load(open('service_account.json'))\n        credentials = (\n            _service_account_async.IDTokenCredentials.from_service_account_info(\n                service_account_info))\n\n    Both helper methods pass on arguments to the constructor, so you can\n    specify additional scopes and a subject if necessary::\n\n        credentials = (\n            _service_account_async.IDTokenCredentials.from_service_account_file(\n                'service-account.json',\n                scopes=['email'],\n                subject='user@example.com'))\n\n    The credentials are considered immutable. If you want to modify the scopes\n    or the subject used for delegation, use :meth:`with_scopes` or\n    :meth:`with_subject`::\n\n        scoped_credentials = credentials.with_scopes(['email'])\n        delegated_credentials = credentials.with_subject(subject)\n\n    \"\"\"\n\n    @_helpers.copy_docstring(credentials_async.Credentials)\n    async def refresh(self, request):\n        assertion = self._make_authorization_grant_assertion()\n        access_token, expiry, _ = await _client_async.id_token_jwt_grant(\n            request, self._token_uri, assertion\n        )\n        self.token = access_token\n        self.expiry = expiry\n", "google/oauth2/__init__.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Google OAuth 2.0 Library for Python.\"\"\"\n\nimport sys\nimport warnings\n\n\nclass Python37DeprecationWarning(DeprecationWarning):  # pragma: NO COVER\n    \"\"\"\n    Deprecation warning raised when Python 3.7 runtime is detected.\n    Python 3.7 support will be dropped after January 1, 2024.\n    \"\"\"\n\n    pass\n\n\n# Checks if the current runtime is Python 3.7.\nif sys.version_info.major == 3 and sys.version_info.minor == 7:  # pragma: NO COVER\n    message = (\n        \"After January 1, 2024, new releases of this library will drop support \"\n        \"for Python 3.7.\"\n    )\n    warnings.warn(message, Python37DeprecationWarning)\n", "google/oauth2/webauthn_types.py": "from dataclasses import dataclass\nimport json\nfrom typing import Any, Dict, List, Optional\n\nfrom google.auth import exceptions\n\n\n@dataclass(frozen=True)\nclass PublicKeyCredentialDescriptor:\n    \"\"\"Descriptor for a security key based credential.\n\n    https://www.w3.org/TR/webauthn-3/#dictionary-credential-descriptor\n\n    Args:\n        id: <url-safe base64-encoded> credential id (key handle).\n        transports: <'usb'|'nfc'|'ble'|'internal'> List of supported transports.\n    \"\"\"\n\n    id: str\n    transports: Optional[List[str]] = None\n\n    def to_dict(self):\n        cred = {\"type\": \"public-key\", \"id\": self.id}\n        if self.transports:\n            cred[\"transports\"] = self.transports\n        return cred\n\n\n@dataclass\nclass AuthenticationExtensionsClientInputs:\n    \"\"\"Client extensions inputs for WebAuthn extensions.\n\n    Args:\n        appid: app id that can be asserted with in addition to rpid.\n            https://www.w3.org/TR/webauthn-3/#sctn-appid-extension\n    \"\"\"\n\n    appid: Optional[str] = None\n\n    def to_dict(self):\n        extensions = {}\n        if self.appid:\n            extensions[\"appid\"] = self.appid\n        return extensions\n\n\n@dataclass\nclass GetRequest:\n    \"\"\"WebAuthn get request\n\n    Args:\n        origin: Origin where the WebAuthn get assertion takes place.\n        rpid: Relying Party ID.\n        challenge: <url-safe base64-encoded> raw challenge.\n        timeout_ms: Timeout number in millisecond.\n        allow_credentials: List of allowed credentials.\n        user_verification: <'required'|'preferred'|'discouraged'> User verification requirement.\n        extensions: WebAuthn authentication extensions inputs.\n    \"\"\"\n\n    origin: str\n    rpid: str\n    challenge: str\n    timeout_ms: Optional[int] = None\n    allow_credentials: Optional[List[PublicKeyCredentialDescriptor]] = None\n    user_verification: Optional[str] = None\n    extensions: Optional[AuthenticationExtensionsClientInputs] = None\n\n    def to_json(self) -> str:\n        req_options: Dict[str, Any] = {\"rpid\": self.rpid, \"challenge\": self.challenge}\n        if self.timeout_ms:\n            req_options[\"timeout\"] = self.timeout_ms\n        if self.allow_credentials:\n            req_options[\"allowCredentials\"] = [\n                c.to_dict() for c in self.allow_credentials\n            ]\n        if self.user_verification:\n            req_options[\"userVerification\"] = self.user_verification\n        if self.extensions:\n            req_options[\"extensions\"] = self.extensions.to_dict()\n        return json.dumps(\n            {\"type\": \"get\", \"origin\": self.origin, \"requestData\": req_options}\n        )\n\n\n@dataclass(frozen=True)\nclass AuthenticatorAssertionResponse:\n    \"\"\"Authenticator response to a WebAuthn get (assertion) request.\n\n    https://www.w3.org/TR/webauthn-3/#authenticatorassertionresponse\n\n    Args:\n        client_data_json: <url-safe base64-encoded> client data JSON.\n        authenticator_data: <url-safe base64-encoded> authenticator data.\n        signature: <url-safe base64-encoded> signature.\n        user_handle: <url-safe base64-encoded> user handle.\n    \"\"\"\n\n    client_data_json: str\n    authenticator_data: str\n    signature: str\n    user_handle: Optional[str]\n\n\n@dataclass(frozen=True)\nclass GetResponse:\n    \"\"\"WebAuthn get (assertion) response.\n\n    Args:\n        id: <url-safe base64-encoded> credential id (key handle).\n        response: The authenticator assertion response.\n        authenticator_attachment: <'cross-platform'|'platform'> The attachment status of the authenticator.\n        client_extension_results: WebAuthn authentication extensions output results in a dictionary.\n    \"\"\"\n\n    id: str\n    response: AuthenticatorAssertionResponse\n    authenticator_attachment: Optional[str]\n    client_extension_results: Optional[Dict]\n\n    @staticmethod\n    def from_json(json_str: str):\n        \"\"\"Verify and construct GetResponse from a JSON string.\"\"\"\n        try:\n            resp_json = json.loads(json_str)\n        except ValueError:\n            raise exceptions.MalformedError(\"Invalid Get JSON response\")\n        if resp_json.get(\"type\") != \"getResponse\":\n            raise exceptions.MalformedError(\n                \"Invalid Get response type: {}\".format(resp_json.get(\"type\"))\n            )\n        pk_cred = resp_json.get(\"responseData\")\n        if pk_cred is None:\n            if resp_json.get(\"error\"):\n                raise exceptions.ReauthFailError(\n                    \"WebAuthn.get failure: {}\".format(resp_json[\"error\"])\n                )\n            else:\n                raise exceptions.MalformedError(\"Get response is empty\")\n        if pk_cred.get(\"type\") != \"public-key\":\n            raise exceptions.MalformedError(\n                \"Invalid credential type: {}\".format(pk_cred.get(\"type\"))\n            )\n        assertion_json = pk_cred[\"response\"]\n        assertion_resp = AuthenticatorAssertionResponse(\n            client_data_json=assertion_json[\"clientDataJSON\"],\n            authenticator_data=assertion_json[\"authenticatorData\"],\n            signature=assertion_json[\"signature\"],\n            user_handle=assertion_json.get(\"userHandle\"),\n        )\n        return GetResponse(\n            id=pk_cred[\"id\"],\n            response=assertion_resp,\n            authenticator_attachment=pk_cred.get(\"authenticatorAttachment\"),\n            client_extension_results=pk_cred.get(\"clientExtensionResults\"),\n        )\n", "google/oauth2/webauthn_handler_factory.py": "from typing import List, Optional\n\nfrom google.oauth2.webauthn_handler import PluginHandler, WebAuthnHandler\n\n\nclass WebauthnHandlerFactory:\n    handlers: List[WebAuthnHandler]\n\n    def __init__(self):\n        self.handlers = [PluginHandler()]\n\n    def get_handler(self) -> Optional[WebAuthnHandler]:\n        for handler in self.handlers:\n            if handler.is_available():\n                return handler\n        return None\n", "google/oauth2/challenges.py": "# Copyright 2021 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\" Challenges for reauthentication.\n\"\"\"\n\nimport abc\nimport base64\nimport getpass\nimport sys\n\nfrom google.auth import _helpers\nfrom google.auth import exceptions\nfrom google.oauth2 import webauthn_handler_factory\nfrom google.oauth2.webauthn_types import (\n    AuthenticationExtensionsClientInputs,\n    GetRequest,\n    PublicKeyCredentialDescriptor,\n)\n\n\nREAUTH_ORIGIN = \"https://accounts.google.com\"\nSAML_CHALLENGE_MESSAGE = (\n    \"Please run `gcloud auth login` to complete reauthentication with SAML.\"\n)\nWEBAUTHN_TIMEOUT_MS = 120000  # Two minute timeout\n\n\ndef get_user_password(text):\n    \"\"\"Get password from user.\n\n    Override this function with a different logic if you are using this library\n    outside a CLI.\n\n    Args:\n        text (str): message for the password prompt.\n\n    Returns:\n        str: password string.\n    \"\"\"\n    return getpass.getpass(text)\n\n\nclass ReauthChallenge(metaclass=abc.ABCMeta):\n    \"\"\"Base class for reauth challenges.\"\"\"\n\n    @property\n    @abc.abstractmethod\n    def name(self):  # pragma: NO COVER\n        \"\"\"Returns the name of the challenge.\"\"\"\n        raise NotImplementedError(\"name property must be implemented\")\n\n    @property\n    @abc.abstractmethod\n    def is_locally_eligible(self):  # pragma: NO COVER\n        \"\"\"Returns true if a challenge is supported locally on this machine.\"\"\"\n        raise NotImplementedError(\"is_locally_eligible property must be implemented\")\n\n    @abc.abstractmethod\n    def obtain_challenge_input(self, metadata):  # pragma: NO COVER\n        \"\"\"Performs logic required to obtain credentials and returns it.\n\n        Args:\n            metadata (Mapping): challenge metadata returned in the 'challenges' field in\n                the initial reauth request. Includes the 'challengeType' field\n                and other challenge-specific fields.\n\n        Returns:\n            response that will be send to the reauth service as the content of\n            the 'proposalResponse' field in the request body. Usually a dict\n            with the keys specific to the challenge. For example,\n            ``{'credential': password}`` for password challenge.\n        \"\"\"\n        raise NotImplementedError(\"obtain_challenge_input method must be implemented\")\n\n\nclass PasswordChallenge(ReauthChallenge):\n    \"\"\"Challenge that asks for user's password.\"\"\"\n\n    @property\n    def name(self):\n        return \"PASSWORD\"\n\n    @property\n    def is_locally_eligible(self):\n        return True\n\n    @_helpers.copy_docstring(ReauthChallenge)\n    def obtain_challenge_input(self, unused_metadata):\n        passwd = get_user_password(\"Please enter your password:\")\n        if not passwd:\n            passwd = \" \"  # avoid the server crashing in case of no password :D\n        return {\"credential\": passwd}\n\n\nclass SecurityKeyChallenge(ReauthChallenge):\n    \"\"\"Challenge that asks for user's security key touch.\"\"\"\n\n    @property\n    def name(self):\n        return \"SECURITY_KEY\"\n\n    @property\n    def is_locally_eligible(self):\n        return True\n\n    @_helpers.copy_docstring(ReauthChallenge)\n    def obtain_challenge_input(self, metadata):\n        # Check if there is an available Webauthn Handler, if not use pyu2f\n        try:\n            factory = webauthn_handler_factory.WebauthnHandlerFactory()\n            webauthn_handler = factory.get_handler()\n            if webauthn_handler is not None:\n                sys.stderr.write(\"Please insert and touch your security key\\n\")\n                return self._obtain_challenge_input_webauthn(metadata, webauthn_handler)\n        except Exception:\n            # Attempt pyu2f if exception in webauthn flow\n            pass\n\n        try:\n            import pyu2f.convenience.authenticator  # type: ignore\n            import pyu2f.errors  # type: ignore\n            import pyu2f.model  # type: ignore\n        except ImportError:\n            raise exceptions.ReauthFailError(\n                \"pyu2f dependency is required to use Security key reauth feature. \"\n                \"It can be installed via `pip install pyu2f` or `pip install google-auth[reauth]`.\"\n            )\n        sk = metadata[\"securityKey\"]\n        challenges = sk[\"challenges\"]\n        # Read both 'applicationId' and 'relyingPartyId', if they are the same, use\n        # applicationId, if they are different, use relyingPartyId first and retry\n        # with applicationId\n        application_id = sk[\"applicationId\"]\n        relying_party_id = sk[\"relyingPartyId\"]\n\n        if application_id != relying_party_id:\n            application_parameters = [relying_party_id, application_id]\n        else:\n            application_parameters = [application_id]\n\n        challenge_data = []\n        for c in challenges:\n            kh = c[\"keyHandle\"].encode(\"ascii\")\n            key = pyu2f.model.RegisteredKey(bytearray(base64.urlsafe_b64decode(kh)))\n            challenge = c[\"challenge\"].encode(\"ascii\")\n            challenge = base64.urlsafe_b64decode(challenge)\n            challenge_data.append({\"key\": key, \"challenge\": challenge})\n\n        # Track number of tries to suppress error message until all application_parameters\n        # are tried.\n        tries = 0\n        for app_id in application_parameters:\n            try:\n                tries += 1\n                api = pyu2f.convenience.authenticator.CreateCompositeAuthenticator(\n                    REAUTH_ORIGIN\n                )\n                response = api.Authenticate(\n                    app_id, challenge_data, print_callback=sys.stderr.write\n                )\n                return {\"securityKey\": response}\n            except pyu2f.errors.U2FError as e:\n                if e.code == pyu2f.errors.U2FError.DEVICE_INELIGIBLE:\n                    # Only show error if all app_ids have been tried\n                    if tries == len(application_parameters):\n                        sys.stderr.write(\"Ineligible security key.\\n\")\n                        return None\n                    continue\n                if e.code == pyu2f.errors.U2FError.TIMEOUT:\n                    sys.stderr.write(\n                        \"Timed out while waiting for security key touch.\\n\"\n                    )\n                else:\n                    raise e\n            except pyu2f.errors.PluginError as e:\n                sys.stderr.write(\"Plugin error: {}.\\n\".format(e))\n                continue\n            except pyu2f.errors.NoDeviceFoundError:\n                sys.stderr.write(\"No security key found.\\n\")\n            return None\n\n    def _obtain_challenge_input_webauthn(self, metadata, webauthn_handler):\n        sk = metadata.get(\"securityKey\")\n        if sk is None:\n            raise exceptions.InvalidValue(\"securityKey is None\")\n        challenges = sk.get(\"challenges\")\n        application_id = sk.get(\"applicationId\")\n        relying_party_id = sk.get(\"relyingPartyId\")\n        if challenges is None or len(challenges) < 1:\n            raise exceptions.InvalidValue(\"challenges is None or empty\")\n        if application_id is None:\n            raise exceptions.InvalidValue(\"application_id is None\")\n        if relying_party_id is None:\n            raise exceptions.InvalidValue(\"relying_party_id is None\")\n\n        allow_credentials = []\n        for challenge in challenges:\n            kh = challenge.get(\"keyHandle\")\n            if kh is None:\n                raise exceptions.InvalidValue(\"keyHandle is None\")\n            key_handle = self._unpadded_urlsafe_b64recode(kh)\n            allow_credentials.append(PublicKeyCredentialDescriptor(id=key_handle))\n\n        extension = AuthenticationExtensionsClientInputs(appid=application_id)\n\n        challenge = challenges[0].get(\"challenge\")\n        if challenge is None:\n            raise exceptions.InvalidValue(\"challenge is None\")\n\n        get_request = GetRequest(\n            origin=REAUTH_ORIGIN,\n            rpid=relying_party_id,\n            challenge=self._unpadded_urlsafe_b64recode(challenge),\n            timeout_ms=WEBAUTHN_TIMEOUT_MS,\n            allow_credentials=allow_credentials,\n            user_verification=\"required\",\n            extensions=extension,\n        )\n\n        try:\n            get_response = webauthn_handler.get(get_request)\n        except Exception as e:\n            sys.stderr.write(\"Webauthn Error: {}.\\n\".format(e))\n            raise e\n\n        response = {\n            \"clientData\": get_response.response.client_data_json,\n            \"authenticatorData\": get_response.response.authenticator_data,\n            \"signatureData\": get_response.response.signature,\n            \"applicationId\": application_id,\n            \"keyHandle\": get_response.id,\n            \"securityKeyReplyType\": 2,\n        }\n        return {\"securityKey\": response}\n\n    def _unpadded_urlsafe_b64recode(self, s):\n        \"\"\"Converts standard b64 encoded string to url safe b64 encoded string\n        with no padding.\"\"\"\n        b = base64.urlsafe_b64decode(s)\n        return base64.urlsafe_b64encode(b).decode().rstrip(\"=\")\n\n\nclass SamlChallenge(ReauthChallenge):\n    \"\"\"Challenge that asks the users to browse to their ID Providers.\n\n    Currently SAML challenge is not supported. When obtaining the challenge\n    input, exception will be raised to instruct the users to run\n    `gcloud auth login` for reauthentication.\n    \"\"\"\n\n    @property\n    def name(self):\n        return \"SAML\"\n\n    @property\n    def is_locally_eligible(self):\n        return True\n\n    def obtain_challenge_input(self, metadata):\n        # Magic Arch has not fully supported returning a proper dedirect URL\n        # for programmatic SAML users today. So we error our here and request\n        # users to use gcloud to complete a login.\n        raise exceptions.ReauthSamlChallengeFailError(SAML_CHALLENGE_MESSAGE)\n\n\nAVAILABLE_CHALLENGES = {\n    challenge.name: challenge\n    for challenge in [SecurityKeyChallenge(), PasswordChallenge(), SamlChallenge()]\n}\n", "google/oauth2/_client_async.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"OAuth 2.0 async client.\n\nThis is a client for interacting with an OAuth 2.0 authorization server's\ntoken endpoint.\n\nFor more information about the token endpoint, see\n`Section 3.1 of rfc6749`_\n\n.. _Section 3.1 of rfc6749: https://tools.ietf.org/html/rfc6749#section-3.2\n\"\"\"\n\nimport datetime\nimport http.client as http_client\nimport json\nimport urllib\n\nfrom google.auth import _exponential_backoff\nfrom google.auth import exceptions\nfrom google.auth import jwt\nfrom google.oauth2 import _client as client\n\n\nasync def _token_endpoint_request_no_throw(\n    request, token_uri, body, access_token=None, use_json=False, can_retry=True\n):\n    \"\"\"Makes a request to the OAuth 2.0 authorization server's token endpoint.\n    This function doesn't throw on response errors.\n\n    Args:\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests.\n        token_uri (str): The OAuth 2.0 authorizations server's token endpoint\n            URI.\n        body (Mapping[str, str]): The parameters to send in the request body.\n        access_token (Optional(str)): The access token needed to make the request.\n        use_json (Optional(bool)): Use urlencoded format or json format for the\n            content type. The default value is False.\n        can_retry (bool): Enable or disable request retry behavior.\n\n    Returns:\n        Tuple(bool, Mapping[str, str], Optional[bool]): A boolean indicating\n          if the request is successful, a mapping for the JSON-decoded response\n          data and in the case of an error a boolean indicating if the error\n          is retryable.\n    \"\"\"\n    if use_json:\n        headers = {\"Content-Type\": client._JSON_CONTENT_TYPE}\n        body = json.dumps(body).encode(\"utf-8\")\n    else:\n        headers = {\"Content-Type\": client._URLENCODED_CONTENT_TYPE}\n        body = urllib.parse.urlencode(body).encode(\"utf-8\")\n\n    if access_token:\n        headers[\"Authorization\"] = \"Bearer {}\".format(access_token)\n\n    async def _perform_request():\n        response = await request(\n            method=\"POST\", url=token_uri, headers=headers, body=body\n        )\n\n        # Using data.read() resulted in zlib decompression errors. This may require future investigation.\n        response_body1 = await response.content()\n\n        response_body = (\n            response_body1.decode(\"utf-8\")\n            if hasattr(response_body1, \"decode\")\n            else response_body1\n        )\n\n        try:\n            response_data = json.loads(response_body)\n        except ValueError:\n            response_data = response_body\n\n        if response.status == http_client.OK:\n            return True, response_data, None\n\n        retryable_error = client._can_retry(\n            status_code=response.status, response_data=response_data\n        )\n\n        return False, response_data, retryable_error\n\n    request_succeeded, response_data, retryable_error = await _perform_request()\n\n    if request_succeeded or not retryable_error or not can_retry:\n        return request_succeeded, response_data, retryable_error\n\n    retries = _exponential_backoff.ExponentialBackoff()\n    for _ in retries:\n        request_succeeded, response_data, retryable_error = await _perform_request()\n        if request_succeeded or not retryable_error:\n            return request_succeeded, response_data, retryable_error\n\n    return False, response_data, retryable_error\n\n\nasync def _token_endpoint_request(\n    request, token_uri, body, access_token=None, use_json=False, can_retry=True\n):\n    \"\"\"Makes a request to the OAuth 2.0 authorization server's token endpoint.\n\n    Args:\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests.\n        token_uri (str): The OAuth 2.0 authorizations server's token endpoint\n            URI.\n        body (Mapping[str, str]): The parameters to send in the request body.\n        access_token (Optional(str)): The access token needed to make the request.\n        use_json (Optional(bool)): Use urlencoded format or json format for the\n            content type. The default value is False.\n        can_retry (bool): Enable or disable request retry behavior.\n\n    Returns:\n        Mapping[str, str]: The JSON-decoded response data.\n\n    Raises:\n        google.auth.exceptions.RefreshError: If the token endpoint returned\n            an error.\n    \"\"\"\n\n    response_status_ok, response_data, retryable_error = await _token_endpoint_request_no_throw(\n        request,\n        token_uri,\n        body,\n        access_token=access_token,\n        use_json=use_json,\n        can_retry=can_retry,\n    )\n    if not response_status_ok:\n        client._handle_error_response(response_data, retryable_error)\n    return response_data\n\n\nasync def jwt_grant(request, token_uri, assertion, can_retry=True):\n    \"\"\"Implements the JWT Profile for OAuth 2.0 Authorization Grants.\n\n    For more details, see `rfc7523 section 4`_.\n\n    Args:\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests.\n        token_uri (str): The OAuth 2.0 authorizations server's token endpoint\n            URI.\n        assertion (str): The OAuth 2.0 assertion.\n        can_retry (bool): Enable or disable request retry behavior.\n\n    Returns:\n        Tuple[str, Optional[datetime], Mapping[str, str]]: The access token,\n            expiration, and additional data returned by the token endpoint.\n\n    Raises:\n        google.auth.exceptions.RefreshError: If the token endpoint returned\n            an error.\n\n    .. _rfc7523 section 4: https://tools.ietf.org/html/rfc7523#section-4\n    \"\"\"\n    body = {\"assertion\": assertion, \"grant_type\": client._JWT_GRANT_TYPE}\n\n    response_data = await _token_endpoint_request(\n        request, token_uri, body, can_retry=can_retry\n    )\n\n    try:\n        access_token = response_data[\"access_token\"]\n    except KeyError as caught_exc:\n        new_exc = exceptions.RefreshError(\n            \"No access token in response.\", response_data, retryable=False\n        )\n        raise new_exc from caught_exc\n\n    expiry = client._parse_expiry(response_data)\n\n    return access_token, expiry, response_data\n\n\nasync def id_token_jwt_grant(request, token_uri, assertion, can_retry=True):\n    \"\"\"Implements the JWT Profile for OAuth 2.0 Authorization Grants, but\n    requests an OpenID Connect ID Token instead of an access token.\n\n    This is a variant on the standard JWT Profile that is currently unique\n    to Google. This was added for the benefit of authenticating to services\n    that require ID Tokens instead of access tokens or JWT bearer tokens.\n\n    Args:\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests.\n        token_uri (str): The OAuth 2.0 authorization server's token endpoint\n            URI.\n        assertion (str): JWT token signed by a service account. The token's\n            payload must include a ``target_audience`` claim.\n        can_retry (bool): Enable or disable request retry behavior.\n\n    Returns:\n        Tuple[str, Optional[datetime], Mapping[str, str]]:\n            The (encoded) Open ID Connect ID Token, expiration, and additional\n            data returned by the endpoint.\n\n    Raises:\n        google.auth.exceptions.RefreshError: If the token endpoint returned\n            an error.\n    \"\"\"\n    body = {\"assertion\": assertion, \"grant_type\": client._JWT_GRANT_TYPE}\n\n    response_data = await _token_endpoint_request(\n        request, token_uri, body, can_retry=can_retry\n    )\n\n    try:\n        id_token = response_data[\"id_token\"]\n    except KeyError as caught_exc:\n        new_exc = exceptions.RefreshError(\n            \"No ID token in response.\", response_data, retryable=False\n        )\n        raise new_exc from caught_exc\n\n    payload = jwt.decode(id_token, verify=False)\n    expiry = datetime.datetime.utcfromtimestamp(payload[\"exp\"])\n\n    return id_token, expiry, response_data\n\n\nasync def refresh_grant(\n    request,\n    token_uri,\n    refresh_token,\n    client_id,\n    client_secret,\n    scopes=None,\n    rapt_token=None,\n    can_retry=True,\n):\n    \"\"\"Implements the OAuth 2.0 refresh token grant.\n\n    For more details, see `rfc678 section 6`_.\n\n    Args:\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests.\n        token_uri (str): The OAuth 2.0 authorizations server's token endpoint\n            URI.\n        refresh_token (str): The refresh token to use to get a new access\n            token.\n        client_id (str): The OAuth 2.0 application's client ID.\n        client_secret (str): The Oauth 2.0 appliaction's client secret.\n        scopes (Optional(Sequence[str])): Scopes to request. If present, all\n            scopes must be authorized for the refresh token. Useful if refresh\n            token has a wild card scope (e.g.\n            'https://www.googleapis.com/auth/any-api').\n        rapt_token (Optional(str)): The reauth Proof Token.\n        can_retry (bool): Enable or disable request retry behavior.\n\n    Returns:\n        Tuple[str, Optional[str], Optional[datetime], Mapping[str, str]]: The\n            access token, new or current refresh token, expiration, and additional data\n            returned by the token endpoint.\n\n    Raises:\n        google.auth.exceptions.RefreshError: If the token endpoint returned\n            an error.\n\n    .. _rfc6748 section 6: https://tools.ietf.org/html/rfc6749#section-6\n    \"\"\"\n    body = {\n        \"grant_type\": client._REFRESH_GRANT_TYPE,\n        \"client_id\": client_id,\n        \"client_secret\": client_secret,\n        \"refresh_token\": refresh_token,\n    }\n    if scopes:\n        body[\"scope\"] = \" \".join(scopes)\n    if rapt_token:\n        body[\"rapt\"] = rapt_token\n\n    response_data = await _token_endpoint_request(\n        request, token_uri, body, can_retry=can_retry\n    )\n    return client._handle_refresh_grant_response(response_data, refresh_token)\n", "google/oauth2/_reauth_async.py": "# Copyright 2021 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"A module that provides functions for handling rapt authentication.\n\nReauth is a process of obtaining additional authentication (such as password,\nsecurity token, etc.) while refreshing OAuth 2.0 credentials for a user.\n\nCredentials that use the Reauth flow must have the reauth scope,\n``https://www.googleapis.com/auth/accounts.reauth``.\n\nThis module provides a high-level function for executing the Reauth process,\n:func:`refresh_grant`, and lower-level helpers for doing the individual\nsteps of the reauth process.\n\nThose steps are:\n\n1. Obtaining a list of challenges from the reauth server.\n2. Running through each challenge and sending the result back to the reauth\n   server.\n3. Refreshing the access token using the returned rapt token.\n\"\"\"\n\nimport sys\n\nfrom google.auth import exceptions\nfrom google.oauth2 import _client\nfrom google.oauth2 import _client_async\nfrom google.oauth2 import challenges\nfrom google.oauth2 import reauth\n\n\nasync def _get_challenges(\n    request, supported_challenge_types, access_token, requested_scopes=None\n):\n    \"\"\"Does initial request to reauth API to get the challenges.\n\n    Args:\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests. This must be an aiohttp request.\n        supported_challenge_types (Sequence[str]): list of challenge names\n            supported by the manager.\n        access_token (str): Access token with reauth scopes.\n        requested_scopes (Optional(Sequence[str])): Authorized scopes for the credentials.\n\n    Returns:\n        dict: The response from the reauth API.\n    \"\"\"\n    body = {\"supportedChallengeTypes\": supported_challenge_types}\n    if requested_scopes:\n        body[\"oauthScopesForDomainPolicyLookup\"] = requested_scopes\n\n    return await _client_async._token_endpoint_request(\n        request,\n        reauth._REAUTH_API + \":start\",\n        body,\n        access_token=access_token,\n        use_json=True,\n    )\n\n\nasync def _send_challenge_result(\n    request, session_id, challenge_id, client_input, access_token\n):\n    \"\"\"Attempt to refresh access token by sending next challenge result.\n\n    Args:\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests. This must be an aiohttp request.\n        session_id (str): session id returned by the initial reauth call.\n        challenge_id (str): challenge id returned by the initial reauth call.\n        client_input: dict with a challenge-specific client input. For example:\n            ``{'credential': password}`` for password challenge.\n        access_token (str): Access token with reauth scopes.\n\n    Returns:\n        dict: The response from the reauth API.\n    \"\"\"\n    body = {\n        \"sessionId\": session_id,\n        \"challengeId\": challenge_id,\n        \"action\": \"RESPOND\",\n        \"proposalResponse\": client_input,\n    }\n\n    return await _client_async._token_endpoint_request(\n        request,\n        reauth._REAUTH_API + \"/{}:continue\".format(session_id),\n        body,\n        access_token=access_token,\n        use_json=True,\n    )\n\n\nasync def _run_next_challenge(msg, request, access_token):\n    \"\"\"Get the next challenge from msg and run it.\n\n    Args:\n        msg (dict): Reauth API response body (either from the initial request to\n            https://reauth.googleapis.com/v2/sessions:start or from sending the\n            previous challenge response to\n            https://reauth.googleapis.com/v2/sessions/id:continue)\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests. This must be an aiohttp request.\n        access_token (str): reauth access token\n\n    Returns:\n        dict: The response from the reauth API.\n\n    Raises:\n        google.auth.exceptions.ReauthError: if reauth failed.\n    \"\"\"\n    for challenge in msg[\"challenges\"]:\n        if challenge[\"status\"] != \"READY\":\n            # Skip non-activated challenges.\n            continue\n        c = challenges.AVAILABLE_CHALLENGES.get(challenge[\"challengeType\"], None)\n        if not c:\n            raise exceptions.ReauthFailError(\n                \"Unsupported challenge type {0}. Supported types: {1}\".format(\n                    challenge[\"challengeType\"],\n                    \",\".join(list(challenges.AVAILABLE_CHALLENGES.keys())),\n                )\n            )\n        if not c.is_locally_eligible:\n            raise exceptions.ReauthFailError(\n                \"Challenge {0} is not locally eligible\".format(\n                    challenge[\"challengeType\"]\n                )\n            )\n        client_input = c.obtain_challenge_input(challenge)\n        if not client_input:\n            return None\n        return await _send_challenge_result(\n            request,\n            msg[\"sessionId\"],\n            challenge[\"challengeId\"],\n            client_input,\n            access_token,\n        )\n    return None\n\n\nasync def _obtain_rapt(request, access_token, requested_scopes):\n    \"\"\"Given an http request method and reauth access token, get rapt token.\n\n    Args:\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests. This must be an aiohttp request.\n        access_token (str): reauth access token\n        requested_scopes (Sequence[str]): scopes required by the client application\n\n    Returns:\n        str: The rapt token.\n\n    Raises:\n        google.auth.exceptions.ReauthError: if reauth failed\n    \"\"\"\n    msg = await _get_challenges(\n        request,\n        list(challenges.AVAILABLE_CHALLENGES.keys()),\n        access_token,\n        requested_scopes,\n    )\n\n    if msg[\"status\"] == reauth._AUTHENTICATED:\n        return msg[\"encodedProofOfReauthToken\"]\n\n    for _ in range(0, reauth.RUN_CHALLENGE_RETRY_LIMIT):\n        if not (\n            msg[\"status\"] == reauth._CHALLENGE_REQUIRED\n            or msg[\"status\"] == reauth._CHALLENGE_PENDING\n        ):\n            raise exceptions.ReauthFailError(\n                \"Reauthentication challenge failed due to API error: {}\".format(\n                    msg[\"status\"]\n                )\n            )\n\n        if not reauth.is_interactive():\n            raise exceptions.ReauthFailError(\n                \"Reauthentication challenge could not be answered because you are not\"\n                \" in an interactive session.\"\n            )\n\n        msg = await _run_next_challenge(msg, request, access_token)\n\n        if msg[\"status\"] == reauth._AUTHENTICATED:\n            return msg[\"encodedProofOfReauthToken\"]\n\n    # If we got here it means we didn't get authenticated.\n    raise exceptions.ReauthFailError(\"Failed to obtain rapt token.\")\n\n\nasync def get_rapt_token(\n    request, client_id, client_secret, refresh_token, token_uri, scopes=None\n):\n    \"\"\"Given an http request method and refresh_token, get rapt token.\n\n    Args:\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests. This must be an aiohttp request.\n        client_id (str): client id to get access token for reauth scope.\n        client_secret (str): client secret for the client_id\n        refresh_token (str): refresh token to refresh access token\n        token_uri (str): uri to refresh access token\n        scopes (Optional(Sequence[str])): scopes required by the client application\n\n    Returns:\n        str: The rapt token.\n    Raises:\n        google.auth.exceptions.RefreshError: If reauth failed.\n    \"\"\"\n    sys.stderr.write(\"Reauthentication required.\\n\")\n\n    # Get access token for reauth.\n    access_token, _, _, _ = await _client_async.refresh_grant(\n        request=request,\n        client_id=client_id,\n        client_secret=client_secret,\n        refresh_token=refresh_token,\n        token_uri=token_uri,\n        scopes=[reauth._REAUTH_SCOPE],\n    )\n\n    # Get rapt token from reauth API.\n    rapt_token = await _obtain_rapt(request, access_token, requested_scopes=scopes)\n\n    return rapt_token\n\n\nasync def refresh_grant(\n    request,\n    token_uri,\n    refresh_token,\n    client_id,\n    client_secret,\n    scopes=None,\n    rapt_token=None,\n    enable_reauth_refresh=False,\n):\n    \"\"\"Implements the reauthentication flow.\n\n    Args:\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests. This must be an aiohttp request.\n        token_uri (str): The OAuth 2.0 authorizations server's token endpoint\n            URI.\n        refresh_token (str): The refresh token to use to get a new access\n            token.\n        client_id (str): The OAuth 2.0 application's client ID.\n        client_secret (str): The Oauth 2.0 appliaction's client secret.\n        scopes (Optional(Sequence[str])): Scopes to request. If present, all\n            scopes must be authorized for the refresh token. Useful if refresh\n            token has a wild card scope (e.g.\n            'https://www.googleapis.com/auth/any-api').\n        rapt_token (Optional(str)): The rapt token for reauth.\n        enable_reauth_refresh (Optional[bool]): Whether reauth refresh flow\n            should be used. The default value is False. This option is for\n            gcloud only, other users should use the default value.\n\n    Returns:\n        Tuple[str, Optional[str], Optional[datetime], Mapping[str, str], str]: The\n            access token, new refresh token, expiration, the additional data\n            returned by the token endpoint, and the rapt token.\n\n    Raises:\n        google.auth.exceptions.RefreshError: If the token endpoint returned\n            an error.\n    \"\"\"\n    body = {\n        \"grant_type\": _client._REFRESH_GRANT_TYPE,\n        \"client_id\": client_id,\n        \"client_secret\": client_secret,\n        \"refresh_token\": refresh_token,\n    }\n    if scopes:\n        body[\"scope\"] = \" \".join(scopes)\n    if rapt_token:\n        body[\"rapt\"] = rapt_token\n\n    response_status_ok, response_data, retryable_error = await _client_async._token_endpoint_request_no_throw(\n        request, token_uri, body\n    )\n    if (\n        not response_status_ok\n        and response_data.get(\"error\") == reauth._REAUTH_NEEDED_ERROR\n        and (\n            response_data.get(\"error_subtype\")\n            == reauth._REAUTH_NEEDED_ERROR_INVALID_RAPT\n            or response_data.get(\"error_subtype\")\n            == reauth._REAUTH_NEEDED_ERROR_RAPT_REQUIRED\n        )\n    ):\n        if not enable_reauth_refresh:\n            raise exceptions.RefreshError(\n                \"Reauthentication is needed. Please run `gcloud auth application-default login` to reauthenticate.\"\n            )\n\n        rapt_token = await get_rapt_token(\n            request, client_id, client_secret, refresh_token, token_uri, scopes=scopes\n        )\n        body[\"rapt\"] = rapt_token\n        (\n            response_status_ok,\n            response_data,\n            retryable_error,\n        ) = await _client_async._token_endpoint_request_no_throw(\n            request, token_uri, body\n        )\n\n    if not response_status_ok:\n        _client._handle_error_response(response_data, retryable_error)\n    refresh_response = _client._handle_refresh_grant_response(\n        response_data, refresh_token\n    )\n    return refresh_response + (rapt_token,)\n", "google/auth/api_key.py": "# Copyright 2022 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Google API key support.\nThis module provides authentication using the `API key`_.\n.. _API key:\n    https://cloud.google.com/docs/authentication/api-keys/\n\"\"\"\n\nfrom google.auth import _helpers\nfrom google.auth import credentials\nfrom google.auth import exceptions\n\n\nclass Credentials(credentials.Credentials):\n    \"\"\"API key credentials.\n    These credentials use API key to provide authorization to applications.\n    \"\"\"\n\n    def __init__(self, token):\n        \"\"\"\n        Args:\n            token (str): API key string\n        Raises:\n            ValueError: If the provided API key is not a non-empty string.\n        \"\"\"\n        super(Credentials, self).__init__()\n        if not token:\n            raise exceptions.InvalidValue(\"Token must be a non-empty API key string\")\n        self.token = token\n\n    @property\n    def expired(self):\n        return False\n\n    @property\n    def valid(self):\n        return True\n\n    @_helpers.copy_docstring(credentials.Credentials)\n    def refresh(self, request):\n        return\n\n    def apply(self, headers, token=None):\n        \"\"\"Apply the API key token to the x-goog-api-key header.\n        Args:\n            headers (Mapping): The HTTP request headers.\n            token (Optional[str]): If specified, overrides the current access\n                token.\n        \"\"\"\n        headers[\"x-goog-api-key\"] = token or self.token\n\n    def before_request(self, request, method, url, headers):\n        \"\"\"Performs credential-specific before request logic.\n        Refreshes the credentials if necessary, then calls :meth:`apply` to\n        apply the token to the x-goog-api-key header.\n        Args:\n            request (google.auth.transport.Request): The object used to make\n                HTTP requests.\n            method (str): The request's HTTP method or the RPC method being\n                invoked.\n            url (str): The request's URI or the RPC service's URI.\n            headers (Mapping): The request's headers.\n        \"\"\"\n        self.apply(headers)\n", "google/auth/_credentials_async.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\n\"\"\"Interfaces for credentials.\"\"\"\n\nimport abc\nimport inspect\n\nfrom google.auth import credentials\n\n\nclass Credentials(credentials.Credentials, metaclass=abc.ABCMeta):\n    \"\"\"Async inherited credentials class from google.auth.credentials.\n    The added functionality is the before_request call which requires\n    async/await syntax.\n    All credentials have a :attr:`token` that is used for authentication and\n    may also optionally set an :attr:`expiry` to indicate when the token will\n    no longer be valid.\n\n    Most credentials will be :attr:`invalid` until :meth:`refresh` is called.\n    Credentials can do this automatically before the first HTTP request in\n    :meth:`before_request`.\n\n    Although the token and expiration will change as the credentials are\n    :meth:`refreshed <refresh>` and used, credentials should be considered\n    immutable. Various credentials will accept configuration such as private\n    keys, scopes, and other options. These options are not changeable after\n    construction. Some classes will provide mechanisms to copy the credentials\n    with modifications such as :meth:`ScopedCredentials.with_scopes`.\n    \"\"\"\n\n    async def before_request(self, request, method, url, headers):\n        \"\"\"Performs credential-specific before request logic.\n\n        Refreshes the credentials if necessary, then calls :meth:`apply` to\n        apply the token to the authentication header.\n\n        Args:\n            request (google.auth.transport.Request): The object used to make\n                HTTP requests.\n            method (str): The request's HTTP method or the RPC method being\n                invoked.\n            url (str): The request's URI or the RPC service's URI.\n            headers (Mapping): The request's headers.\n        \"\"\"\n        # pylint: disable=unused-argument\n        # (Subclasses may use these arguments to ascertain information about\n        # the http request.)\n\n        if not self.valid:\n            if inspect.iscoroutinefunction(self.refresh):\n                await self.refresh(request)\n            else:\n                self.refresh(request)\n        self.apply(headers)\n\n\nclass CredentialsWithQuotaProject(credentials.CredentialsWithQuotaProject):\n    \"\"\"Abstract base for credentials supporting ``with_quota_project`` factory\"\"\"\n\n\nclass AnonymousCredentials(credentials.AnonymousCredentials, Credentials):\n    \"\"\"Credentials that do not provide any authentication information.\n\n    These are useful in the case of services that support anonymous access or\n    local service emulators that do not use credentials. This class inherits\n    from the sync anonymous credentials file, but is kept if async credentials\n    is initialized and we would like anonymous credentials.\n    \"\"\"\n\n\nclass ReadOnlyScoped(credentials.ReadOnlyScoped, metaclass=abc.ABCMeta):\n    \"\"\"Interface for credentials whose scopes can be queried.\n\n    OAuth 2.0-based credentials allow limiting access using scopes as described\n    in `RFC6749 Section 3.3`_.\n    If a credential class implements this interface then the credentials either\n    use scopes in their implementation.\n\n    Some credentials require scopes in order to obtain a token. You can check\n    if scoping is necessary with :attr:`requires_scopes`::\n\n        if credentials.requires_scopes:\n            # Scoping is required.\n            credentials = _credentials_async.with_scopes(scopes=['one', 'two'])\n\n    Credentials that require scopes must either be constructed with scopes::\n\n        credentials = SomeScopedCredentials(scopes=['one', 'two'])\n\n    Or must copy an existing instance using :meth:`with_scopes`::\n\n        scoped_credentials = _credentials_async.with_scopes(scopes=['one', 'two'])\n\n    Some credentials have scopes but do not allow or require scopes to be set,\n    these credentials can be used as-is.\n\n    .. _RFC6749 Section 3.3: https://tools.ietf.org/html/rfc6749#section-3.3\n    \"\"\"\n\n\nclass Scoped(credentials.Scoped):\n    \"\"\"Interface for credentials whose scopes can be replaced while copying.\n\n    OAuth 2.0-based credentials allow limiting access using scopes as described\n    in `RFC6749 Section 3.3`_.\n    If a credential class implements this interface then the credentials either\n    use scopes in their implementation.\n\n    Some credentials require scopes in order to obtain a token. You can check\n    if scoping is necessary with :attr:`requires_scopes`::\n\n        if credentials.requires_scopes:\n            # Scoping is required.\n            credentials = _credentials_async.create_scoped(['one', 'two'])\n\n    Credentials that require scopes must either be constructed with scopes::\n\n        credentials = SomeScopedCredentials(scopes=['one', 'two'])\n\n    Or must copy an existing instance using :meth:`with_scopes`::\n\n        scoped_credentials = credentials.with_scopes(scopes=['one', 'two'])\n\n    Some credentials have scopes but do not allow or require scopes to be set,\n    these credentials can be used as-is.\n\n    .. _RFC6749 Section 3.3: https://tools.ietf.org/html/rfc6749#section-3.3\n    \"\"\"\n\n\ndef with_scopes_if_required(credentials, scopes):\n    \"\"\"Creates a copy of the credentials with scopes if scoping is required.\n\n    This helper function is useful when you do not know (or care to know) the\n    specific type of credentials you are using (such as when you use\n    :func:`google.auth.default`). This function will call\n    :meth:`Scoped.with_scopes` if the credentials are scoped credentials and if\n    the credentials require scoping. Otherwise, it will return the credentials\n    as-is.\n\n    Args:\n        credentials (google.auth.credentials.Credentials): The credentials to\n            scope if necessary.\n        scopes (Sequence[str]): The list of scopes to use.\n\n    Returns:\n        google.auth._credentials_async.Credentials: Either a new set of scoped\n            credentials, or the passed in credentials instance if no scoping\n            was required.\n    \"\"\"\n    if isinstance(credentials, Scoped) and credentials.requires_scopes:\n        return credentials.with_scopes(scopes)\n    else:\n        return credentials\n\n\nclass Signing(credentials.Signing, metaclass=abc.ABCMeta):\n    \"\"\"Interface for credentials that can cryptographically sign messages.\"\"\"\n", "google/auth/downscoped.py": "# Copyright 2021 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Downscoping with Credential Access Boundaries\n\nThis module provides the ability to downscope credentials using\n`Downscoping with Credential Access Boundaries`_. This is useful to restrict the\nIdentity and Access Management (IAM) permissions that a short-lived credential\ncan use.\n\nTo downscope permissions of a source credential, a Credential Access Boundary\nthat specifies which resources the new credential can access, as well as\nan upper bound on the permissions that are available on each resource, has to\nbe defined. A downscoped credential can then be instantiated using the source\ncredential and the Credential Access Boundary.\n\nThe common pattern of usage is to have a token broker with elevated access\ngenerate these downscoped credentials from higher access source credentials and\npass the downscoped short-lived access tokens to a token consumer via some\nsecure authenticated channel for limited access to Google Cloud Storage\nresources.\n\nFor example, a token broker can be set up on a server in a private network.\nVarious workloads (token consumers) in the same network will send authenticated\nrequests to that broker for downscoped tokens to access or modify specific google\ncloud storage buckets.\n\nThe broker will instantiate downscoped credentials instances that can be used to\ngenerate short lived downscoped access tokens that can be passed to the token\nconsumer. These downscoped access tokens can be injected by the consumer into\ngoogle.oauth2.Credentials and used to initialize a storage client instance to\naccess Google Cloud Storage resources with restricted access.\n\nNote: Only Cloud Storage supports Credential Access Boundaries. Other Google\nCloud services do not support this feature.\n\n.. _Downscoping with Credential Access Boundaries: https://cloud.google.com/iam/docs/downscoping-short-lived-credentials\n\"\"\"\n\nimport datetime\n\nfrom google.auth import _helpers\nfrom google.auth import credentials\nfrom google.auth import exceptions\nfrom google.oauth2 import sts\n\n# The maximum number of access boundary rules a Credential Access Boundary can\n# contain.\n_MAX_ACCESS_BOUNDARY_RULES_COUNT = 10\n# The token exchange grant_type used for exchanging credentials.\n_STS_GRANT_TYPE = \"urn:ietf:params:oauth:grant-type:token-exchange\"\n# The token exchange requested_token_type. This is always an access_token.\n_STS_REQUESTED_TOKEN_TYPE = \"urn:ietf:params:oauth:token-type:access_token\"\n# The STS token URL used to exchanged a short lived access token for a downscoped one.\n_STS_TOKEN_URL_PATTERN = \"https://sts.{}/v1/token\"\n# The subject token type to use when exchanging a short lived access token for a\n# downscoped token.\n_STS_SUBJECT_TOKEN_TYPE = \"urn:ietf:params:oauth:token-type:access_token\"\n\n\nclass CredentialAccessBoundary(object):\n    \"\"\"Defines a Credential Access Boundary which contains a list of access boundary\n    rules. Each rule contains information on the resource that the rule applies to,\n    the upper bound of the permissions that are available on that resource and an\n    optional condition to further restrict permissions.\n    \"\"\"\n\n    def __init__(self, rules=[]):\n        \"\"\"Instantiates a Credential Access Boundary. A Credential Access Boundary\n        can contain up to 10 access boundary rules.\n\n        Args:\n            rules (Sequence[google.auth.downscoped.AccessBoundaryRule]): The list of\n                access boundary rules limiting the access that a downscoped credential\n                will have.\n        Raises:\n            InvalidType: If any of the rules are not a valid type.\n            InvalidValue: If the provided rules exceed the maximum allowed.\n        \"\"\"\n        self.rules = rules\n\n    @property\n    def rules(self):\n        \"\"\"Returns the list of access boundary rules defined on the Credential\n        Access Boundary.\n\n        Returns:\n            Tuple[google.auth.downscoped.AccessBoundaryRule, ...]: The list of access\n                boundary rules defined on the Credential Access Boundary. These are returned\n                as an immutable tuple to prevent modification.\n        \"\"\"\n        return tuple(self._rules)\n\n    @rules.setter\n    def rules(self, value):\n        \"\"\"Updates the current rules on the Credential Access Boundary. This will overwrite\n        the existing set of rules.\n\n        Args:\n            value (Sequence[google.auth.downscoped.AccessBoundaryRule]): The list of\n                access boundary rules limiting the access that a downscoped credential\n                will have.\n        Raises:\n            InvalidType: If any of the rules are not a valid type.\n            InvalidValue: If the provided rules exceed the maximum allowed.\n        \"\"\"\n        if len(value) > _MAX_ACCESS_BOUNDARY_RULES_COUNT:\n            raise exceptions.InvalidValue(\n                \"Credential access boundary rules can have a maximum of {} rules.\".format(\n                    _MAX_ACCESS_BOUNDARY_RULES_COUNT\n                )\n            )\n        for access_boundary_rule in value:\n            if not isinstance(access_boundary_rule, AccessBoundaryRule):\n                raise exceptions.InvalidType(\n                    \"List of rules provided do not contain a valid 'google.auth.downscoped.AccessBoundaryRule'.\"\n                )\n        # Make a copy of the original list.\n        self._rules = list(value)\n\n    def add_rule(self, rule):\n        \"\"\"Adds a single access boundary rule to the existing rules.\n\n        Args:\n            rule (google.auth.downscoped.AccessBoundaryRule): The access boundary rule,\n                limiting the access that a downscoped credential will have, to be added to\n                the existing rules.\n        Raises:\n            InvalidType: If any of the rules are not a valid type.\n            InvalidValue: If the provided rules exceed the maximum allowed.\n        \"\"\"\n        if len(self.rules) == _MAX_ACCESS_BOUNDARY_RULES_COUNT:\n            raise exceptions.InvalidValue(\n                \"Credential access boundary rules can have a maximum of {} rules.\".format(\n                    _MAX_ACCESS_BOUNDARY_RULES_COUNT\n                )\n            )\n        if not isinstance(rule, AccessBoundaryRule):\n            raise exceptions.InvalidType(\n                \"The provided rule does not contain a valid 'google.auth.downscoped.AccessBoundaryRule'.\"\n            )\n        self._rules.append(rule)\n\n    def to_json(self):\n        \"\"\"Generates the dictionary representation of the Credential Access Boundary.\n        This uses the format expected by the Security Token Service API as documented in\n        `Defining a Credential Access Boundary`_.\n\n        .. _Defining a Credential Access Boundary:\n            https://cloud.google.com/iam/docs/downscoping-short-lived-credentials#define-boundary\n\n        Returns:\n            Mapping: Credential Access Boundary Rule represented in a dictionary object.\n        \"\"\"\n        rules = []\n        for access_boundary_rule in self.rules:\n            rules.append(access_boundary_rule.to_json())\n\n        return {\"accessBoundary\": {\"accessBoundaryRules\": rules}}\n\n\nclass AccessBoundaryRule(object):\n    \"\"\"Defines an access boundary rule which contains information on the resource that\n    the rule applies to, the upper bound of the permissions that are available on that\n    resource and an optional condition to further restrict permissions.\n    \"\"\"\n\n    def __init__(\n        self, available_resource, available_permissions, availability_condition=None\n    ):\n        \"\"\"Instantiates a single access boundary rule.\n\n        Args:\n            available_resource (str): The full resource name of the Cloud Storage bucket\n                that the rule applies to. Use the format\n                \"//storage.googleapis.com/projects/_/buckets/bucket-name\".\n            available_permissions (Sequence[str]): A list defining the upper bound that\n                the downscoped token will have on the available permissions for the\n                resource. Each value is the identifier for an IAM predefined role or\n                custom role, with the prefix \"inRole:\". For example:\n                \"inRole:roles/storage.objectViewer\".\n                Only the permissions in these roles will be available.\n            availability_condition (Optional[google.auth.downscoped.AvailabilityCondition]):\n                Optional condition that restricts the availability of permissions to\n                specific Cloud Storage objects.\n\n        Raises:\n            InvalidType: If any of the parameters are not of the expected types.\n            InvalidValue: If any of the parameters are not of the expected values.\n        \"\"\"\n        self.available_resource = available_resource\n        self.available_permissions = available_permissions\n        self.availability_condition = availability_condition\n\n    @property\n    def available_resource(self):\n        \"\"\"Returns the current available resource.\n\n        Returns:\n           str: The current available resource.\n        \"\"\"\n        return self._available_resource\n\n    @available_resource.setter\n    def available_resource(self, value):\n        \"\"\"Updates the current available resource.\n\n        Args:\n            value (str): The updated value of the available resource.\n\n        Raises:\n            google.auth.exceptions.InvalidType: If the value is not a string.\n        \"\"\"\n        if not isinstance(value, str):\n            raise exceptions.InvalidType(\n                \"The provided available_resource is not a string.\"\n            )\n        self._available_resource = value\n\n    @property\n    def available_permissions(self):\n        \"\"\"Returns the current available permissions.\n\n        Returns:\n           Tuple[str, ...]: The current available permissions. These are returned\n               as an immutable tuple to prevent modification.\n        \"\"\"\n        return tuple(self._available_permissions)\n\n    @available_permissions.setter\n    def available_permissions(self, value):\n        \"\"\"Updates the current available permissions.\n\n        Args:\n            value (Sequence[str]): The updated value of the available permissions.\n\n        Raises:\n            InvalidType: If the value is not a list of strings.\n            InvalidValue: If the value is not valid.\n        \"\"\"\n        for available_permission in value:\n            if not isinstance(available_permission, str):\n                raise exceptions.InvalidType(\n                    \"Provided available_permissions are not a list of strings.\"\n                )\n            if available_permission.find(\"inRole:\") != 0:\n                raise exceptions.InvalidValue(\n                    \"available_permissions must be prefixed with 'inRole:'.\"\n                )\n        # Make a copy of the original list.\n        self._available_permissions = list(value)\n\n    @property\n    def availability_condition(self):\n        \"\"\"Returns the current availability condition.\n\n        Returns:\n           Optional[google.auth.downscoped.AvailabilityCondition]: The current\n               availability condition.\n        \"\"\"\n        return self._availability_condition\n\n    @availability_condition.setter\n    def availability_condition(self, value):\n        \"\"\"Updates the current availability condition.\n\n        Args:\n            value (Optional[google.auth.downscoped.AvailabilityCondition]): The updated\n                value of the availability condition.\n\n        Raises:\n            google.auth.exceptions.InvalidType: If the value is not of type google.auth.downscoped.AvailabilityCondition\n                or None.\n        \"\"\"\n        if not isinstance(value, AvailabilityCondition) and value is not None:\n            raise exceptions.InvalidType(\n                \"The provided availability_condition is not a 'google.auth.downscoped.AvailabilityCondition' or None.\"\n            )\n        self._availability_condition = value\n\n    def to_json(self):\n        \"\"\"Generates the dictionary representation of the access boundary rule.\n        This uses the format expected by the Security Token Service API as documented in\n        `Defining a Credential Access Boundary`_.\n\n        .. _Defining a Credential Access Boundary:\n            https://cloud.google.com/iam/docs/downscoping-short-lived-credentials#define-boundary\n\n        Returns:\n            Mapping: The access boundary rule represented in a dictionary object.\n        \"\"\"\n        json = {\n            \"availablePermissions\": list(self.available_permissions),\n            \"availableResource\": self.available_resource,\n        }\n        if self.availability_condition:\n            json[\"availabilityCondition\"] = self.availability_condition.to_json()\n        return json\n\n\nclass AvailabilityCondition(object):\n    \"\"\"An optional condition that can be used as part of a Credential Access Boundary\n    to further restrict permissions.\"\"\"\n\n    def __init__(self, expression, title=None, description=None):\n        \"\"\"Instantiates an availability condition using the provided expression and\n        optional title or description.\n\n        Args:\n            expression (str): A condition expression that specifies the Cloud Storage\n                objects where permissions are available. For example, this expression\n                makes permissions available for objects whose name starts with \"customer-a\":\n                \"resource.name.startsWith('projects/_/buckets/example-bucket/objects/customer-a')\"\n            title (Optional[str]): An optional short string that identifies the purpose of\n                the condition.\n            description (Optional[str]): Optional details about the purpose of the condition.\n\n        Raises:\n            InvalidType: If any of the parameters are not of the expected types.\n            InvalidValue: If any of the parameters are not of the expected values.\n        \"\"\"\n        self.expression = expression\n        self.title = title\n        self.description = description\n\n    @property\n    def expression(self):\n        \"\"\"Returns the current condition expression.\n\n        Returns:\n           str: The current conditon expression.\n        \"\"\"\n        return self._expression\n\n    @expression.setter\n    def expression(self, value):\n        \"\"\"Updates the current condition expression.\n\n        Args:\n            value (str): The updated value of the condition expression.\n\n        Raises:\n            google.auth.exceptions.InvalidType: If the value is not of type string.\n        \"\"\"\n        if not isinstance(value, str):\n            raise exceptions.InvalidType(\"The provided expression is not a string.\")\n        self._expression = value\n\n    @property\n    def title(self):\n        \"\"\"Returns the current title.\n\n        Returns:\n           Optional[str]: The current title.\n        \"\"\"\n        return self._title\n\n    @title.setter\n    def title(self, value):\n        \"\"\"Updates the current title.\n\n        Args:\n            value (Optional[str]): The updated value of the title.\n\n        Raises:\n            google.auth.exceptions.InvalidType: If the value is not of type string or None.\n        \"\"\"\n        if not isinstance(value, str) and value is not None:\n            raise exceptions.InvalidType(\"The provided title is not a string or None.\")\n        self._title = value\n\n    @property\n    def description(self):\n        \"\"\"Returns the current description.\n\n        Returns:\n           Optional[str]: The current description.\n        \"\"\"\n        return self._description\n\n    @description.setter\n    def description(self, value):\n        \"\"\"Updates the current description.\n\n        Args:\n            value (Optional[str]): The updated value of the description.\n\n        Raises:\n            google.auth.exceptions.InvalidType: If the value is not of type string or None.\n        \"\"\"\n        if not isinstance(value, str) and value is not None:\n            raise exceptions.InvalidType(\n                \"The provided description is not a string or None.\"\n            )\n        self._description = value\n\n    def to_json(self):\n        \"\"\"Generates the dictionary representation of the availability condition.\n        This uses the format expected by the Security Token Service API as documented in\n        `Defining a Credential Access Boundary`_.\n\n        .. _Defining a Credential Access Boundary:\n            https://cloud.google.com/iam/docs/downscoping-short-lived-credentials#define-boundary\n\n        Returns:\n            Mapping[str, str]: The availability condition represented in a dictionary\n                object.\n        \"\"\"\n        json = {\"expression\": self.expression}\n        if self.title:\n            json[\"title\"] = self.title\n        if self.description:\n            json[\"description\"] = self.description\n        return json\n\n\nclass Credentials(credentials.CredentialsWithQuotaProject):\n    \"\"\"Defines a set of Google credentials that are downscoped from an existing set\n    of Google OAuth2 credentials. This is useful to restrict the Identity and Access\n    Management (IAM) permissions that a short-lived credential can use.\n    The common pattern of usage is to have a token broker with elevated access\n    generate these downscoped credentials from higher access source credentials and\n    pass the downscoped short-lived access tokens to a token consumer via some\n    secure authenticated channel for limited access to Google Cloud Storage\n    resources.\n    \"\"\"\n\n    def __init__(\n        self,\n        source_credentials,\n        credential_access_boundary,\n        quota_project_id=None,\n        universe_domain=credentials.DEFAULT_UNIVERSE_DOMAIN,\n    ):\n        \"\"\"Instantiates a downscoped credentials object using the provided source\n        credentials and credential access boundary rules.\n        To downscope permissions of a source credential, a Credential Access Boundary\n        that specifies which resources the new credential can access, as well as an\n        upper bound on the permissions that are available on each resource, has to be\n        defined. A downscoped credential can then be instantiated using the source\n        credential and the Credential Access Boundary.\n\n        Args:\n            source_credentials (google.auth.credentials.Credentials): The source credentials\n                to be downscoped based on the provided Credential Access Boundary rules.\n            credential_access_boundary (google.auth.downscoped.CredentialAccessBoundary):\n                The Credential Access Boundary which contains a list of access boundary\n                rules. Each rule contains information on the resource that the rule applies to,\n                the upper bound of the permissions that are available on that resource and an\n                optional condition to further restrict permissions.\n            quota_project_id (Optional[str]): The optional quota project ID.\n            universe_domain (Optional[str]): The universe domain value, default is googleapis.com\n        Raises:\n            google.auth.exceptions.RefreshError: If the source credentials\n                return an error on token refresh.\n            google.auth.exceptions.OAuthError: If the STS token exchange\n                endpoint returned an error during downscoped token generation.\n        \"\"\"\n\n        super(Credentials, self).__init__()\n        self._source_credentials = source_credentials\n        self._credential_access_boundary = credential_access_boundary\n        self._quota_project_id = quota_project_id\n        self._universe_domain = universe_domain or credentials.DEFAULT_UNIVERSE_DOMAIN\n        self._sts_client = sts.Client(\n            _STS_TOKEN_URL_PATTERN.format(self.universe_domain)\n        )\n\n    @_helpers.copy_docstring(credentials.Credentials)\n    def refresh(self, request):\n        # Generate an access token from the source credentials.\n        self._source_credentials.refresh(request)\n        now = _helpers.utcnow()\n        # Exchange the access token for a downscoped access token.\n        response_data = self._sts_client.exchange_token(\n            request=request,\n            grant_type=_STS_GRANT_TYPE,\n            subject_token=self._source_credentials.token,\n            subject_token_type=_STS_SUBJECT_TOKEN_TYPE,\n            requested_token_type=_STS_REQUESTED_TOKEN_TYPE,\n            additional_options=self._credential_access_boundary.to_json(),\n        )\n        self.token = response_data.get(\"access_token\")\n        # For downscoping CAB flow, the STS endpoint may not return the expiration\n        # field for some flows. The generated downscoped token should always have\n        # the same expiration time as the source credentials. When no expires_in\n        # field is returned in the response, we can just get the expiration time\n        # from the source credentials.\n        if response_data.get(\"expires_in\"):\n            lifetime = datetime.timedelta(seconds=response_data.get(\"expires_in\"))\n            self.expiry = now + lifetime\n        else:\n            self.expiry = self._source_credentials.expiry\n\n    @_helpers.copy_docstring(credentials.CredentialsWithQuotaProject)\n    def with_quota_project(self, quota_project_id):\n        return self.__class__(\n            self._source_credentials,\n            self._credential_access_boundary,\n            quota_project_id=quota_project_id,\n        )\n", "google/auth/iam.py": "# Copyright 2017 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Tools for using the Google `Cloud Identity and Access Management (IAM)\nAPI`_'s auth-related functionality.\n\n.. _Cloud Identity and Access Management (IAM) API:\n    https://cloud.google.com/iam/docs/\n\"\"\"\n\nimport base64\nimport http.client as http_client\nimport json\n\nfrom google.auth import _helpers\nfrom google.auth import crypt\nfrom google.auth import exceptions\n\n\n_IAM_SCOPE = [\"https://www.googleapis.com/auth/iam\"]\n\n_IAM_ENDPOINT = (\n    \"https://iamcredentials.googleapis.com/v1/projects/-\"\n    + \"/serviceAccounts/{}:generateAccessToken\"\n)\n\n_IAM_SIGN_ENDPOINT = (\n    \"https://iamcredentials.googleapis.com/v1/projects/-\"\n    + \"/serviceAccounts/{}:signBlob\"\n)\n\n_IAM_IDTOKEN_ENDPOINT = (\n    \"https://iamcredentials.googleapis.com/v1/\"\n    + \"projects/-/serviceAccounts/{}:generateIdToken\"\n)\n\n\nclass Signer(crypt.Signer):\n    \"\"\"Signs messages using the IAM `signBlob API`_.\n\n    This is useful when you need to sign bytes but do not have access to the\n    credential's private key file.\n\n    .. _signBlob API:\n        https://cloud.google.com/iam/reference/rest/v1/projects.serviceAccounts\n        /signBlob\n    \"\"\"\n\n    def __init__(self, request, credentials, service_account_email):\n        \"\"\"\n        Args:\n            request (google.auth.transport.Request): The object used to make\n                HTTP requests.\n            credentials (google.auth.credentials.Credentials): The credentials\n                that will be used to authenticate the request to the IAM API.\n                The credentials must have of one the following scopes:\n\n                - https://www.googleapis.com/auth/iam\n                - https://www.googleapis.com/auth/cloud-platform\n            service_account_email (str): The service account email identifying\n                which service account to use to sign bytes. Often, this can\n                be the same as the service account email in the given\n                credentials.\n        \"\"\"\n        self._request = request\n        self._credentials = credentials\n        self._service_account_email = service_account_email\n\n    def _make_signing_request(self, message):\n        \"\"\"Makes a request to the API signBlob API.\"\"\"\n        message = _helpers.to_bytes(message)\n\n        method = \"POST\"\n        url = _IAM_SIGN_ENDPOINT.format(self._service_account_email)\n        headers = {\"Content-Type\": \"application/json\"}\n        body = json.dumps(\n            {\"payload\": base64.b64encode(message).decode(\"utf-8\")}\n        ).encode(\"utf-8\")\n\n        self._credentials.before_request(self._request, method, url, headers)\n        response = self._request(url=url, method=method, body=body, headers=headers)\n\n        if response.status != http_client.OK:\n            raise exceptions.TransportError(\n                \"Error calling the IAM signBlob API: {}\".format(response.data)\n            )\n\n        return json.loads(response.data.decode(\"utf-8\"))\n\n    @property\n    def key_id(self):\n        \"\"\"Optional[str]: The key ID used to identify this private key.\n\n        .. warning::\n           This is always ``None``. The key ID used by IAM can not\n           be reliably determined ahead of time.\n        \"\"\"\n        return None\n\n    @_helpers.copy_docstring(crypt.Signer)\n    def sign(self, message):\n        response = self._make_signing_request(message)\n        return base64.b64decode(response[\"signedBlob\"])\n", "google/auth/exceptions.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Exceptions used in the google.auth package.\"\"\"\n\n\nclass GoogleAuthError(Exception):\n    \"\"\"Base class for all google.auth errors.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super(GoogleAuthError, self).__init__(*args)\n        retryable = kwargs.get(\"retryable\", False)\n        self._retryable = retryable\n\n    @property\n    def retryable(self):\n        return self._retryable\n\n\nclass TransportError(GoogleAuthError):\n    \"\"\"Used to indicate an error occurred during an HTTP request.\"\"\"\n\n\nclass RefreshError(GoogleAuthError):\n    \"\"\"Used to indicate that an refreshing the credentials' access token\n    failed.\"\"\"\n\n\nclass UserAccessTokenError(GoogleAuthError):\n    \"\"\"Used to indicate ``gcloud auth print-access-token`` command failed.\"\"\"\n\n\nclass DefaultCredentialsError(GoogleAuthError):\n    \"\"\"Used to indicate that acquiring default credentials failed.\"\"\"\n\n\nclass MutualTLSChannelError(GoogleAuthError):\n    \"\"\"Used to indicate that mutual TLS channel creation is failed, or mutual\n    TLS channel credentials is missing or invalid.\"\"\"\n\n\nclass ClientCertError(GoogleAuthError):\n    \"\"\"Used to indicate that client certificate is missing or invalid.\"\"\"\n\n    @property\n    def retryable(self):\n        return False\n\n\nclass OAuthError(GoogleAuthError):\n    \"\"\"Used to indicate an error occurred during an OAuth related HTTP\n    request.\"\"\"\n\n\nclass ReauthFailError(RefreshError):\n    \"\"\"An exception for when reauth failed.\"\"\"\n\n    def __init__(self, message=None, **kwargs):\n        super(ReauthFailError, self).__init__(\n            \"Reauthentication failed. {0}\".format(message), **kwargs\n        )\n\n\nclass ReauthSamlChallengeFailError(ReauthFailError):\n    \"\"\"An exception for SAML reauth challenge failures.\"\"\"\n\n\nclass MalformedError(DefaultCredentialsError, ValueError):\n    \"\"\"An exception for malformed data.\"\"\"\n\n\nclass InvalidResource(DefaultCredentialsError, ValueError):\n    \"\"\"An exception for URL error.\"\"\"\n\n\nclass InvalidOperation(DefaultCredentialsError, ValueError):\n    \"\"\"An exception for invalid operation.\"\"\"\n\n\nclass InvalidValue(DefaultCredentialsError, ValueError):\n    \"\"\"Used to wrap general ValueError of python.\"\"\"\n\n\nclass InvalidType(DefaultCredentialsError, TypeError):\n    \"\"\"Used to wrap general TypeError of python.\"\"\"\n\n\nclass OSError(DefaultCredentialsError, EnvironmentError):\n    \"\"\"Used to wrap EnvironmentError(OSError after python3.3).\"\"\"\n", "google/auth/_cloud_sdk.py": "# Copyright 2015 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Helpers for reading the Google Cloud SDK's configuration.\"\"\"\n\nimport os\nimport subprocess\n\nfrom google.auth import _helpers\nfrom google.auth import environment_vars\nfrom google.auth import exceptions\n\n\n# The ~/.config subdirectory containing gcloud credentials.\n_CONFIG_DIRECTORY = \"gcloud\"\n# Windows systems store config at %APPDATA%\\gcloud\n_WINDOWS_CONFIG_ROOT_ENV_VAR = \"APPDATA\"\n# The name of the file in the Cloud SDK config that contains default\n# credentials.\n_CREDENTIALS_FILENAME = \"application_default_credentials.json\"\n# The name of the Cloud SDK shell script\n_CLOUD_SDK_POSIX_COMMAND = \"gcloud\"\n_CLOUD_SDK_WINDOWS_COMMAND = \"gcloud.cmd\"\n# The command to get the Cloud SDK configuration\n_CLOUD_SDK_CONFIG_GET_PROJECT_COMMAND = (\"config\", \"get\", \"project\")\n# The command to get google user access token\n_CLOUD_SDK_USER_ACCESS_TOKEN_COMMAND = (\"auth\", \"print-access-token\")\n# Cloud SDK's application-default client ID\nCLOUD_SDK_CLIENT_ID = (\n    \"764086051850-6qr4p6gpi6hn506pt8ejuq83di341hur.apps.googleusercontent.com\"\n)\n\n\ndef get_config_path():\n    \"\"\"Returns the absolute path the the Cloud SDK's configuration directory.\n\n    Returns:\n        str: The Cloud SDK config path.\n    \"\"\"\n    # If the path is explicitly set, return that.\n    try:\n        return os.environ[environment_vars.CLOUD_SDK_CONFIG_DIR]\n    except KeyError:\n        pass\n\n    # Non-windows systems store this at ~/.config/gcloud\n    if os.name != \"nt\":\n        return os.path.join(os.path.expanduser(\"~\"), \".config\", _CONFIG_DIRECTORY)\n    # Windows systems store config at %APPDATA%\\gcloud\n    else:\n        try:\n            return os.path.join(\n                os.environ[_WINDOWS_CONFIG_ROOT_ENV_VAR], _CONFIG_DIRECTORY\n            )\n        except KeyError:\n            # This should never happen unless someone is really\n            # messing with things, but we'll cover the case anyway.\n            drive = os.environ.get(\"SystemDrive\", \"C:\")\n            return os.path.join(drive, \"\\\\\", _CONFIG_DIRECTORY)\n\n\ndef get_application_default_credentials_path():\n    \"\"\"Gets the path to the application default credentials file.\n\n    The path may or may not exist.\n\n    Returns:\n        str: The full path to application default credentials.\n    \"\"\"\n    config_path = get_config_path()\n    return os.path.join(config_path, _CREDENTIALS_FILENAME)\n\n\ndef _run_subprocess_ignore_stderr(command):\n    \"\"\" Return subprocess.check_output with the given command and ignores stderr.\"\"\"\n    with open(os.devnull, \"w\") as devnull:\n        output = subprocess.check_output(command, stderr=devnull)\n    return output\n\n\ndef get_project_id():\n    \"\"\"Gets the project ID from the Cloud SDK.\n\n    Returns:\n        Optional[str]: The project ID.\n    \"\"\"\n    if os.name == \"nt\":\n        command = _CLOUD_SDK_WINDOWS_COMMAND\n    else:\n        command = _CLOUD_SDK_POSIX_COMMAND\n\n    try:\n        # Ignore the stderr coming from gcloud, so it won't be mixed into the output.\n        # https://github.com/googleapis/google-auth-library-python/issues/673\n        project = _run_subprocess_ignore_stderr(\n            (command,) + _CLOUD_SDK_CONFIG_GET_PROJECT_COMMAND\n        )\n\n        # Turn bytes into a string and remove \"\\n\"\n        project = _helpers.from_bytes(project).strip()\n        return project if project else None\n    except (subprocess.CalledProcessError, OSError, IOError):\n        return None\n\n\ndef get_auth_access_token(account=None):\n    \"\"\"Load user access token with the ``gcloud auth print-access-token`` command.\n\n    Args:\n        account (Optional[str]): Account to get the access token for. If not\n            specified, the current active account will be used.\n\n    Returns:\n        str: The user access token.\n\n    Raises:\n        google.auth.exceptions.UserAccessTokenError: if failed to get access\n            token from gcloud.\n    \"\"\"\n    if os.name == \"nt\":\n        command = _CLOUD_SDK_WINDOWS_COMMAND\n    else:\n        command = _CLOUD_SDK_POSIX_COMMAND\n\n    try:\n        if account:\n            command = (\n                (command,)\n                + _CLOUD_SDK_USER_ACCESS_TOKEN_COMMAND\n                + (\"--account=\" + account,)\n            )\n        else:\n            command = (command,) + _CLOUD_SDK_USER_ACCESS_TOKEN_COMMAND\n\n        access_token = subprocess.check_output(command, stderr=subprocess.STDOUT)\n        # remove the trailing \"\\n\"\n        return access_token.decode(\"utf-8\").strip()\n    except (subprocess.CalledProcessError, OSError, IOError) as caught_exc:\n        new_exc = exceptions.UserAccessTokenError(\n            \"Failed to obtain access token\", caught_exc\n        )\n        raise new_exc from caught_exc\n", "google/auth/_jwt_async.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"JSON Web Tokens\n\nProvides support for creating (encoding) and verifying (decoding) JWTs,\nespecially JWTs generated and consumed by Google infrastructure.\n\nSee `rfc7519`_ for more details on JWTs.\n\nTo encode a JWT use :func:`encode`::\n\n    from google.auth import crypt\n    from google.auth import jwt_async\n\n    signer = crypt.Signer(private_key)\n    payload = {'some': 'payload'}\n    encoded = jwt_async.encode(signer, payload)\n\nTo decode a JWT and verify claims use :func:`decode`::\n\n    claims = jwt_async.decode(encoded, certs=public_certs)\n\nYou can also skip verification::\n\n    claims = jwt_async.decode(encoded, verify=False)\n\n.. _rfc7519: https://tools.ietf.org/html/rfc7519\n\n\nNOTE: This async support is experimental and marked internal. This surface may\nchange in minor releases.\n\"\"\"\n\nfrom google.auth import _credentials_async\nfrom google.auth import jwt\n\n\ndef encode(signer, payload, header=None, key_id=None):\n    \"\"\"Make a signed JWT.\n\n    Args:\n        signer (google.auth.crypt.Signer): The signer used to sign the JWT.\n        payload (Mapping[str, str]): The JWT payload.\n        header (Mapping[str, str]): Additional JWT header payload.\n        key_id (str): The key id to add to the JWT header. If the\n            signer has a key id it will be used as the default. If this is\n            specified it will override the signer's key id.\n\n    Returns:\n        bytes: The encoded JWT.\n    \"\"\"\n    return jwt.encode(signer, payload, header, key_id)\n\n\ndef decode(token, certs=None, verify=True, audience=None):\n    \"\"\"Decode and verify a JWT.\n\n    Args:\n        token (str): The encoded JWT.\n        certs (Union[str, bytes, Mapping[str, Union[str, bytes]]]): The\n            certificate used to validate the JWT signature. If bytes or string,\n            it must the the public key certificate in PEM format. If a mapping,\n            it must be a mapping of key IDs to public key certificates in PEM\n            format. The mapping must contain the same key ID that's specified\n            in the token's header.\n        verify (bool): Whether to perform signature and claim validation.\n            Verification is done by default.\n        audience (str): The audience claim, 'aud', that this JWT should\n            contain. If None then the JWT's 'aud' parameter is not verified.\n\n    Returns:\n        Mapping[str, str]: The deserialized JSON payload in the JWT.\n\n    Raises:\n        ValueError: if any verification checks failed.\n    \"\"\"\n\n    return jwt.decode(token, certs, verify, audience)\n\n\nclass Credentials(\n    jwt.Credentials, _credentials_async.Signing, _credentials_async.Credentials\n):\n    \"\"\"Credentials that use a JWT as the bearer token.\n\n    These credentials require an \"audience\" claim. This claim identifies the\n    intended recipient of the bearer token.\n\n    The constructor arguments determine the claims for the JWT that is\n    sent with requests. Usually, you'll construct these credentials with\n    one of the helper constructors as shown in the next section.\n\n    To create JWT credentials using a Google service account private key\n    JSON file::\n\n        audience = 'https://pubsub.googleapis.com/google.pubsub.v1.Publisher'\n        credentials = jwt_async.Credentials.from_service_account_file(\n            'service-account.json',\n            audience=audience)\n\n    If you already have the service account file loaded and parsed::\n\n        service_account_info = json.load(open('service_account.json'))\n        credentials = jwt_async.Credentials.from_service_account_info(\n            service_account_info,\n            audience=audience)\n\n    Both helper methods pass on arguments to the constructor, so you can\n    specify the JWT claims::\n\n        credentials = jwt_async.Credentials.from_service_account_file(\n            'service-account.json',\n            audience=audience,\n            additional_claims={'meta': 'data'})\n\n    You can also construct the credentials directly if you have a\n    :class:`~google.auth.crypt.Signer` instance::\n\n        credentials = jwt_async.Credentials(\n            signer,\n            issuer='your-issuer',\n            subject='your-subject',\n            audience=audience)\n\n    The claims are considered immutable. If you want to modify the claims,\n    you can easily create another instance using :meth:`with_claims`::\n\n        new_audience = (\n            'https://pubsub.googleapis.com/google.pubsub.v1.Subscriber')\n        new_credentials = credentials.with_claims(audience=new_audience)\n    \"\"\"\n\n\nclass OnDemandCredentials(\n    jwt.OnDemandCredentials, _credentials_async.Signing, _credentials_async.Credentials\n):\n    \"\"\"On-demand JWT credentials.\n\n    Like :class:`Credentials`, this class uses a JWT as the bearer token for\n    authentication. However, this class does not require the audience at\n    construction time. Instead, it will generate a new token on-demand for\n    each request using the request URI as the audience. It caches tokens\n    so that multiple requests to the same URI do not incur the overhead\n    of generating a new token every time.\n\n    This behavior is especially useful for `gRPC`_ clients. A gRPC service may\n    have multiple audience and gRPC clients may not know all of the audiences\n    required for accessing a particular service. With these credentials,\n    no knowledge of the audiences is required ahead of time.\n\n    .. _grpc: http://www.grpc.io/\n    \"\"\"\n", "google/auth/external_account_authorized_user.py": "# Copyright 2022 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"External Account Authorized User Credentials.\nThis module provides credentials based on OAuth 2.0 access and refresh tokens.\nThese credentials usually access resources on behalf of a user (resource\nowner).\n\nSpecifically, these are sourced using external identities via Workforce Identity Federation.\n\nObtaining the initial access and refresh token can be done through the Google Cloud CLI.\n\nExample credential:\n{\n  \"type\": \"external_account_authorized_user\",\n  \"audience\": \"//iam.googleapis.com/locations/global/workforcePools/$WORKFORCE_POOL_ID/providers/$PROVIDER_ID\",\n  \"refresh_token\": \"refreshToken\",\n  \"token_url\": \"https://sts.googleapis.com/v1/oauth/token\",\n  \"token_info_url\": \"https://sts.googleapis.com/v1/instrospect\",\n  \"client_id\": \"clientId\",\n  \"client_secret\": \"clientSecret\"\n}\n\"\"\"\n\nimport datetime\nimport io\nimport json\n\nfrom google.auth import _helpers\nfrom google.auth import credentials\nfrom google.auth import exceptions\nfrom google.oauth2 import sts\nfrom google.oauth2 import utils\n\n_EXTERNAL_ACCOUNT_AUTHORIZED_USER_JSON_TYPE = \"external_account_authorized_user\"\n\n\nclass Credentials(\n    credentials.CredentialsWithQuotaProject,\n    credentials.ReadOnlyScoped,\n    credentials.CredentialsWithTokenUri,\n):\n    \"\"\"Credentials for External Account Authorized Users.\n\n    This is used to instantiate Credentials for exchanging refresh tokens from\n    authorized users for Google access token and authorizing requests to Google\n    APIs.\n\n    The credentials are considered immutable. If you want to modify the\n    quota project, use `with_quota_project` and if you want to modify the token\n    uri, use `with_token_uri`.\n    \"\"\"\n\n    def __init__(\n        self,\n        token=None,\n        expiry=None,\n        refresh_token=None,\n        audience=None,\n        client_id=None,\n        client_secret=None,\n        token_url=None,\n        token_info_url=None,\n        revoke_url=None,\n        scopes=None,\n        quota_project_id=None,\n        universe_domain=credentials.DEFAULT_UNIVERSE_DOMAIN,\n    ):\n        \"\"\"Instantiates a external account authorized user credentials object.\n\n        Args:\n        token (str): The OAuth 2.0 access token. Can be None if refresh information\n            is provided.\n        expiry (datetime.datetime): The optional expiration datetime of the OAuth 2.0 access\n            token.\n        refresh_token (str): The optional OAuth 2.0 refresh token. If specified,\n            credentials can be refreshed.\n        audience (str): The optional STS audience which contains the resource name for the workforce\n            pool and the provider identifier in that pool.\n        client_id (str): The OAuth 2.0 client ID. Must be specified for refresh, can be left as\n            None if the token can not be refreshed.\n        client_secret (str): The OAuth 2.0 client secret. Must be specified for refresh, can be\n            left as None if the token can not be refreshed.\n        token_url (str): The optional STS token exchange endpoint for refresh. Must be specified for\n            refresh, can be left as None if the token can not be refreshed.\n        token_info_url (str): The optional STS endpoint URL for token introspection.\n        revoke_url (str): The optional STS endpoint URL for revoking tokens.\n        quota_project_id (str): The optional project ID used for quota and billing.\n            This project may be different from the project used to\n            create the credentials.\n        universe_domain (Optional[str]): The universe domain. The default value\n            is googleapis.com.\n\n        Returns:\n            google.auth.external_account_authorized_user.Credentials: The\n                constructed credentials.\n        \"\"\"\n        super(Credentials, self).__init__()\n\n        self.token = token\n        self.expiry = expiry\n        self._audience = audience\n        self._refresh_token = refresh_token\n        self._token_url = token_url\n        self._token_info_url = token_info_url\n        self._client_id = client_id\n        self._client_secret = client_secret\n        self._revoke_url = revoke_url\n        self._quota_project_id = quota_project_id\n        self._scopes = scopes\n        self._universe_domain = universe_domain or credentials.DEFAULT_UNIVERSE_DOMAIN\n\n        if not self.valid and not self.can_refresh:\n            raise exceptions.InvalidOperation(\n                \"Token should be created with fields to make it valid (`token` and \"\n                \"`expiry`), or fields to allow it to refresh (`refresh_token`, \"\n                \"`token_url`, `client_id`, `client_secret`).\"\n            )\n\n        self._client_auth = None\n        if self._client_id:\n            self._client_auth = utils.ClientAuthentication(\n                utils.ClientAuthType.basic, self._client_id, self._client_secret\n            )\n        self._sts_client = sts.Client(self._token_url, self._client_auth)\n\n    @property\n    def info(self):\n        \"\"\"Generates the serializable dictionary representation of the current\n        credentials.\n\n        Returns:\n            Mapping: The dictionary representation of the credentials. This is the\n                reverse of the \"from_info\" method defined in this class. It is\n                useful for serializing the current credentials so it can deserialized\n                later.\n        \"\"\"\n        config_info = self.constructor_args()\n        config_info.update(type=_EXTERNAL_ACCOUNT_AUTHORIZED_USER_JSON_TYPE)\n        if config_info[\"expiry\"]:\n            config_info[\"expiry\"] = config_info[\"expiry\"].isoformat() + \"Z\"\n\n        return {key: value for key, value in config_info.items() if value is not None}\n\n    def constructor_args(self):\n        return {\n            \"audience\": self._audience,\n            \"refresh_token\": self._refresh_token,\n            \"token_url\": self._token_url,\n            \"token_info_url\": self._token_info_url,\n            \"client_id\": self._client_id,\n            \"client_secret\": self._client_secret,\n            \"token\": self.token,\n            \"expiry\": self.expiry,\n            \"revoke_url\": self._revoke_url,\n            \"scopes\": self._scopes,\n            \"quota_project_id\": self._quota_project_id,\n            \"universe_domain\": self._universe_domain,\n        }\n\n    @property\n    def scopes(self):\n        \"\"\"Optional[str]: The OAuth 2.0 permission scopes.\"\"\"\n        return self._scopes\n\n    @property\n    def requires_scopes(self):\n        \"\"\" False: OAuth 2.0 credentials have their scopes set when\n        the initial token is requested and can not be changed.\"\"\"\n        return False\n\n    @property\n    def client_id(self):\n        \"\"\"Optional[str]: The OAuth 2.0 client ID.\"\"\"\n        return self._client_id\n\n    @property\n    def client_secret(self):\n        \"\"\"Optional[str]: The OAuth 2.0 client secret.\"\"\"\n        return self._client_secret\n\n    @property\n    def audience(self):\n        \"\"\"Optional[str]: The STS audience which contains the resource name for the\n            workforce pool and the provider identifier in that pool.\"\"\"\n        return self._audience\n\n    @property\n    def refresh_token(self):\n        \"\"\"Optional[str]: The OAuth 2.0 refresh token.\"\"\"\n        return self._refresh_token\n\n    @property\n    def token_url(self):\n        \"\"\"Optional[str]: The STS token exchange endpoint for refresh.\"\"\"\n        return self._token_url\n\n    @property\n    def token_info_url(self):\n        \"\"\"Optional[str]: The STS endpoint for token info.\"\"\"\n        return self._token_info_url\n\n    @property\n    def revoke_url(self):\n        \"\"\"Optional[str]: The STS endpoint for token revocation.\"\"\"\n        return self._revoke_url\n\n    @property\n    def is_user(self):\n        \"\"\" True: This credential always represents a user.\"\"\"\n        return True\n\n    @property\n    def can_refresh(self):\n        return all(\n            (self._refresh_token, self._token_url, self._client_id, self._client_secret)\n        )\n\n    def get_project_id(self, request=None):\n        \"\"\"Retrieves the project ID corresponding to the workload identity or workforce pool.\n        For workforce pool credentials, it returns the project ID corresponding to\n        the workforce_pool_user_project.\n\n        When not determinable, None is returned.\n\n        Args:\n            request (google.auth.transport.requests.Request): Request object.\n                Unused here, but passed from _default.default().\n\n        Return:\n          str: project ID is not determinable for this credential type so it returns None\n        \"\"\"\n\n        return None\n\n    def to_json(self, strip=None):\n        \"\"\"Utility function that creates a JSON representation of this\n        credential.\n        Args:\n            strip (Sequence[str]): Optional list of members to exclude from the\n                                   generated JSON.\n        Returns:\n            str: A JSON representation of this instance. When converted into\n            a dictionary, it can be passed to from_info()\n            to create a new instance.\n        \"\"\"\n        strip = strip if strip else []\n        return json.dumps({k: v for (k, v) in self.info.items() if k not in strip})\n\n    def refresh(self, request):\n        \"\"\"Refreshes the access token.\n\n        Args:\n            request (google.auth.transport.Request): The object used to make\n                HTTP requests.\n\n        Raises:\n            google.auth.exceptions.RefreshError: If the credentials could\n                not be refreshed.\n        \"\"\"\n        if not self.can_refresh:\n            raise exceptions.RefreshError(\n                \"The credentials do not contain the necessary fields need to \"\n                \"refresh the access token. You must specify refresh_token, \"\n                \"token_url, client_id, and client_secret.\"\n            )\n\n        now = _helpers.utcnow()\n        response_data = self._make_sts_request(request)\n\n        self.token = response_data.get(\"access_token\")\n\n        lifetime = datetime.timedelta(seconds=response_data.get(\"expires_in\"))\n        self.expiry = now + lifetime\n\n        if \"refresh_token\" in response_data:\n            self._refresh_token = response_data[\"refresh_token\"]\n\n    def _make_sts_request(self, request):\n        return self._sts_client.refresh_token(request, self._refresh_token)\n\n    @_helpers.copy_docstring(credentials.CredentialsWithQuotaProject)\n    def with_quota_project(self, quota_project_id):\n        kwargs = self.constructor_args()\n        kwargs.update(quota_project_id=quota_project_id)\n        return self.__class__(**kwargs)\n\n    @_helpers.copy_docstring(credentials.CredentialsWithTokenUri)\n    def with_token_uri(self, token_uri):\n        kwargs = self.constructor_args()\n        kwargs.update(token_url=token_uri)\n        return self.__class__(**kwargs)\n\n    @_helpers.copy_docstring(credentials.CredentialsWithUniverseDomain)\n    def with_universe_domain(self, universe_domain):\n        kwargs = self.constructor_args()\n        kwargs.update(universe_domain=universe_domain)\n        return self.__class__(**kwargs)\n\n    @classmethod\n    def from_info(cls, info, **kwargs):\n        \"\"\"Creates a Credentials instance from parsed external account info.\n\n        Args:\n            info (Mapping[str, str]): The external account info in Google\n                format.\n            kwargs: Additional arguments to pass to the constructor.\n\n        Returns:\n            google.auth.external_account_authorized_user.Credentials: The\n                constructed credentials.\n\n        Raises:\n            ValueError: For invalid parameters.\n        \"\"\"\n        expiry = info.get(\"expiry\")\n        if expiry:\n            expiry = datetime.datetime.strptime(\n                expiry.rstrip(\"Z\").split(\".\")[0], \"%Y-%m-%dT%H:%M:%S\"\n            )\n        return cls(\n            audience=info.get(\"audience\"),\n            refresh_token=info.get(\"refresh_token\"),\n            token_url=info.get(\"token_url\"),\n            token_info_url=info.get(\"token_info_url\"),\n            client_id=info.get(\"client_id\"),\n            client_secret=info.get(\"client_secret\"),\n            token=info.get(\"token\"),\n            expiry=expiry,\n            revoke_url=info.get(\"revoke_url\"),\n            quota_project_id=info.get(\"quota_project_id\"),\n            scopes=info.get(\"scopes\"),\n            universe_domain=info.get(\n                \"universe_domain\", credentials.DEFAULT_UNIVERSE_DOMAIN\n            ),\n            **kwargs\n        )\n\n    @classmethod\n    def from_file(cls, filename, **kwargs):\n        \"\"\"Creates a Credentials instance from an external account json file.\n\n        Args:\n            filename (str): The path to the external account json file.\n            kwargs: Additional arguments to pass to the constructor.\n\n        Returns:\n            google.auth.external_account_authorized_user.Credentials: The\n                constructed credentials.\n        \"\"\"\n        with io.open(filename, \"r\", encoding=\"utf-8\") as json_file:\n            data = json.load(json_file)\n            return cls.from_info(data, **kwargs)\n", "google/auth/version.py": "# Copyright 2021 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n__version__ = \"2.30.0\"\n", "google/auth/_default.py": "# Copyright 2015 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Application default credentials.\n\nImplements application default credentials and project ID detection.\n\"\"\"\n\nimport io\nimport json\nimport logging\nimport os\nimport warnings\n\nfrom google.auth import environment_vars\nfrom google.auth import exceptions\nimport google.auth.transport._http_client\n\n_LOGGER = logging.getLogger(__name__)\n\n# Valid types accepted for file-based credentials.\n_AUTHORIZED_USER_TYPE = \"authorized_user\"\n_SERVICE_ACCOUNT_TYPE = \"service_account\"\n_EXTERNAL_ACCOUNT_TYPE = \"external_account\"\n_EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE = \"external_account_authorized_user\"\n_IMPERSONATED_SERVICE_ACCOUNT_TYPE = \"impersonated_service_account\"\n_GDCH_SERVICE_ACCOUNT_TYPE = \"gdch_service_account\"\n_VALID_TYPES = (\n    _AUTHORIZED_USER_TYPE,\n    _SERVICE_ACCOUNT_TYPE,\n    _EXTERNAL_ACCOUNT_TYPE,\n    _EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE,\n    _IMPERSONATED_SERVICE_ACCOUNT_TYPE,\n    _GDCH_SERVICE_ACCOUNT_TYPE,\n)\n\n# Help message when no credentials can be found.\n_CLOUD_SDK_MISSING_CREDENTIALS = \"\"\"\\\nYour default credentials were not found. To set up Application Default Credentials, \\\nsee https://cloud.google.com/docs/authentication/external/set-up-adc for more information.\\\n\"\"\"\n\n# Warning when using Cloud SDK user credentials\n_CLOUD_SDK_CREDENTIALS_WARNING = \"\"\"\\\nYour application has authenticated using end user credentials from Google \\\nCloud SDK without a quota project. You might receive a \"quota exceeded\" \\\nor \"API not enabled\" error. See the following page for troubleshooting: \\\nhttps://cloud.google.com/docs/authentication/adc-troubleshooting/user-creds. \\\n\"\"\"\n\n# The subject token type used for AWS external_account credentials.\n_AWS_SUBJECT_TOKEN_TYPE = \"urn:ietf:params:aws:token-type:aws4_request\"\n\n\ndef _warn_about_problematic_credentials(credentials):\n    \"\"\"Determines if the credentials are problematic.\n\n    Credentials from the Cloud SDK that are associated with Cloud SDK's project\n    are problematic because they may not have APIs enabled and have limited\n    quota. If this is the case, warn about it.\n    \"\"\"\n    from google.auth import _cloud_sdk\n\n    if credentials.client_id == _cloud_sdk.CLOUD_SDK_CLIENT_ID:\n        warnings.warn(_CLOUD_SDK_CREDENTIALS_WARNING)\n\n\ndef load_credentials_from_file(\n    filename, scopes=None, default_scopes=None, quota_project_id=None, request=None\n):\n    \"\"\"Loads Google credentials from a file.\n\n    The credentials file must be a service account key, stored authorized\n    user credentials, external account credentials, or impersonated service\n    account credentials.\n\n    Args:\n        filename (str): The full path to the credentials file.\n        scopes (Optional[Sequence[str]]): The list of scopes for the credentials. If\n            specified, the credentials will automatically be scoped if\n            necessary\n        default_scopes (Optional[Sequence[str]]): Default scopes passed by a\n            Google client library. Use 'scopes' for user-defined scopes.\n        quota_project_id (Optional[str]):  The project ID used for\n            quota and billing.\n        request (Optional[google.auth.transport.Request]): An object used to make\n            HTTP requests. This is used to determine the associated project ID\n            for a workload identity pool resource (external account credentials).\n            If not specified, then it will use a\n            google.auth.transport.requests.Request client to make requests.\n\n    Returns:\n        Tuple[google.auth.credentials.Credentials, Optional[str]]: Loaded\n            credentials and the project ID. Authorized user credentials do not\n            have the project ID information. External account credentials project\n            IDs may not always be determined.\n\n    Raises:\n        google.auth.exceptions.DefaultCredentialsError: if the file is in the\n            wrong format or is missing.\n    \"\"\"\n    if not os.path.exists(filename):\n        raise exceptions.DefaultCredentialsError(\n            \"File {} was not found.\".format(filename)\n        )\n\n    with io.open(filename, \"r\") as file_obj:\n        try:\n            info = json.load(file_obj)\n        except ValueError as caught_exc:\n            new_exc = exceptions.DefaultCredentialsError(\n                \"File {} is not a valid json file.\".format(filename), caught_exc\n            )\n            raise new_exc from caught_exc\n    return _load_credentials_from_info(\n        filename, info, scopes, default_scopes, quota_project_id, request\n    )\n\n\ndef load_credentials_from_dict(\n    info, scopes=None, default_scopes=None, quota_project_id=None, request=None\n):\n    \"\"\"Loads Google credentials from a dict.\n\n    The credentials file must be a service account key, stored authorized\n    user credentials, external account credentials, or impersonated service\n    account credentials.\n\n    Args:\n        info (Dict[str, Any]): A dict object containing the credentials\n        scopes (Optional[Sequence[str]]): The list of scopes for the credentials. If\n            specified, the credentials will automatically be scoped if\n            necessary\n        default_scopes (Optional[Sequence[str]]): Default scopes passed by a\n            Google client library. Use 'scopes' for user-defined scopes.\n        quota_project_id (Optional[str]):  The project ID used for\n            quota and billing.\n        request (Optional[google.auth.transport.Request]): An object used to make\n            HTTP requests. This is used to determine the associated project ID\n            for a workload identity pool resource (external account credentials).\n            If not specified, then it will use a\n            google.auth.transport.requests.Request client to make requests.\n\n    Returns:\n        Tuple[google.auth.credentials.Credentials, Optional[str]]: Loaded\n            credentials and the project ID. Authorized user credentials do not\n            have the project ID information. External account credentials project\n            IDs may not always be determined.\n\n    Raises:\n        google.auth.exceptions.DefaultCredentialsError: if the file is in the\n            wrong format or is missing.\n    \"\"\"\n    if not isinstance(info, dict):\n        raise exceptions.DefaultCredentialsError(\n            \"info object was of type {} but dict type was expected.\".format(type(info))\n        )\n\n    return _load_credentials_from_info(\n        \"dict object\", info, scopes, default_scopes, quota_project_id, request\n    )\n\n\ndef _load_credentials_from_info(\n    filename, info, scopes, default_scopes, quota_project_id, request\n):\n    from google.auth.credentials import CredentialsWithQuotaProject\n\n    credential_type = info.get(\"type\")\n\n    if credential_type == _AUTHORIZED_USER_TYPE:\n        credentials, project_id = _get_authorized_user_credentials(\n            filename, info, scopes\n        )\n\n    elif credential_type == _SERVICE_ACCOUNT_TYPE:\n        credentials, project_id = _get_service_account_credentials(\n            filename, info, scopes, default_scopes\n        )\n\n    elif credential_type == _EXTERNAL_ACCOUNT_TYPE:\n        credentials, project_id = _get_external_account_credentials(\n            info,\n            filename,\n            scopes=scopes,\n            default_scopes=default_scopes,\n            request=request,\n        )\n\n    elif credential_type == _EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE:\n        credentials, project_id = _get_external_account_authorized_user_credentials(\n            filename, info, request\n        )\n\n    elif credential_type == _IMPERSONATED_SERVICE_ACCOUNT_TYPE:\n        credentials, project_id = _get_impersonated_service_account_credentials(\n            filename, info, scopes\n        )\n    elif credential_type == _GDCH_SERVICE_ACCOUNT_TYPE:\n        credentials, project_id = _get_gdch_service_account_credentials(filename, info)\n    else:\n        raise exceptions.DefaultCredentialsError(\n            \"The file {file} does not have a valid type. \"\n            \"Type is {type}, expected one of {valid_types}.\".format(\n                file=filename, type=credential_type, valid_types=_VALID_TYPES\n            )\n        )\n    if isinstance(credentials, CredentialsWithQuotaProject):\n        credentials = _apply_quota_project_id(credentials, quota_project_id)\n    return credentials, project_id\n\n\ndef _get_gcloud_sdk_credentials(quota_project_id=None):\n    \"\"\"Gets the credentials and project ID from the Cloud SDK.\"\"\"\n    from google.auth import _cloud_sdk\n\n    _LOGGER.debug(\"Checking Cloud SDK credentials as part of auth process...\")\n\n    # Check if application default credentials exist.\n    credentials_filename = _cloud_sdk.get_application_default_credentials_path()\n\n    if not os.path.isfile(credentials_filename):\n        _LOGGER.debug(\"Cloud SDK credentials not found on disk; not using them\")\n        return None, None\n\n    credentials, project_id = load_credentials_from_file(\n        credentials_filename, quota_project_id=quota_project_id\n    )\n\n    if not project_id:\n        project_id = _cloud_sdk.get_project_id()\n\n    return credentials, project_id\n\n\ndef _get_explicit_environ_credentials(quota_project_id=None):\n    \"\"\"Gets credentials from the GOOGLE_APPLICATION_CREDENTIALS environment\n    variable.\"\"\"\n    from google.auth import _cloud_sdk\n\n    cloud_sdk_adc_path = _cloud_sdk.get_application_default_credentials_path()\n    explicit_file = os.environ.get(environment_vars.CREDENTIALS)\n\n    _LOGGER.debug(\n        \"Checking %s for explicit credentials as part of auth process...\", explicit_file\n    )\n\n    if explicit_file is not None and explicit_file == cloud_sdk_adc_path:\n        # Cloud sdk flow calls gcloud to fetch project id, so if the explicit\n        # file path is cloud sdk credentials path, then we should fall back\n        # to cloud sdk flow, otherwise project id cannot be obtained.\n        _LOGGER.debug(\n            \"Explicit credentials path %s is the same as Cloud SDK credentials path, fall back to Cloud SDK credentials flow...\",\n            explicit_file,\n        )\n        return _get_gcloud_sdk_credentials(quota_project_id=quota_project_id)\n\n    if explicit_file is not None:\n        credentials, project_id = load_credentials_from_file(\n            os.environ[environment_vars.CREDENTIALS], quota_project_id=quota_project_id\n        )\n\n        return credentials, project_id\n\n    else:\n        return None, None\n\n\ndef _get_gae_credentials():\n    \"\"\"Gets Google App Engine App Identity credentials and project ID.\"\"\"\n    # If not GAE gen1, prefer the metadata service even if the GAE APIs are\n    # available as per https://google.aip.dev/auth/4115.\n    if os.environ.get(environment_vars.LEGACY_APPENGINE_RUNTIME) != \"python27\":\n        return None, None\n\n    # While this library is normally bundled with app_engine, there are\n    # some cases where it's not available, so we tolerate ImportError.\n    try:\n        _LOGGER.debug(\"Checking for App Engine runtime as part of auth process...\")\n        import google.auth.app_engine as app_engine\n    except ImportError:\n        _LOGGER.warning(\"Import of App Engine auth library failed.\")\n        return None, None\n\n    try:\n        credentials = app_engine.Credentials()\n        project_id = app_engine.get_project_id()\n        return credentials, project_id\n    except EnvironmentError:\n        _LOGGER.debug(\n            \"No App Engine library was found so cannot authentication via App Engine Identity Credentials.\"\n        )\n        return None, None\n\n\ndef _get_gce_credentials(request=None, quota_project_id=None):\n    \"\"\"Gets credentials and project ID from the GCE Metadata Service.\"\"\"\n    # Ping requires a transport, but we want application default credentials\n    # to require no arguments. So, we'll use the _http_client transport which\n    # uses http.client. This is only acceptable because the metadata server\n    # doesn't do SSL and never requires proxies.\n\n    # While this library is normally bundled with compute_engine, there are\n    # some cases where it's not available, so we tolerate ImportError.\n    try:\n        from google.auth import compute_engine\n        from google.auth.compute_engine import _metadata\n    except ImportError:\n        _LOGGER.warning(\"Import of Compute Engine auth library failed.\")\n        return None, None\n\n    if request is None:\n        request = google.auth.transport._http_client.Request()\n\n    if _metadata.is_on_gce(request=request):\n        # Get the project ID.\n        try:\n            project_id = _metadata.get_project_id(request=request)\n        except exceptions.TransportError:\n            project_id = None\n\n        cred = compute_engine.Credentials()\n        cred = _apply_quota_project_id(cred, quota_project_id)\n\n        return cred, project_id\n    else:\n        _LOGGER.warning(\n            \"Authentication failed using Compute Engine authentication due to unavailable metadata server.\"\n        )\n        return None, None\n\n\ndef _get_external_account_credentials(\n    info, filename, scopes=None, default_scopes=None, request=None\n):\n    \"\"\"Loads external account Credentials from the parsed external account info.\n\n    The credentials information must correspond to a supported external account\n    credentials.\n\n    Args:\n        info (Mapping[str, str]): The external account info in Google format.\n        filename (str): The full path to the credentials file.\n        scopes (Optional[Sequence[str]]): The list of scopes for the credentials. If\n            specified, the credentials will automatically be scoped if\n            necessary.\n        default_scopes (Optional[Sequence[str]]): Default scopes passed by a\n            Google client library. Use 'scopes' for user-defined scopes.\n        request (Optional[google.auth.transport.Request]): An object used to make\n            HTTP requests. This is used to determine the associated project ID\n            for a workload identity pool resource (external account credentials).\n            If not specified, then it will use a\n            google.auth.transport.requests.Request client to make requests.\n\n    Returns:\n        Tuple[google.auth.credentials.Credentials, Optional[str]]: Loaded\n            credentials and the project ID. External account credentials project\n            IDs may not always be determined.\n\n    Raises:\n        google.auth.exceptions.DefaultCredentialsError: if the info dictionary\n            is in the wrong format or is missing required information.\n    \"\"\"\n    # There are currently 3 types of external_account credentials.\n    if info.get(\"subject_token_type\") == _AWS_SUBJECT_TOKEN_TYPE:\n        # Check if configuration corresponds to an AWS credentials.\n        from google.auth import aws\n\n        credentials = aws.Credentials.from_info(\n            info, scopes=scopes, default_scopes=default_scopes\n        )\n    elif (\n        info.get(\"credential_source\") is not None\n        and info.get(\"credential_source\").get(\"executable\") is not None\n    ):\n        from google.auth import pluggable\n\n        credentials = pluggable.Credentials.from_info(\n            info, scopes=scopes, default_scopes=default_scopes\n        )\n    else:\n        try:\n            # Check if configuration corresponds to an Identity Pool credentials.\n            from google.auth import identity_pool\n\n            credentials = identity_pool.Credentials.from_info(\n                info, scopes=scopes, default_scopes=default_scopes\n            )\n        except ValueError:\n            # If the configuration is invalid or does not correspond to any\n            # supported external_account credentials, raise an error.\n            raise exceptions.DefaultCredentialsError(\n                \"Failed to load external account credentials from {}\".format(filename)\n            )\n    if request is None:\n        import google.auth.transport.requests\n\n        request = google.auth.transport.requests.Request()\n\n    return credentials, credentials.get_project_id(request=request)\n\n\ndef _get_external_account_authorized_user_credentials(\n    filename, info, scopes=None, default_scopes=None, request=None\n):\n    try:\n        from google.auth import external_account_authorized_user\n\n        credentials = external_account_authorized_user.Credentials.from_info(info)\n    except ValueError:\n        raise exceptions.DefaultCredentialsError(\n            \"Failed to load external account authorized user credentials from {}\".format(\n                filename\n            )\n        )\n\n    return credentials, None\n\n\ndef _get_authorized_user_credentials(filename, info, scopes=None):\n    from google.oauth2 import credentials\n\n    try:\n        credentials = credentials.Credentials.from_authorized_user_info(\n            info, scopes=scopes\n        )\n    except ValueError as caught_exc:\n        msg = \"Failed to load authorized user credentials from {}\".format(filename)\n        new_exc = exceptions.DefaultCredentialsError(msg, caught_exc)\n        raise new_exc from caught_exc\n    return credentials, None\n\n\ndef _get_service_account_credentials(filename, info, scopes=None, default_scopes=None):\n    from google.oauth2 import service_account\n\n    try:\n        credentials = service_account.Credentials.from_service_account_info(\n            info, scopes=scopes, default_scopes=default_scopes\n        )\n    except ValueError as caught_exc:\n        msg = \"Failed to load service account credentials from {}\".format(filename)\n        new_exc = exceptions.DefaultCredentialsError(msg, caught_exc)\n        raise new_exc from caught_exc\n    return credentials, info.get(\"project_id\")\n\n\ndef _get_impersonated_service_account_credentials(filename, info, scopes):\n    from google.auth import impersonated_credentials\n\n    try:\n        source_credentials_info = info.get(\"source_credentials\")\n        source_credentials_type = source_credentials_info.get(\"type\")\n        if source_credentials_type == _AUTHORIZED_USER_TYPE:\n            source_credentials, _ = _get_authorized_user_credentials(\n                filename, source_credentials_info\n            )\n        elif source_credentials_type == _SERVICE_ACCOUNT_TYPE:\n            source_credentials, _ = _get_service_account_credentials(\n                filename, source_credentials_info\n            )\n        else:\n            raise exceptions.InvalidType(\n                \"source credential of type {} is not supported.\".format(\n                    source_credentials_type\n                )\n            )\n        impersonation_url = info.get(\"service_account_impersonation_url\")\n        start_index = impersonation_url.rfind(\"/\")\n        end_index = impersonation_url.find(\":generateAccessToken\")\n        if start_index == -1 or end_index == -1 or start_index > end_index:\n            raise exceptions.InvalidValue(\n                \"Cannot extract target principal from {}\".format(impersonation_url)\n            )\n        target_principal = impersonation_url[start_index + 1 : end_index]\n        delegates = info.get(\"delegates\")\n        quota_project_id = info.get(\"quota_project_id\")\n        credentials = impersonated_credentials.Credentials(\n            source_credentials,\n            target_principal,\n            scopes,\n            delegates,\n            quota_project_id=quota_project_id,\n        )\n    except ValueError as caught_exc:\n        msg = \"Failed to load impersonated service account credentials from {}\".format(\n            filename\n        )\n        new_exc = exceptions.DefaultCredentialsError(msg, caught_exc)\n        raise new_exc from caught_exc\n    return credentials, None\n\n\ndef _get_gdch_service_account_credentials(filename, info):\n    from google.oauth2 import gdch_credentials\n\n    try:\n        credentials = gdch_credentials.ServiceAccountCredentials.from_service_account_info(\n            info\n        )\n    except ValueError as caught_exc:\n        msg = \"Failed to load GDCH service account credentials from {}\".format(filename)\n        new_exc = exceptions.DefaultCredentialsError(msg, caught_exc)\n        raise new_exc from caught_exc\n    return credentials, info.get(\"project\")\n\n\ndef get_api_key_credentials(key):\n    \"\"\"Return credentials with the given API key.\"\"\"\n    from google.auth import api_key\n\n    return api_key.Credentials(key)\n\n\ndef _apply_quota_project_id(credentials, quota_project_id):\n    if quota_project_id:\n        credentials = credentials.with_quota_project(quota_project_id)\n    else:\n        credentials = credentials.with_quota_project_from_environment()\n\n    from google.oauth2 import credentials as authorized_user_credentials\n\n    if isinstance(credentials, authorized_user_credentials.Credentials) and (\n        not credentials.quota_project_id\n    ):\n        _warn_about_problematic_credentials(credentials)\n    return credentials\n\n\ndef default(scopes=None, request=None, quota_project_id=None, default_scopes=None):\n    \"\"\"Gets the default credentials for the current environment.\n\n    `Application Default Credentials`_ provides an easy way to obtain\n    credentials to call Google APIs for server-to-server or local applications.\n    This function acquires credentials from the environment in the following\n    order:\n\n    1. If the environment variable ``GOOGLE_APPLICATION_CREDENTIALS`` is set\n       to the path of a valid service account JSON private key file, then it is\n       loaded and returned. The project ID returned is the project ID defined\n       in the service account file if available (some older files do not\n       contain project ID information).\n\n       If the environment variable is set to the path of a valid external\n       account JSON configuration file (workload identity federation), then the\n       configuration file is used to determine and retrieve the external\n       credentials from the current environment (AWS, Azure, etc).\n       These will then be exchanged for Google access tokens via the Google STS\n       endpoint.\n       The project ID returned in this case is the one corresponding to the\n       underlying workload identity pool resource if determinable.\n\n       If the environment variable is set to the path of a valid GDCH service\n       account JSON file (`Google Distributed Cloud Hosted`_), then a GDCH\n       credential will be returned. The project ID returned is the project\n       specified in the JSON file.\n    2. If the `Google Cloud SDK`_ is installed and has application default\n       credentials set they are loaded and returned.\n\n       To enable application default credentials with the Cloud SDK run::\n\n            gcloud auth application-default login\n\n       If the Cloud SDK has an active project, the project ID is returned. The\n       active project can be set using::\n\n            gcloud config set project\n\n    3. If the application is running in the `App Engine standard environment`_\n       (first generation) then the credentials and project ID from the\n       `App Identity Service`_ are used.\n    4. If the application is running in `Compute Engine`_ or `Cloud Run`_ or\n       the `App Engine flexible environment`_ or the `App Engine standard\n       environment`_ (second generation) then the credentials and project ID\n       are obtained from the `Metadata Service`_.\n    5. If no credentials are found,\n       :class:`~google.auth.exceptions.DefaultCredentialsError` will be raised.\n\n    .. _Application Default Credentials: https://developers.google.com\\\n            /identity/protocols/application-default-credentials\n    .. _Google Cloud SDK: https://cloud.google.com/sdk\n    .. _App Engine standard environment: https://cloud.google.com/appengine\n    .. _App Identity Service: https://cloud.google.com/appengine/docs/python\\\n            /appidentity/\n    .. _Compute Engine: https://cloud.google.com/compute\n    .. _App Engine flexible environment: https://cloud.google.com\\\n            /appengine/flexible\n    .. _Metadata Service: https://cloud.google.com/compute/docs\\\n            /storing-retrieving-metadata\n    .. _Cloud Run: https://cloud.google.com/run\n    .. _Google Distributed Cloud Hosted: https://cloud.google.com/blog/topics\\\n            /hybrid-cloud/announcing-google-distributed-cloud-edge-and-hosted\n\n    Example::\n\n        import google.auth\n\n        credentials, project_id = google.auth.default()\n\n    Args:\n        scopes (Sequence[str]): The list of scopes for the credentials. If\n            specified, the credentials will automatically be scoped if\n            necessary.\n        request (Optional[google.auth.transport.Request]): An object used to make\n            HTTP requests. This is used to either detect whether the application\n            is running on Compute Engine or to determine the associated project\n            ID for a workload identity pool resource (external account\n            credentials). If not specified, then it will either use the standard\n            library http client to make requests for Compute Engine credentials\n            or a google.auth.transport.requests.Request client for external\n            account credentials.\n        quota_project_id (Optional[str]): The project ID used for\n            quota and billing.\n        default_scopes (Optional[Sequence[str]]): Default scopes passed by a\n            Google client library. Use 'scopes' for user-defined scopes.\n    Returns:\n        Tuple[~google.auth.credentials.Credentials, Optional[str]]:\n            the current environment's credentials and project ID. Project ID\n            may be None, which indicates that the Project ID could not be\n            ascertained from the environment.\n\n    Raises:\n        ~google.auth.exceptions.DefaultCredentialsError:\n            If no credentials were found, or if the credentials found were\n            invalid.\n    \"\"\"\n    from google.auth.credentials import with_scopes_if_required\n    from google.auth.credentials import CredentialsWithQuotaProject\n\n    explicit_project_id = os.environ.get(\n        environment_vars.PROJECT, os.environ.get(environment_vars.LEGACY_PROJECT)\n    )\n\n    checkers = (\n        # Avoid passing scopes here to prevent passing scopes to user credentials.\n        # with_scopes_if_required() below will ensure scopes/default scopes are\n        # safely set on the returned credentials since requires_scopes will\n        # guard against setting scopes on user credentials.\n        lambda: _get_explicit_environ_credentials(quota_project_id=quota_project_id),\n        lambda: _get_gcloud_sdk_credentials(quota_project_id=quota_project_id),\n        _get_gae_credentials,\n        lambda: _get_gce_credentials(request, quota_project_id=quota_project_id),\n    )\n\n    for checker in checkers:\n        credentials, project_id = checker()\n        if credentials is not None:\n            credentials = with_scopes_if_required(\n                credentials, scopes, default_scopes=default_scopes\n            )\n\n            effective_project_id = explicit_project_id or project_id\n\n            # For external account credentials, scopes are required to determine\n            # the project ID. Try to get the project ID again if not yet\n            # determined.\n            if not effective_project_id and callable(\n                getattr(credentials, \"get_project_id\", None)\n            ):\n                if request is None:\n                    import google.auth.transport.requests\n\n                    request = google.auth.transport.requests.Request()\n                effective_project_id = credentials.get_project_id(request=request)\n\n            if quota_project_id and isinstance(\n                credentials, CredentialsWithQuotaProject\n            ):\n                credentials = credentials.with_quota_project(quota_project_id)\n\n            if not effective_project_id:\n                _LOGGER.warning(\n                    \"No project ID could be determined. Consider running \"\n                    \"`gcloud config set project` or setting the %s \"\n                    \"environment variable\",\n                    environment_vars.PROJECT,\n                )\n            return credentials, effective_project_id\n\n    raise exceptions.DefaultCredentialsError(_CLOUD_SDK_MISSING_CREDENTIALS)\n", "google/auth/impersonated_credentials.py": "# Copyright 2018 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Google Cloud Impersonated credentials.\n\nThis module provides authentication for applications where local credentials\nimpersonates a remote service account using `IAM Credentials API`_.\n\nThis class can be used to impersonate a service account as long as the original\nCredential object has the \"Service Account Token Creator\" role on the target\nservice account.\n\n    .. _IAM Credentials API:\n        https://cloud.google.com/iam/credentials/reference/rest/\n\"\"\"\n\nimport base64\nimport copy\nfrom datetime import datetime\nimport http.client as http_client\nimport json\n\nfrom google.auth import _helpers\nfrom google.auth import credentials\nfrom google.auth import exceptions\nfrom google.auth import iam\nfrom google.auth import jwt\nfrom google.auth import metrics\n\n\n_REFRESH_ERROR = \"Unable to acquire impersonated credentials\"\n\n_DEFAULT_TOKEN_LIFETIME_SECS = 3600  # 1 hour in seconds\n\n\ndef _make_iam_token_request(\n    request, principal, headers, body, iam_endpoint_override=None\n):\n    \"\"\"Makes a request to the Google Cloud IAM service for an access token.\n    Args:\n        request (Request): The Request object to use.\n        principal (str): The principal to request an access token for.\n        headers (Mapping[str, str]): Map of headers to transmit.\n        body (Mapping[str, str]): JSON Payload body for the iamcredentials\n            API call.\n        iam_endpoint_override (Optiona[str]): The full IAM endpoint override\n            with the target_principal embedded. This is useful when supporting\n            impersonation with regional endpoints.\n\n    Raises:\n        google.auth.exceptions.TransportError: Raised if there is an underlying\n            HTTP connection error\n        google.auth.exceptions.RefreshError: Raised if the impersonated\n            credentials are not available.  Common reasons are\n            `iamcredentials.googleapis.com` is not enabled or the\n            `Service Account Token Creator` is not assigned\n    \"\"\"\n    iam_endpoint = iam_endpoint_override or iam._IAM_ENDPOINT.format(principal)\n\n    body = json.dumps(body).encode(\"utf-8\")\n\n    response = request(url=iam_endpoint, method=\"POST\", headers=headers, body=body)\n\n    # support both string and bytes type response.data\n    response_body = (\n        response.data.decode(\"utf-8\")\n        if hasattr(response.data, \"decode\")\n        else response.data\n    )\n\n    if response.status != http_client.OK:\n        raise exceptions.RefreshError(_REFRESH_ERROR, response_body)\n\n    try:\n        token_response = json.loads(response_body)\n        token = token_response[\"accessToken\"]\n        expiry = datetime.strptime(token_response[\"expireTime\"], \"%Y-%m-%dT%H:%M:%SZ\")\n\n        return token, expiry\n\n    except (KeyError, ValueError) as caught_exc:\n        new_exc = exceptions.RefreshError(\n            \"{}: No access token or invalid expiration in response.\".format(\n                _REFRESH_ERROR\n            ),\n            response_body,\n        )\n        raise new_exc from caught_exc\n\n\nclass Credentials(\n    credentials.Scoped, credentials.CredentialsWithQuotaProject, credentials.Signing\n):\n    \"\"\"This module defines impersonated credentials which are essentially\n    impersonated identities.\n\n    Impersonated Credentials allows credentials issued to a user or\n    service account to impersonate another. The target service account must\n    grant the originating credential principal the\n    `Service Account Token Creator`_ IAM role:\n\n    For more information about Token Creator IAM role and\n    IAMCredentials API, see\n    `Creating Short-Lived Service Account Credentials`_.\n\n    .. _Service Account Token Creator:\n        https://cloud.google.com/iam/docs/service-accounts#the_service_account_token_creator_role\n\n    .. _Creating Short-Lived Service Account Credentials:\n        https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials\n\n    Usage:\n\n    First grant source_credentials the `Service Account Token Creator`\n    role on the target account to impersonate.   In this example, the\n    service account represented by svc_account.json has the\n    token creator role on\n    `impersonated-account@_project_.iam.gserviceaccount.com`.\n\n    Enable the IAMCredentials API on the source project:\n    `gcloud services enable iamcredentials.googleapis.com`.\n\n    Initialize a source credential which does not have access to\n    list bucket::\n\n        from google.oauth2 import service_account\n\n        target_scopes = [\n            'https://www.googleapis.com/auth/devstorage.read_only']\n\n        source_credentials = (\n            service_account.Credentials.from_service_account_file(\n                '/path/to/svc_account.json',\n                scopes=target_scopes))\n\n    Now use the source credentials to acquire credentials to impersonate\n    another service account::\n\n        from google.auth import impersonated_credentials\n\n        target_credentials = impersonated_credentials.Credentials(\n          source_credentials=source_credentials,\n          target_principal='impersonated-account@_project_.iam.gserviceaccount.com',\n          target_scopes = target_scopes,\n          lifetime=500)\n\n    Resource access is granted::\n\n        client = storage.Client(credentials=target_credentials)\n        buckets = client.list_buckets(project='your_project')\n        for bucket in buckets:\n          print(bucket.name)\n    \"\"\"\n\n    def __init__(\n        self,\n        source_credentials,\n        target_principal,\n        target_scopes,\n        delegates=None,\n        lifetime=_DEFAULT_TOKEN_LIFETIME_SECS,\n        quota_project_id=None,\n        iam_endpoint_override=None,\n    ):\n        \"\"\"\n        Args:\n            source_credentials (google.auth.Credentials): The source credential\n                used as to acquire the impersonated credentials.\n            target_principal (str): The service account to impersonate.\n            target_scopes (Sequence[str]): Scopes to request during the\n                authorization grant.\n            delegates (Sequence[str]): The chained list of delegates required\n                to grant the final access_token.  If set, the sequence of\n                identities must have \"Service Account Token Creator\" capability\n                granted to the prceeding identity.  For example, if set to\n                [serviceAccountB, serviceAccountC], the source_credential\n                must have the Token Creator role on serviceAccountB.\n                serviceAccountB must have the Token Creator on\n                serviceAccountC.\n                Finally, C must have Token Creator on target_principal.\n                If left unset, source_credential must have that role on\n                target_principal.\n            lifetime (int): Number of seconds the delegated credential should\n                be valid for (upto 3600).\n            quota_project_id (Optional[str]): The project ID used for quota and billing.\n                This project may be different from the project used to\n                create the credentials.\n            iam_endpoint_override (Optiona[str]): The full IAM endpoint override\n                with the target_principal embedded. This is useful when supporting\n                impersonation with regional endpoints.\n        \"\"\"\n\n        super(Credentials, self).__init__()\n\n        self._source_credentials = copy.copy(source_credentials)\n        # Service account source credentials must have the _IAM_SCOPE\n        # added to refresh correctly. User credentials cannot have\n        # their original scopes modified.\n        if isinstance(self._source_credentials, credentials.Scoped):\n            self._source_credentials = self._source_credentials.with_scopes(\n                iam._IAM_SCOPE\n            )\n            # If the source credential is service account and self signed jwt\n            # is needed, we need to create a jwt credential inside it\n            if (\n                hasattr(self._source_credentials, \"_create_self_signed_jwt\")\n                and self._source_credentials._always_use_jwt_access\n            ):\n                self._source_credentials._create_self_signed_jwt(None)\n        self._target_principal = target_principal\n        self._target_scopes = target_scopes\n        self._delegates = delegates\n        self._lifetime = lifetime or _DEFAULT_TOKEN_LIFETIME_SECS\n        self.token = None\n        self.expiry = _helpers.utcnow()\n        self._quota_project_id = quota_project_id\n        self._iam_endpoint_override = iam_endpoint_override\n\n    def _metric_header_for_usage(self):\n        return metrics.CRED_TYPE_SA_IMPERSONATE\n\n    @_helpers.copy_docstring(credentials.Credentials)\n    def refresh(self, request):\n        self._update_token(request)\n\n    def _update_token(self, request):\n        \"\"\"Updates credentials with a new access_token representing\n        the impersonated account.\n\n        Args:\n            request (google.auth.transport.requests.Request): Request object\n                to use for refreshing credentials.\n        \"\"\"\n\n        # Refresh our source credentials if it is not valid.\n        if (\n            self._source_credentials.token_state == credentials.TokenState.STALE\n            or self._source_credentials.token_state == credentials.TokenState.INVALID\n        ):\n            self._source_credentials.refresh(request)\n\n        body = {\n            \"delegates\": self._delegates,\n            \"scope\": self._target_scopes,\n            \"lifetime\": str(self._lifetime) + \"s\",\n        }\n\n        headers = {\n            \"Content-Type\": \"application/json\",\n            metrics.API_CLIENT_HEADER: metrics.token_request_access_token_impersonate(),\n        }\n\n        # Apply the source credentials authentication info.\n        self._source_credentials.apply(headers)\n\n        self.token, self.expiry = _make_iam_token_request(\n            request=request,\n            principal=self._target_principal,\n            headers=headers,\n            body=body,\n            iam_endpoint_override=self._iam_endpoint_override,\n        )\n\n    def sign_bytes(self, message):\n        from google.auth.transport.requests import AuthorizedSession\n\n        iam_sign_endpoint = iam._IAM_SIGN_ENDPOINT.format(self._target_principal)\n\n        body = {\n            \"payload\": base64.b64encode(message).decode(\"utf-8\"),\n            \"delegates\": self._delegates,\n        }\n\n        headers = {\"Content-Type\": \"application/json\"}\n\n        authed_session = AuthorizedSession(self._source_credentials)\n\n        try:\n            response = authed_session.post(\n                url=iam_sign_endpoint, headers=headers, json=body\n            )\n        finally:\n            authed_session.close()\n\n        if response.status_code != http_client.OK:\n            raise exceptions.TransportError(\n                \"Error calling sign_bytes: {}\".format(response.json())\n            )\n\n        return base64.b64decode(response.json()[\"signedBlob\"])\n\n    @property\n    def signer_email(self):\n        return self._target_principal\n\n    @property\n    def service_account_email(self):\n        return self._target_principal\n\n    @property\n    def signer(self):\n        return self\n\n    @property\n    def requires_scopes(self):\n        return not self._target_scopes\n\n    @_helpers.copy_docstring(credentials.CredentialsWithQuotaProject)\n    def with_quota_project(self, quota_project_id):\n        return self.__class__(\n            self._source_credentials,\n            target_principal=self._target_principal,\n            target_scopes=self._target_scopes,\n            delegates=self._delegates,\n            lifetime=self._lifetime,\n            quota_project_id=quota_project_id,\n            iam_endpoint_override=self._iam_endpoint_override,\n        )\n\n    @_helpers.copy_docstring(credentials.Scoped)\n    def with_scopes(self, scopes, default_scopes=None):\n        return self.__class__(\n            self._source_credentials,\n            target_principal=self._target_principal,\n            target_scopes=scopes or default_scopes,\n            delegates=self._delegates,\n            lifetime=self._lifetime,\n            quota_project_id=self._quota_project_id,\n            iam_endpoint_override=self._iam_endpoint_override,\n        )\n\n\nclass IDTokenCredentials(credentials.CredentialsWithQuotaProject):\n    \"\"\"Open ID Connect ID Token-based service account credentials.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        target_credentials,\n        target_audience=None,\n        include_email=False,\n        quota_project_id=None,\n    ):\n        \"\"\"\n        Args:\n            target_credentials (google.auth.Credentials): The target\n                credential used as to acquire the id tokens for.\n            target_audience (string): Audience to issue the token for.\n            include_email (bool): Include email in IdToken\n            quota_project_id (Optional[str]):  The project ID used for\n                quota and billing.\n        \"\"\"\n        super(IDTokenCredentials, self).__init__()\n\n        if not isinstance(target_credentials, Credentials):\n            raise exceptions.GoogleAuthError(\n                \"Provided Credential must be \" \"impersonated_credentials\"\n            )\n        self._target_credentials = target_credentials\n        self._target_audience = target_audience\n        self._include_email = include_email\n        self._quota_project_id = quota_project_id\n\n    def from_credentials(self, target_credentials, target_audience=None):\n        return self.__class__(\n            target_credentials=target_credentials,\n            target_audience=target_audience,\n            include_email=self._include_email,\n            quota_project_id=self._quota_project_id,\n        )\n\n    def with_target_audience(self, target_audience):\n        return self.__class__(\n            target_credentials=self._target_credentials,\n            target_audience=target_audience,\n            include_email=self._include_email,\n            quota_project_id=self._quota_project_id,\n        )\n\n    def with_include_email(self, include_email):\n        return self.__class__(\n            target_credentials=self._target_credentials,\n            target_audience=self._target_audience,\n            include_email=include_email,\n            quota_project_id=self._quota_project_id,\n        )\n\n    @_helpers.copy_docstring(credentials.CredentialsWithQuotaProject)\n    def with_quota_project(self, quota_project_id):\n        return self.__class__(\n            target_credentials=self._target_credentials,\n            target_audience=self._target_audience,\n            include_email=self._include_email,\n            quota_project_id=quota_project_id,\n        )\n\n    @_helpers.copy_docstring(credentials.Credentials)\n    def refresh(self, request):\n        from google.auth.transport.requests import AuthorizedSession\n\n        iam_sign_endpoint = iam._IAM_IDTOKEN_ENDPOINT.format(\n            self._target_credentials.signer_email\n        )\n\n        body = {\n            \"audience\": self._target_audience,\n            \"delegates\": self._target_credentials._delegates,\n            \"includeEmail\": self._include_email,\n        }\n\n        headers = {\n            \"Content-Type\": \"application/json\",\n            metrics.API_CLIENT_HEADER: metrics.token_request_id_token_impersonate(),\n        }\n\n        authed_session = AuthorizedSession(\n            self._target_credentials._source_credentials, auth_request=request\n        )\n\n        try:\n            response = authed_session.post(\n                url=iam_sign_endpoint,\n                headers=headers,\n                data=json.dumps(body).encode(\"utf-8\"),\n            )\n        finally:\n            authed_session.close()\n\n        if response.status_code != http_client.OK:\n            raise exceptions.RefreshError(\n                \"Error getting ID token: {}\".format(response.json())\n            )\n\n        id_token = response.json()[\"token\"]\n        self.token = id_token\n        self.expiry = datetime.utcfromtimestamp(\n            jwt.decode(id_token, verify=False)[\"exp\"]\n        )\n", "google/auth/pluggable.py": "# Copyright 2022 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Pluggable Credentials.\nPluggable Credentials are initialized using external_account arguments which\nare typically loaded from third-party executables. Unlike other\ncredentials that can be initialized with a list of explicit arguments, secrets\nor credentials, external account clients use the environment and hints/guidelines\nprovided by the external_account JSON file to retrieve credentials and exchange\nthem for Google access tokens.\n\nExample credential_source for pluggable credential:\n{\n    \"executable\": {\n        \"command\": \"/path/to/get/credentials.sh --arg1=value1 --arg2=value2\",\n        \"timeout_millis\": 5000,\n        \"output_file\": \"/path/to/generated/cached/credentials\"\n    }\n}\n\"\"\"\n\ntry:\n    from collections.abc import Mapping\n# Python 2.7 compatibility\nexcept ImportError:  # pragma: NO COVER\n    from collections import Mapping  # type: ignore\nimport json\nimport os\nimport subprocess\nimport sys\nimport time\n\nfrom google.auth import _helpers\nfrom google.auth import exceptions\nfrom google.auth import external_account\n\n# The max supported executable spec version.\nEXECUTABLE_SUPPORTED_MAX_VERSION = 1\n\nEXECUTABLE_TIMEOUT_MILLIS_DEFAULT = 30 * 1000  # 30 seconds\nEXECUTABLE_TIMEOUT_MILLIS_LOWER_BOUND = 5 * 1000  # 5 seconds\nEXECUTABLE_TIMEOUT_MILLIS_UPPER_BOUND = 120 * 1000  # 2 minutes\n\nEXECUTABLE_INTERACTIVE_TIMEOUT_MILLIS_LOWER_BOUND = 30 * 1000  # 30 seconds\nEXECUTABLE_INTERACTIVE_TIMEOUT_MILLIS_UPPER_BOUND = 30 * 60 * 1000  # 30 minutes\n\n\nclass Credentials(external_account.Credentials):\n    \"\"\"External account credentials sourced from executables.\"\"\"\n\n    def __init__(\n        self,\n        audience,\n        subject_token_type,\n        token_url,\n        credential_source,\n        *args,\n        **kwargs\n    ):\n        \"\"\"Instantiates an external account credentials object from a executables.\n\n        Args:\n            audience (str): The STS audience field.\n            subject_token_type (str): The subject token type.\n            token_url (str): The STS endpoint URL.\n            credential_source (Mapping): The credential source dictionary used to\n                provide instructions on how to retrieve external credential to be\n                exchanged for Google access tokens.\n\n                Example credential_source for pluggable credential:\n\n                    {\n                        \"executable\": {\n                            \"command\": \"/path/to/get/credentials.sh --arg1=value1 --arg2=value2\",\n                            \"timeout_millis\": 5000,\n                            \"output_file\": \"/path/to/generated/cached/credentials\"\n                        }\n                    }\n            args (List): Optional positional arguments passed into the underlying :meth:`~external_account.Credentials.__init__` method.\n            kwargs (Mapping): Optional keyword arguments passed into the underlying :meth:`~external_account.Credentials.__init__` method.\n\n        Raises:\n            google.auth.exceptions.RefreshError: If an error is encountered during\n                access token retrieval logic.\n            google.auth.exceptions.InvalidValue: For invalid parameters.\n            google.auth.exceptions.MalformedError: For invalid parameters.\n\n        .. note:: Typically one of the helper constructors\n            :meth:`from_file` or\n            :meth:`from_info` are used instead of calling the constructor directly.\n        \"\"\"\n\n        self.interactive = kwargs.pop(\"interactive\", False)\n        super(Credentials, self).__init__(\n            audience=audience,\n            subject_token_type=subject_token_type,\n            token_url=token_url,\n            credential_source=credential_source,\n            *args,\n            **kwargs\n        )\n        if not isinstance(credential_source, Mapping):\n            self._credential_source_executable = None\n            raise exceptions.MalformedError(\n                \"Missing credential_source. The credential_source is not a dict.\"\n            )\n        self._credential_source_executable = credential_source.get(\"executable\")\n        if not self._credential_source_executable:\n            raise exceptions.MalformedError(\n                \"Missing credential_source. An 'executable' must be provided.\"\n            )\n        self._credential_source_executable_command = self._credential_source_executable.get(\n            \"command\"\n        )\n        self._credential_source_executable_timeout_millis = self._credential_source_executable.get(\n            \"timeout_millis\"\n        )\n        self._credential_source_executable_interactive_timeout_millis = self._credential_source_executable.get(\n            \"interactive_timeout_millis\"\n        )\n        self._credential_source_executable_output_file = self._credential_source_executable.get(\n            \"output_file\"\n        )\n\n        # Dummy value. This variable is only used via injection, not exposed to ctor\n        self._tokeninfo_username = \"\"\n\n        if not self._credential_source_executable_command:\n            raise exceptions.MalformedError(\n                \"Missing command field. Executable command must be provided.\"\n            )\n        if not self._credential_source_executable_timeout_millis:\n            self._credential_source_executable_timeout_millis = (\n                EXECUTABLE_TIMEOUT_MILLIS_DEFAULT\n            )\n        elif (\n            self._credential_source_executable_timeout_millis\n            < EXECUTABLE_TIMEOUT_MILLIS_LOWER_BOUND\n            or self._credential_source_executable_timeout_millis\n            > EXECUTABLE_TIMEOUT_MILLIS_UPPER_BOUND\n        ):\n            raise exceptions.InvalidValue(\"Timeout must be between 5 and 120 seconds.\")\n\n        if self._credential_source_executable_interactive_timeout_millis:\n            if (\n                self._credential_source_executable_interactive_timeout_millis\n                < EXECUTABLE_INTERACTIVE_TIMEOUT_MILLIS_LOWER_BOUND\n                or self._credential_source_executable_interactive_timeout_millis\n                > EXECUTABLE_INTERACTIVE_TIMEOUT_MILLIS_UPPER_BOUND\n            ):\n                raise exceptions.InvalidValue(\n                    \"Interactive timeout must be between 30 seconds and 30 minutes.\"\n                )\n\n    @_helpers.copy_docstring(external_account.Credentials)\n    def retrieve_subject_token(self, request):\n        self._validate_running_mode()\n\n        # Check output file.\n        if self._credential_source_executable_output_file is not None:\n            try:\n                with open(\n                    self._credential_source_executable_output_file, encoding=\"utf-8\"\n                ) as output_file:\n                    response = json.load(output_file)\n            except Exception:\n                pass\n            else:\n                try:\n                    # If the cached response is expired, _parse_subject_token will raise an error which will be ignored and we will call the executable again.\n                    subject_token = self._parse_subject_token(response)\n                    if (\n                        \"expiration_time\" not in response\n                    ):  # Always treat missing expiration_time as expired and proceed to executable run.\n                        raise exceptions.RefreshError\n                except (exceptions.MalformedError, exceptions.InvalidValue):\n                    raise\n                except exceptions.RefreshError:\n                    pass\n                else:\n                    return subject_token\n\n        if not _helpers.is_python_3():\n            raise exceptions.RefreshError(\n                \"Pluggable auth is only supported for python 3.7+\"\n            )\n\n        # Inject env vars.\n        env = os.environ.copy()\n        self._inject_env_variables(env)\n        env[\"GOOGLE_EXTERNAL_ACCOUNT_REVOKE\"] = \"0\"\n\n        # Run executable.\n        exe_timeout = (\n            self._credential_source_executable_interactive_timeout_millis / 1000\n            if self.interactive\n            else self._credential_source_executable_timeout_millis / 1000\n        )\n        exe_stdin = sys.stdin if self.interactive else None\n        exe_stdout = sys.stdout if self.interactive else subprocess.PIPE\n        exe_stderr = sys.stdout if self.interactive else subprocess.STDOUT\n\n        result = subprocess.run(\n            self._credential_source_executable_command.split(),\n            timeout=exe_timeout,\n            stdin=exe_stdin,\n            stdout=exe_stdout,\n            stderr=exe_stderr,\n            env=env,\n        )\n        if result.returncode != 0:\n            raise exceptions.RefreshError(\n                \"Executable exited with non-zero return code {}. Error: {}\".format(\n                    result.returncode, result.stdout\n                )\n            )\n\n        # Handle executable output.\n        response = json.loads(result.stdout.decode(\"utf-8\")) if result.stdout else None\n        if not response and self._credential_source_executable_output_file is not None:\n            response = json.load(\n                open(self._credential_source_executable_output_file, encoding=\"utf-8\")\n            )\n\n        subject_token = self._parse_subject_token(response)\n        return subject_token\n\n    def revoke(self, request):\n        \"\"\"Revokes the subject token using the credential_source object.\n\n        Args:\n            request (google.auth.transport.Request): A callable used to make\n                HTTP requests.\n        Raises:\n            google.auth.exceptions.RefreshError: If the executable revocation\n                not properly executed.\n\n        \"\"\"\n        if not self.interactive:\n            raise exceptions.InvalidValue(\n                \"Revoke is only enabled under interactive mode.\"\n            )\n        self._validate_running_mode()\n\n        if not _helpers.is_python_3():\n            raise exceptions.RefreshError(\n                \"Pluggable auth is only supported for python 3.7+\"\n            )\n\n        # Inject variables\n        env = os.environ.copy()\n        self._inject_env_variables(env)\n        env[\"GOOGLE_EXTERNAL_ACCOUNT_REVOKE\"] = \"1\"\n\n        # Run executable\n        result = subprocess.run(\n            self._credential_source_executable_command.split(),\n            timeout=self._credential_source_executable_interactive_timeout_millis\n            / 1000,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.STDOUT,\n            env=env,\n        )\n\n        if result.returncode != 0:\n            raise exceptions.RefreshError(\n                \"Auth revoke failed on executable. Exit with non-zero return code {}. Error: {}\".format(\n                    result.returncode, result.stdout\n                )\n            )\n\n        response = json.loads(result.stdout.decode(\"utf-8\"))\n        self._validate_revoke_response(response)\n\n    @property\n    def external_account_id(self):\n        \"\"\"Returns the external account identifier.\n\n        When service account impersonation is used the identifier is the service\n        account email.\n\n        Without service account impersonation, this returns None, unless it is\n        being used by the Google Cloud CLI which populates this field.\n        \"\"\"\n\n        return self.service_account_email or self._tokeninfo_username\n\n    @classmethod\n    def from_info(cls, info, **kwargs):\n        \"\"\"Creates a Pluggable Credentials instance from parsed external account info.\n\n        Args:\n            info (Mapping[str, str]): The Pluggable external account info in Google\n                format.\n            kwargs: Additional arguments to pass to the constructor.\n\n        Returns:\n            google.auth.pluggable.Credentials: The constructed\n                credentials.\n\n        Raises:\n            google.auth.exceptions.InvalidValue: For invalid parameters.\n            google.auth.exceptions.MalformedError: For invalid parameters.\n        \"\"\"\n        return super(Credentials, cls).from_info(info, **kwargs)\n\n    @classmethod\n    def from_file(cls, filename, **kwargs):\n        \"\"\"Creates an Pluggable Credentials instance from an external account json file.\n\n        Args:\n            filename (str): The path to the Pluggable external account json file.\n            kwargs: Additional arguments to pass to the constructor.\n\n        Returns:\n            google.auth.pluggable.Credentials: The constructed\n                credentials.\n        \"\"\"\n        return super(Credentials, cls).from_file(filename, **kwargs)\n\n    def _inject_env_variables(self, env):\n        env[\"GOOGLE_EXTERNAL_ACCOUNT_AUDIENCE\"] = self._audience\n        env[\"GOOGLE_EXTERNAL_ACCOUNT_TOKEN_TYPE\"] = self._subject_token_type\n        env[\"GOOGLE_EXTERNAL_ACCOUNT_ID\"] = self.external_account_id\n        env[\"GOOGLE_EXTERNAL_ACCOUNT_INTERACTIVE\"] = \"1\" if self.interactive else \"0\"\n\n        if self._service_account_impersonation_url is not None:\n            env[\n                \"GOOGLE_EXTERNAL_ACCOUNT_IMPERSONATED_EMAIL\"\n            ] = self.service_account_email\n        if self._credential_source_executable_output_file is not None:\n            env[\n                \"GOOGLE_EXTERNAL_ACCOUNT_OUTPUT_FILE\"\n            ] = self._credential_source_executable_output_file\n\n    def _parse_subject_token(self, response):\n        self._validate_response_schema(response)\n        if not response[\"success\"]:\n            if \"code\" not in response or \"message\" not in response:\n                raise exceptions.MalformedError(\n                    \"Error code and message fields are required in the response.\"\n                )\n            raise exceptions.RefreshError(\n                \"Executable returned unsuccessful response: code: {}, message: {}.\".format(\n                    response[\"code\"], response[\"message\"]\n                )\n            )\n        if \"expiration_time\" in response and response[\"expiration_time\"] < time.time():\n            raise exceptions.RefreshError(\n                \"The token returned by the executable is expired.\"\n            )\n        if \"token_type\" not in response:\n            raise exceptions.MalformedError(\n                \"The executable response is missing the token_type field.\"\n            )\n        if (\n            response[\"token_type\"] == \"urn:ietf:params:oauth:token-type:jwt\"\n            or response[\"token_type\"] == \"urn:ietf:params:oauth:token-type:id_token\"\n        ):  # OIDC\n            return response[\"id_token\"]\n        elif response[\"token_type\"] == \"urn:ietf:params:oauth:token-type:saml2\":  # SAML\n            return response[\"saml_response\"]\n        else:\n            raise exceptions.RefreshError(\"Executable returned unsupported token type.\")\n\n    def _validate_revoke_response(self, response):\n        self._validate_response_schema(response)\n        if not response[\"success\"]:\n            raise exceptions.RefreshError(\"Revoke failed with unsuccessful response.\")\n\n    def _validate_response_schema(self, response):\n        if \"version\" not in response:\n            raise exceptions.MalformedError(\n                \"The executable response is missing the version field.\"\n            )\n        if response[\"version\"] > EXECUTABLE_SUPPORTED_MAX_VERSION:\n            raise exceptions.RefreshError(\n                \"Executable returned unsupported version {}.\".format(\n                    response[\"version\"]\n                )\n            )\n\n        if \"success\" not in response:\n            raise exceptions.MalformedError(\n                \"The executable response is missing the success field.\"\n            )\n\n    def _validate_running_mode(self):\n        env_allow_executables = os.environ.get(\n            \"GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES\"\n        )\n        if env_allow_executables != \"1\":\n            raise exceptions.MalformedError(\n                \"Executables need to be explicitly allowed (set GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES to '1') to run.\"\n            )\n\n        if self.interactive and not self._credential_source_executable_output_file:\n            raise exceptions.MalformedError(\n                \"An output_file must be specified in the credential configuration for interactive mode.\"\n            )\n\n        if (\n            self.interactive\n            and not self._credential_source_executable_interactive_timeout_millis\n        ):\n            raise exceptions.InvalidOperation(\n                \"Interactive mode cannot run without an interactive timeout.\"\n            )\n\n        if self.interactive and not self.is_workforce_pool:\n            raise exceptions.InvalidValue(\n                \"Interactive mode is only enabled for workforce pool.\"\n            )\n\n    def _create_default_metrics_options(self):\n        metrics_options = super(Credentials, self)._create_default_metrics_options()\n        metrics_options[\"source\"] = \"executable\"\n        return metrics_options\n", "google/auth/credentials.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\n\"\"\"Interfaces for credentials.\"\"\"\n\nimport abc\nfrom enum import Enum\nimport os\n\nfrom google.auth import _helpers, environment_vars\nfrom google.auth import exceptions\nfrom google.auth import metrics\nfrom google.auth._refresh_worker import RefreshThreadManager\n\nDEFAULT_UNIVERSE_DOMAIN = \"googleapis.com\"\n\n\nclass Credentials(metaclass=abc.ABCMeta):\n    \"\"\"Base class for all credentials.\n\n    All credentials have a :attr:`token` that is used for authentication and\n    may also optionally set an :attr:`expiry` to indicate when the token will\n    no longer be valid.\n\n    Most credentials will be :attr:`invalid` until :meth:`refresh` is called.\n    Credentials can do this automatically before the first HTTP request in\n    :meth:`before_request`.\n\n    Although the token and expiration will change as the credentials are\n    :meth:`refreshed <refresh>` and used, credentials should be considered\n    immutable. Various credentials will accept configuration such as private\n    keys, scopes, and other options. These options are not changeable after\n    construction. Some classes will provide mechanisms to copy the credentials\n    with modifications such as :meth:`ScopedCredentials.with_scopes`.\n    \"\"\"\n\n    def __init__(self):\n        self.token = None\n        \"\"\"str: The bearer token that can be used in HTTP headers to make\n        authenticated requests.\"\"\"\n        self.expiry = None\n        \"\"\"Optional[datetime]: When the token expires and is no longer valid.\n        If this is None, the token is assumed to never expire.\"\"\"\n        self._quota_project_id = None\n        \"\"\"Optional[str]: Project to use for quota and billing purposes.\"\"\"\n        self._trust_boundary = None\n        \"\"\"Optional[dict]: Cache of a trust boundary response which has a list\n        of allowed regions and an encoded string representation of credentials\n        trust boundary.\"\"\"\n        self._universe_domain = DEFAULT_UNIVERSE_DOMAIN\n        \"\"\"Optional[str]: The universe domain value, default is googleapis.com\n        \"\"\"\n\n        self._use_non_blocking_refresh = False\n        self._refresh_worker = RefreshThreadManager()\n\n    @property\n    def expired(self):\n        \"\"\"Checks if the credentials are expired.\n\n        Note that credentials can be invalid but not expired because\n        Credentials with :attr:`expiry` set to None is considered to never\n        expire.\n\n        .. deprecated:: v2.24.0\n          Prefer checking :attr:`token_state` instead.\n        \"\"\"\n        if not self.expiry:\n            return False\n        # Remove some threshold from expiry to err on the side of reporting\n        # expiration early so that we avoid the 401-refresh-retry loop.\n        skewed_expiry = self.expiry - _helpers.REFRESH_THRESHOLD\n        return _helpers.utcnow() >= skewed_expiry\n\n    @property\n    def valid(self):\n        \"\"\"Checks the validity of the credentials.\n\n        This is True if the credentials have a :attr:`token` and the token\n        is not :attr:`expired`.\n\n        .. deprecated:: v2.24.0\n          Prefer checking :attr:`token_state` instead.\n        \"\"\"\n        return self.token is not None and not self.expired\n\n    @property\n    def token_state(self):\n        \"\"\"\n        See `:obj:`TokenState`\n        \"\"\"\n        if self.token is None:\n            return TokenState.INVALID\n\n        # Credentials that can't expire are always treated as fresh.\n        if self.expiry is None:\n            return TokenState.FRESH\n\n        expired = _helpers.utcnow() >= self.expiry\n        if expired:\n            return TokenState.INVALID\n\n        is_stale = _helpers.utcnow() >= (self.expiry - _helpers.REFRESH_THRESHOLD)\n        if is_stale:\n            return TokenState.STALE\n\n        return TokenState.FRESH\n\n    @property\n    def quota_project_id(self):\n        \"\"\"Project to use for quota and billing purposes.\"\"\"\n        return self._quota_project_id\n\n    @property\n    def universe_domain(self):\n        \"\"\"The universe domain value.\"\"\"\n        return self._universe_domain\n\n    @abc.abstractmethod\n    def refresh(self, request):\n        \"\"\"Refreshes the access token.\n\n        Args:\n            request (google.auth.transport.Request): The object used to make\n                HTTP requests.\n\n        Raises:\n            google.auth.exceptions.RefreshError: If the credentials could\n                not be refreshed.\n        \"\"\"\n        # pylint: disable=missing-raises-doc\n        # (pylint doesn't recognize that this is abstract)\n        raise NotImplementedError(\"Refresh must be implemented\")\n\n    def _metric_header_for_usage(self):\n        \"\"\"The x-goog-api-client header for token usage metric.\n\n        This header will be added to the API service requests in before_request\n        method. For example, \"cred-type/sa-jwt\" means service account self\n        signed jwt access token is used in the API service request\n        authorization header. Children credentials classes need to override\n        this method to provide the header value, if the token usage metric is\n        needed.\n\n        Returns:\n            str: The x-goog-api-client header value.\n        \"\"\"\n        return None\n\n    def apply(self, headers, token=None):\n        \"\"\"Apply the token to the authentication header.\n\n        Args:\n            headers (Mapping): The HTTP request headers.\n            token (Optional[str]): If specified, overrides the current access\n                token.\n        \"\"\"\n        headers[\"authorization\"] = \"Bearer {}\".format(\n            _helpers.from_bytes(token or self.token)\n        )\n        \"\"\"Trust boundary value will be a cached value from global lookup.\n\n        The response of trust boundary will be a list of regions and a hex\n        encoded representation.\n\n        An example of global lookup response:\n        {\n          \"locations\": [\n            \"us-central1\", \"us-east1\", \"europe-west1\", \"asia-east1\"\n          ]\n          \"encoded_locations\": \"0xA30\"\n        }\n        \"\"\"\n        if self._trust_boundary is not None:\n            headers[\"x-allowed-locations\"] = self._trust_boundary[\"encoded_locations\"]\n        if self.quota_project_id:\n            headers[\"x-goog-user-project\"] = self.quota_project_id\n\n    def _blocking_refresh(self, request):\n        if not self.valid:\n            self.refresh(request)\n\n    def _non_blocking_refresh(self, request):\n        use_blocking_refresh_fallback = False\n\n        if self.token_state == TokenState.STALE:\n            use_blocking_refresh_fallback = not self._refresh_worker.start_refresh(\n                self, request\n            )\n\n        if self.token_state == TokenState.INVALID or use_blocking_refresh_fallback:\n            self.refresh(request)\n            # If the blocking refresh succeeds then we can clear the error info\n            # on the background refresh worker, and perform refreshes in a\n            # background thread.\n            self._refresh_worker.clear_error()\n\n    def before_request(self, request, method, url, headers):\n        \"\"\"Performs credential-specific before request logic.\n\n        Refreshes the credentials if necessary, then calls :meth:`apply` to\n        apply the token to the authentication header.\n\n        Args:\n            request (google.auth.transport.Request): The object used to make\n                HTTP requests.\n            method (str): The request's HTTP method or the RPC method being\n                invoked.\n            url (str): The request's URI or the RPC service's URI.\n            headers (Mapping): The request's headers.\n        \"\"\"\n        # pylint: disable=unused-argument\n        # (Subclasses may use these arguments to ascertain information about\n        # the http request.)\n        if self._use_non_blocking_refresh:\n            self._non_blocking_refresh(request)\n        else:\n            self._blocking_refresh(request)\n\n        metrics.add_metric_header(headers, self._metric_header_for_usage())\n        self.apply(headers)\n\n    def with_non_blocking_refresh(self):\n        self._use_non_blocking_refresh = True\n\n\nclass CredentialsWithQuotaProject(Credentials):\n    \"\"\"Abstract base for credentials supporting ``with_quota_project`` factory\"\"\"\n\n    def with_quota_project(self, quota_project_id):\n        \"\"\"Returns a copy of these credentials with a modified quota project.\n\n        Args:\n            quota_project_id (str): The project to use for quota and\n                billing purposes\n\n        Returns:\n            google.auth.credentials.Credentials: A new credentials instance.\n        \"\"\"\n        raise NotImplementedError(\"This credential does not support quota project.\")\n\n    def with_quota_project_from_environment(self):\n        quota_from_env = os.environ.get(environment_vars.GOOGLE_CLOUD_QUOTA_PROJECT)\n        if quota_from_env:\n            return self.with_quota_project(quota_from_env)\n        return self\n\n\nclass CredentialsWithTokenUri(Credentials):\n    \"\"\"Abstract base for credentials supporting ``with_token_uri`` factory\"\"\"\n\n    def with_token_uri(self, token_uri):\n        \"\"\"Returns a copy of these credentials with a modified token uri.\n\n        Args:\n            token_uri (str): The uri to use for fetching/exchanging tokens\n\n        Returns:\n            google.auth.credentials.Credentials: A new credentials instance.\n        \"\"\"\n        raise NotImplementedError(\"This credential does not use token uri.\")\n\n\nclass CredentialsWithUniverseDomain(Credentials):\n    \"\"\"Abstract base for credentials supporting ``with_universe_domain`` factory\"\"\"\n\n    def with_universe_domain(self, universe_domain):\n        \"\"\"Returns a copy of these credentials with a modified universe domain.\n\n        Args:\n            universe_domain (str): The universe domain to use\n\n        Returns:\n            google.auth.credentials.Credentials: A new credentials instance.\n        \"\"\"\n        raise NotImplementedError(\n            \"This credential does not support with_universe_domain.\"\n        )\n\n\nclass AnonymousCredentials(Credentials):\n    \"\"\"Credentials that do not provide any authentication information.\n\n    These are useful in the case of services that support anonymous access or\n    local service emulators that do not use credentials.\n    \"\"\"\n\n    @property\n    def expired(self):\n        \"\"\"Returns `False`, anonymous credentials never expire.\"\"\"\n        return False\n\n    @property\n    def valid(self):\n        \"\"\"Returns `True`, anonymous credentials are always valid.\"\"\"\n        return True\n\n    def refresh(self, request):\n        \"\"\"Raises :class:``InvalidOperation``, anonymous credentials cannot be\n        refreshed.\"\"\"\n        raise exceptions.InvalidOperation(\"Anonymous credentials cannot be refreshed.\")\n\n    def apply(self, headers, token=None):\n        \"\"\"Anonymous credentials do nothing to the request.\n\n        The optional ``token`` argument is not supported.\n\n        Raises:\n            google.auth.exceptions.InvalidValue: If a token was specified.\n        \"\"\"\n        if token is not None:\n            raise exceptions.InvalidValue(\"Anonymous credentials don't support tokens.\")\n\n    def before_request(self, request, method, url, headers):\n        \"\"\"Anonymous credentials do nothing to the request.\"\"\"\n\n\nclass ReadOnlyScoped(metaclass=abc.ABCMeta):\n    \"\"\"Interface for credentials whose scopes can be queried.\n\n    OAuth 2.0-based credentials allow limiting access using scopes as described\n    in `RFC6749 Section 3.3`_.\n    If a credential class implements this interface then the credentials either\n    use scopes in their implementation.\n\n    Some credentials require scopes in order to obtain a token. You can check\n    if scoping is necessary with :attr:`requires_scopes`::\n\n        if credentials.requires_scopes:\n            # Scoping is required.\n            credentials = credentials.with_scopes(scopes=['one', 'two'])\n\n    Credentials that require scopes must either be constructed with scopes::\n\n        credentials = SomeScopedCredentials(scopes=['one', 'two'])\n\n    Or must copy an existing instance using :meth:`with_scopes`::\n\n        scoped_credentials = credentials.with_scopes(scopes=['one', 'two'])\n\n    Some credentials have scopes but do not allow or require scopes to be set,\n    these credentials can be used as-is.\n\n    .. _RFC6749 Section 3.3: https://tools.ietf.org/html/rfc6749#section-3.3\n    \"\"\"\n\n    def __init__(self):\n        super(ReadOnlyScoped, self).__init__()\n        self._scopes = None\n        self._default_scopes = None\n\n    @property\n    def scopes(self):\n        \"\"\"Sequence[str]: the credentials' current set of scopes.\"\"\"\n        return self._scopes\n\n    @property\n    def default_scopes(self):\n        \"\"\"Sequence[str]: the credentials' current set of default scopes.\"\"\"\n        return self._default_scopes\n\n    @abc.abstractproperty\n    def requires_scopes(self):\n        \"\"\"True if these credentials require scopes to obtain an access token.\n        \"\"\"\n        return False\n\n    def has_scopes(self, scopes):\n        \"\"\"Checks if the credentials have the given scopes.\n\n        .. warning: This method is not guaranteed to be accurate if the\n            credentials are :attr:`~Credentials.invalid`.\n\n        Args:\n            scopes (Sequence[str]): The list of scopes to check.\n\n        Returns:\n            bool: True if the credentials have the given scopes.\n        \"\"\"\n        credential_scopes = (\n            self._scopes if self._scopes is not None else self._default_scopes\n        )\n        return set(scopes).issubset(set(credential_scopes or []))\n\n\nclass Scoped(ReadOnlyScoped):\n    \"\"\"Interface for credentials whose scopes can be replaced while copying.\n\n    OAuth 2.0-based credentials allow limiting access using scopes as described\n    in `RFC6749 Section 3.3`_.\n    If a credential class implements this interface then the credentials either\n    use scopes in their implementation.\n\n    Some credentials require scopes in order to obtain a token. You can check\n    if scoping is necessary with :attr:`requires_scopes`::\n\n        if credentials.requires_scopes:\n            # Scoping is required.\n            credentials = credentials.create_scoped(['one', 'two'])\n\n    Credentials that require scopes must either be constructed with scopes::\n\n        credentials = SomeScopedCredentials(scopes=['one', 'two'])\n\n    Or must copy an existing instance using :meth:`with_scopes`::\n\n        scoped_credentials = credentials.with_scopes(scopes=['one', 'two'])\n\n    Some credentials have scopes but do not allow or require scopes to be set,\n    these credentials can be used as-is.\n\n    .. _RFC6749 Section 3.3: https://tools.ietf.org/html/rfc6749#section-3.3\n    \"\"\"\n\n    @abc.abstractmethod\n    def with_scopes(self, scopes, default_scopes=None):\n        \"\"\"Create a copy of these credentials with the specified scopes.\n\n        Args:\n            scopes (Sequence[str]): The list of scopes to attach to the\n                current credentials.\n\n        Raises:\n            NotImplementedError: If the credentials' scopes can not be changed.\n                This can be avoided by checking :attr:`requires_scopes` before\n                calling this method.\n        \"\"\"\n        raise NotImplementedError(\"This class does not require scoping.\")\n\n\ndef with_scopes_if_required(credentials, scopes, default_scopes=None):\n    \"\"\"Creates a copy of the credentials with scopes if scoping is required.\n\n    This helper function is useful when you do not know (or care to know) the\n    specific type of credentials you are using (such as when you use\n    :func:`google.auth.default`). This function will call\n    :meth:`Scoped.with_scopes` if the credentials are scoped credentials and if\n    the credentials require scoping. Otherwise, it will return the credentials\n    as-is.\n\n    Args:\n        credentials (google.auth.credentials.Credentials): The credentials to\n            scope if necessary.\n        scopes (Sequence[str]): The list of scopes to use.\n        default_scopes (Sequence[str]): Default scopes passed by a\n            Google client library. Use 'scopes' for user-defined scopes.\n\n    Returns:\n        google.auth.credentials.Credentials: Either a new set of scoped\n            credentials, or the passed in credentials instance if no scoping\n            was required.\n    \"\"\"\n    if isinstance(credentials, Scoped) and credentials.requires_scopes:\n        return credentials.with_scopes(scopes, default_scopes=default_scopes)\n    else:\n        return credentials\n\n\nclass Signing(metaclass=abc.ABCMeta):\n    \"\"\"Interface for credentials that can cryptographically sign messages.\"\"\"\n\n    @abc.abstractmethod\n    def sign_bytes(self, message):\n        \"\"\"Signs the given message.\n\n        Args:\n            message (bytes): The message to sign.\n\n        Returns:\n            bytes: The message's cryptographic signature.\n        \"\"\"\n        # pylint: disable=missing-raises-doc,redundant-returns-doc\n        # (pylint doesn't recognize that this is abstract)\n        raise NotImplementedError(\"Sign bytes must be implemented.\")\n\n    @abc.abstractproperty\n    def signer_email(self):\n        \"\"\"Optional[str]: An email address that identifies the signer.\"\"\"\n        # pylint: disable=missing-raises-doc\n        # (pylint doesn't recognize that this is abstract)\n        raise NotImplementedError(\"Signer email must be implemented.\")\n\n    @abc.abstractproperty\n    def signer(self):\n        \"\"\"google.auth.crypt.Signer: The signer used to sign bytes.\"\"\"\n        # pylint: disable=missing-raises-doc\n        # (pylint doesn't recognize that this is abstract)\n        raise NotImplementedError(\"Signer must be implemented.\")\n\n\nclass TokenState(Enum):\n    \"\"\"\n    Tracks the state of a token.\n    FRESH: The token is valid. It is not expired or close to expired, or the token has no expiry.\n    STALE: The token is close to expired, and should be refreshed. The token can be used normally.\n    INVALID: The token is expired or invalid. The token cannot be used for a normal operation.\n    \"\"\"\n\n    FRESH = 1\n    STALE = 2\n    INVALID = 3\n", "google/auth/_service_account_info.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Helper functions for loading data from a Google service account file.\"\"\"\n\nimport io\nimport json\n\nfrom google.auth import crypt\nfrom google.auth import exceptions\n\n\ndef from_dict(data, require=None, use_rsa_signer=True):\n    \"\"\"Validates a dictionary containing Google service account data.\n\n    Creates and returns a :class:`google.auth.crypt.Signer` instance from the\n    private key specified in the data.\n\n    Args:\n        data (Mapping[str, str]): The service account data\n        require (Sequence[str]): List of keys required to be present in the\n            info.\n        use_rsa_signer (Optional[bool]): Whether to use RSA signer or EC signer.\n            We use RSA signer by default.\n\n    Returns:\n        google.auth.crypt.Signer: A signer created from the private key in the\n            service account file.\n\n    Raises:\n        MalformedError: if the data was in the wrong format, or if one of the\n            required keys is missing.\n    \"\"\"\n    keys_needed = set(require if require is not None else [])\n\n    missing = keys_needed.difference(data.keys())\n\n    if missing:\n        raise exceptions.MalformedError(\n            \"Service account info was not in the expected format, missing \"\n            \"fields {}.\".format(\", \".join(missing))\n        )\n\n    # Create a signer.\n    if use_rsa_signer:\n        signer = crypt.RSASigner.from_service_account_info(data)\n    else:\n        signer = crypt.ES256Signer.from_service_account_info(data)\n\n    return signer\n\n\ndef from_filename(filename, require=None, use_rsa_signer=True):\n    \"\"\"Reads a Google service account JSON file and returns its parsed info.\n\n    Args:\n        filename (str): The path to the service account .json file.\n        require (Sequence[str]): List of keys required to be present in the\n            info.\n        use_rsa_signer (Optional[bool]): Whether to use RSA signer or EC signer.\n            We use RSA signer by default.\n\n    Returns:\n        Tuple[ Mapping[str, str], google.auth.crypt.Signer ]: The verified\n            info and a signer instance.\n    \"\"\"\n    with io.open(filename, \"r\", encoding=\"utf-8\") as json_file:\n        data = json.load(json_file)\n        return data, from_dict(data, require=require, use_rsa_signer=use_rsa_signer)\n", "google/auth/_oauth2client.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Helpers for transitioning from oauth2client to google-auth.\n\n.. warning::\n    This module is private as it is intended to assist first-party downstream\n    clients with the transition from oauth2client to google-auth.\n\"\"\"\n\nfrom __future__ import absolute_import\n\nfrom google.auth import _helpers\nimport google.auth.app_engine\nimport google.auth.compute_engine\nimport google.oauth2.credentials\nimport google.oauth2.service_account\n\ntry:\n    import oauth2client.client  # type: ignore\n    import oauth2client.contrib.gce  # type: ignore\n    import oauth2client.service_account  # type: ignore\nexcept ImportError as caught_exc:\n    raise ImportError(\"oauth2client is not installed.\") from caught_exc\n\ntry:\n    import oauth2client.contrib.appengine  # type: ignore\n\n    _HAS_APPENGINE = True\nexcept ImportError:\n    _HAS_APPENGINE = False\n\n\n_CONVERT_ERROR_TMPL = \"Unable to convert {} to a google-auth credentials class.\"\n\n\ndef _convert_oauth2_credentials(credentials):\n    \"\"\"Converts to :class:`google.oauth2.credentials.Credentials`.\n\n    Args:\n        credentials (Union[oauth2client.client.OAuth2Credentials,\n            oauth2client.client.GoogleCredentials]): The credentials to\n            convert.\n\n    Returns:\n        google.oauth2.credentials.Credentials: The converted credentials.\n    \"\"\"\n    new_credentials = google.oauth2.credentials.Credentials(\n        token=credentials.access_token,\n        refresh_token=credentials.refresh_token,\n        token_uri=credentials.token_uri,\n        client_id=credentials.client_id,\n        client_secret=credentials.client_secret,\n        scopes=credentials.scopes,\n    )\n\n    new_credentials._expires = credentials.token_expiry\n\n    return new_credentials\n\n\ndef _convert_service_account_credentials(credentials):\n    \"\"\"Converts to :class:`google.oauth2.service_account.Credentials`.\n\n    Args:\n        credentials (Union[\n            oauth2client.service_account.ServiceAccountCredentials,\n            oauth2client.service_account._JWTAccessCredentials]): The\n            credentials to convert.\n\n    Returns:\n        google.oauth2.service_account.Credentials: The converted credentials.\n    \"\"\"\n    info = credentials.serialization_data.copy()\n    info[\"token_uri\"] = credentials.token_uri\n    return google.oauth2.service_account.Credentials.from_service_account_info(info)\n\n\ndef _convert_gce_app_assertion_credentials(credentials):\n    \"\"\"Converts to :class:`google.auth.compute_engine.Credentials`.\n\n    Args:\n        credentials (oauth2client.contrib.gce.AppAssertionCredentials): The\n            credentials to convert.\n\n    Returns:\n        google.oauth2.service_account.Credentials: The converted credentials.\n    \"\"\"\n    return google.auth.compute_engine.Credentials(\n        service_account_email=credentials.service_account_email\n    )\n\n\ndef _convert_appengine_app_assertion_credentials(credentials):\n    \"\"\"Converts to :class:`google.auth.app_engine.Credentials`.\n\n    Args:\n        credentials (oauth2client.contrib.app_engine.AppAssertionCredentials):\n            The credentials to convert.\n\n    Returns:\n        google.oauth2.service_account.Credentials: The converted credentials.\n    \"\"\"\n    # pylint: disable=invalid-name\n    return google.auth.app_engine.Credentials(\n        scopes=_helpers.string_to_scopes(credentials.scope),\n        service_account_id=credentials.service_account_id,\n    )\n\n\n_CLASS_CONVERSION_MAP = {\n    oauth2client.client.OAuth2Credentials: _convert_oauth2_credentials,\n    oauth2client.client.GoogleCredentials: _convert_oauth2_credentials,\n    oauth2client.service_account.ServiceAccountCredentials: _convert_service_account_credentials,\n    oauth2client.service_account._JWTAccessCredentials: _convert_service_account_credentials,\n    oauth2client.contrib.gce.AppAssertionCredentials: _convert_gce_app_assertion_credentials,\n}\n\nif _HAS_APPENGINE:\n    _CLASS_CONVERSION_MAP[\n        oauth2client.contrib.appengine.AppAssertionCredentials\n    ] = _convert_appengine_app_assertion_credentials\n\n\ndef convert(credentials):\n    \"\"\"Convert oauth2client credentials to google-auth credentials.\n\n    This class converts:\n\n    - :class:`oauth2client.client.OAuth2Credentials` to\n      :class:`google.oauth2.credentials.Credentials`.\n    - :class:`oauth2client.client.GoogleCredentials` to\n      :class:`google.oauth2.credentials.Credentials`.\n    - :class:`oauth2client.service_account.ServiceAccountCredentials` to\n      :class:`google.oauth2.service_account.Credentials`.\n    - :class:`oauth2client.service_account._JWTAccessCredentials` to\n      :class:`google.oauth2.service_account.Credentials`.\n    - :class:`oauth2client.contrib.gce.AppAssertionCredentials` to\n      :class:`google.auth.compute_engine.Credentials`.\n    - :class:`oauth2client.contrib.appengine.AppAssertionCredentials` to\n      :class:`google.auth.app_engine.Credentials`.\n\n    Returns:\n        google.auth.credentials.Credentials: The converted credentials.\n\n    Raises:\n        ValueError: If the credentials could not be converted.\n    \"\"\"\n\n    credentials_class = type(credentials)\n\n    try:\n        return _CLASS_CONVERSION_MAP[credentials_class](credentials)\n    except KeyError as caught_exc:\n        new_exc = ValueError(_CONVERT_ERROR_TMPL.format(credentials_class))\n        raise new_exc from caught_exc\n", "google/auth/metrics.py": "# Copyright 2023 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\" We use x-goog-api-client header to report metrics. This module provides\nthe constants and helper methods to construct x-goog-api-client header.\n\"\"\"\n\nimport platform\n\nfrom google.auth import version\n\n\nAPI_CLIENT_HEADER = \"x-goog-api-client\"\n\n# BYOID Specific consts\nBYOID_HEADER_SECTION = \"google-byoid-sdk\"\n\n# Auth request type\nREQUEST_TYPE_ACCESS_TOKEN = \"auth-request-type/at\"\nREQUEST_TYPE_ID_TOKEN = \"auth-request-type/it\"\nREQUEST_TYPE_MDS_PING = \"auth-request-type/mds\"\nREQUEST_TYPE_REAUTH_START = \"auth-request-type/re-start\"\nREQUEST_TYPE_REAUTH_CONTINUE = \"auth-request-type/re-cont\"\n\n# Credential type\nCRED_TYPE_USER = \"cred-type/u\"\nCRED_TYPE_SA_ASSERTION = \"cred-type/sa\"\nCRED_TYPE_SA_JWT = \"cred-type/jwt\"\nCRED_TYPE_SA_MDS = \"cred-type/mds\"\nCRED_TYPE_SA_IMPERSONATE = \"cred-type/imp\"\n\n\n# Versions\ndef python_and_auth_lib_version():\n    return \"gl-python/{} auth/{}\".format(platform.python_version(), version.__version__)\n\n\n# Token request metric header values\n\n# x-goog-api-client header value for access token request via metadata server.\n# Example: \"gl-python/3.7 auth/1.1 auth-request-type/at cred-type/mds\"\ndef token_request_access_token_mds():\n    return \"{} {} {}\".format(\n        python_and_auth_lib_version(), REQUEST_TYPE_ACCESS_TOKEN, CRED_TYPE_SA_MDS\n    )\n\n\n# x-goog-api-client header value for ID token request via metadata server.\n# Example: \"gl-python/3.7 auth/1.1 auth-request-type/it cred-type/mds\"\ndef token_request_id_token_mds():\n    return \"{} {} {}\".format(\n        python_and_auth_lib_version(), REQUEST_TYPE_ID_TOKEN, CRED_TYPE_SA_MDS\n    )\n\n\n# x-goog-api-client header value for impersonated credentials access token request.\n# Example: \"gl-python/3.7 auth/1.1 auth-request-type/at cred-type/imp\"\ndef token_request_access_token_impersonate():\n    return \"{} {} {}\".format(\n        python_and_auth_lib_version(),\n        REQUEST_TYPE_ACCESS_TOKEN,\n        CRED_TYPE_SA_IMPERSONATE,\n    )\n\n\n# x-goog-api-client header value for impersonated credentials ID token request.\n# Example: \"gl-python/3.7 auth/1.1 auth-request-type/it cred-type/imp\"\ndef token_request_id_token_impersonate():\n    return \"{} {} {}\".format(\n        python_and_auth_lib_version(), REQUEST_TYPE_ID_TOKEN, CRED_TYPE_SA_IMPERSONATE\n    )\n\n\n# x-goog-api-client header value for service account credentials access token\n# request (assertion flow).\n# Example: \"gl-python/3.7 auth/1.1 auth-request-type/at cred-type/sa\"\ndef token_request_access_token_sa_assertion():\n    return \"{} {} {}\".format(\n        python_and_auth_lib_version(), REQUEST_TYPE_ACCESS_TOKEN, CRED_TYPE_SA_ASSERTION\n    )\n\n\n# x-goog-api-client header value for service account credentials ID token\n# request (assertion flow).\n# Example: \"gl-python/3.7 auth/1.1 auth-request-type/it cred-type/sa\"\ndef token_request_id_token_sa_assertion():\n    return \"{} {} {}\".format(\n        python_and_auth_lib_version(), REQUEST_TYPE_ID_TOKEN, CRED_TYPE_SA_ASSERTION\n    )\n\n\n# x-goog-api-client header value for user credentials token request.\n# Example: \"gl-python/3.7 auth/1.1 cred-type/u\"\ndef token_request_user():\n    return \"{} {}\".format(python_and_auth_lib_version(), CRED_TYPE_USER)\n\n\n# Miscellenous metrics\n\n# x-goog-api-client header value for metadata server ping.\n# Example: \"gl-python/3.7 auth/1.1 auth-request-type/mds\"\ndef mds_ping():\n    return \"{} {}\".format(python_and_auth_lib_version(), REQUEST_TYPE_MDS_PING)\n\n\n# x-goog-api-client header value for reauth start endpoint calls.\n# Example: \"gl-python/3.7 auth/1.1 auth-request-type/re-start\"\ndef reauth_start():\n    return \"{} {}\".format(python_and_auth_lib_version(), REQUEST_TYPE_REAUTH_START)\n\n\n# x-goog-api-client header value for reauth continue endpoint calls.\n# Example: \"gl-python/3.7 auth/1.1 cred-type/re-cont\"\ndef reauth_continue():\n    return \"{} {}\".format(python_and_auth_lib_version(), REQUEST_TYPE_REAUTH_CONTINUE)\n\n\n# x-goog-api-client header value for BYOID calls to the Security Token Service exchange token endpoint.\n# Example: \"gl-python/3.7 auth/1.1 google-byoid-sdk source/aws sa-impersonation/true sa-impersonation/true\"\ndef byoid_metrics_header(metrics_options):\n    header = \"{} {}\".format(python_and_auth_lib_version(), BYOID_HEADER_SECTION)\n    for key, value in metrics_options.items():\n        header = \"{} {}/{}\".format(header, key, value)\n    return header\n\n\ndef add_metric_header(headers, metric_header_value):\n    \"\"\"Add x-goog-api-client header with the given value.\n\n    Args:\n        headers (Mapping[str, str]): The headers to which we will add the\n            metric header.\n        metric_header_value (Optional[str]): If value is None, do nothing;\n            if headers already has a x-goog-api-client header, append the value\n            to the existing header; otherwise add a new x-goog-api-client\n            header with the given value.\n    \"\"\"\n    if not metric_header_value:\n        return\n    if API_CLIENT_HEADER not in headers:\n        headers[API_CLIENT_HEADER] = metric_header_value\n    else:\n        headers[API_CLIENT_HEADER] += \" \" + metric_header_value\n", "google/auth/identity_pool.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Identity Pool Credentials.\n\nThis module provides credentials to access Google Cloud resources from on-prem\nor non-Google Cloud platforms which support external credentials (e.g. OIDC ID\ntokens) retrieved from local file locations or local servers. This includes\nMicrosoft Azure and OIDC identity providers (e.g. K8s workloads registered with\nHub with Hub workload identity enabled).\n\nThese credentials are recommended over the use of service account credentials\nin on-prem/non-Google Cloud platforms as they do not involve the management of\nlong-live service account private keys.\n\nIdentity Pool Credentials are initialized using external_account\narguments which are typically loaded from an external credentials file or\nan external credentials URL.\n\nThis module also provides a definition for an abstract subject token supplier.\nThis supplier can be implemented to return a valid OIDC or SAML2.0 subject token\nand used to create Identity Pool credentials. The credentials will then call the\nsupplier instead of using pre-defined methods such as reading a local file or\ncalling a URL.\n\"\"\"\n\ntry:\n    from collections.abc import Mapping\n# Python 2.7 compatibility\nexcept ImportError:  # pragma: NO COVER\n    from collections import Mapping  # type: ignore\nimport abc\nimport json\nimport os\nfrom typing import NamedTuple\n\nfrom google.auth import _helpers\nfrom google.auth import exceptions\nfrom google.auth import external_account\n\n\nclass SubjectTokenSupplier(metaclass=abc.ABCMeta):\n    \"\"\"Base class for subject token suppliers. This can be implemented with custom logic to retrieve\n    a subject token to exchange for a Google Cloud access token when using Workload or\n    Workforce Identity Federation. The identity pool credential does not cache the subject token,\n    so caching logic should be added in the implementation.\n    \"\"\"\n\n    @abc.abstractmethod\n    def get_subject_token(self, context, request):\n        \"\"\"Returns the requested subject token. The subject token must be valid.\n\n        .. warning: This is not cached by the calling Google credential, so caching logic should be implemented in the supplier.\n\n        Args:\n            context (google.auth.externalaccount.SupplierContext): The context object\n                containing information about the requested audience and subject token type.\n            request (google.auth.transport.Request): The object used to make\n                HTTP requests.\n\n        Raises:\n            google.auth.exceptions.RefreshError: If an error is encountered during\n                subject token retrieval logic.\n\n        Returns:\n            str: The requested subject token string.\n        \"\"\"\n        raise NotImplementedError(\"\")\n\n\nclass _TokenContent(NamedTuple):\n    \"\"\"Models the token content response from file and url internal suppliers.\n        Attributes:\n            content (str): The string content of the file or URL response.\n            location (str): The location the content was retrieved from. This will either be a file location or a URL.\n    \"\"\"\n\n    content: str\n    location: str\n\n\nclass _FileSupplier(SubjectTokenSupplier):\n    \"\"\" Internal implementation of subject token supplier which supports reading a subject token from a file.\"\"\"\n\n    def __init__(self, path, format_type, subject_token_field_name):\n        self._path = path\n        self._format_type = format_type\n        self._subject_token_field_name = subject_token_field_name\n\n    @_helpers.copy_docstring(SubjectTokenSupplier)\n    def get_subject_token(self, context, request):\n        if not os.path.exists(self._path):\n            raise exceptions.RefreshError(\"File '{}' was not found.\".format(self._path))\n\n        with open(self._path, \"r\", encoding=\"utf-8\") as file_obj:\n            token_content = _TokenContent(file_obj.read(), self._path)\n\n        return _parse_token_data(\n            token_content, self._format_type, self._subject_token_field_name\n        )\n\n\nclass _UrlSupplier(SubjectTokenSupplier):\n    \"\"\" Internal implementation of subject token supplier which supports retrieving a subject token by calling a URL endpoint.\"\"\"\n\n    def __init__(self, url, format_type, subject_token_field_name, headers):\n        self._url = url\n        self._format_type = format_type\n        self._subject_token_field_name = subject_token_field_name\n        self._headers = headers\n\n    @_helpers.copy_docstring(SubjectTokenSupplier)\n    def get_subject_token(self, context, request):\n        response = request(url=self._url, method=\"GET\", headers=self._headers)\n\n        # support both string and bytes type response.data\n        response_body = (\n            response.data.decode(\"utf-8\")\n            if hasattr(response.data, \"decode\")\n            else response.data\n        )\n\n        if response.status != 200:\n            raise exceptions.RefreshError(\n                \"Unable to retrieve Identity Pool subject token\", response_body\n            )\n        token_content = _TokenContent(response_body, self._url)\n        return _parse_token_data(\n            token_content, self._format_type, self._subject_token_field_name\n        )\n\n\ndef _parse_token_data(token_content, format_type=\"text\", subject_token_field_name=None):\n    if format_type == \"text\":\n        token = token_content.content\n    else:\n        try:\n            # Parse file content as JSON.\n            response_data = json.loads(token_content.content)\n            # Get the subject_token.\n            token = response_data[subject_token_field_name]\n        except (KeyError, ValueError):\n            raise exceptions.RefreshError(\n                \"Unable to parse subject_token from JSON file '{}' using key '{}'\".format(\n                    token_content.location, subject_token_field_name\n                )\n            )\n    if not token:\n        raise exceptions.RefreshError(\n            \"Missing subject_token in the credential_source file\"\n        )\n    return token\n\n\nclass Credentials(external_account.Credentials):\n    \"\"\"External account credentials sourced from files and URLs.\"\"\"\n\n    def __init__(\n        self,\n        audience,\n        subject_token_type,\n        token_url=external_account._DEFAULT_TOKEN_URL,\n        credential_source=None,\n        subject_token_supplier=None,\n        *args,\n        **kwargs\n    ):\n        \"\"\"Instantiates an external account credentials object from a file/URL.\n\n        Args:\n            audience (str): The STS audience field.\n            subject_token_type (str): The subject token type based on the Oauth2.0 token exchange spec.\n                Expected values include::\n\n                    \u201curn:ietf:params:oauth:token-type:jwt\u201d\n                    \u201curn:ietf:params:oauth:token-type:id-token\u201d\n                    \u201curn:ietf:params:oauth:token-type:saml2\u201d\n\n            token_url (Optional [str]): The STS endpoint URL. If not provided, will default to \"https://sts.googleapis.com/v1/token\".\n            credential_source (Optional [Mapping]): The credential source dictionary used to\n                provide instructions on how to retrieve external credential to be\n                exchanged for Google access tokens. Either a credential source or\n                a subject token supplier must be provided.\n\n                Example credential_source for url-sourced credential::\n\n                    {\n                        \"url\": \"http://www.example.com\",\n                        \"format\": {\n                            \"type\": \"json\",\n                            \"subject_token_field_name\": \"access_token\",\n                        },\n                        \"headers\": {\"foo\": \"bar\"},\n                    }\n\n                Example credential_source for file-sourced credential::\n\n                    {\n                        \"file\": \"/path/to/token/file.txt\"\n                    }\n            subject_token_supplier (Optional [SubjectTokenSupplier]): Optional subject token supplier.\n                This will be called to supply a valid subject token which will then\n                be exchanged for Google access tokens. Either a subject token  supplier\n                or a credential source must be provided.\n            args (List): Optional positional arguments passed into the underlying :meth:`~external_account.Credentials.__init__` method.\n            kwargs (Mapping): Optional keyword arguments passed into the underlying :meth:`~external_account.Credentials.__init__` method.\n\n        Raises:\n            google.auth.exceptions.RefreshError: If an error is encountered during\n                access token retrieval logic.\n            ValueError: For invalid parameters.\n\n        .. note:: Typically one of the helper constructors\n            :meth:`from_file` or\n            :meth:`from_info` are used instead of calling the constructor directly.\n        \"\"\"\n\n        super(Credentials, self).__init__(\n            audience=audience,\n            subject_token_type=subject_token_type,\n            token_url=token_url,\n            credential_source=credential_source,\n            *args,\n            **kwargs\n        )\n        if credential_source is None and subject_token_supplier is None:\n            raise exceptions.InvalidValue(\n                \"A valid credential source or a subject token supplier must be provided.\"\n            )\n        if credential_source is not None and subject_token_supplier is not None:\n            raise exceptions.InvalidValue(\n                \"Identity pool credential cannot have both a credential source and a subject token supplier.\"\n            )\n\n        if subject_token_supplier is not None:\n            self._subject_token_supplier = subject_token_supplier\n            self._credential_source_file = None\n            self._credential_source_url = None\n        else:\n            if not isinstance(credential_source, Mapping):\n                self._credential_source_executable = None\n                raise exceptions.MalformedError(\n                    \"Invalid credential_source. The credential_source is not a dict.\"\n                )\n            self._credential_source_file = credential_source.get(\"file\")\n            self._credential_source_url = credential_source.get(\"url\")\n            self._credential_source_headers = credential_source.get(\"headers\")\n            credential_source_format = credential_source.get(\"format\", {})\n            # Get credential_source format type. When not provided, this\n            # defaults to text.\n            self._credential_source_format_type = (\n                credential_source_format.get(\"type\") or \"text\"\n            )\n            # environment_id is only supported in AWS or dedicated future external\n            # account credentials.\n            if \"environment_id\" in credential_source:\n                raise exceptions.MalformedError(\n                    \"Invalid Identity Pool credential_source field 'environment_id'\"\n                )\n            if self._credential_source_format_type not in [\"text\", \"json\"]:\n                raise exceptions.MalformedError(\n                    \"Invalid credential_source format '{}'\".format(\n                        self._credential_source_format_type\n                    )\n                )\n            # For JSON types, get the required subject_token field name.\n            if self._credential_source_format_type == \"json\":\n                self._credential_source_field_name = credential_source_format.get(\n                    \"subject_token_field_name\"\n                )\n                if self._credential_source_field_name is None:\n                    raise exceptions.MalformedError(\n                        \"Missing subject_token_field_name for JSON credential_source format\"\n                    )\n            else:\n                self._credential_source_field_name = None\n\n            if self._credential_source_file and self._credential_source_url:\n                raise exceptions.MalformedError(\n                    \"Ambiguous credential_source. 'file' is mutually exclusive with 'url'.\"\n                )\n            if not self._credential_source_file and not self._credential_source_url:\n                raise exceptions.MalformedError(\n                    \"Missing credential_source. A 'file' or 'url' must be provided.\"\n                )\n\n            if self._credential_source_file:\n                self._subject_token_supplier = _FileSupplier(\n                    self._credential_source_file,\n                    self._credential_source_format_type,\n                    self._credential_source_field_name,\n                )\n            else:\n                self._subject_token_supplier = _UrlSupplier(\n                    self._credential_source_url,\n                    self._credential_source_format_type,\n                    self._credential_source_field_name,\n                    self._credential_source_headers,\n                )\n\n    @_helpers.copy_docstring(external_account.Credentials)\n    def retrieve_subject_token(self, request):\n        return self._subject_token_supplier.get_subject_token(\n            self._supplier_context, request\n        )\n\n    def _create_default_metrics_options(self):\n        metrics_options = super(Credentials, self)._create_default_metrics_options()\n        # Check that credential source is a dict before checking for file vs url. This check needs to be done\n        # here because the external_account credential constructor needs to pass the metrics options to the\n        # impersonated credential object before the identity_pool credentials are validated.\n        if isinstance(self._credential_source, Mapping):\n            if self._credential_source.get(\"file\"):\n                metrics_options[\"source\"] = \"file\"\n            else:\n                metrics_options[\"source\"] = \"url\"\n        else:\n            metrics_options[\"source\"] = \"programmatic\"\n        return metrics_options\n\n    def _has_custom_supplier(self):\n        return self._credential_source is None\n\n    def _constructor_args(self):\n        args = super(Credentials, self)._constructor_args()\n        # If a custom supplier was used, append it to the args dict.\n        if self._has_custom_supplier():\n            args.update({\"subject_token_supplier\": self._subject_token_supplier})\n        return args\n\n    @classmethod\n    def from_info(cls, info, **kwargs):\n        \"\"\"Creates an Identity Pool Credentials instance from parsed external account info.\n\n        Args:\n            info (Mapping[str, str]): The Identity Pool external account info in Google\n                format.\n            kwargs: Additional arguments to pass to the constructor.\n\n        Returns:\n            google.auth.identity_pool.Credentials: The constructed\n                credentials.\n\n        Raises:\n            ValueError: For invalid parameters.\n        \"\"\"\n        subject_token_supplier = info.get(\"subject_token_supplier\")\n        kwargs.update({\"subject_token_supplier\": subject_token_supplier})\n        return super(Credentials, cls).from_info(info, **kwargs)\n\n    @classmethod\n    def from_file(cls, filename, **kwargs):\n        \"\"\"Creates an IdentityPool Credentials instance from an external account json file.\n\n        Args:\n            filename (str): The path to the IdentityPool external account json file.\n            kwargs: Additional arguments to pass to the constructor.\n\n        Returns:\n            google.auth.identity_pool.Credentials: The constructed\n                credentials.\n        \"\"\"\n        return super(Credentials, cls).from_file(filename, **kwargs)\n", "google/auth/app_engine.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Google App Engine standard environment support.\n\nThis module provides authentication and signing for applications running on App\nEngine in the standard environment using the `App Identity API`_.\n\n\n.. _App Identity API:\n    https://cloud.google.com/appengine/docs/python/appidentity/\n\"\"\"\n\nimport datetime\n\nfrom google.auth import _helpers\nfrom google.auth import credentials\nfrom google.auth import crypt\nfrom google.auth import exceptions\n\n# pytype: disable=import-error\ntry:\n    from google.appengine.api import app_identity  # type: ignore\nexcept ImportError:\n    app_identity = None  # type: ignore\n# pytype: enable=import-error\n\n\nclass Signer(crypt.Signer):\n    \"\"\"Signs messages using the App Engine App Identity service.\n\n    This can be used in place of :class:`google.auth.crypt.Signer` when\n    running in the App Engine standard environment.\n    \"\"\"\n\n    @property\n    def key_id(self):\n        \"\"\"Optional[str]: The key ID used to identify this private key.\n\n        .. warning::\n           This is always ``None``. The key ID used by App Engine can not\n           be reliably determined ahead of time.\n        \"\"\"\n        return None\n\n    @_helpers.copy_docstring(crypt.Signer)\n    def sign(self, message):\n        message = _helpers.to_bytes(message)\n        _, signature = app_identity.sign_blob(message)\n        return signature\n\n\ndef get_project_id():\n    \"\"\"Gets the project ID for the current App Engine application.\n\n    Returns:\n        str: The project ID\n\n    Raises:\n        google.auth.exceptions.OSError: If the App Engine APIs are unavailable.\n    \"\"\"\n    # pylint: disable=missing-raises-doc\n    # Pylint rightfully thinks google.auth.exceptions.OSError is OSError, but doesn't\n    # realize it's a valid alias.\n    if app_identity is None:\n        raise exceptions.OSError(\"The App Engine APIs are not available.\")\n    return app_identity.get_application_id()\n\n\nclass Credentials(\n    credentials.Scoped, credentials.Signing, credentials.CredentialsWithQuotaProject\n):\n    \"\"\"App Engine standard environment credentials.\n\n    These credentials use the App Engine App Identity API to obtain access\n    tokens.\n    \"\"\"\n\n    def __init__(\n        self,\n        scopes=None,\n        default_scopes=None,\n        service_account_id=None,\n        quota_project_id=None,\n    ):\n        \"\"\"\n        Args:\n            scopes (Sequence[str]): Scopes to request from the App Identity\n                API.\n            default_scopes (Sequence[str]): Default scopes passed by a\n                Google client library. Use 'scopes' for user-defined scopes.\n            service_account_id (str): The service account ID passed into\n                :func:`google.appengine.api.app_identity.get_access_token`.\n                If not specified, the default application service account\n                ID will be used.\n            quota_project_id (Optional[str]): The project ID used for quota\n                and billing.\n\n        Raises:\n            google.auth.exceptions.OSError: If the App Engine APIs are unavailable.\n        \"\"\"\n        # pylint: disable=missing-raises-doc\n        # Pylint rightfully thinks google.auth.exceptions.OSError is OSError, but doesn't\n        # realize it's a valid alias.\n        if app_identity is None:\n            raise exceptions.OSError(\"The App Engine APIs are not available.\")\n\n        super(Credentials, self).__init__()\n        self._scopes = scopes\n        self._default_scopes = default_scopes\n        self._service_account_id = service_account_id\n        self._signer = Signer()\n        self._quota_project_id = quota_project_id\n\n    @_helpers.copy_docstring(credentials.Credentials)\n    def refresh(self, request):\n        scopes = self._scopes if self._scopes is not None else self._default_scopes\n        # pylint: disable=unused-argument\n        token, ttl = app_identity.get_access_token(scopes, self._service_account_id)\n        expiry = datetime.datetime.utcfromtimestamp(ttl)\n\n        self.token, self.expiry = token, expiry\n\n    @property\n    def service_account_email(self):\n        \"\"\"The service account email.\"\"\"\n        if self._service_account_id is None:\n            self._service_account_id = app_identity.get_service_account_name()\n        return self._service_account_id\n\n    @property\n    def requires_scopes(self):\n        \"\"\"Checks if the credentials requires scopes.\n\n        Returns:\n            bool: True if there are no scopes set otherwise False.\n        \"\"\"\n        return not self._scopes and not self._default_scopes\n\n    @_helpers.copy_docstring(credentials.Scoped)\n    def with_scopes(self, scopes, default_scopes=None):\n        return self.__class__(\n            scopes=scopes,\n            default_scopes=default_scopes,\n            service_account_id=self._service_account_id,\n            quota_project_id=self.quota_project_id,\n        )\n\n    @_helpers.copy_docstring(credentials.CredentialsWithQuotaProject)\n    def with_quota_project(self, quota_project_id):\n        return self.__class__(\n            scopes=self._scopes,\n            service_account_id=self._service_account_id,\n            quota_project_id=quota_project_id,\n        )\n\n    @_helpers.copy_docstring(credentials.Signing)\n    def sign_bytes(self, message):\n        return self._signer.sign(message)\n\n    @property  # type: ignore\n    @_helpers.copy_docstring(credentials.Signing)\n    def signer_email(self):\n        return self.service_account_email\n\n    @property  # type: ignore\n    @_helpers.copy_docstring(credentials.Signing)\n    def signer(self):\n        return self._signer\n", "google/auth/_exponential_backoff.py": "# Copyright 2022 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport random\nimport time\n\n# The default amount of retry attempts\n_DEFAULT_RETRY_TOTAL_ATTEMPTS = 3\n\n# The default initial backoff period (1.0 second).\n_DEFAULT_INITIAL_INTERVAL_SECONDS = 1.0\n\n# The default randomization factor (0.1 which results in a random period ranging\n# between 10% below and 10% above the retry interval).\n_DEFAULT_RANDOMIZATION_FACTOR = 0.1\n\n# The default multiplier value (2 which is 100% increase per back off).\n_DEFAULT_MULTIPLIER = 2.0\n\n\"\"\"Exponential Backoff Utility\n\nThis is a private module that implements the exponential back off algorithm.\nIt can be used as a utility for code that needs to retry on failure, for example\nan HTTP request.\n\"\"\"\n\n\nclass ExponentialBackoff:\n    \"\"\"An exponential backoff iterator. This can be used in a for loop to\n    perform requests with exponential backoff.\n\n    Args:\n        total_attempts Optional[int]:\n            The maximum amount of retries that should happen.\n            The default value is 3 attempts.\n        initial_wait_seconds Optional[int]:\n            The amount of time to sleep in the first backoff. This parameter\n            should be in seconds.\n            The default value is 1 second.\n        randomization_factor Optional[float]:\n            The amount of jitter that should be in each backoff. For example,\n            a value of 0.1 will introduce a jitter range of 10% to the\n            current backoff period.\n            The default value is 0.1.\n        multiplier Optional[float]:\n            The backoff multipler. This adjusts how much each backoff will\n            increase. For example a value of 2.0 leads to a 200% backoff\n            on each attempt. If the initial_wait is 1.0 it would look like\n            this sequence [1.0, 2.0, 4.0, 8.0].\n            The default value is 2.0.\n    \"\"\"\n\n    def __init__(\n        self,\n        total_attempts=_DEFAULT_RETRY_TOTAL_ATTEMPTS,\n        initial_wait_seconds=_DEFAULT_INITIAL_INTERVAL_SECONDS,\n        randomization_factor=_DEFAULT_RANDOMIZATION_FACTOR,\n        multiplier=_DEFAULT_MULTIPLIER,\n    ):\n        self._total_attempts = total_attempts\n        self._initial_wait_seconds = initial_wait_seconds\n\n        self._current_wait_in_seconds = self._initial_wait_seconds\n\n        self._randomization_factor = randomization_factor\n        self._multiplier = multiplier\n        self._backoff_count = 0\n\n    def __iter__(self):\n        self._backoff_count = 0\n        self._current_wait_in_seconds = self._initial_wait_seconds\n        return self\n\n    def __next__(self):\n        if self._backoff_count >= self._total_attempts:\n            raise StopIteration\n        self._backoff_count += 1\n\n        jitter_variance = self._current_wait_in_seconds * self._randomization_factor\n        jitter = random.uniform(\n            self._current_wait_in_seconds - jitter_variance,\n            self._current_wait_in_seconds + jitter_variance,\n        )\n\n        time.sleep(jitter)\n\n        self._current_wait_in_seconds *= self._multiplier\n        return self._backoff_count\n\n    @property\n    def total_attempts(self):\n        \"\"\"The total amount of backoff attempts that will be made.\"\"\"\n        return self._total_attempts\n\n    @property\n    def backoff_count(self):\n        \"\"\"The current amount of backoff attempts that have been made.\"\"\"\n        return self._backoff_count\n", "google/auth/environment_vars.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Environment variables used by :mod:`google.auth`.\"\"\"\n\n\nPROJECT = \"GOOGLE_CLOUD_PROJECT\"\n\"\"\"Environment variable defining default project.\n\nThis used by :func:`google.auth.default` to explicitly set a project ID. This\nenvironment variable is also used by the Google Cloud Python Library.\n\"\"\"\n\nLEGACY_PROJECT = \"GCLOUD_PROJECT\"\n\"\"\"Previously used environment variable defining the default project.\n\nThis environment variable is used instead of the current one in some\nsituations (such as Google App Engine).\n\"\"\"\n\nGOOGLE_CLOUD_QUOTA_PROJECT = \"GOOGLE_CLOUD_QUOTA_PROJECT\"\n\"\"\"Environment variable defining the project to be used for\nquota and billing.\"\"\"\n\nCREDENTIALS = \"GOOGLE_APPLICATION_CREDENTIALS\"\n\"\"\"Environment variable defining the location of Google application default\ncredentials.\"\"\"\n\n# The environment variable name which can replace ~/.config if set.\nCLOUD_SDK_CONFIG_DIR = \"CLOUDSDK_CONFIG\"\n\"\"\"Environment variable defines the location of Google Cloud SDK's config\nfiles.\"\"\"\n\n# These two variables allow for customization of the addresses used when\n# contacting the GCE metadata service.\nGCE_METADATA_HOST = \"GCE_METADATA_HOST\"\n\"\"\"Environment variable providing an alternate hostname or host:port to be\nused for GCE metadata requests.\n\nThis environment variable was originally named GCE_METADATA_ROOT. The system will\ncheck this environemnt variable first; should there be no value present,\nthe system will fall back to the old variable.\n\"\"\"\n\nGCE_METADATA_ROOT = \"GCE_METADATA_ROOT\"\n\"\"\"Old environment variable for GCE_METADATA_HOST.\"\"\"\n\nGCE_METADATA_IP = \"GCE_METADATA_IP\"\n\"\"\"Environment variable providing an alternate ip:port to be used for ip-only\nGCE metadata requests.\"\"\"\n\nGOOGLE_API_USE_CLIENT_CERTIFICATE = \"GOOGLE_API_USE_CLIENT_CERTIFICATE\"\n\"\"\"Environment variable controlling whether to use client certificate or not.\n\nThe default value is false. Users have to explicitly set this value to true\nin order to use client certificate to establish a mutual TLS channel.\"\"\"\n\nLEGACY_APPENGINE_RUNTIME = \"APPENGINE_RUNTIME\"\n\"\"\"Gen1 environment variable defining the App Engine Runtime.\n\nUsed to distinguish between GAE gen1 and GAE gen2+.\n\"\"\"\n\n# AWS environment variables used with AWS workload identity pools to retrieve\n# AWS security credentials and the AWS region needed to create a serialized\n# signed requests to the AWS STS GetCalledIdentity API that can be exchanged\n# for a Google access tokens via the GCP STS endpoint.\n# When not available the AWS metadata server is used to retrieve these values.\nAWS_ACCESS_KEY_ID = \"AWS_ACCESS_KEY_ID\"\nAWS_SECRET_ACCESS_KEY = \"AWS_SECRET_ACCESS_KEY\"\nAWS_SESSION_TOKEN = \"AWS_SESSION_TOKEN\"\nAWS_REGION = \"AWS_REGION\"\nAWS_DEFAULT_REGION = \"AWS_DEFAULT_REGION\"\n", "google/auth/_refresh_worker.py": "# Copyright 2023 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport copy\nimport logging\nimport threading\n\nimport google.auth.exceptions as e\n\n_LOGGER = logging.getLogger(__name__)\n\n\nclass RefreshThreadManager:\n    \"\"\"\n    Organizes exactly one background job that refresh a token.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initializes the manager.\"\"\"\n\n        self._worker = None\n        self._lock = threading.Lock()  # protects access to worker threads.\n\n    def start_refresh(self, cred, request):\n        \"\"\"Starts a refresh thread for the given credentials.\n        The credentials are refreshed using the request parameter.\n        request and cred MUST not be None\n\n        Returns True if a background refresh was kicked off. False otherwise.\n\n        Args:\n            cred: A credentials object.\n            request: A request object.\n        Returns:\n          bool\n        \"\"\"\n        if cred is None or request is None:\n            raise e.InvalidValue(\n                \"Unable to start refresh. cred and request must be valid and instantiated objects.\"\n            )\n\n        with self._lock:\n            if self._worker is not None and self._worker._error_info is not None:\n                return False\n\n            if self._worker is None or not self._worker.is_alive():  # pragma: NO COVER\n                self._worker = RefreshThread(cred=cred, request=copy.deepcopy(request))\n                self._worker.start()\n        return True\n\n    def clear_error(self):\n        \"\"\"\n      Removes any errors that were stored from previous background refreshes.\n      \"\"\"\n        with self._lock:\n            if self._worker:\n                self._worker._error_info = None\n\n    def __getstate__(self):\n        \"\"\"Pickle helper that serializes the _lock attribute.\"\"\"\n        state = self.__dict__.copy()\n        state[\"_lock\"] = None\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Pickle helper that deserializes the _lock attribute.\"\"\"\n        state[\"_lock\"] = threading.Lock()\n        self.__dict__.update(state)\n\n\nclass RefreshThread(threading.Thread):\n    \"\"\"\n    Thread that refreshes credentials.\n    \"\"\"\n\n    def __init__(self, cred, request, **kwargs):\n        \"\"\"Initializes the thread.\n\n        Args:\n            cred: A Credential object to refresh.\n            request: A Request object used to perform a credential refresh.\n            **kwargs: Additional keyword arguments.\n        \"\"\"\n\n        super().__init__(**kwargs)\n        self._cred = cred\n        self._request = request\n        self._error_info = None\n\n    def run(self):\n        \"\"\"\n        Perform the credential refresh.\n        \"\"\"\n        try:\n            self._cred.refresh(self._request)\n        except Exception as err:  # pragma: NO COVER\n            _LOGGER.error(f\"Background refresh failed due to: {err}\")\n            self._error_info = err\n", "google/auth/__init__.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Google Auth Library for Python.\"\"\"\n\nimport logging\nimport sys\nimport warnings\n\nfrom google.auth import version as google_auth_version\nfrom google.auth._default import (\n    default,\n    load_credentials_from_dict,\n    load_credentials_from_file,\n)\n\n\n__version__ = google_auth_version.__version__\n\n\n__all__ = [\"default\", \"load_credentials_from_file\", \"load_credentials_from_dict\"]\n\n\nclass Python37DeprecationWarning(DeprecationWarning):  # pragma: NO COVER\n    \"\"\"\n    Deprecation warning raised when Python 3.7 runtime is detected.\n    Python 3.7 support will be dropped after January 1, 2024.\n    \"\"\"\n\n    pass\n\n\n# Checks if the current runtime is Python 3.7.\nif sys.version_info.major == 3 and sys.version_info.minor == 7:  # pragma: NO COVER\n    message = (\n        \"After January 1, 2024, new releases of this library will drop support \"\n        \"for Python 3.7.\"\n    )\n    warnings.warn(message, Python37DeprecationWarning)\n\n# Set default logging handler to avoid \"No handler found\" warnings.\nlogging.getLogger(__name__).addHandler(logging.NullHandler())\n", "google/auth/_helpers.py": "# Copyright 2015 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Helper functions for commonly used utilities.\"\"\"\n\nimport base64\nimport calendar\nimport datetime\nfrom email.message import Message\nimport sys\nimport urllib\n\nfrom google.auth import exceptions\n\n# The smallest MDS cache used by this library stores tokens until 4 minutes from\n# expiry.\nREFRESH_THRESHOLD = datetime.timedelta(minutes=3, seconds=45)\n\n\ndef copy_docstring(source_class):\n    \"\"\"Decorator that copies a method's docstring from another class.\n\n    Args:\n        source_class (type): The class that has the documented method.\n\n    Returns:\n        Callable: A decorator that will copy the docstring of the same\n            named method in the source class to the decorated method.\n    \"\"\"\n\n    def decorator(method):\n        \"\"\"Decorator implementation.\n\n        Args:\n            method (Callable): The method to copy the docstring to.\n\n        Returns:\n            Callable: the same method passed in with an updated docstring.\n\n        Raises:\n            google.auth.exceptions.InvalidOperation: if the method already has a docstring.\n        \"\"\"\n        if method.__doc__:\n            raise exceptions.InvalidOperation(\"Method already has a docstring.\")\n\n        source_method = getattr(source_class, method.__name__)\n        method.__doc__ = source_method.__doc__\n\n        return method\n\n    return decorator\n\n\ndef parse_content_type(header_value):\n    \"\"\"Parse a 'content-type' header value to get just the plain media-type (without parameters).\n\n    This is done using the class Message from email.message as suggested in PEP 594\n        (because the cgi is now deprecated and will be removed in python 3.13,\n        see https://peps.python.org/pep-0594/#cgi).\n\n    Args:\n        header_value (str): The value of a 'content-type' header as a string.\n\n    Returns:\n        str: A string with just the lowercase media-type from the parsed 'content-type' header.\n            If the provided content-type is not parsable, returns 'text/plain',\n            the default value for textual files.\n    \"\"\"\n    m = Message()\n    m[\"content-type\"] = header_value\n    return (\n        m.get_content_type()\n    )  # Despite the name, actually returns just the media-type\n\n\ndef utcnow():\n    \"\"\"Returns the current UTC datetime.\n\n    Returns:\n        datetime: The current time in UTC.\n    \"\"\"\n    # We used datetime.utcnow() before, since it's deprecated from python 3.12,\n    # we are using datetime.now(timezone.utc) now. \"utcnow()\" is offset-native\n    # (no timezone info), but \"now()\" is offset-aware (with timezone info).\n    # This will cause datetime comparison problem. For backward compatibility,\n    # we need to remove the timezone info.\n    now = datetime.datetime.now(datetime.timezone.utc)\n    now = now.replace(tzinfo=None)\n    return now\n\n\ndef datetime_to_secs(value):\n    \"\"\"Convert a datetime object to the number of seconds since the UNIX epoch.\n\n    Args:\n        value (datetime): The datetime to convert.\n\n    Returns:\n        int: The number of seconds since the UNIX epoch.\n    \"\"\"\n    return calendar.timegm(value.utctimetuple())\n\n\ndef to_bytes(value, encoding=\"utf-8\"):\n    \"\"\"Converts a string value to bytes, if necessary.\n\n    Args:\n        value (Union[str, bytes]): The value to be converted.\n        encoding (str): The encoding to use to convert unicode to bytes.\n            Defaults to \"utf-8\".\n\n    Returns:\n        bytes: The original value converted to bytes (if unicode) or as\n            passed in if it started out as bytes.\n\n    Raises:\n        google.auth.exceptions.InvalidValue: If the value could not be converted to bytes.\n    \"\"\"\n    result = value.encode(encoding) if isinstance(value, str) else value\n    if isinstance(result, bytes):\n        return result\n    else:\n        raise exceptions.InvalidValue(\n            \"{0!r} could not be converted to bytes\".format(value)\n        )\n\n\ndef from_bytes(value):\n    \"\"\"Converts bytes to a string value, if necessary.\n\n    Args:\n        value (Union[str, bytes]): The value to be converted.\n\n    Returns:\n        str: The original value converted to unicode (if bytes) or as passed in\n            if it started out as unicode.\n\n    Raises:\n        google.auth.exceptions.InvalidValue: If the value could not be converted to unicode.\n    \"\"\"\n    result = value.decode(\"utf-8\") if isinstance(value, bytes) else value\n    if isinstance(result, str):\n        return result\n    else:\n        raise exceptions.InvalidValue(\n            \"{0!r} could not be converted to unicode\".format(value)\n        )\n\n\ndef update_query(url, params, remove=None):\n    \"\"\"Updates a URL's query parameters.\n\n    Replaces any current values if they are already present in the URL.\n\n    Args:\n        url (str): The URL to update.\n        params (Mapping[str, str]): A mapping of query parameter\n            keys to values.\n        remove (Sequence[str]): Parameters to remove from the query string.\n\n    Returns:\n        str: The URL with updated query parameters.\n\n    Examples:\n\n        >>> url = 'http://example.com?a=1'\n        >>> update_query(url, {'a': '2'})\n        http://example.com?a=2\n        >>> update_query(url, {'b': '3'})\n        http://example.com?a=1&b=3\n        >> update_query(url, {'b': '3'}, remove=['a'])\n        http://example.com?b=3\n\n    \"\"\"\n    if remove is None:\n        remove = []\n\n    # Split the URL into parts.\n    parts = urllib.parse.urlparse(url)\n    # Parse the query string.\n    query_params = urllib.parse.parse_qs(parts.query)\n    # Update the query parameters with the new parameters.\n    query_params.update(params)\n    # Remove any values specified in remove.\n    query_params = {\n        key: value for key, value in query_params.items() if key not in remove\n    }\n    # Re-encoded the query string.\n    new_query = urllib.parse.urlencode(query_params, doseq=True)\n    # Unsplit the url.\n    new_parts = parts._replace(query=new_query)\n    return urllib.parse.urlunparse(new_parts)\n\n\ndef scopes_to_string(scopes):\n    \"\"\"Converts scope value to a string suitable for sending to OAuth 2.0\n    authorization servers.\n\n    Args:\n        scopes (Sequence[str]): The sequence of scopes to convert.\n\n    Returns:\n        str: The scopes formatted as a single string.\n    \"\"\"\n    return \" \".join(scopes)\n\n\ndef string_to_scopes(scopes):\n    \"\"\"Converts stringifed scopes value to a list.\n\n    Args:\n        scopes (Union[Sequence, str]): The string of space-separated scopes\n            to convert.\n    Returns:\n        Sequence(str): The separated scopes.\n    \"\"\"\n    if not scopes:\n        return []\n\n    return scopes.split(\" \")\n\n\ndef padded_urlsafe_b64decode(value):\n    \"\"\"Decodes base64 strings lacking padding characters.\n\n    Google infrastructure tends to omit the base64 padding characters.\n\n    Args:\n        value (Union[str, bytes]): The encoded value.\n\n    Returns:\n        bytes: The decoded value\n    \"\"\"\n    b64string = to_bytes(value)\n    padded = b64string + b\"=\" * (-len(b64string) % 4)\n    return base64.urlsafe_b64decode(padded)\n\n\ndef unpadded_urlsafe_b64encode(value):\n    \"\"\"Encodes base64 strings removing any padding characters.\n\n    `rfc 7515`_ defines Base64url to NOT include any padding\n    characters, but the stdlib doesn't do that by default.\n\n    _rfc7515: https://tools.ietf.org/html/rfc7515#page-6\n\n    Args:\n        value (Union[str|bytes]): The bytes-like value to encode\n\n    Returns:\n        Union[str|bytes]: The encoded value\n    \"\"\"\n    return base64.urlsafe_b64encode(value).rstrip(b\"=\")\n\n\ndef is_python_3():\n    \"\"\"Check if the Python interpreter is Python 2 or 3.\n\n    Returns:\n        bool: True if the Python interpreter is Python 3 and False otherwise.\n    \"\"\"\n    return sys.version_info > (3, 0)\n", "google/auth/aws.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"AWS Credentials and AWS Signature V4 Request Signer.\n\nThis module provides credentials to access Google Cloud resources from Amazon\nWeb Services (AWS) workloads. These credentials are recommended over the\nuse of service account credentials in AWS as they do not involve the management\nof long-live service account private keys.\n\nAWS Credentials are initialized using external_account arguments which are\ntypically loaded from the external credentials JSON file.\n\nThis module also provides a definition for an abstract AWS security credentials supplier.\nThis supplier can be implemented to return valid AWS security credentials and an AWS region\nand used to create AWS credentials. The credentials will then call the\nsupplier instead of using pre-defined methods such as calling the EC2 metadata endpoints.\n\nThis module also provides a basic implementation of the\n`AWS Signature Version 4`_ request signing algorithm.\n\nAWS Credentials use serialized signed requests to the\n`AWS STS GetCallerIdentity`_ API that can be exchanged for Google access tokens\nvia the GCP STS endpoint.\n\n.. _AWS Signature Version 4: https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html\n.. _AWS STS GetCallerIdentity: https://docs.aws.amazon.com/STS/latest/APIReference/API_GetCallerIdentity.html\n\"\"\"\n\nimport abc\nfrom dataclasses import dataclass\nimport hashlib\nimport hmac\nimport http.client as http_client\nimport json\nimport os\nimport posixpath\nimport re\nfrom typing import Optional\nimport urllib\nfrom urllib.parse import urljoin\n\nfrom google.auth import _helpers\nfrom google.auth import environment_vars\nfrom google.auth import exceptions\nfrom google.auth import external_account\n\n# AWS Signature Version 4 signing algorithm identifier.\n_AWS_ALGORITHM = \"AWS4-HMAC-SHA256\"\n# The termination string for the AWS credential scope value as defined in\n# https://docs.aws.amazon.com/general/latest/gr/sigv4-create-string-to-sign.html\n_AWS_REQUEST_TYPE = \"aws4_request\"\n# The AWS authorization header name for the security session token if available.\n_AWS_SECURITY_TOKEN_HEADER = \"x-amz-security-token\"\n# The AWS authorization header name for the auto-generated date.\n_AWS_DATE_HEADER = \"x-amz-date\"\n# The default AWS regional credential verification URL.\n_DEFAULT_AWS_REGIONAL_CREDENTIAL_VERIFICATION_URL = (\n    \"https://sts.{region}.amazonaws.com?Action=GetCallerIdentity&Version=2011-06-15\"\n)\n# IMDSV2 session token lifetime. This is set to a low value because the session token is used immediately.\n_IMDSV2_SESSION_TOKEN_TTL_SECONDS = \"300\"\n\n\nclass RequestSigner(object):\n    \"\"\"Implements an AWS request signer based on the AWS Signature Version 4 signing\n    process.\n    https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html\n    \"\"\"\n\n    def __init__(self, region_name):\n        \"\"\"Instantiates an AWS request signer used to compute authenticated signed\n        requests to AWS APIs based on the AWS Signature Version 4 signing process.\n\n        Args:\n            region_name (str): The AWS region to use.\n        \"\"\"\n\n        self._region_name = region_name\n\n    def get_request_options(\n        self,\n        aws_security_credentials,\n        url,\n        method,\n        request_payload=\"\",\n        additional_headers={},\n    ):\n        \"\"\"Generates the signed request for the provided HTTP request for calling\n        an AWS API. This follows the steps described at:\n        https://docs.aws.amazon.com/general/latest/gr/sigv4_signing.html\n\n        Args:\n            aws_security_credentials (AWSSecurityCredentials): The AWS security credentials.\n            url (str): The AWS service URL containing the canonical URI and\n                query string.\n            method (str): The HTTP method used to call this API.\n            request_payload (Optional[str]): The optional request payload if\n                available.\n            additional_headers (Optional[Mapping[str, str]]): The optional\n                additional headers needed for the requested AWS API.\n\n        Returns:\n            Mapping[str, str]: The AWS signed request dictionary object.\n        \"\"\"\n\n        additional_headers = additional_headers or {}\n\n        uri = urllib.parse.urlparse(url)\n        # Normalize the URL path. This is needed for the canonical_uri.\n        # os.path.normpath can't be used since it normalizes \"/\" paths\n        # to \"\\\\\" in Windows OS.\n        normalized_uri = urllib.parse.urlparse(\n            urljoin(url, posixpath.normpath(uri.path))\n        )\n        # Validate provided URL.\n        if not uri.hostname or uri.scheme != \"https\":\n            raise exceptions.InvalidResource(\"Invalid AWS service URL\")\n\n        header_map = _generate_authentication_header_map(\n            host=uri.hostname,\n            canonical_uri=normalized_uri.path or \"/\",\n            canonical_querystring=_get_canonical_querystring(uri.query),\n            method=method,\n            region=self._region_name,\n            aws_security_credentials=aws_security_credentials,\n            request_payload=request_payload,\n            additional_headers=additional_headers,\n        )\n        headers = {\n            \"Authorization\": header_map.get(\"authorization_header\"),\n            \"host\": uri.hostname,\n        }\n        # Add x-amz-date if available.\n        if \"amz_date\" in header_map:\n            headers[_AWS_DATE_HEADER] = header_map.get(\"amz_date\")\n        # Append additional optional headers, eg. X-Amz-Target, Content-Type, etc.\n        for key in additional_headers:\n            headers[key] = additional_headers[key]\n\n        # Add session token if available.\n        if aws_security_credentials.session_token is not None:\n            headers[_AWS_SECURITY_TOKEN_HEADER] = aws_security_credentials.session_token\n\n        signed_request = {\"url\": url, \"method\": method, \"headers\": headers}\n        if request_payload:\n            signed_request[\"data\"] = request_payload\n        return signed_request\n\n\ndef _get_canonical_querystring(query):\n    \"\"\"Generates the canonical query string given a raw query string.\n    Logic is based on\n    https://docs.aws.amazon.com/general/latest/gr/sigv4-create-canonical-request.html\n\n    Args:\n        query (str): The raw query string.\n\n    Returns:\n        str: The canonical query string.\n    \"\"\"\n    # Parse raw query string.\n    querystring = urllib.parse.parse_qs(query)\n    querystring_encoded_map = {}\n    for key in querystring:\n        quote_key = urllib.parse.quote(key, safe=\"-_.~\")\n        # URI encode key.\n        querystring_encoded_map[quote_key] = []\n        for item in querystring[key]:\n            # For each key, URI encode all values for that key.\n            querystring_encoded_map[quote_key].append(\n                urllib.parse.quote(item, safe=\"-_.~\")\n            )\n        # Sort values for each key.\n        querystring_encoded_map[quote_key].sort()\n    # Sort keys.\n    sorted_keys = list(querystring_encoded_map.keys())\n    sorted_keys.sort()\n    # Reconstruct the query string. Preserve keys with multiple values.\n    querystring_encoded_pairs = []\n    for key in sorted_keys:\n        for item in querystring_encoded_map[key]:\n            querystring_encoded_pairs.append(\"{}={}\".format(key, item))\n    return \"&\".join(querystring_encoded_pairs)\n\n\ndef _sign(key, msg):\n    \"\"\"Creates the HMAC-SHA256 hash of the provided message using the provided\n    key.\n\n    Args:\n        key (str): The HMAC-SHA256 key to use.\n        msg (str): The message to hash.\n\n    Returns:\n        str: The computed hash bytes.\n    \"\"\"\n    return hmac.new(key, msg.encode(\"utf-8\"), hashlib.sha256).digest()\n\n\ndef _get_signing_key(key, date_stamp, region_name, service_name):\n    \"\"\"Calculates the signing key used to calculate the signature for\n    AWS Signature Version 4 based on:\n    https://docs.aws.amazon.com/general/latest/gr/sigv4-calculate-signature.html\n\n    Args:\n        key (str): The AWS secret access key.\n        date_stamp (str): The '%Y%m%d' date format.\n        region_name (str): The AWS region.\n        service_name (str): The AWS service name, eg. sts.\n\n    Returns:\n        str: The signing key bytes.\n    \"\"\"\n    k_date = _sign((\"AWS4\" + key).encode(\"utf-8\"), date_stamp)\n    k_region = _sign(k_date, region_name)\n    k_service = _sign(k_region, service_name)\n    k_signing = _sign(k_service, \"aws4_request\")\n    return k_signing\n\n\ndef _generate_authentication_header_map(\n    host,\n    canonical_uri,\n    canonical_querystring,\n    method,\n    region,\n    aws_security_credentials,\n    request_payload=\"\",\n    additional_headers={},\n):\n    \"\"\"Generates the authentication header map needed for generating the AWS\n    Signature Version 4 signed request.\n\n    Args:\n        host (str): The AWS service URL hostname.\n        canonical_uri (str): The AWS service URL path name.\n        canonical_querystring (str): The AWS service URL query string.\n        method (str): The HTTP method used to call this API.\n        region (str): The AWS region.\n        aws_security_credentials (AWSSecurityCredentials): The AWS security credentials.\n        request_payload (Optional[str]): The optional request payload if\n            available.\n        additional_headers (Optional[Mapping[str, str]]): The optional\n            additional headers needed for the requested AWS API.\n\n    Returns:\n        Mapping[str, str]: The AWS authentication header dictionary object.\n            This contains the x-amz-date and authorization header information.\n    \"\"\"\n    # iam.amazonaws.com host => iam service.\n    # sts.us-east-2.amazonaws.com host => sts service.\n    service_name = host.split(\".\")[0]\n\n    current_time = _helpers.utcnow()\n    amz_date = current_time.strftime(\"%Y%m%dT%H%M%SZ\")\n    date_stamp = current_time.strftime(\"%Y%m%d\")\n\n    # Change all additional headers to be lower case.\n    full_headers = {}\n    for key in additional_headers:\n        full_headers[key.lower()] = additional_headers[key]\n    # Add AWS session token if available.\n    if aws_security_credentials.session_token is not None:\n        full_headers[\n            _AWS_SECURITY_TOKEN_HEADER\n        ] = aws_security_credentials.session_token\n\n    # Required headers\n    full_headers[\"host\"] = host\n    # Do not use generated x-amz-date if the date header is provided.\n    # Previously the date was not fixed with x-amz- and could be provided\n    # manually.\n    # https://github.com/boto/botocore/blob/879f8440a4e9ace5d3cf145ce8b3d5e5ffb892ef/tests/unit/auth/aws4_testsuite/get-header-value-trim.req\n    if \"date\" not in full_headers:\n        full_headers[_AWS_DATE_HEADER] = amz_date\n\n    # Header keys need to be sorted alphabetically.\n    canonical_headers = \"\"\n    header_keys = list(full_headers.keys())\n    header_keys.sort()\n    for key in header_keys:\n        canonical_headers = \"{}{}:{}\\n\".format(\n            canonical_headers, key, full_headers[key]\n        )\n    signed_headers = \";\".join(header_keys)\n\n    payload_hash = hashlib.sha256((request_payload or \"\").encode(\"utf-8\")).hexdigest()\n\n    # https://docs.aws.amazon.com/general/latest/gr/sigv4-create-canonical-request.html\n    canonical_request = \"{}\\n{}\\n{}\\n{}\\n{}\\n{}\".format(\n        method,\n        canonical_uri,\n        canonical_querystring,\n        canonical_headers,\n        signed_headers,\n        payload_hash,\n    )\n\n    credential_scope = \"{}/{}/{}/{}\".format(\n        date_stamp, region, service_name, _AWS_REQUEST_TYPE\n    )\n\n    # https://docs.aws.amazon.com/general/latest/gr/sigv4-create-string-to-sign.html\n    string_to_sign = \"{}\\n{}\\n{}\\n{}\".format(\n        _AWS_ALGORITHM,\n        amz_date,\n        credential_scope,\n        hashlib.sha256(canonical_request.encode(\"utf-8\")).hexdigest(),\n    )\n\n    # https://docs.aws.amazon.com/general/latest/gr/sigv4-calculate-signature.html\n    signing_key = _get_signing_key(\n        aws_security_credentials.secret_access_key, date_stamp, region, service_name\n    )\n    signature = hmac.new(\n        signing_key, string_to_sign.encode(\"utf-8\"), hashlib.sha256\n    ).hexdigest()\n\n    # https://docs.aws.amazon.com/general/latest/gr/sigv4-add-signature-to-request.html\n    authorization_header = \"{} Credential={}/{}, SignedHeaders={}, Signature={}\".format(\n        _AWS_ALGORITHM,\n        aws_security_credentials.access_key_id,\n        credential_scope,\n        signed_headers,\n        signature,\n    )\n\n    authentication_header = {\"authorization_header\": authorization_header}\n    # Do not use generated x-amz-date if the date header is provided.\n    if \"date\" not in full_headers:\n        authentication_header[\"amz_date\"] = amz_date\n    return authentication_header\n\n\n@dataclass\nclass AwsSecurityCredentials:\n    \"\"\"A class that models AWS security credentials with an optional session token.\n\n        Attributes:\n            access_key_id (str): The AWS security credentials access key id.\n            secret_access_key (str): The AWS security credentials secret access key.\n            session_token (Optional[str]): The optional AWS security credentials session token. This should be set when using temporary credentials.\n    \"\"\"\n\n    access_key_id: str\n    secret_access_key: str\n    session_token: Optional[str] = None\n\n\nclass AwsSecurityCredentialsSupplier(metaclass=abc.ABCMeta):\n    \"\"\"Base class for AWS security credential suppliers. This can be implemented with custom logic to retrieve\n    AWS security credentials to exchange for a Google Cloud access token. The AWS external account credential does\n    not cache the AWS security credentials, so caching logic should be added in the implementation.\n    \"\"\"\n\n    @abc.abstractmethod\n    def get_aws_security_credentials(self, context, request):\n        \"\"\"Returns the AWS security credentials for the requested context.\n\n        .. warning: This is not cached by the calling Google credential, so caching logic should be implemented in the supplier.\n\n        Args:\n            context (google.auth.externalaccount.SupplierContext): The context object\n                containing information about the requested audience and subject token type.\n            request (google.auth.transport.Request): The object used to make\n                HTTP requests.\n\n        Raises:\n            google.auth.exceptions.RefreshError: If an error is encountered during\n                security credential retrieval logic.\n\n        Returns:\n            AwsSecurityCredentials: The requested AWS security credentials.\n        \"\"\"\n        raise NotImplementedError(\"\")\n\n    @abc.abstractmethod\n    def get_aws_region(self, context, request):\n        \"\"\"Returns the AWS region for the requested context.\n\n        Args:\n            context (google.auth.externalaccount.SupplierContext): The context object\n                containing information about the requested audience and subject token type.\n            request (google.auth.transport.Request): The object used to make\n                HTTP requests.\n\n        Raises:\n            google.auth.exceptions.RefreshError: If an error is encountered during\n                region retrieval logic.\n\n        Returns:\n            str: The AWS region.\n        \"\"\"\n        raise NotImplementedError(\"\")\n\n\nclass _DefaultAwsSecurityCredentialsSupplier(AwsSecurityCredentialsSupplier):\n    \"\"\"Default implementation of AWS security credentials supplier. Supports retrieving\n    credentials and region via EC2 metadata endpoints and environment variables.\n    \"\"\"\n\n    def __init__(self, credential_source):\n        self._region_url = credential_source.get(\"region_url\")\n        self._security_credentials_url = credential_source.get(\"url\")\n        self._imdsv2_session_token_url = credential_source.get(\n            \"imdsv2_session_token_url\"\n        )\n\n    @_helpers.copy_docstring(AwsSecurityCredentialsSupplier)\n    def get_aws_security_credentials(self, context, request):\n\n        # Check environment variables for permanent credentials first.\n        # https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html\n        env_aws_access_key_id = os.environ.get(environment_vars.AWS_ACCESS_KEY_ID)\n        env_aws_secret_access_key = os.environ.get(\n            environment_vars.AWS_SECRET_ACCESS_KEY\n        )\n        # This is normally not available for permanent credentials.\n        env_aws_session_token = os.environ.get(environment_vars.AWS_SESSION_TOKEN)\n        if env_aws_access_key_id and env_aws_secret_access_key:\n            return AwsSecurityCredentials(\n                env_aws_access_key_id, env_aws_secret_access_key, env_aws_session_token\n            )\n\n        imdsv2_session_token = self._get_imdsv2_session_token(request)\n        role_name = self._get_metadata_role_name(request, imdsv2_session_token)\n\n        # Get security credentials.\n        credentials = self._get_metadata_security_credentials(\n            request, role_name, imdsv2_session_token\n        )\n\n        return AwsSecurityCredentials(\n            credentials.get(\"AccessKeyId\"),\n            credentials.get(\"SecretAccessKey\"),\n            credentials.get(\"Token\"),\n        )\n\n    @_helpers.copy_docstring(AwsSecurityCredentialsSupplier)\n    def get_aws_region(self, context, request):\n        # The AWS metadata server is not available in some AWS environments\n        # such as AWS lambda. Instead, it is available via environment\n        # variable.\n        env_aws_region = os.environ.get(environment_vars.AWS_REGION)\n        if env_aws_region is not None:\n            return env_aws_region\n\n        env_aws_region = os.environ.get(environment_vars.AWS_DEFAULT_REGION)\n        if env_aws_region is not None:\n            return env_aws_region\n\n        if not self._region_url:\n            raise exceptions.RefreshError(\"Unable to determine AWS region\")\n\n        headers = None\n        imdsv2_session_token = self._get_imdsv2_session_token(request)\n        if imdsv2_session_token is not None:\n            headers = {\"X-aws-ec2-metadata-token\": imdsv2_session_token}\n\n        response = request(url=self._region_url, method=\"GET\", headers=headers)\n\n        # Support both string and bytes type response.data.\n        response_body = (\n            response.data.decode(\"utf-8\")\n            if hasattr(response.data, \"decode\")\n            else response.data\n        )\n\n        if response.status != http_client.OK:\n            raise exceptions.RefreshError(\n                \"Unable to retrieve AWS region: {}\".format(response_body)\n            )\n\n        # This endpoint will return the region in format: us-east-2b.\n        # Only the us-east-2 part should be used.\n        return response_body[:-1]\n\n    def _get_imdsv2_session_token(self, request):\n        if request is not None and self._imdsv2_session_token_url is not None:\n            headers = {\n                \"X-aws-ec2-metadata-token-ttl-seconds\": _IMDSV2_SESSION_TOKEN_TTL_SECONDS\n            }\n\n            imdsv2_session_token_response = request(\n                url=self._imdsv2_session_token_url, method=\"PUT\", headers=headers\n            )\n\n            if imdsv2_session_token_response.status != http_client.OK:\n                raise exceptions.RefreshError(\n                    \"Unable to retrieve AWS Session Token: {}\".format(\n                        imdsv2_session_token_response.data\n                    )\n                )\n\n            return imdsv2_session_token_response.data\n        else:\n            return None\n\n    def _get_metadata_security_credentials(\n        self, request, role_name, imdsv2_session_token\n    ):\n        \"\"\"Retrieves the AWS security credentials required for signing AWS\n        requests from the AWS metadata server.\n\n        Args:\n            request (google.auth.transport.Request): A callable used to make\n                HTTP requests.\n            role_name (str): The AWS role name required by the AWS metadata\n                server security_credentials endpoint in order to return the\n                credentials.\n            imdsv2_session_token (str): The AWS IMDSv2 session token to be added as a\n                header in the requests to AWS metadata endpoint.\n\n        Returns:\n            Mapping[str, str]: The AWS metadata server security credentials\n                response.\n\n        Raises:\n            google.auth.exceptions.RefreshError: If an error occurs while\n                retrieving the AWS security credentials.\n        \"\"\"\n        headers = {\"Content-Type\": \"application/json\"}\n        if imdsv2_session_token is not None:\n            headers[\"X-aws-ec2-metadata-token\"] = imdsv2_session_token\n\n        response = request(\n            url=\"{}/{}\".format(self._security_credentials_url, role_name),\n            method=\"GET\",\n            headers=headers,\n        )\n\n        # support both string and bytes type response.data\n        response_body = (\n            response.data.decode(\"utf-8\")\n            if hasattr(response.data, \"decode\")\n            else response.data\n        )\n\n        if response.status != http_client.OK:\n            raise exceptions.RefreshError(\n                \"Unable to retrieve AWS security credentials: {}\".format(response_body)\n            )\n\n        credentials_response = json.loads(response_body)\n\n        return credentials_response\n\n    def _get_metadata_role_name(self, request, imdsv2_session_token):\n        \"\"\"Retrieves the AWS role currently attached to the current AWS\n        workload by querying the AWS metadata server. This is needed for the\n        AWS metadata server security credentials endpoint in order to retrieve\n        the AWS security credentials needed to sign requests to AWS APIs.\n\n        Args:\n            request (google.auth.transport.Request): A callable used to make\n                HTTP requests.\n            imdsv2_session_token (str): The AWS IMDSv2 session token to be added as a\n                header in the requests to AWS metadata endpoint.\n\n        Returns:\n            str: The AWS role name.\n\n        Raises:\n            google.auth.exceptions.RefreshError: If an error occurs while\n                retrieving the AWS role name.\n        \"\"\"\n        if self._security_credentials_url is None:\n            raise exceptions.RefreshError(\n                \"Unable to determine the AWS metadata server security credentials endpoint\"\n            )\n\n        headers = None\n        if imdsv2_session_token is not None:\n            headers = {\"X-aws-ec2-metadata-token\": imdsv2_session_token}\n\n        response = request(\n            url=self._security_credentials_url, method=\"GET\", headers=headers\n        )\n\n        # support both string and bytes type response.data\n        response_body = (\n            response.data.decode(\"utf-8\")\n            if hasattr(response.data, \"decode\")\n            else response.data\n        )\n\n        if response.status != http_client.OK:\n            raise exceptions.RefreshError(\n                \"Unable to retrieve AWS role name {}\".format(response_body)\n            )\n\n        return response_body\n\n\nclass Credentials(external_account.Credentials):\n    \"\"\"AWS external account credentials.\n    This is used to exchange serialized AWS signature v4 signed requests to\n    AWS STS GetCallerIdentity service for Google access tokens.\n    \"\"\"\n\n    def __init__(\n        self,\n        audience,\n        subject_token_type,\n        token_url=external_account._DEFAULT_TOKEN_URL,\n        credential_source=None,\n        aws_security_credentials_supplier=None,\n        *args,\n        **kwargs\n    ):\n        \"\"\"Instantiates an AWS workload external account credentials object.\n\n        Args:\n            audience (str): The STS audience field.\n            subject_token_type (str): The subject token type based on the Oauth2.0 token exchange spec.\n                Expected values include::\n\n                    \u201curn:ietf:params:aws:token-type:aws4_request\u201d\n\n            token_url (Optional [str]): The STS endpoint URL. If not provided, will default to \"https://sts.googleapis.com/v1/token\".\n            credential_source (Optional [Mapping]): The credential source dictionary used\n                to provide instructions on how to retrieve external credential to be exchanged for Google access tokens.\n                Either a credential source or an AWS security credentials supplier must be provided.\n\n                Example credential_source for AWS credential::\n\n                    {\n                        \"environment_id\": \"aws1\",\n                        \"regional_cred_verification_url\": \"https://sts.{region}.amazonaws.com?Action=GetCallerIdentity&Version=2011-06-15\",\n                        \"region_url\": \"http://169.254.169.254/latest/meta-data/placement/availability-zone\",\n                        \"url\": \"http://169.254.169.254/latest/meta-data/iam/security-credentials\",\n                        imdsv2_session_token_url\": \"http://169.254.169.254/latest/api/token\"\n                    }\n\n            aws_security_credentials_supplier (Optional [AwsSecurityCredentialsSupplier]): Optional AWS security credentials supplier.\n                This will be called to supply valid AWS security credentails which will then\n                be exchanged for Google access tokens. Either an AWS security credentials supplier\n                or a credential source must be provided.\n            args (List): Optional positional arguments passed into the underlying :meth:`~external_account.Credentials.__init__` method.\n            kwargs (Mapping): Optional keyword arguments passed into the underlying :meth:`~external_account.Credentials.__init__` method.\n\n        Raises:\n            google.auth.exceptions.RefreshError: If an error is encountered during\n                access token retrieval logic.\n            ValueError: For invalid parameters.\n\n        .. note:: Typically one of the helper constructors\n            :meth:`from_file` or\n            :meth:`from_info` are used instead of calling the constructor directly.\n        \"\"\"\n        super(Credentials, self).__init__(\n            audience=audience,\n            subject_token_type=subject_token_type,\n            token_url=token_url,\n            credential_source=credential_source,\n            *args,\n            **kwargs\n        )\n        if credential_source is None and aws_security_credentials_supplier is None:\n            raise exceptions.InvalidValue(\n                \"A valid credential source or AWS security credentials supplier must be provided.\"\n            )\n        if (\n            credential_source is not None\n            and aws_security_credentials_supplier is not None\n        ):\n            raise exceptions.InvalidValue(\n                \"AWS credential cannot have both a credential source and an AWS security credentials supplier.\"\n            )\n\n        if aws_security_credentials_supplier:\n            self._aws_security_credentials_supplier = aws_security_credentials_supplier\n            # The regional cred verification URL would normally be provided through the credential source. So set it to the default one here.\n            self._cred_verification_url = (\n                _DEFAULT_AWS_REGIONAL_CREDENTIAL_VERIFICATION_URL\n            )\n        else:\n            environment_id = credential_source.get(\"environment_id\") or \"\"\n            self._aws_security_credentials_supplier = _DefaultAwsSecurityCredentialsSupplier(\n                credential_source\n            )\n            self._cred_verification_url = credential_source.get(\n                \"regional_cred_verification_url\"\n            )\n\n            # Get the environment ID, i.e. \"aws1\". Currently, only one version supported (1).\n            matches = re.match(r\"^(aws)([\\d]+)$\", environment_id)\n            if matches:\n                env_id, env_version = matches.groups()\n            else:\n                env_id, env_version = (None, None)\n\n            if env_id != \"aws\" or self._cred_verification_url is None:\n                raise exceptions.InvalidResource(\n                    \"No valid AWS 'credential_source' provided\"\n                )\n            elif env_version is None or int(env_version) != 1:\n                raise exceptions.InvalidValue(\n                    \"aws version '{}' is not supported in the current build.\".format(\n                        env_version\n                    )\n                )\n\n        self._target_resource = audience\n        self._request_signer = None\n\n    def retrieve_subject_token(self, request):\n        \"\"\"Retrieves the subject token using the credential_source object.\n        The subject token is a serialized `AWS GetCallerIdentity signed request`_.\n\n        The logic is summarized as:\n\n        Retrieve the AWS region from the AWS_REGION or AWS_DEFAULT_REGION\n        environment variable or from the AWS metadata server availability-zone\n        if not found in the environment variable.\n\n        Check AWS credentials in environment variables. If not found, retrieve\n        from the AWS metadata server security-credentials endpoint.\n\n        When retrieving AWS credentials from the metadata server\n        security-credentials endpoint, the AWS role needs to be determined by\n        calling the security-credentials endpoint without any argument. Then the\n        credentials can be retrieved via: security-credentials/role_name\n\n        Generate the signed request to AWS STS GetCallerIdentity action.\n\n        Inject x-goog-cloud-target-resource into header and serialize the\n        signed request. This will be the subject-token to pass to GCP STS.\n\n        .. _AWS GetCallerIdentity signed request:\n            https://cloud.google.com/iam/docs/access-resources-aws#exchange-token\n\n        Args:\n            request (google.auth.transport.Request): A callable used to make\n                HTTP requests.\n        Returns:\n            str: The retrieved subject token.\n        \"\"\"\n\n        # Initialize the request signer if not yet initialized after determining\n        # the current AWS region.\n        if self._request_signer is None:\n            self._region = self._aws_security_credentials_supplier.get_aws_region(\n                self._supplier_context, request\n            )\n            self._request_signer = RequestSigner(self._region)\n\n        # Retrieve the AWS security credentials needed to generate the signed\n        # request.\n        aws_security_credentials = self._aws_security_credentials_supplier.get_aws_security_credentials(\n            self._supplier_context, request\n        )\n        # Generate the signed request to AWS STS GetCallerIdentity API.\n        # Use the required regional endpoint. Otherwise, the request will fail.\n        request_options = self._request_signer.get_request_options(\n            aws_security_credentials,\n            self._cred_verification_url.replace(\"{region}\", self._region),\n            \"POST\",\n        )\n        # The GCP STS endpoint expects the headers to be formatted as:\n        # [\n        #   {key: 'x-amz-date', value: '...'},\n        #   {key: 'Authorization', value: '...'},\n        #   ...\n        # ]\n        # And then serialized as:\n        # quote(json.dumps({\n        #   url: '...',\n        #   method: 'POST',\n        #   headers: [{key: 'x-amz-date', value: '...'}, ...]\n        # }))\n        request_headers = request_options.get(\"headers\")\n        # The full, canonical resource name of the workload identity pool\n        # provider, with or without the HTTPS prefix.\n        # Including this header as part of the signature is recommended to\n        # ensure data integrity.\n        request_headers[\"x-goog-cloud-target-resource\"] = self._target_resource\n\n        # Serialize AWS signed request.\n        aws_signed_req = {}\n        aws_signed_req[\"url\"] = request_options.get(\"url\")\n        aws_signed_req[\"method\"] = request_options.get(\"method\")\n        aws_signed_req[\"headers\"] = []\n        # Reformat header to GCP STS expected format.\n        for key in request_headers.keys():\n            aws_signed_req[\"headers\"].append(\n                {\"key\": key, \"value\": request_headers[key]}\n            )\n\n        return urllib.parse.quote(\n            json.dumps(aws_signed_req, separators=(\",\", \":\"), sort_keys=True)\n        )\n\n    def _create_default_metrics_options(self):\n        metrics_options = super(Credentials, self)._create_default_metrics_options()\n        metrics_options[\"source\"] = \"aws\"\n        if self._has_custom_supplier():\n            metrics_options[\"source\"] = \"programmatic\"\n        return metrics_options\n\n    def _has_custom_supplier(self):\n        return self._credential_source is None\n\n    def _constructor_args(self):\n        args = super(Credentials, self)._constructor_args()\n        # If a custom supplier was used, append it to the args dict.\n        if self._has_custom_supplier():\n            args.update(\n                {\n                    \"aws_security_credentials_supplier\": self._aws_security_credentials_supplier\n                }\n            )\n        return args\n\n    @classmethod\n    def from_info(cls, info, **kwargs):\n        \"\"\"Creates an AWS Credentials instance from parsed external account info.\n\n        Args:\n            info (Mapping[str, str]): The AWS external account info in Google\n                format.\n            kwargs: Additional arguments to pass to the constructor.\n\n        Returns:\n            google.auth.aws.Credentials: The constructed credentials.\n\n        Raises:\n            ValueError: For invalid parameters.\n        \"\"\"\n        aws_security_credentials_supplier = info.get(\n            \"aws_security_credentials_supplier\"\n        )\n        kwargs.update(\n            {\"aws_security_credentials_supplier\": aws_security_credentials_supplier}\n        )\n        return super(Credentials, cls).from_info(info, **kwargs)\n\n    @classmethod\n    def from_file(cls, filename, **kwargs):\n        \"\"\"Creates an AWS Credentials instance from an external account json file.\n\n        Args:\n            filename (str): The path to the AWS external account json file.\n            kwargs: Additional arguments to pass to the constructor.\n\n        Returns:\n            google.auth.aws.Credentials: The constructed credentials.\n        \"\"\"\n        return super(Credentials, cls).from_file(filename, **kwargs)\n", "google/auth/jwt.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"JSON Web Tokens\n\nProvides support for creating (encoding) and verifying (decoding) JWTs,\nespecially JWTs generated and consumed by Google infrastructure.\n\nSee `rfc7519`_ for more details on JWTs.\n\nTo encode a JWT use :func:`encode`::\n\n    from google.auth import crypt\n    from google.auth import jwt\n\n    signer = crypt.Signer(private_key)\n    payload = {'some': 'payload'}\n    encoded = jwt.encode(signer, payload)\n\nTo decode a JWT and verify claims use :func:`decode`::\n\n    claims = jwt.decode(encoded, certs=public_certs)\n\nYou can also skip verification::\n\n    claims = jwt.decode(encoded, verify=False)\n\n.. _rfc7519: https://tools.ietf.org/html/rfc7519\n\n\"\"\"\n\ntry:\n    from collections.abc import Mapping\n# Python 2.7 compatibility\nexcept ImportError:  # pragma: NO COVER\n    from collections import Mapping  # type: ignore\nimport copy\nimport datetime\nimport json\nimport urllib\n\nimport cachetools\n\nfrom google.auth import _helpers\nfrom google.auth import _service_account_info\nfrom google.auth import crypt\nfrom google.auth import exceptions\nimport google.auth.credentials\n\ntry:\n    from google.auth.crypt import es256\nexcept ImportError:  # pragma: NO COVER\n    es256 = None  # type: ignore\n\n_DEFAULT_TOKEN_LIFETIME_SECS = 3600  # 1 hour in seconds\n_DEFAULT_MAX_CACHE_SIZE = 10\n_ALGORITHM_TO_VERIFIER_CLASS = {\"RS256\": crypt.RSAVerifier}\n_CRYPTOGRAPHY_BASED_ALGORITHMS = frozenset([\"ES256\"])\n\nif es256 is not None:  # pragma: NO COVER\n    _ALGORITHM_TO_VERIFIER_CLASS[\"ES256\"] = es256.ES256Verifier  # type: ignore\n\n\ndef encode(signer, payload, header=None, key_id=None):\n    \"\"\"Make a signed JWT.\n\n    Args:\n        signer (google.auth.crypt.Signer): The signer used to sign the JWT.\n        payload (Mapping[str, str]): The JWT payload.\n        header (Mapping[str, str]): Additional JWT header payload.\n        key_id (str): The key id to add to the JWT header. If the\n            signer has a key id it will be used as the default. If this is\n            specified it will override the signer's key id.\n\n    Returns:\n        bytes: The encoded JWT.\n    \"\"\"\n    if header is None:\n        header = {}\n\n    if key_id is None:\n        key_id = signer.key_id\n\n    header.update({\"typ\": \"JWT\"})\n\n    if \"alg\" not in header:\n        if es256 is not None and isinstance(signer, es256.ES256Signer):\n            header.update({\"alg\": \"ES256\"})\n        else:\n            header.update({\"alg\": \"RS256\"})\n\n    if key_id is not None:\n        header[\"kid\"] = key_id\n\n    segments = [\n        _helpers.unpadded_urlsafe_b64encode(json.dumps(header).encode(\"utf-8\")),\n        _helpers.unpadded_urlsafe_b64encode(json.dumps(payload).encode(\"utf-8\")),\n    ]\n\n    signing_input = b\".\".join(segments)\n    signature = signer.sign(signing_input)\n    segments.append(_helpers.unpadded_urlsafe_b64encode(signature))\n\n    return b\".\".join(segments)\n\n\ndef _decode_jwt_segment(encoded_section):\n    \"\"\"Decodes a single JWT segment.\"\"\"\n    section_bytes = _helpers.padded_urlsafe_b64decode(encoded_section)\n    try:\n        return json.loads(section_bytes.decode(\"utf-8\"))\n    except ValueError as caught_exc:\n        new_exc = exceptions.MalformedError(\n            \"Can't parse segment: {0}\".format(section_bytes)\n        )\n        raise new_exc from caught_exc\n\n\ndef _unverified_decode(token):\n    \"\"\"Decodes a token and does no verification.\n\n    Args:\n        token (Union[str, bytes]): The encoded JWT.\n\n    Returns:\n        Tuple[Mapping, Mapping, str, str]: header, payload, signed_section, and\n            signature.\n\n    Raises:\n        google.auth.exceptions.MalformedError: if there are an incorrect amount of segments in the token or segments of the wrong type.\n    \"\"\"\n    token = _helpers.to_bytes(token)\n\n    if token.count(b\".\") != 2:\n        raise exceptions.MalformedError(\n            \"Wrong number of segments in token: {0}\".format(token)\n        )\n\n    encoded_header, encoded_payload, signature = token.split(b\".\")\n    signed_section = encoded_header + b\".\" + encoded_payload\n    signature = _helpers.padded_urlsafe_b64decode(signature)\n\n    # Parse segments\n    header = _decode_jwt_segment(encoded_header)\n    payload = _decode_jwt_segment(encoded_payload)\n\n    if not isinstance(header, Mapping):\n        raise exceptions.MalformedError(\n            \"Header segment should be a JSON object: {0}\".format(encoded_header)\n        )\n\n    if not isinstance(payload, Mapping):\n        raise exceptions.MalformedError(\n            \"Payload segment should be a JSON object: {0}\".format(encoded_payload)\n        )\n\n    return header, payload, signed_section, signature\n\n\ndef decode_header(token):\n    \"\"\"Return the decoded header of a token.\n\n    No verification is done. This is useful to extract the key id from\n    the header in order to acquire the appropriate certificate to verify\n    the token.\n\n    Args:\n        token (Union[str, bytes]): the encoded JWT.\n\n    Returns:\n        Mapping: The decoded JWT header.\n    \"\"\"\n    header, _, _, _ = _unverified_decode(token)\n    return header\n\n\ndef _verify_iat_and_exp(payload, clock_skew_in_seconds=0):\n    \"\"\"Verifies the ``iat`` (Issued At) and ``exp`` (Expires) claims in a token\n    payload.\n\n    Args:\n        payload (Mapping[str, str]): The JWT payload.\n        clock_skew_in_seconds (int): The clock skew used for `iat` and `exp`\n            validation.\n\n    Raises:\n        google.auth.exceptions.InvalidValue: if value validation failed.\n        google.auth.exceptions.MalformedError: if schema validation failed.\n    \"\"\"\n    now = _helpers.datetime_to_secs(_helpers.utcnow())\n\n    # Make sure the iat and exp claims are present.\n    for key in (\"iat\", \"exp\"):\n        if key not in payload:\n            raise exceptions.MalformedError(\n                \"Token does not contain required claim {}\".format(key)\n            )\n\n    # Make sure the token wasn't issued in the future.\n    iat = payload[\"iat\"]\n    # Err on the side of accepting a token that is slightly early to account\n    # for clock skew.\n    earliest = iat - clock_skew_in_seconds\n    if now < earliest:\n        raise exceptions.InvalidValue(\n            \"Token used too early, {} < {}. Check that your computer's clock is set correctly.\".format(\n                now, iat\n            )\n        )\n\n    # Make sure the token wasn't issued in the past.\n    exp = payload[\"exp\"]\n    # Err on the side of accepting a token that is slightly out of date\n    # to account for clow skew.\n    latest = exp + clock_skew_in_seconds\n    if latest < now:\n        raise exceptions.InvalidValue(\"Token expired, {} < {}\".format(latest, now))\n\n\ndef decode(token, certs=None, verify=True, audience=None, clock_skew_in_seconds=0):\n    \"\"\"Decode and verify a JWT.\n\n    Args:\n        token (str): The encoded JWT.\n        certs (Union[str, bytes, Mapping[str, Union[str, bytes]]]): The\n            certificate used to validate the JWT signature. If bytes or string,\n            it must the the public key certificate in PEM format. If a mapping,\n            it must be a mapping of key IDs to public key certificates in PEM\n            format. The mapping must contain the same key ID that's specified\n            in the token's header.\n        verify (bool): Whether to perform signature and claim validation.\n            Verification is done by default.\n        audience (str or list): The audience claim, 'aud', that this JWT should\n            contain. Or a list of audience claims. If None then the JWT's 'aud'\n            parameter is not verified.\n        clock_skew_in_seconds (int): The clock skew used for `iat` and `exp`\n            validation.\n\n    Returns:\n        Mapping[str, str]: The deserialized JSON payload in the JWT.\n\n    Raises:\n        google.auth.exceptions.InvalidValue: if value validation failed.\n        google.auth.exceptions.MalformedError: if schema validation failed.\n    \"\"\"\n    header, payload, signed_section, signature = _unverified_decode(token)\n\n    if not verify:\n        return payload\n\n    # Pluck the key id and algorithm from the header and make sure we have\n    # a verifier that can support it.\n    key_alg = header.get(\"alg\")\n    key_id = header.get(\"kid\")\n\n    try:\n        verifier_cls = _ALGORITHM_TO_VERIFIER_CLASS[key_alg]\n    except KeyError as exc:\n        if key_alg in _CRYPTOGRAPHY_BASED_ALGORITHMS:\n            raise exceptions.InvalidValue(\n                \"The key algorithm {} requires the cryptography package to be installed.\".format(\n                    key_alg\n                )\n            ) from exc\n        else:\n            raise exceptions.InvalidValue(\n                \"Unsupported signature algorithm {}\".format(key_alg)\n            ) from exc\n    # If certs is specified as a dictionary of key IDs to certificates, then\n    # use the certificate identified by the key ID in the token header.\n    if isinstance(certs, Mapping):\n        if key_id:\n            if key_id not in certs:\n                raise exceptions.MalformedError(\n                    \"Certificate for key id {} not found.\".format(key_id)\n                )\n            certs_to_check = [certs[key_id]]\n        # If there's no key id in the header, check against all of the certs.\n        else:\n            certs_to_check = certs.values()\n    else:\n        certs_to_check = certs\n\n    # Verify that the signature matches the message.\n    if not crypt.verify_signature(\n        signed_section, signature, certs_to_check, verifier_cls\n    ):\n        raise exceptions.MalformedError(\"Could not verify token signature.\")\n\n    # Verify the issued at and created times in the payload.\n    _verify_iat_and_exp(payload, clock_skew_in_seconds)\n\n    # Check audience.\n    if audience is not None:\n        claim_audience = payload.get(\"aud\")\n        if isinstance(audience, str):\n            audience = [audience]\n        if claim_audience not in audience:\n            raise exceptions.InvalidValue(\n                \"Token has wrong audience {}, expected one of {}\".format(\n                    claim_audience, audience\n                )\n            )\n\n    return payload\n\n\nclass Credentials(\n    google.auth.credentials.Signing, google.auth.credentials.CredentialsWithQuotaProject\n):\n    \"\"\"Credentials that use a JWT as the bearer token.\n\n    These credentials require an \"audience\" claim. This claim identifies the\n    intended recipient of the bearer token.\n\n    The constructor arguments determine the claims for the JWT that is\n    sent with requests. Usually, you'll construct these credentials with\n    one of the helper constructors as shown in the next section.\n\n    To create JWT credentials using a Google service account private key\n    JSON file::\n\n        audience = 'https://pubsub.googleapis.com/google.pubsub.v1.Publisher'\n        credentials = jwt.Credentials.from_service_account_file(\n            'service-account.json',\n            audience=audience)\n\n    If you already have the service account file loaded and parsed::\n\n        service_account_info = json.load(open('service_account.json'))\n        credentials = jwt.Credentials.from_service_account_info(\n            service_account_info,\n            audience=audience)\n\n    Both helper methods pass on arguments to the constructor, so you can\n    specify the JWT claims::\n\n        credentials = jwt.Credentials.from_service_account_file(\n            'service-account.json',\n            audience=audience,\n            additional_claims={'meta': 'data'})\n\n    You can also construct the credentials directly if you have a\n    :class:`~google.auth.crypt.Signer` instance::\n\n        credentials = jwt.Credentials(\n            signer,\n            issuer='your-issuer',\n            subject='your-subject',\n            audience=audience)\n\n    The claims are considered immutable. If you want to modify the claims,\n    you can easily create another instance using :meth:`with_claims`::\n\n        new_audience = (\n            'https://pubsub.googleapis.com/google.pubsub.v1.Subscriber')\n        new_credentials = credentials.with_claims(audience=new_audience)\n    \"\"\"\n\n    def __init__(\n        self,\n        signer,\n        issuer,\n        subject,\n        audience,\n        additional_claims=None,\n        token_lifetime=_DEFAULT_TOKEN_LIFETIME_SECS,\n        quota_project_id=None,\n    ):\n        \"\"\"\n        Args:\n            signer (google.auth.crypt.Signer): The signer used to sign JWTs.\n            issuer (str): The `iss` claim.\n            subject (str): The `sub` claim.\n            audience (str): the `aud` claim. The intended audience for the\n                credentials.\n            additional_claims (Mapping[str, str]): Any additional claims for\n                the JWT payload.\n            token_lifetime (int): The amount of time in seconds for\n                which the token is valid. Defaults to 1 hour.\n            quota_project_id (Optional[str]): The project ID used for quota\n                and billing.\n        \"\"\"\n        super(Credentials, self).__init__()\n        self._signer = signer\n        self._issuer = issuer\n        self._subject = subject\n        self._audience = audience\n        self._token_lifetime = token_lifetime\n        self._quota_project_id = quota_project_id\n\n        if additional_claims is None:\n            additional_claims = {}\n\n        self._additional_claims = additional_claims\n\n    @classmethod\n    def _from_signer_and_info(cls, signer, info, **kwargs):\n        \"\"\"Creates a Credentials instance from a signer and service account\n        info.\n\n        Args:\n            signer (google.auth.crypt.Signer): The signer used to sign JWTs.\n            info (Mapping[str, str]): The service account info.\n            kwargs: Additional arguments to pass to the constructor.\n\n        Returns:\n            google.auth.jwt.Credentials: The constructed credentials.\n\n        Raises:\n            google.auth.exceptions.MalformedError: If the info is not in the expected format.\n        \"\"\"\n        kwargs.setdefault(\"subject\", info[\"client_email\"])\n        kwargs.setdefault(\"issuer\", info[\"client_email\"])\n        return cls(signer, **kwargs)\n\n    @classmethod\n    def from_service_account_info(cls, info, **kwargs):\n        \"\"\"Creates an Credentials instance from a dictionary.\n\n        Args:\n            info (Mapping[str, str]): The service account info in Google\n                format.\n            kwargs: Additional arguments to pass to the constructor.\n\n        Returns:\n            google.auth.jwt.Credentials: The constructed credentials.\n\n        Raises:\n            google.auth.exceptions.MalformedError: If the info is not in the expected format.\n        \"\"\"\n        signer = _service_account_info.from_dict(info, require=[\"client_email\"])\n        return cls._from_signer_and_info(signer, info, **kwargs)\n\n    @classmethod\n    def from_service_account_file(cls, filename, **kwargs):\n        \"\"\"Creates a Credentials instance from a service account .json file\n        in Google format.\n\n        Args:\n            filename (str): The path to the service account .json file.\n            kwargs: Additional arguments to pass to the constructor.\n\n        Returns:\n            google.auth.jwt.Credentials: The constructed credentials.\n        \"\"\"\n        info, signer = _service_account_info.from_filename(\n            filename, require=[\"client_email\"]\n        )\n        return cls._from_signer_and_info(signer, info, **kwargs)\n\n    @classmethod\n    def from_signing_credentials(cls, credentials, audience, **kwargs):\n        \"\"\"Creates a new :class:`google.auth.jwt.Credentials` instance from an\n        existing :class:`google.auth.credentials.Signing` instance.\n\n        The new instance will use the same signer as the existing instance and\n        will use the existing instance's signer email as the issuer and\n        subject by default.\n\n        Example::\n\n            svc_creds = service_account.Credentials.from_service_account_file(\n                'service_account.json')\n            audience = (\n                'https://pubsub.googleapis.com/google.pubsub.v1.Publisher')\n            jwt_creds = jwt.Credentials.from_signing_credentials(\n                svc_creds, audience=audience)\n\n        Args:\n            credentials (google.auth.credentials.Signing): The credentials to\n                use to construct the new credentials.\n            audience (str): the `aud` claim. The intended audience for the\n                credentials.\n            kwargs: Additional arguments to pass to the constructor.\n\n        Returns:\n            google.auth.jwt.Credentials: A new Credentials instance.\n        \"\"\"\n        kwargs.setdefault(\"issuer\", credentials.signer_email)\n        kwargs.setdefault(\"subject\", credentials.signer_email)\n        return cls(credentials.signer, audience=audience, **kwargs)\n\n    def with_claims(\n        self, issuer=None, subject=None, audience=None, additional_claims=None\n    ):\n        \"\"\"Returns a copy of these credentials with modified claims.\n\n        Args:\n            issuer (str): The `iss` claim. If unspecified the current issuer\n                claim will be used.\n            subject (str): The `sub` claim. If unspecified the current subject\n                claim will be used.\n            audience (str): the `aud` claim. If unspecified the current\n                audience claim will be used.\n            additional_claims (Mapping[str, str]): Any additional claims for\n                the JWT payload. This will be merged with the current\n                additional claims.\n\n        Returns:\n            google.auth.jwt.Credentials: A new credentials instance.\n        \"\"\"\n        new_additional_claims = copy.deepcopy(self._additional_claims)\n        new_additional_claims.update(additional_claims or {})\n\n        return self.__class__(\n            self._signer,\n            issuer=issuer if issuer is not None else self._issuer,\n            subject=subject if subject is not None else self._subject,\n            audience=audience if audience is not None else self._audience,\n            additional_claims=new_additional_claims,\n            quota_project_id=self._quota_project_id,\n        )\n\n    @_helpers.copy_docstring(google.auth.credentials.CredentialsWithQuotaProject)\n    def with_quota_project(self, quota_project_id):\n        return self.__class__(\n            self._signer,\n            issuer=self._issuer,\n            subject=self._subject,\n            audience=self._audience,\n            additional_claims=self._additional_claims,\n            quota_project_id=quota_project_id,\n        )\n\n    def _make_jwt(self):\n        \"\"\"Make a signed JWT.\n\n        Returns:\n            Tuple[bytes, datetime]: The encoded JWT and the expiration.\n        \"\"\"\n        now = _helpers.utcnow()\n        lifetime = datetime.timedelta(seconds=self._token_lifetime)\n        expiry = now + lifetime\n\n        payload = {\n            \"iss\": self._issuer,\n            \"sub\": self._subject,\n            \"iat\": _helpers.datetime_to_secs(now),\n            \"exp\": _helpers.datetime_to_secs(expiry),\n        }\n        if self._audience:\n            payload[\"aud\"] = self._audience\n\n        payload.update(self._additional_claims)\n\n        jwt = encode(self._signer, payload)\n\n        return jwt, expiry\n\n    def refresh(self, request):\n        \"\"\"Refreshes the access token.\n\n        Args:\n            request (Any): Unused.\n        \"\"\"\n        # pylint: disable=unused-argument\n        # (pylint doesn't correctly recognize overridden methods.)\n        self.token, self.expiry = self._make_jwt()\n\n    @_helpers.copy_docstring(google.auth.credentials.Signing)\n    def sign_bytes(self, message):\n        return self._signer.sign(message)\n\n    @property  # type: ignore\n    @_helpers.copy_docstring(google.auth.credentials.Signing)\n    def signer_email(self):\n        return self._issuer\n\n    @property  # type: ignore\n    @_helpers.copy_docstring(google.auth.credentials.Signing)\n    def signer(self):\n        return self._signer\n\n    @property  # type: ignore\n    def additional_claims(self):\n        \"\"\" Additional claims the JWT object was created with.\"\"\"\n        return self._additional_claims\n\n\nclass OnDemandCredentials(\n    google.auth.credentials.Signing, google.auth.credentials.CredentialsWithQuotaProject\n):\n    \"\"\"On-demand JWT credentials.\n\n    Like :class:`Credentials`, this class uses a JWT as the bearer token for\n    authentication. However, this class does not require the audience at\n    construction time. Instead, it will generate a new token on-demand for\n    each request using the request URI as the audience. It caches tokens\n    so that multiple requests to the same URI do not incur the overhead\n    of generating a new token every time.\n\n    This behavior is especially useful for `gRPC`_ clients. A gRPC service may\n    have multiple audience and gRPC clients may not know all of the audiences\n    required for accessing a particular service. With these credentials,\n    no knowledge of the audiences is required ahead of time.\n\n    .. _grpc: http://www.grpc.io/\n    \"\"\"\n\n    def __init__(\n        self,\n        signer,\n        issuer,\n        subject,\n        additional_claims=None,\n        token_lifetime=_DEFAULT_TOKEN_LIFETIME_SECS,\n        max_cache_size=_DEFAULT_MAX_CACHE_SIZE,\n        quota_project_id=None,\n    ):\n        \"\"\"\n        Args:\n            signer (google.auth.crypt.Signer): The signer used to sign JWTs.\n            issuer (str): The `iss` claim.\n            subject (str): The `sub` claim.\n            additional_claims (Mapping[str, str]): Any additional claims for\n                the JWT payload.\n            token_lifetime (int): The amount of time in seconds for\n                which the token is valid. Defaults to 1 hour.\n            max_cache_size (int): The maximum number of JWT tokens to keep in\n                cache. Tokens are cached using :class:`cachetools.LRUCache`.\n            quota_project_id (Optional[str]): The project ID used for quota\n                and billing.\n\n        \"\"\"\n        super(OnDemandCredentials, self).__init__()\n        self._signer = signer\n        self._issuer = issuer\n        self._subject = subject\n        self._token_lifetime = token_lifetime\n        self._quota_project_id = quota_project_id\n\n        if additional_claims is None:\n            additional_claims = {}\n\n        self._additional_claims = additional_claims\n        self._cache = cachetools.LRUCache(maxsize=max_cache_size)\n\n    @classmethod\n    def _from_signer_and_info(cls, signer, info, **kwargs):\n        \"\"\"Creates an OnDemandCredentials instance from a signer and service\n        account info.\n\n        Args:\n            signer (google.auth.crypt.Signer): The signer used to sign JWTs.\n            info (Mapping[str, str]): The service account info.\n            kwargs: Additional arguments to pass to the constructor.\n\n        Returns:\n            google.auth.jwt.OnDemandCredentials: The constructed credentials.\n\n        Raises:\n            google.auth.exceptions.MalformedError: If the info is not in the expected format.\n        \"\"\"\n        kwargs.setdefault(\"subject\", info[\"client_email\"])\n        kwargs.setdefault(\"issuer\", info[\"client_email\"])\n        return cls(signer, **kwargs)\n\n    @classmethod\n    def from_service_account_info(cls, info, **kwargs):\n        \"\"\"Creates an OnDemandCredentials instance from a dictionary.\n\n        Args:\n            info (Mapping[str, str]): The service account info in Google\n                format.\n            kwargs: Additional arguments to pass to the constructor.\n\n        Returns:\n            google.auth.jwt.OnDemandCredentials: The constructed credentials.\n\n        Raises:\n            google.auth.exceptions.MalformedError: If the info is not in the expected format.\n        \"\"\"\n        signer = _service_account_info.from_dict(info, require=[\"client_email\"])\n        return cls._from_signer_and_info(signer, info, **kwargs)\n\n    @classmethod\n    def from_service_account_file(cls, filename, **kwargs):\n        \"\"\"Creates an OnDemandCredentials instance from a service account .json\n        file in Google format.\n\n        Args:\n            filename (str): The path to the service account .json file.\n            kwargs: Additional arguments to pass to the constructor.\n\n        Returns:\n            google.auth.jwt.OnDemandCredentials: The constructed credentials.\n        \"\"\"\n        info, signer = _service_account_info.from_filename(\n            filename, require=[\"client_email\"]\n        )\n        return cls._from_signer_and_info(signer, info, **kwargs)\n\n    @classmethod\n    def from_signing_credentials(cls, credentials, **kwargs):\n        \"\"\"Creates a new :class:`google.auth.jwt.OnDemandCredentials` instance\n        from an existing :class:`google.auth.credentials.Signing` instance.\n\n        The new instance will use the same signer as the existing instance and\n        will use the existing instance's signer email as the issuer and\n        subject by default.\n\n        Example::\n\n            svc_creds = service_account.Credentials.from_service_account_file(\n                'service_account.json')\n            jwt_creds = jwt.OnDemandCredentials.from_signing_credentials(\n                svc_creds)\n\n        Args:\n            credentials (google.auth.credentials.Signing): The credentials to\n                use to construct the new credentials.\n            kwargs: Additional arguments to pass to the constructor.\n\n        Returns:\n            google.auth.jwt.Credentials: A new Credentials instance.\n        \"\"\"\n        kwargs.setdefault(\"issuer\", credentials.signer_email)\n        kwargs.setdefault(\"subject\", credentials.signer_email)\n        return cls(credentials.signer, **kwargs)\n\n    def with_claims(self, issuer=None, subject=None, additional_claims=None):\n        \"\"\"Returns a copy of these credentials with modified claims.\n\n        Args:\n            issuer (str): The `iss` claim. If unspecified the current issuer\n                claim will be used.\n            subject (str): The `sub` claim. If unspecified the current subject\n                claim will be used.\n            additional_claims (Mapping[str, str]): Any additional claims for\n                the JWT payload. This will be merged with the current\n                additional claims.\n\n        Returns:\n            google.auth.jwt.OnDemandCredentials: A new credentials instance.\n        \"\"\"\n        new_additional_claims = copy.deepcopy(self._additional_claims)\n        new_additional_claims.update(additional_claims or {})\n\n        return self.__class__(\n            self._signer,\n            issuer=issuer if issuer is not None else self._issuer,\n            subject=subject if subject is not None else self._subject,\n            additional_claims=new_additional_claims,\n            max_cache_size=self._cache.maxsize,\n            quota_project_id=self._quota_project_id,\n        )\n\n    @_helpers.copy_docstring(google.auth.credentials.CredentialsWithQuotaProject)\n    def with_quota_project(self, quota_project_id):\n\n        return self.__class__(\n            self._signer,\n            issuer=self._issuer,\n            subject=self._subject,\n            additional_claims=self._additional_claims,\n            max_cache_size=self._cache.maxsize,\n            quota_project_id=quota_project_id,\n        )\n\n    @property\n    def valid(self):\n        \"\"\"Checks the validity of the credentials.\n\n        These credentials are always valid because it generates tokens on\n        demand.\n        \"\"\"\n        return True\n\n    def _make_jwt_for_audience(self, audience):\n        \"\"\"Make a new JWT for the given audience.\n\n        Args:\n            audience (str): The intended audience.\n\n        Returns:\n            Tuple[bytes, datetime]: The encoded JWT and the expiration.\n        \"\"\"\n        now = _helpers.utcnow()\n        lifetime = datetime.timedelta(seconds=self._token_lifetime)\n        expiry = now + lifetime\n\n        payload = {\n            \"iss\": self._issuer,\n            \"sub\": self._subject,\n            \"iat\": _helpers.datetime_to_secs(now),\n            \"exp\": _helpers.datetime_to_secs(expiry),\n            \"aud\": audience,\n        }\n\n        payload.update(self._additional_claims)\n\n        jwt = encode(self._signer, payload)\n\n        return jwt, expiry\n\n    def _get_jwt_for_audience(self, audience):\n        \"\"\"Get a JWT For a given audience.\n\n        If there is already an existing, non-expired token in the cache for\n        the audience, that token is used. Otherwise, a new token will be\n        created.\n\n        Args:\n            audience (str): The intended audience.\n\n        Returns:\n            bytes: The encoded JWT.\n        \"\"\"\n        token, expiry = self._cache.get(audience, (None, None))\n\n        if token is None or expiry < _helpers.utcnow():\n            token, expiry = self._make_jwt_for_audience(audience)\n            self._cache[audience] = token, expiry\n\n        return token\n\n    def refresh(self, request):\n        \"\"\"Raises an exception, these credentials can not be directly\n        refreshed.\n\n        Args:\n            request (Any): Unused.\n\n        Raises:\n            google.auth.RefreshError\n        \"\"\"\n        # pylint: disable=unused-argument\n        # (pylint doesn't correctly recognize overridden methods.)\n        raise exceptions.RefreshError(\n            \"OnDemandCredentials can not be directly refreshed.\"\n        )\n\n    def before_request(self, request, method, url, headers):\n        \"\"\"Performs credential-specific before request logic.\n\n        Args:\n            request (Any): Unused. JWT credentials do not need to make an\n                HTTP request to refresh.\n            method (str): The request's HTTP method.\n            url (str): The request's URI. This is used as the audience claim\n                when generating the JWT.\n            headers (Mapping): The request's headers.\n        \"\"\"\n        # pylint: disable=unused-argument\n        # (pylint doesn't correctly recognize overridden methods.)\n        parts = urllib.parse.urlsplit(url)\n        # Strip query string and fragment\n        audience = urllib.parse.urlunsplit(\n            (parts.scheme, parts.netloc, parts.path, \"\", \"\")\n        )\n        token = self._get_jwt_for_audience(audience)\n        self.apply(headers, token=token)\n\n    @_helpers.copy_docstring(google.auth.credentials.Signing)\n    def sign_bytes(self, message):\n        return self._signer.sign(message)\n\n    @property  # type: ignore\n    @_helpers.copy_docstring(google.auth.credentials.Signing)\n    def signer_email(self):\n        return self._issuer\n\n    @property  # type: ignore\n    @_helpers.copy_docstring(google.auth.credentials.Signing)\n    def signer(self):\n        return self._signer\n", "google/auth/_default_async.py": "# Copyright 2020 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Application default credentials.\n\nImplements application default credentials and project ID detection.\n\"\"\"\n\nimport io\nimport json\nimport os\n\nfrom google.auth import _default\nfrom google.auth import environment_vars\nfrom google.auth import exceptions\n\n\ndef load_credentials_from_file(filename, scopes=None, quota_project_id=None):\n    \"\"\"Loads Google credentials from a file.\n\n    The credentials file must be a service account key or stored authorized\n    user credentials.\n\n    Args:\n        filename (str): The full path to the credentials file.\n        scopes (Optional[Sequence[str]]): The list of scopes for the credentials. If\n            specified, the credentials will automatically be scoped if\n            necessary\n        quota_project_id (Optional[str]):  The project ID used for\n                quota and billing.\n\n    Returns:\n        Tuple[google.auth.credentials.Credentials, Optional[str]]: Loaded\n            credentials and the project ID. Authorized user credentials do not\n            have the project ID information.\n\n    Raises:\n        google.auth.exceptions.DefaultCredentialsError: if the file is in the\n            wrong format or is missing.\n    \"\"\"\n    if not os.path.exists(filename):\n        raise exceptions.DefaultCredentialsError(\n            \"File {} was not found.\".format(filename)\n        )\n\n    with io.open(filename, \"r\") as file_obj:\n        try:\n            info = json.load(file_obj)\n        except ValueError as caught_exc:\n            new_exc = exceptions.DefaultCredentialsError(\n                \"File {} is not a valid json file.\".format(filename), caught_exc\n            )\n            raise new_exc from caught_exc\n\n    # The type key should indicate that the file is either a service account\n    # credentials file or an authorized user credentials file.\n    credential_type = info.get(\"type\")\n\n    if credential_type == _default._AUTHORIZED_USER_TYPE:\n        from google.oauth2 import _credentials_async as credentials\n\n        try:\n            credentials = credentials.Credentials.from_authorized_user_info(\n                info, scopes=scopes\n            )\n        except ValueError as caught_exc:\n            msg = \"Failed to load authorized user credentials from {}\".format(filename)\n            new_exc = exceptions.DefaultCredentialsError(msg, caught_exc)\n            raise new_exc from caught_exc\n        if quota_project_id:\n            credentials = credentials.with_quota_project(quota_project_id)\n        if not credentials.quota_project_id:\n            _default._warn_about_problematic_credentials(credentials)\n        return credentials, None\n\n    elif credential_type == _default._SERVICE_ACCOUNT_TYPE:\n        from google.oauth2 import _service_account_async as service_account\n\n        try:\n            credentials = service_account.Credentials.from_service_account_info(\n                info, scopes=scopes\n            ).with_quota_project(quota_project_id)\n        except ValueError as caught_exc:\n            msg = \"Failed to load service account credentials from {}\".format(filename)\n            new_exc = exceptions.DefaultCredentialsError(msg, caught_exc)\n            raise new_exc from caught_exc\n        return credentials, info.get(\"project_id\")\n\n    else:\n        raise exceptions.DefaultCredentialsError(\n            \"The file {file} does not have a valid type. \"\n            \"Type is {type}, expected one of {valid_types}.\".format(\n                file=filename, type=credential_type, valid_types=_default._VALID_TYPES\n            )\n        )\n\n\ndef _get_gcloud_sdk_credentials(quota_project_id=None):\n    \"\"\"Gets the credentials and project ID from the Cloud SDK.\"\"\"\n    from google.auth import _cloud_sdk\n\n    # Check if application default credentials exist.\n    credentials_filename = _cloud_sdk.get_application_default_credentials_path()\n\n    if not os.path.isfile(credentials_filename):\n        return None, None\n\n    credentials, project_id = load_credentials_from_file(\n        credentials_filename, quota_project_id=quota_project_id\n    )\n\n    if not project_id:\n        project_id = _cloud_sdk.get_project_id()\n\n    return credentials, project_id\n\n\ndef _get_explicit_environ_credentials(quota_project_id=None):\n    \"\"\"Gets credentials from the GOOGLE_APPLICATION_CREDENTIALS environment\n    variable.\"\"\"\n    from google.auth import _cloud_sdk\n\n    cloud_sdk_adc_path = _cloud_sdk.get_application_default_credentials_path()\n    explicit_file = os.environ.get(environment_vars.CREDENTIALS)\n\n    if explicit_file is not None and explicit_file == cloud_sdk_adc_path:\n        # Cloud sdk flow calls gcloud to fetch project id, so if the explicit\n        # file path is cloud sdk credentials path, then we should fall back\n        # to cloud sdk flow, otherwise project id cannot be obtained.\n        return _get_gcloud_sdk_credentials(quota_project_id=quota_project_id)\n\n    if explicit_file is not None:\n        credentials, project_id = load_credentials_from_file(\n            os.environ[environment_vars.CREDENTIALS], quota_project_id=quota_project_id\n        )\n\n        return credentials, project_id\n\n    else:\n        return None, None\n\n\ndef _get_gae_credentials():\n    \"\"\"Gets Google App Engine App Identity credentials and project ID.\"\"\"\n    # While this library is normally bundled with app_engine, there are\n    # some cases where it's not available, so we tolerate ImportError.\n\n    return _default._get_gae_credentials()\n\n\ndef _get_gce_credentials(request=None):\n    \"\"\"Gets credentials and project ID from the GCE Metadata Service.\"\"\"\n    # Ping requires a transport, but we want application default credentials\n    # to require no arguments. So, we'll use the _http_client transport which\n    # uses http.client. This is only acceptable because the metadata server\n    # doesn't do SSL and never requires proxies.\n\n    # While this library is normally bundled with compute_engine, there are\n    # some cases where it's not available, so we tolerate ImportError.\n\n    return _default._get_gce_credentials(request)\n\n\ndef default_async(scopes=None, request=None, quota_project_id=None):\n    \"\"\"Gets the default credentials for the current environment.\n\n    `Application Default Credentials`_ provides an easy way to obtain\n    credentials to call Google APIs for server-to-server or local applications.\n    This function acquires credentials from the environment in the following\n    order:\n\n    1. If the environment variable ``GOOGLE_APPLICATION_CREDENTIALS`` is set\n       to the path of a valid service account JSON private key file, then it is\n       loaded and returned. The project ID returned is the project ID defined\n       in the service account file if available (some older files do not\n       contain project ID information).\n    2. If the `Google Cloud SDK`_ is installed and has application default\n       credentials set they are loaded and returned.\n\n       To enable application default credentials with the Cloud SDK run::\n\n            gcloud auth application-default login\n\n       If the Cloud SDK has an active project, the project ID is returned. The\n       active project can be set using::\n\n            gcloud config set project\n\n    3. If the application is running in the `App Engine standard environment`_\n       (first generation) then the credentials and project ID from the\n       `App Identity Service`_ are used.\n    4. If the application is running in `Compute Engine`_ or `Cloud Run`_ or\n       the `App Engine flexible environment`_ or the `App Engine standard\n       environment`_ (second generation) then the credentials and project ID\n       are obtained from the `Metadata Service`_.\n    5. If no credentials are found,\n       :class:`~google.auth.exceptions.DefaultCredentialsError` will be raised.\n\n    .. _Application Default Credentials: https://developers.google.com\\\n            /identity/protocols/application-default-credentials\n    .. _Google Cloud SDK: https://cloud.google.com/sdk\n    .. _App Engine standard environment: https://cloud.google.com/appengine\n    .. _App Identity Service: https://cloud.google.com/appengine/docs/python\\\n            /appidentity/\n    .. _Compute Engine: https://cloud.google.com/compute\n    .. _App Engine flexible environment: https://cloud.google.com\\\n            /appengine/flexible\n    .. _Metadata Service: https://cloud.google.com/compute/docs\\\n            /storing-retrieving-metadata\n    .. _Cloud Run: https://cloud.google.com/run\n\n    Example::\n\n        import google.auth\n\n        credentials, project_id = google.auth.default()\n\n    Args:\n        scopes (Sequence[str]): The list of scopes for the credentials. If\n            specified, the credentials will automatically be scoped if\n            necessary.\n        request (google.auth.transport.Request): An object used to make\n            HTTP requests. This is used to detect whether the application\n            is running on Compute Engine. If not specified, then it will\n            use the standard library http client to make requests.\n        quota_project_id (Optional[str]):  The project ID used for\n            quota and billing.\n    Returns:\n        Tuple[~google.auth.credentials.Credentials, Optional[str]]:\n            the current environment's credentials and project ID. Project ID\n            may be None, which indicates that the Project ID could not be\n            ascertained from the environment.\n\n    Raises:\n        ~google.auth.exceptions.DefaultCredentialsError:\n            If no credentials were found, or if the credentials found were\n            invalid.\n    \"\"\"\n    from google.auth._credentials_async import with_scopes_if_required\n    from google.auth.credentials import CredentialsWithQuotaProject\n\n    explicit_project_id = os.environ.get(\n        environment_vars.PROJECT, os.environ.get(environment_vars.LEGACY_PROJECT)\n    )\n\n    checkers = (\n        lambda: _get_explicit_environ_credentials(quota_project_id=quota_project_id),\n        lambda: _get_gcloud_sdk_credentials(quota_project_id=quota_project_id),\n        _get_gae_credentials,\n        lambda: _get_gce_credentials(request),\n    )\n\n    for checker in checkers:\n        credentials, project_id = checker()\n        if credentials is not None:\n            credentials = with_scopes_if_required(credentials, scopes)\n            if quota_project_id and isinstance(\n                credentials, CredentialsWithQuotaProject\n            ):\n                credentials = credentials.with_quota_project(quota_project_id)\n            effective_project_id = explicit_project_id or project_id\n            if not effective_project_id:\n                _default._LOGGER.warning(\n                    \"No project ID could be determined. Consider running \"\n                    \"`gcloud config set project` or setting the %s \"\n                    \"environment variable\",\n                    environment_vars.PROJECT,\n                )\n            return credentials, effective_project_id\n\n    raise exceptions.DefaultCredentialsError(_default._CLOUD_SDK_MISSING_CREDENTIALS)\n", "google/auth/external_account.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"External Account Credentials.\n\nThis module provides credentials that exchange workload identity pool external\ncredentials for Google access tokens. This facilitates accessing Google Cloud\nPlatform resources from on-prem and non-Google Cloud platforms (e.g. AWS,\nMicrosoft Azure, OIDC identity providers), using native credentials retrieved\nfrom the current environment without the need to copy, save and manage\nlong-lived service account credentials.\n\nSpecifically, this is intended to use access tokens acquired using the GCP STS\ntoken exchange endpoint following the `OAuth 2.0 Token Exchange`_ spec.\n\n.. _OAuth 2.0 Token Exchange: https://tools.ietf.org/html/rfc8693\n\"\"\"\n\nimport abc\nimport copy\nfrom dataclasses import dataclass\nimport datetime\nimport io\nimport json\nimport re\n\nfrom google.auth import _helpers\nfrom google.auth import credentials\nfrom google.auth import exceptions\nfrom google.auth import impersonated_credentials\nfrom google.auth import metrics\nfrom google.oauth2 import sts\nfrom google.oauth2 import utils\n\n# External account JSON type identifier.\n_EXTERNAL_ACCOUNT_JSON_TYPE = \"external_account\"\n# The token exchange grant_type used for exchanging credentials.\n_STS_GRANT_TYPE = \"urn:ietf:params:oauth:grant-type:token-exchange\"\n# The token exchange requested_token_type. This is always an access_token.\n_STS_REQUESTED_TOKEN_TYPE = \"urn:ietf:params:oauth:token-type:access_token\"\n# Cloud resource manager URL used to retrieve project information.\n_CLOUD_RESOURCE_MANAGER = \"https://cloudresourcemanager.googleapis.com/v1/projects/\"\n# Default Google sts token url.\n_DEFAULT_TOKEN_URL = \"https://sts.{universe_domain}/v1/token\"\n\n\n@dataclass\nclass SupplierContext:\n    \"\"\"A context class that contains information about the requested third party credential that is passed\n        to AWS security credential and subject token suppliers.\n\n        Attributes:\n            subject_token_type (str): The requested subject token type based on the Oauth2.0 token exchange spec.\n                Expected values include::\n\n                    \u201curn:ietf:params:oauth:token-type:jwt\u201d\n                    \u201curn:ietf:params:oauth:token-type:id-token\u201d\n                    \u201curn:ietf:params:oauth:token-type:saml2\u201d\n                    \u201curn:ietf:params:aws:token-type:aws4_request\u201d\n\n            audience (str): The requested audience for the subject token.\n    \"\"\"\n\n    subject_token_type: str\n    audience: str\n\n\nclass Credentials(\n    credentials.Scoped,\n    credentials.CredentialsWithQuotaProject,\n    credentials.CredentialsWithTokenUri,\n    metaclass=abc.ABCMeta,\n):\n    \"\"\"Base class for all external account credentials.\n\n    This is used to instantiate Credentials for exchanging external account\n    credentials for Google access token and authorizing requests to Google APIs.\n    The base class implements the common logic for exchanging external account\n    credentials for Google access tokens.\n    \"\"\"\n\n    def __init__(\n        self,\n        audience,\n        subject_token_type,\n        token_url,\n        credential_source,\n        service_account_impersonation_url=None,\n        service_account_impersonation_options=None,\n        client_id=None,\n        client_secret=None,\n        token_info_url=None,\n        quota_project_id=None,\n        scopes=None,\n        default_scopes=None,\n        workforce_pool_user_project=None,\n        universe_domain=credentials.DEFAULT_UNIVERSE_DOMAIN,\n        trust_boundary=None,\n    ):\n        \"\"\"Instantiates an external account credentials object.\n\n        Args:\n            audience (str): The STS audience field.\n            subject_token_type (str): The subject token type based on the Oauth2.0 token exchange spec.\n                Expected values include::\n\n                    \u201curn:ietf:params:oauth:token-type:jwt\u201d\n                    \u201curn:ietf:params:oauth:token-type:id-token\u201d\n                    \u201curn:ietf:params:oauth:token-type:saml2\u201d\n                    \u201curn:ietf:params:aws:token-type:aws4_request\u201d\n\n            token_url (str): The STS endpoint URL.\n            credential_source (Mapping): The credential source dictionary.\n            service_account_impersonation_url (Optional[str]): The optional service account\n                impersonation generateAccessToken URL.\n            client_id (Optional[str]): The optional client ID.\n            client_secret (Optional[str]): The optional client secret.\n            token_info_url (str): The optional STS endpoint URL for token introspection.\n            quota_project_id (Optional[str]): The optional quota project ID.\n            scopes (Optional[Sequence[str]]): Optional scopes to request during the\n                authorization grant.\n            default_scopes (Optional[Sequence[str]]): Default scopes passed by a\n                Google client library. Use 'scopes' for user-defined scopes.\n            workforce_pool_user_project (Optona[str]): The optional workforce pool user\n                project number when the credential corresponds to a workforce pool and not\n                a workload identity pool. The underlying principal must still have\n                serviceusage.services.use IAM permission to use the project for\n                billing/quota.\n            universe_domain (str): The universe domain. The default universe\n                domain is googleapis.com.\n            trust_boundary (str): String representation of trust boundary meta.\n        Raises:\n            google.auth.exceptions.RefreshError: If the generateAccessToken\n                endpoint returned an error.\n        \"\"\"\n        super(Credentials, self).__init__()\n        self._audience = audience\n        self._subject_token_type = subject_token_type\n        self._universe_domain = universe_domain\n        self._token_url = token_url\n        if self._token_url == _DEFAULT_TOKEN_URL:\n            self._token_url = self._token_url.replace(\n                \"{universe_domain}\", self._universe_domain\n            )\n        self._token_info_url = token_info_url\n        self._credential_source = credential_source\n        self._service_account_impersonation_url = service_account_impersonation_url\n        self._service_account_impersonation_options = (\n            service_account_impersonation_options or {}\n        )\n        self._client_id = client_id\n        self._client_secret = client_secret\n        self._quota_project_id = quota_project_id\n        self._scopes = scopes\n        self._default_scopes = default_scopes\n        self._workforce_pool_user_project = workforce_pool_user_project\n        self._trust_boundary = {\n            \"locations\": [],\n            \"encoded_locations\": \"0x0\",\n        }  # expose a placeholder trust boundary value.\n\n        if self._client_id:\n            self._client_auth = utils.ClientAuthentication(\n                utils.ClientAuthType.basic, self._client_id, self._client_secret\n            )\n        else:\n            self._client_auth = None\n        self._sts_client = sts.Client(self._token_url, self._client_auth)\n\n        self._metrics_options = self._create_default_metrics_options()\n\n        self._impersonated_credentials = None\n        self._project_id = None\n        self._supplier_context = SupplierContext(\n            self._subject_token_type, self._audience\n        )\n\n        if not self.is_workforce_pool and self._workforce_pool_user_project:\n            # Workload identity pools do not support workforce pool user projects.\n            raise exceptions.InvalidValue(\n                \"workforce_pool_user_project should not be set for non-workforce pool \"\n                \"credentials\"\n            )\n\n    @property\n    def info(self):\n        \"\"\"Generates the dictionary representation of the current credentials.\n\n        Returns:\n            Mapping: The dictionary representation of the credentials. This is the\n                reverse of \"from_info\" defined on the subclasses of this class. It is\n                useful for serializing the current credentials so it can deserialized\n                later.\n        \"\"\"\n        config_info = self._constructor_args()\n        config_info.update(\n            type=_EXTERNAL_ACCOUNT_JSON_TYPE,\n            service_account_impersonation=config_info.pop(\n                \"service_account_impersonation_options\", None\n            ),\n        )\n        config_info.pop(\"scopes\", None)\n        config_info.pop(\"default_scopes\", None)\n        return {key: value for key, value in config_info.items() if value is not None}\n\n    def _constructor_args(self):\n        args = {\n            \"audience\": self._audience,\n            \"subject_token_type\": self._subject_token_type,\n            \"token_url\": self._token_url,\n            \"token_info_url\": self._token_info_url,\n            \"service_account_impersonation_url\": self._service_account_impersonation_url,\n            \"service_account_impersonation_options\": copy.deepcopy(\n                self._service_account_impersonation_options\n            )\n            or None,\n            \"credential_source\": copy.deepcopy(self._credential_source),\n            \"quota_project_id\": self._quota_project_id,\n            \"client_id\": self._client_id,\n            \"client_secret\": self._client_secret,\n            \"workforce_pool_user_project\": self._workforce_pool_user_project,\n            \"scopes\": self._scopes,\n            \"default_scopes\": self._default_scopes,\n            \"universe_domain\": self._universe_domain,\n        }\n        if not self.is_workforce_pool:\n            args.pop(\"workforce_pool_user_project\")\n        return args\n\n    @property\n    def service_account_email(self):\n        \"\"\"Returns the service account email if service account impersonation is used.\n\n        Returns:\n            Optional[str]: The service account email if impersonation is used. Otherwise\n                None is returned.\n        \"\"\"\n        if self._service_account_impersonation_url:\n            # Parse email from URL. The formal looks as follows:\n            # https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/name@project-id.iam.gserviceaccount.com:generateAccessToken\n            url = self._service_account_impersonation_url\n            start_index = url.rfind(\"/\")\n            end_index = url.find(\":generateAccessToken\")\n            if start_index != -1 and end_index != -1 and start_index < end_index:\n                start_index = start_index + 1\n                return url[start_index:end_index]\n        return None\n\n    @property\n    def is_user(self):\n        \"\"\"Returns whether the credentials represent a user (True) or workload (False).\n        Workloads behave similarly to service accounts. Currently workloads will use\n        service account impersonation but will eventually not require impersonation.\n        As a result, this property is more reliable than the service account email\n        property in determining if the credentials represent a user or workload.\n\n        Returns:\n            bool: True if the credentials represent a user. False if they represent a\n                workload.\n        \"\"\"\n        # If service account impersonation is used, the credentials will always represent a\n        # service account.\n        if self._service_account_impersonation_url:\n            return False\n        return self.is_workforce_pool\n\n    @property\n    def is_workforce_pool(self):\n        \"\"\"Returns whether the credentials represent a workforce pool (True) or\n        workload (False) based on the credentials' audience.\n\n        This will also return True for impersonated workforce pool credentials.\n\n        Returns:\n            bool: True if the credentials represent a workforce pool. False if they\n                represent a workload.\n        \"\"\"\n        # Workforce pools representing users have the following audience format:\n        # //iam.googleapis.com/locations/$location/workforcePools/$poolId/providers/$providerId\n        p = re.compile(r\"//iam\\.googleapis\\.com/locations/[^/]+/workforcePools/\")\n        return p.match(self._audience or \"\") is not None\n\n    @property\n    def requires_scopes(self):\n        \"\"\"Checks if the credentials requires scopes.\n\n        Returns:\n            bool: True if there are no scopes set otherwise False.\n        \"\"\"\n        return not self._scopes and not self._default_scopes\n\n    @property\n    def project_number(self):\n        \"\"\"Optional[str]: The project number corresponding to the workload identity pool.\"\"\"\n\n        # STS audience pattern:\n        # //iam.googleapis.com/projects/$PROJECT_NUMBER/locations/...\n        components = self._audience.split(\"/\")\n        try:\n            project_index = components.index(\"projects\")\n            if project_index + 1 < len(components):\n                return components[project_index + 1] or None\n        except ValueError:\n            return None\n\n    @property\n    def token_info_url(self):\n        \"\"\"Optional[str]: The STS token introspection endpoint.\"\"\"\n\n        return self._token_info_url\n\n    @_helpers.copy_docstring(credentials.Scoped)\n    def with_scopes(self, scopes, default_scopes=None):\n        kwargs = self._constructor_args()\n        kwargs.update(scopes=scopes, default_scopes=default_scopes)\n        scoped = self.__class__(**kwargs)\n        scoped._metrics_options = self._metrics_options\n        return scoped\n\n    @abc.abstractmethod\n    def retrieve_subject_token(self, request):\n        \"\"\"Retrieves the subject token using the credential_source object.\n\n        Args:\n            request (google.auth.transport.Request): A callable used to make\n                HTTP requests.\n        Returns:\n            str: The retrieved subject token.\n        \"\"\"\n        # pylint: disable=missing-raises-doc\n        # (pylint doesn't recognize that this is abstract)\n        raise NotImplementedError(\"retrieve_subject_token must be implemented\")\n\n    def get_project_id(self, request):\n        \"\"\"Retrieves the project ID corresponding to the workload identity or workforce pool.\n        For workforce pool credentials, it returns the project ID corresponding to\n        the workforce_pool_user_project.\n\n        When not determinable, None is returned.\n\n        This is introduced to support the current pattern of using the Auth library:\n\n            credentials, project_id = google.auth.default()\n\n        The resource may not have permission (resourcemanager.projects.get) to\n        call this API or the required scopes may not be selected:\n        https://cloud.google.com/resource-manager/reference/rest/v1/projects/get#authorization-scopes\n\n        Args:\n            request (google.auth.transport.Request): A callable used to make\n                HTTP requests.\n        Returns:\n            Optional[str]: The project ID corresponding to the workload identity pool\n                or workforce pool if determinable.\n        \"\"\"\n        if self._project_id:\n            # If already retrieved, return the cached project ID value.\n            return self._project_id\n        scopes = self._scopes if self._scopes is not None else self._default_scopes\n        # Scopes are required in order to retrieve a valid access token.\n        project_number = self.project_number or self._workforce_pool_user_project\n        if project_number and scopes:\n            headers = {}\n            url = _CLOUD_RESOURCE_MANAGER + project_number\n            self.before_request(request, \"GET\", url, headers)\n            response = request(url=url, method=\"GET\", headers=headers)\n\n            response_body = (\n                response.data.decode(\"utf-8\")\n                if hasattr(response.data, \"decode\")\n                else response.data\n            )\n            response_data = json.loads(response_body)\n\n            if response.status == 200:\n                # Cache result as this field is immutable.\n                self._project_id = response_data.get(\"projectId\")\n                return self._project_id\n\n        return None\n\n    @_helpers.copy_docstring(credentials.Credentials)\n    def refresh(self, request):\n        scopes = self._scopes if self._scopes is not None else self._default_scopes\n\n        if self._should_initialize_impersonated_credentials():\n            self._impersonated_credentials = self._initialize_impersonated_credentials()\n\n        if self._impersonated_credentials:\n            self._impersonated_credentials.refresh(request)\n            self.token = self._impersonated_credentials.token\n            self.expiry = self._impersonated_credentials.expiry\n        else:\n            now = _helpers.utcnow()\n            additional_options = None\n            # Do not pass workforce_pool_user_project when client authentication\n            # is used. The client ID is sufficient for determining the user project.\n            if self._workforce_pool_user_project and not self._client_id:\n                additional_options = {\"userProject\": self._workforce_pool_user_project}\n            additional_headers = {\n                metrics.API_CLIENT_HEADER: metrics.byoid_metrics_header(\n                    self._metrics_options\n                )\n            }\n            response_data = self._sts_client.exchange_token(\n                request=request,\n                grant_type=_STS_GRANT_TYPE,\n                subject_token=self.retrieve_subject_token(request),\n                subject_token_type=self._subject_token_type,\n                audience=self._audience,\n                scopes=scopes,\n                requested_token_type=_STS_REQUESTED_TOKEN_TYPE,\n                additional_options=additional_options,\n                additional_headers=additional_headers,\n            )\n            self.token = response_data.get(\"access_token\")\n            expires_in = response_data.get(\"expires_in\")\n            # Some services do not respect the OAUTH2.0 RFC and send expires_in as a\n            # JSON String.\n            if isinstance(expires_in, str):\n                expires_in = int(expires_in)\n\n            lifetime = datetime.timedelta(seconds=expires_in)\n\n            self.expiry = now + lifetime\n\n    @_helpers.copy_docstring(credentials.CredentialsWithQuotaProject)\n    def with_quota_project(self, quota_project_id):\n        # Return copy of instance with the provided quota project ID.\n        kwargs = self._constructor_args()\n        kwargs.update(quota_project_id=quota_project_id)\n        new_cred = self.__class__(**kwargs)\n        new_cred._metrics_options = self._metrics_options\n        return new_cred\n\n    @_helpers.copy_docstring(credentials.CredentialsWithTokenUri)\n    def with_token_uri(self, token_uri):\n        kwargs = self._constructor_args()\n        kwargs.update(token_url=token_uri)\n        new_cred = self.__class__(**kwargs)\n        new_cred._metrics_options = self._metrics_options\n        return new_cred\n\n    @_helpers.copy_docstring(credentials.CredentialsWithUniverseDomain)\n    def with_universe_domain(self, universe_domain):\n        kwargs = self._constructor_args()\n        kwargs.update(universe_domain=universe_domain)\n        new_cred = self.__class__(**kwargs)\n        new_cred._metrics_options = self._metrics_options\n        return new_cred\n\n    def _should_initialize_impersonated_credentials(self):\n        return (\n            self._service_account_impersonation_url is not None\n            and self._impersonated_credentials is None\n        )\n\n    def _initialize_impersonated_credentials(self):\n        \"\"\"Generates an impersonated credentials.\n\n        For more details, see `projects.serviceAccounts.generateAccessToken`_.\n\n        .. _projects.serviceAccounts.generateAccessToken: https://cloud.google.com/iam/docs/reference/credentials/rest/v1/projects.serviceAccounts/generateAccessToken\n\n        Returns:\n            impersonated_credentials.Credential: The impersonated credentials\n                object.\n\n        Raises:\n            google.auth.exceptions.RefreshError: If the generateAccessToken\n                endpoint returned an error.\n        \"\"\"\n        # Return copy of instance with no service account impersonation.\n        kwargs = self._constructor_args()\n        kwargs.update(\n            service_account_impersonation_url=None,\n            service_account_impersonation_options={},\n        )\n        source_credentials = self.__class__(**kwargs)\n        source_credentials._metrics_options = self._metrics_options\n\n        # Determine target_principal.\n        target_principal = self.service_account_email\n        if not target_principal:\n            raise exceptions.RefreshError(\n                \"Unable to determine target principal from service account impersonation URL.\"\n            )\n\n        scopes = self._scopes if self._scopes is not None else self._default_scopes\n        # Initialize and return impersonated credentials.\n        return impersonated_credentials.Credentials(\n            source_credentials=source_credentials,\n            target_principal=target_principal,\n            target_scopes=scopes,\n            quota_project_id=self._quota_project_id,\n            iam_endpoint_override=self._service_account_impersonation_url,\n            lifetime=self._service_account_impersonation_options.get(\n                \"token_lifetime_seconds\"\n            ),\n        )\n\n    def _create_default_metrics_options(self):\n        metrics_options = {}\n        if self._service_account_impersonation_url:\n            metrics_options[\"sa-impersonation\"] = \"true\"\n        else:\n            metrics_options[\"sa-impersonation\"] = \"false\"\n        if self._service_account_impersonation_options.get(\"token_lifetime_seconds\"):\n            metrics_options[\"config-lifetime\"] = \"true\"\n        else:\n            metrics_options[\"config-lifetime\"] = \"false\"\n\n        return metrics_options\n\n    @classmethod\n    def from_info(cls, info, **kwargs):\n        \"\"\"Creates a Credentials instance from parsed external account info.\n\n        Args:\n            info (Mapping[str, str]): The external account info in Google\n                format.\n            kwargs: Additional arguments to pass to the constructor.\n\n        Returns:\n            google.auth.identity_pool.Credentials: The constructed\n                credentials.\n\n        Raises:\n            InvalidValue: For invalid parameters.\n        \"\"\"\n        return cls(\n            audience=info.get(\"audience\"),\n            subject_token_type=info.get(\"subject_token_type\"),\n            token_url=info.get(\"token_url\"),\n            token_info_url=info.get(\"token_info_url\"),\n            service_account_impersonation_url=info.get(\n                \"service_account_impersonation_url\"\n            ),\n            service_account_impersonation_options=info.get(\n                \"service_account_impersonation\"\n            )\n            or {},\n            client_id=info.get(\"client_id\"),\n            client_secret=info.get(\"client_secret\"),\n            credential_source=info.get(\"credential_source\"),\n            quota_project_id=info.get(\"quota_project_id\"),\n            workforce_pool_user_project=info.get(\"workforce_pool_user_project\"),\n            universe_domain=info.get(\n                \"universe_domain\", credentials.DEFAULT_UNIVERSE_DOMAIN\n            ),\n            **kwargs\n        )\n\n    @classmethod\n    def from_file(cls, filename, **kwargs):\n        \"\"\"Creates a Credentials instance from an external account json file.\n\n        Args:\n            filename (str): The path to the external account json file.\n            kwargs: Additional arguments to pass to the constructor.\n\n        Returns:\n            google.auth.identity_pool.Credentials: The constructed\n                credentials.\n        \"\"\"\n        with io.open(filename, \"r\", encoding=\"utf-8\") as json_file:\n            data = json.load(json_file)\n            return cls.from_info(data, **kwargs)\n", "google/auth/compute_engine/credentials.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Google Compute Engine credentials.\n\nThis module provides authentication for an application running on Google\nCompute Engine using the Compute Engine metadata server.\n\n\"\"\"\n\nimport datetime\n\nfrom google.auth import _helpers\nfrom google.auth import credentials\nfrom google.auth import exceptions\nfrom google.auth import iam\nfrom google.auth import jwt\nfrom google.auth import metrics\nfrom google.auth.compute_engine import _metadata\nfrom google.oauth2 import _client\n\n\nclass Credentials(\n    credentials.Scoped,\n    credentials.CredentialsWithQuotaProject,\n    credentials.CredentialsWithUniverseDomain,\n):\n    \"\"\"Compute Engine Credentials.\n\n    These credentials use the Google Compute Engine metadata server to obtain\n    OAuth 2.0 access tokens associated with the instance's service account,\n    and are also used for Cloud Run, Flex and App Engine (except for the Python\n    2.7 runtime, which is supported only on older versions of this library).\n\n    For more information about Compute Engine authentication, including how\n    to configure scopes, see the `Compute Engine authentication\n    documentation`_.\n\n    .. note:: On Compute Engine the metadata server ignores requested scopes.\n        On Cloud Run, Flex and App Engine the server honours requested scopes.\n\n    .. _Compute Engine authentication documentation:\n        https://cloud.google.com/compute/docs/authentication#using\n    \"\"\"\n\n    def __init__(\n        self,\n        service_account_email=\"default\",\n        quota_project_id=None,\n        scopes=None,\n        default_scopes=None,\n        universe_domain=None,\n    ):\n        \"\"\"\n        Args:\n            service_account_email (str): The service account email to use, or\n                'default'. A Compute Engine instance may have multiple service\n                accounts.\n            quota_project_id (Optional[str]): The project ID used for quota and\n                billing.\n            scopes (Optional[Sequence[str]]): The list of scopes for the credentials.\n            default_scopes (Optional[Sequence[str]]): Default scopes passed by a\n                Google client library. Use 'scopes' for user-defined scopes.\n            universe_domain (Optional[str]): The universe domain. If not\n                provided or None, credential will attempt to fetch the value\n                from metadata server. If metadata server doesn't have universe\n                domain endpoint, then the default googleapis.com will be used.\n        \"\"\"\n        super(Credentials, self).__init__()\n        self._service_account_email = service_account_email\n        self._quota_project_id = quota_project_id\n        self._scopes = scopes\n        self._default_scopes = default_scopes\n        self._universe_domain_cached = False\n        if universe_domain:\n            self._universe_domain = universe_domain\n            self._universe_domain_cached = True\n\n    def _retrieve_info(self, request):\n        \"\"\"Retrieve information about the service account.\n\n        Updates the scopes and retrieves the full service account email.\n\n        Args:\n            request (google.auth.transport.Request): The object used to make\n                HTTP requests.\n        \"\"\"\n        info = _metadata.get_service_account_info(\n            request, service_account=self._service_account_email\n        )\n\n        self._service_account_email = info[\"email\"]\n\n        # Don't override scopes requested by the user.\n        if self._scopes is None:\n            self._scopes = info[\"scopes\"]\n\n    def _metric_header_for_usage(self):\n        return metrics.CRED_TYPE_SA_MDS\n\n    def refresh(self, request):\n        \"\"\"Refresh the access token and scopes.\n\n        Args:\n            request (google.auth.transport.Request): The object used to make\n                HTTP requests.\n\n        Raises:\n            google.auth.exceptions.RefreshError: If the Compute Engine metadata\n                service can't be reached if if the instance has not\n                credentials.\n        \"\"\"\n        scopes = self._scopes if self._scopes is not None else self._default_scopes\n        try:\n            self._retrieve_info(request)\n            self.token, self.expiry = _metadata.get_service_account_token(\n                request, service_account=self._service_account_email, scopes=scopes\n            )\n        except exceptions.TransportError as caught_exc:\n            new_exc = exceptions.RefreshError(caught_exc)\n            raise new_exc from caught_exc\n\n    @property\n    def service_account_email(self):\n        \"\"\"The service account email.\n\n        .. note:: This is not guaranteed to be set until :meth:`refresh` has been\n            called.\n        \"\"\"\n        return self._service_account_email\n\n    @property\n    def requires_scopes(self):\n        return not self._scopes\n\n    @property\n    def universe_domain(self):\n        if self._universe_domain_cached:\n            return self._universe_domain\n\n        from google.auth.transport import requests as google_auth_requests\n\n        self._universe_domain = _metadata.get_universe_domain(\n            google_auth_requests.Request()\n        )\n        self._universe_domain_cached = True\n        return self._universe_domain\n\n    @_helpers.copy_docstring(credentials.CredentialsWithQuotaProject)\n    def with_quota_project(self, quota_project_id):\n        creds = self.__class__(\n            service_account_email=self._service_account_email,\n            quota_project_id=quota_project_id,\n            scopes=self._scopes,\n            default_scopes=self._default_scopes,\n        )\n        creds._universe_domain = self._universe_domain\n        creds._universe_domain_cached = self._universe_domain_cached\n        return creds\n\n    @_helpers.copy_docstring(credentials.Scoped)\n    def with_scopes(self, scopes, default_scopes=None):\n        # Compute Engine credentials can not be scoped (the metadata service\n        # ignores the scopes parameter). App Engine, Cloud Run and Flex support\n        # requesting scopes.\n        creds = self.__class__(\n            scopes=scopes,\n            default_scopes=default_scopes,\n            service_account_email=self._service_account_email,\n            quota_project_id=self._quota_project_id,\n        )\n        creds._universe_domain = self._universe_domain\n        creds._universe_domain_cached = self._universe_domain_cached\n        return creds\n\n    @_helpers.copy_docstring(credentials.CredentialsWithUniverseDomain)\n    def with_universe_domain(self, universe_domain):\n        return self.__class__(\n            scopes=self._scopes,\n            default_scopes=self._default_scopes,\n            service_account_email=self._service_account_email,\n            quota_project_id=self._quota_project_id,\n            universe_domain=universe_domain,\n        )\n\n\n_DEFAULT_TOKEN_LIFETIME_SECS = 3600  # 1 hour in seconds\n_DEFAULT_TOKEN_URI = \"https://www.googleapis.com/oauth2/v4/token\"\n\n\nclass IDTokenCredentials(\n    credentials.CredentialsWithQuotaProject,\n    credentials.Signing,\n    credentials.CredentialsWithTokenUri,\n):\n    \"\"\"Open ID Connect ID Token-based service account credentials.\n\n    These credentials relies on the default service account of a GCE instance.\n\n    ID token can be requested from `GCE metadata server identity endpoint`_, IAM\n    token endpoint or other token endpoints you specify. If metadata server\n    identity endpoint is not used, the GCE instance must have been started with\n    a service account that has access to the IAM Cloud API.\n\n    .. _GCE metadata server identity endpoint:\n        https://cloud.google.com/compute/docs/instances/verifying-instance-identity\n    \"\"\"\n\n    def __init__(\n        self,\n        request,\n        target_audience,\n        token_uri=None,\n        additional_claims=None,\n        service_account_email=None,\n        signer=None,\n        use_metadata_identity_endpoint=False,\n        quota_project_id=None,\n    ):\n        \"\"\"\n        Args:\n            request (google.auth.transport.Request): The object used to make\n                HTTP requests.\n            target_audience (str): The intended audience for these credentials,\n                used when requesting the ID Token. The ID Token's ``aud`` claim\n                will be set to this string.\n            token_uri (str): The OAuth 2.0 Token URI.\n            additional_claims (Mapping[str, str]): Any additional claims for\n                the JWT assertion used in the authorization grant.\n            service_account_email (str): Optional explicit service account to\n                use to sign JWT tokens.\n                By default, this is the default GCE service account.\n            signer (google.auth.crypt.Signer): The signer used to sign JWTs.\n                In case the signer is specified, the request argument will be\n                ignored.\n            use_metadata_identity_endpoint (bool): Whether to use GCE metadata\n                identity endpoint. For backward compatibility the default value\n                is False. If set to True, ``token_uri``, ``additional_claims``,\n                ``service_account_email``, ``signer`` argument should not be set;\n                otherwise ValueError will be raised.\n            quota_project_id (Optional[str]): The project ID used for quota and\n                billing.\n\n        Raises:\n            ValueError:\n                If ``use_metadata_identity_endpoint`` is set to True, and one of\n                ``token_uri``, ``additional_claims``, ``service_account_email``,\n                 ``signer`` arguments is set.\n        \"\"\"\n        super(IDTokenCredentials, self).__init__()\n\n        self._quota_project_id = quota_project_id\n        self._use_metadata_identity_endpoint = use_metadata_identity_endpoint\n        self._target_audience = target_audience\n\n        if use_metadata_identity_endpoint:\n            if token_uri or additional_claims or service_account_email or signer:\n                raise exceptions.MalformedError(\n                    \"If use_metadata_identity_endpoint is set, token_uri, \"\n                    \"additional_claims, service_account_email, signer arguments\"\n                    \" must not be set\"\n                )\n            self._token_uri = None\n            self._additional_claims = None\n            self._signer = None\n\n        if service_account_email is None:\n            sa_info = _metadata.get_service_account_info(request)\n            self._service_account_email = sa_info[\"email\"]\n        else:\n            self._service_account_email = service_account_email\n\n        if not use_metadata_identity_endpoint:\n            if signer is None:\n                signer = iam.Signer(\n                    request=request,\n                    credentials=Credentials(),\n                    service_account_email=self._service_account_email,\n                )\n            self._signer = signer\n            self._token_uri = token_uri or _DEFAULT_TOKEN_URI\n\n            if additional_claims is not None:\n                self._additional_claims = additional_claims\n            else:\n                self._additional_claims = {}\n\n    def with_target_audience(self, target_audience):\n        \"\"\"Create a copy of these credentials with the specified target\n        audience.\n        Args:\n            target_audience (str): The intended audience for these credentials,\n            used when requesting the ID Token.\n        Returns:\n            google.auth.service_account.IDTokenCredentials: A new credentials\n                instance.\n        \"\"\"\n        # since the signer is already instantiated,\n        # the request is not needed\n        if self._use_metadata_identity_endpoint:\n            return self.__class__(\n                None,\n                target_audience=target_audience,\n                use_metadata_identity_endpoint=True,\n                quota_project_id=self._quota_project_id,\n            )\n        else:\n            return self.__class__(\n                None,\n                service_account_email=self._service_account_email,\n                token_uri=self._token_uri,\n                target_audience=target_audience,\n                additional_claims=self._additional_claims.copy(),\n                signer=self.signer,\n                use_metadata_identity_endpoint=False,\n                quota_project_id=self._quota_project_id,\n            )\n\n    @_helpers.copy_docstring(credentials.CredentialsWithQuotaProject)\n    def with_quota_project(self, quota_project_id):\n\n        # since the signer is already instantiated,\n        # the request is not needed\n        if self._use_metadata_identity_endpoint:\n            return self.__class__(\n                None,\n                target_audience=self._target_audience,\n                use_metadata_identity_endpoint=True,\n                quota_project_id=quota_project_id,\n            )\n        else:\n            return self.__class__(\n                None,\n                service_account_email=self._service_account_email,\n                token_uri=self._token_uri,\n                target_audience=self._target_audience,\n                additional_claims=self._additional_claims.copy(),\n                signer=self.signer,\n                use_metadata_identity_endpoint=False,\n                quota_project_id=quota_project_id,\n            )\n\n    @_helpers.copy_docstring(credentials.CredentialsWithTokenUri)\n    def with_token_uri(self, token_uri):\n\n        # since the signer is already instantiated,\n        # the request is not needed\n        if self._use_metadata_identity_endpoint:\n            raise exceptions.MalformedError(\n                \"If use_metadata_identity_endpoint is set, token_uri\" \" must not be set\"\n            )\n        else:\n            return self.__class__(\n                None,\n                service_account_email=self._service_account_email,\n                token_uri=token_uri,\n                target_audience=self._target_audience,\n                additional_claims=self._additional_claims.copy(),\n                signer=self.signer,\n                use_metadata_identity_endpoint=False,\n                quota_project_id=self.quota_project_id,\n            )\n\n    def _make_authorization_grant_assertion(self):\n        \"\"\"Create the OAuth 2.0 assertion.\n        This assertion is used during the OAuth 2.0 grant to acquire an\n        ID token.\n        Returns:\n            bytes: The authorization grant assertion.\n        \"\"\"\n        now = _helpers.utcnow()\n        lifetime = datetime.timedelta(seconds=_DEFAULT_TOKEN_LIFETIME_SECS)\n        expiry = now + lifetime\n\n        payload = {\n            \"iat\": _helpers.datetime_to_secs(now),\n            \"exp\": _helpers.datetime_to_secs(expiry),\n            # The issuer must be the service account email.\n            \"iss\": self.service_account_email,\n            # The audience must be the auth token endpoint's URI\n            \"aud\": self._token_uri,\n            # The target audience specifies which service the ID token is\n            # intended for.\n            \"target_audience\": self._target_audience,\n        }\n\n        payload.update(self._additional_claims)\n\n        token = jwt.encode(self._signer, payload)\n\n        return token\n\n    def _call_metadata_identity_endpoint(self, request):\n        \"\"\"Request ID token from metadata identity endpoint.\n\n        Args:\n            request (google.auth.transport.Request): The object used to make\n                HTTP requests.\n\n        Returns:\n            Tuple[str, datetime.datetime]: The ID token and the expiry of the ID token.\n\n        Raises:\n            google.auth.exceptions.RefreshError: If the Compute Engine metadata\n                service can't be reached or if the instance has no credentials.\n            ValueError: If extracting expiry from the obtained ID token fails.\n        \"\"\"\n        try:\n            path = \"instance/service-accounts/default/identity\"\n            params = {\"audience\": self._target_audience, \"format\": \"full\"}\n            metrics_header = {\n                metrics.API_CLIENT_HEADER: metrics.token_request_id_token_mds()\n            }\n            id_token = _metadata.get(\n                request, path, params=params, headers=metrics_header\n            )\n        except exceptions.TransportError as caught_exc:\n            new_exc = exceptions.RefreshError(caught_exc)\n            raise new_exc from caught_exc\n\n        _, payload, _, _ = jwt._unverified_decode(id_token)\n        return id_token, datetime.datetime.utcfromtimestamp(payload[\"exp\"])\n\n    def refresh(self, request):\n        \"\"\"Refreshes the ID token.\n\n        Args:\n            request (google.auth.transport.Request): The object used to make\n                HTTP requests.\n\n        Raises:\n            google.auth.exceptions.RefreshError: If the credentials could\n                not be refreshed.\n            ValueError: If extracting expiry from the obtained ID token fails.\n        \"\"\"\n        if self._use_metadata_identity_endpoint:\n            self.token, self.expiry = self._call_metadata_identity_endpoint(request)\n        else:\n            assertion = self._make_authorization_grant_assertion()\n            access_token, expiry, _ = _client.id_token_jwt_grant(\n                request, self._token_uri, assertion\n            )\n            self.token = access_token\n            self.expiry = expiry\n\n    @property  # type: ignore\n    @_helpers.copy_docstring(credentials.Signing)\n    def signer(self):\n        return self._signer\n\n    def sign_bytes(self, message):\n        \"\"\"Signs the given message.\n\n        Args:\n            message (bytes): The message to sign.\n\n        Returns:\n            bytes: The message's cryptographic signature.\n\n        Raises:\n            ValueError:\n                Signer is not available if metadata identity endpoint is used.\n        \"\"\"\n        if self._use_metadata_identity_endpoint:\n            raise exceptions.InvalidOperation(\n                \"Signer is not available if metadata identity endpoint is used\"\n            )\n        return self._signer.sign(message)\n\n    @property\n    def service_account_email(self):\n        \"\"\"The service account email.\"\"\"\n        return self._service_account_email\n\n    @property\n    def signer_email(self):\n        return self._service_account_email\n", "google/auth/compute_engine/_metadata.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Provides helper methods for talking to the Compute Engine metadata server.\n\nSee https://cloud.google.com/compute/docs/metadata for more details.\n\"\"\"\n\nimport datetime\nimport http.client as http_client\nimport json\nimport logging\nimport os\nfrom urllib.parse import urljoin\n\nfrom google.auth import _helpers\nfrom google.auth import environment_vars\nfrom google.auth import exceptions\nfrom google.auth import metrics\n\n_LOGGER = logging.getLogger(__name__)\n\n# Environment variable GCE_METADATA_HOST is originally named\n# GCE_METADATA_ROOT. For compatiblity reasons, here it checks\n# the new variable first; if not set, the system falls back\n# to the old variable.\n_GCE_METADATA_HOST = os.getenv(environment_vars.GCE_METADATA_HOST, None)\nif not _GCE_METADATA_HOST:\n    _GCE_METADATA_HOST = os.getenv(\n        environment_vars.GCE_METADATA_ROOT, \"metadata.google.internal\"\n    )\n_METADATA_ROOT = \"http://{}/computeMetadata/v1/\".format(_GCE_METADATA_HOST)\n\n# This is used to ping the metadata server, it avoids the cost of a DNS\n# lookup.\n_METADATA_IP_ROOT = \"http://{}\".format(\n    os.getenv(environment_vars.GCE_METADATA_IP, \"169.254.169.254\")\n)\n_METADATA_FLAVOR_HEADER = \"metadata-flavor\"\n_METADATA_FLAVOR_VALUE = \"Google\"\n_METADATA_HEADERS = {_METADATA_FLAVOR_HEADER: _METADATA_FLAVOR_VALUE}\n\n# Timeout in seconds to wait for the GCE metadata server when detecting the\n# GCE environment.\ntry:\n    _METADATA_DEFAULT_TIMEOUT = int(os.getenv(\"GCE_METADATA_TIMEOUT\", 3))\nexcept ValueError:  # pragma: NO COVER\n    _METADATA_DEFAULT_TIMEOUT = 3\n\n# Detect GCE Residency\n_GOOGLE = \"Google\"\n_GCE_PRODUCT_NAME_FILE = \"/sys/class/dmi/id/product_name\"\n\n\ndef is_on_gce(request):\n    \"\"\"Checks to see if the code runs on Google Compute Engine\n\n    Args:\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests.\n\n    Returns:\n        bool: True if the code runs on Google Compute Engine, False otherwise.\n    \"\"\"\n    if ping(request):\n        return True\n\n    if os.name == \"nt\":\n        # TODO: implement GCE residency detection on Windows\n        return False\n\n    # Detect GCE residency on Linux\n    return detect_gce_residency_linux()\n\n\ndef detect_gce_residency_linux():\n    \"\"\"Detect Google Compute Engine residency by smbios check on Linux\n\n    Returns:\n        bool: True if the GCE product name file is detected, False otherwise.\n    \"\"\"\n    try:\n        with open(_GCE_PRODUCT_NAME_FILE, \"r\") as file_obj:\n            content = file_obj.read().strip()\n\n    except Exception:\n        return False\n\n    return content.startswith(_GOOGLE)\n\n\ndef ping(request, timeout=_METADATA_DEFAULT_TIMEOUT, retry_count=3):\n    \"\"\"Checks to see if the metadata server is available.\n\n    Args:\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests.\n        timeout (int): How long to wait for the metadata server to respond.\n        retry_count (int): How many times to attempt connecting to metadata\n            server using above timeout.\n\n    Returns:\n        bool: True if the metadata server is reachable, False otherwise.\n    \"\"\"\n    # NOTE: The explicit ``timeout`` is a workaround. The underlying\n    #       issue is that resolving an unknown host on some networks will take\n    #       20-30 seconds; making this timeout short fixes the issue, but\n    #       could lead to false negatives in the event that we are on GCE, but\n    #       the metadata resolution was particularly slow. The latter case is\n    #       \"unlikely\".\n    retries = 0\n    headers = _METADATA_HEADERS.copy()\n    headers[metrics.API_CLIENT_HEADER] = metrics.mds_ping()\n\n    while retries < retry_count:\n        try:\n            response = request(\n                url=_METADATA_IP_ROOT, method=\"GET\", headers=headers, timeout=timeout\n            )\n\n            metadata_flavor = response.headers.get(_METADATA_FLAVOR_HEADER)\n            return (\n                response.status == http_client.OK\n                and metadata_flavor == _METADATA_FLAVOR_VALUE\n            )\n\n        except exceptions.TransportError as e:\n            _LOGGER.warning(\n                \"Compute Engine Metadata server unavailable on \"\n                \"attempt %s of %s. Reason: %s\",\n                retries + 1,\n                retry_count,\n                e,\n            )\n            retries += 1\n\n    return False\n\n\ndef get(\n    request,\n    path,\n    root=_METADATA_ROOT,\n    params=None,\n    recursive=False,\n    retry_count=5,\n    headers=None,\n    return_none_for_not_found_error=False,\n):\n    \"\"\"Fetch a resource from the metadata server.\n\n    Args:\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests.\n        path (str): The resource to retrieve. For example,\n            ``'instance/service-accounts/default'``.\n        root (str): The full path to the metadata server root.\n        params (Optional[Mapping[str, str]]): A mapping of query parameter\n            keys to values.\n        recursive (bool): Whether to do a recursive query of metadata. See\n            https://cloud.google.com/compute/docs/metadata#aggcontents for more\n            details.\n        retry_count (int): How many times to attempt connecting to metadata\n            server using above timeout.\n        headers (Optional[Mapping[str, str]]): Headers for the request.\n        return_none_for_not_found_error (Optional[bool]): If True, returns None\n            for 404 error instead of throwing an exception.\n\n    Returns:\n        Union[Mapping, str]: If the metadata server returns JSON, a mapping of\n            the decoded JSON is return. Otherwise, the response content is\n            returned as a string.\n\n    Raises:\n        google.auth.exceptions.TransportError: if an error occurred while\n            retrieving metadata.\n    \"\"\"\n    base_url = urljoin(root, path)\n    query_params = {} if params is None else params\n\n    headers_to_use = _METADATA_HEADERS.copy()\n    if headers:\n        headers_to_use.update(headers)\n\n    if recursive:\n        query_params[\"recursive\"] = \"true\"\n\n    url = _helpers.update_query(base_url, query_params)\n\n    retries = 0\n    while retries < retry_count:\n        try:\n            response = request(url=url, method=\"GET\", headers=headers_to_use)\n            break\n\n        except exceptions.TransportError as e:\n            _LOGGER.warning(\n                \"Compute Engine Metadata server unavailable on \"\n                \"attempt %s of %s. Reason: %s\",\n                retries + 1,\n                retry_count,\n                e,\n            )\n            retries += 1\n    else:\n        raise exceptions.TransportError(\n            \"Failed to retrieve {} from the Google Compute Engine \"\n            \"metadata service. Compute Engine Metadata server unavailable\".format(url)\n        )\n\n    content = _helpers.from_bytes(response.data)\n\n    if response.status == http_client.NOT_FOUND and return_none_for_not_found_error:\n        return None\n\n    if response.status == http_client.OK:\n        if (\n            _helpers.parse_content_type(response.headers[\"content-type\"])\n            == \"application/json\"\n        ):\n            try:\n                return json.loads(content)\n            except ValueError as caught_exc:\n                new_exc = exceptions.TransportError(\n                    \"Received invalid JSON from the Google Compute Engine \"\n                    \"metadata service: {:.20}\".format(content)\n                )\n                raise new_exc from caught_exc\n        else:\n            return content\n\n    raise exceptions.TransportError(\n        \"Failed to retrieve {} from the Google Compute Engine \"\n        \"metadata service. Status: {} Response:\\n{}\".format(\n            url, response.status, response.data\n        ),\n        response,\n    )\n\n\ndef get_project_id(request):\n    \"\"\"Get the Google Cloud Project ID from the metadata server.\n\n    Args:\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests.\n\n    Returns:\n        str: The project ID\n\n    Raises:\n        google.auth.exceptions.TransportError: if an error occurred while\n            retrieving metadata.\n    \"\"\"\n    return get(request, \"project/project-id\")\n\n\ndef get_universe_domain(request):\n    \"\"\"Get the universe domain value from the metadata server.\n\n    Args:\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests.\n\n    Returns:\n        str: The universe domain value. If the universe domain endpoint is not\n        not found, return the default value, which is googleapis.com\n\n    Raises:\n        google.auth.exceptions.TransportError: if an error other than\n            404 occurs while retrieving metadata.\n    \"\"\"\n    universe_domain = get(\n        request, \"universe/universe_domain\", return_none_for_not_found_error=True\n    )\n    if not universe_domain:\n        return \"googleapis.com\"\n    return universe_domain\n\n\ndef get_service_account_info(request, service_account=\"default\"):\n    \"\"\"Get information about a service account from the metadata server.\n\n    Args:\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests.\n        service_account (str): The string 'default' or a service account email\n            address. The determines which service account for which to acquire\n            information.\n\n    Returns:\n        Mapping: The service account's information, for example::\n\n            {\n                'email': '...',\n                'scopes': ['scope', ...],\n                'aliases': ['default', '...']\n            }\n\n    Raises:\n        google.auth.exceptions.TransportError: if an error occurred while\n            retrieving metadata.\n    \"\"\"\n    path = \"instance/service-accounts/{0}/\".format(service_account)\n    # See https://cloud.google.com/compute/docs/metadata#aggcontents\n    # for more on the use of 'recursive'.\n    return get(request, path, params={\"recursive\": \"true\"})\n\n\ndef get_service_account_token(request, service_account=\"default\", scopes=None):\n    \"\"\"Get the OAuth 2.0 access token for a service account.\n\n    Args:\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests.\n        service_account (str): The string 'default' or a service account email\n            address. The determines which service account for which to acquire\n            an access token.\n        scopes (Optional[Union[str, List[str]]]): Optional string or list of\n            strings with auth scopes.\n    Returns:\n        Tuple[str, datetime]: The access token and its expiration.\n\n    Raises:\n        google.auth.exceptions.TransportError: if an error occurred while\n            retrieving metadata.\n    \"\"\"\n    if scopes:\n        if not isinstance(scopes, str):\n            scopes = \",\".join(scopes)\n        params = {\"scopes\": scopes}\n    else:\n        params = None\n\n    metrics_header = {\n        metrics.API_CLIENT_HEADER: metrics.token_request_access_token_mds()\n    }\n\n    path = \"instance/service-accounts/{0}/token\".format(service_account)\n    token_json = get(request, path, params=params, headers=metrics_header)\n    token_expiry = _helpers.utcnow() + datetime.timedelta(\n        seconds=token_json[\"expires_in\"]\n    )\n    return token_json[\"access_token\"], token_expiry\n", "google/auth/compute_engine/__init__.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Google Compute Engine authentication.\"\"\"\n\nfrom google.auth.compute_engine._metadata import detect_gce_residency_linux\nfrom google.auth.compute_engine.credentials import Credentials\nfrom google.auth.compute_engine.credentials import IDTokenCredentials\n\n\n__all__ = [\"Credentials\", \"IDTokenCredentials\", \"detect_gce_residency_linux\"]\n", "google/auth/crypt/_python_rsa.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Pure-Python RSA cryptography implementation.\n\nUses the ``rsa``, ``pyasn1`` and ``pyasn1_modules`` packages\nto parse PEM files storing PKCS#1 or PKCS#8 keys as well as\ncertificates. There is no support for p12 files.\n\"\"\"\n\nfrom __future__ import absolute_import\n\nimport io\n\nfrom pyasn1.codec.der import decoder  # type: ignore\nfrom pyasn1_modules import pem  # type: ignore\nfrom pyasn1_modules.rfc2459 import Certificate  # type: ignore\nfrom pyasn1_modules.rfc5208 import PrivateKeyInfo  # type: ignore\nimport rsa  # type: ignore\n\nfrom google.auth import _helpers\nfrom google.auth import exceptions\nfrom google.auth.crypt import base\n\n_POW2 = (128, 64, 32, 16, 8, 4, 2, 1)\n_CERTIFICATE_MARKER = b\"-----BEGIN CERTIFICATE-----\"\n_PKCS1_MARKER = (\"-----BEGIN RSA PRIVATE KEY-----\", \"-----END RSA PRIVATE KEY-----\")\n_PKCS8_MARKER = (\"-----BEGIN PRIVATE KEY-----\", \"-----END PRIVATE KEY-----\")\n_PKCS8_SPEC = PrivateKeyInfo()\n\n\ndef _bit_list_to_bytes(bit_list):\n    \"\"\"Converts an iterable of 1s and 0s to bytes.\n\n    Combines the list 8 at a time, treating each group of 8 bits\n    as a single byte.\n\n    Args:\n        bit_list (Sequence): Sequence of 1s and 0s.\n\n    Returns:\n        bytes: The decoded bytes.\n    \"\"\"\n    num_bits = len(bit_list)\n    byte_vals = bytearray()\n    for start in range(0, num_bits, 8):\n        curr_bits = bit_list[start : start + 8]\n        char_val = sum(val * digit for val, digit in zip(_POW2, curr_bits))\n        byte_vals.append(char_val)\n    return bytes(byte_vals)\n\n\nclass RSAVerifier(base.Verifier):\n    \"\"\"Verifies RSA cryptographic signatures using public keys.\n\n    Args:\n        public_key (rsa.key.PublicKey): The public key used to verify\n            signatures.\n    \"\"\"\n\n    def __init__(self, public_key):\n        self._pubkey = public_key\n\n    @_helpers.copy_docstring(base.Verifier)\n    def verify(self, message, signature):\n        message = _helpers.to_bytes(message)\n        try:\n            return rsa.pkcs1.verify(message, signature, self._pubkey)\n        except (ValueError, rsa.pkcs1.VerificationError):\n            return False\n\n    @classmethod\n    def from_string(cls, public_key):\n        \"\"\"Construct an Verifier instance from a public key or public\n        certificate string.\n\n        Args:\n            public_key (Union[str, bytes]): The public key in PEM format or the\n                x509 public key certificate.\n\n        Returns:\n            google.auth.crypt._python_rsa.RSAVerifier: The constructed verifier.\n\n        Raises:\n            ValueError: If the public_key can't be parsed.\n        \"\"\"\n        public_key = _helpers.to_bytes(public_key)\n        is_x509_cert = _CERTIFICATE_MARKER in public_key\n\n        # If this is a certificate, extract the public key info.\n        if is_x509_cert:\n            der = rsa.pem.load_pem(public_key, \"CERTIFICATE\")\n            asn1_cert, remaining = decoder.decode(der, asn1Spec=Certificate())\n            if remaining != b\"\":\n                raise exceptions.InvalidValue(\"Unused bytes\", remaining)\n\n            cert_info = asn1_cert[\"tbsCertificate\"][\"subjectPublicKeyInfo\"]\n            key_bytes = _bit_list_to_bytes(cert_info[\"subjectPublicKey\"])\n            pubkey = rsa.PublicKey.load_pkcs1(key_bytes, \"DER\")\n        else:\n            pubkey = rsa.PublicKey.load_pkcs1(public_key, \"PEM\")\n        return cls(pubkey)\n\n\nclass RSASigner(base.Signer, base.FromServiceAccountMixin):\n    \"\"\"Signs messages with an RSA private key.\n\n    Args:\n        private_key (rsa.key.PrivateKey): The private key to sign with.\n        key_id (str): Optional key ID used to identify this private key. This\n            can be useful to associate the private key with its associated\n            public key or certificate.\n    \"\"\"\n\n    def __init__(self, private_key, key_id=None):\n        self._key = private_key\n        self._key_id = key_id\n\n    @property  # type: ignore\n    @_helpers.copy_docstring(base.Signer)\n    def key_id(self):\n        return self._key_id\n\n    @_helpers.copy_docstring(base.Signer)\n    def sign(self, message):\n        message = _helpers.to_bytes(message)\n        return rsa.pkcs1.sign(message, self._key, \"SHA-256\")\n\n    @classmethod\n    def from_string(cls, key, key_id=None):\n        \"\"\"Construct an Signer instance from a private key in PEM format.\n\n        Args:\n            key (str): Private key in PEM format.\n            key_id (str): An optional key id used to identify the private key.\n\n        Returns:\n            google.auth.crypt.Signer: The constructed signer.\n\n        Raises:\n            ValueError: If the key cannot be parsed as PKCS#1 or PKCS#8 in\n                PEM format.\n        \"\"\"\n        key = _helpers.from_bytes(key)  # PEM expects str in Python 3\n        marker_id, key_bytes = pem.readPemBlocksFromFile(\n            io.StringIO(key), _PKCS1_MARKER, _PKCS8_MARKER\n        )\n\n        # Key is in pkcs1 format.\n        if marker_id == 0:\n            private_key = rsa.key.PrivateKey.load_pkcs1(key_bytes, format=\"DER\")\n        # Key is in pkcs8.\n        elif marker_id == 1:\n            key_info, remaining = decoder.decode(key_bytes, asn1Spec=_PKCS8_SPEC)\n            if remaining != b\"\":\n                raise exceptions.InvalidValue(\"Unused bytes\", remaining)\n            private_key_info = key_info.getComponentByName(\"privateKey\")\n            private_key = rsa.key.PrivateKey.load_pkcs1(\n                private_key_info.asOctets(), format=\"DER\"\n            )\n        else:\n            raise exceptions.MalformedError(\"No key could be detected.\")\n\n        return cls(private_key, key_id=key_id)\n", "google/auth/crypt/base.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Base classes for cryptographic signers and verifiers.\"\"\"\n\nimport abc\nimport io\nimport json\n\nfrom google.auth import exceptions\n\n_JSON_FILE_PRIVATE_KEY = \"private_key\"\n_JSON_FILE_PRIVATE_KEY_ID = \"private_key_id\"\n\n\nclass Verifier(metaclass=abc.ABCMeta):\n    \"\"\"Abstract base class for crytographic signature verifiers.\"\"\"\n\n    @abc.abstractmethod\n    def verify(self, message, signature):\n        \"\"\"Verifies a message against a cryptographic signature.\n\n        Args:\n            message (Union[str, bytes]): The message to verify.\n            signature (Union[str, bytes]): The cryptography signature to check.\n\n        Returns:\n            bool: True if message was signed by the private key associated\n            with the public key that this object was constructed with.\n        \"\"\"\n        # pylint: disable=missing-raises-doc,redundant-returns-doc\n        # (pylint doesn't recognize that this is abstract)\n        raise NotImplementedError(\"Verify must be implemented\")\n\n\nclass Signer(metaclass=abc.ABCMeta):\n    \"\"\"Abstract base class for cryptographic signers.\"\"\"\n\n    @abc.abstractproperty\n    def key_id(self):\n        \"\"\"Optional[str]: The key ID used to identify this private key.\"\"\"\n        raise NotImplementedError(\"Key id must be implemented\")\n\n    @abc.abstractmethod\n    def sign(self, message):\n        \"\"\"Signs a message.\n\n        Args:\n            message (Union[str, bytes]): The message to be signed.\n\n        Returns:\n            bytes: The signature of the message.\n        \"\"\"\n        # pylint: disable=missing-raises-doc,redundant-returns-doc\n        # (pylint doesn't recognize that this is abstract)\n        raise NotImplementedError(\"Sign must be implemented\")\n\n\nclass FromServiceAccountMixin(metaclass=abc.ABCMeta):\n    \"\"\"Mix-in to enable factory constructors for a Signer.\"\"\"\n\n    @abc.abstractmethod\n    def from_string(cls, key, key_id=None):\n        \"\"\"Construct an Signer instance from a private key string.\n\n        Args:\n            key (str): Private key as a string.\n            key_id (str): An optional key id used to identify the private key.\n\n        Returns:\n            google.auth.crypt.Signer: The constructed signer.\n\n        Raises:\n            ValueError: If the key cannot be parsed.\n        \"\"\"\n        raise NotImplementedError(\"from_string must be implemented\")\n\n    @classmethod\n    def from_service_account_info(cls, info):\n        \"\"\"Creates a Signer instance instance from a dictionary containing\n        service account info in Google format.\n\n        Args:\n            info (Mapping[str, str]): The service account info in Google\n                format.\n\n        Returns:\n            google.auth.crypt.Signer: The constructed signer.\n\n        Raises:\n            ValueError: If the info is not in the expected format.\n        \"\"\"\n        if _JSON_FILE_PRIVATE_KEY not in info:\n            raise exceptions.MalformedError(\n                \"The private_key field was not found in the service account \" \"info.\"\n            )\n\n        return cls.from_string(\n            info[_JSON_FILE_PRIVATE_KEY], info.get(_JSON_FILE_PRIVATE_KEY_ID)\n        )\n\n    @classmethod\n    def from_service_account_file(cls, filename):\n        \"\"\"Creates a Signer instance from a service account .json file\n        in Google format.\n\n        Args:\n            filename (str): The path to the service account .json file.\n\n        Returns:\n            google.auth.crypt.Signer: The constructed signer.\n        \"\"\"\n        with io.open(filename, \"r\", encoding=\"utf-8\") as json_file:\n            data = json.load(json_file)\n\n        return cls.from_service_account_info(data)\n", "google/auth/crypt/_cryptography_rsa.py": "# Copyright 2017 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"RSA verifier and signer that use the ``cryptography`` library.\n\nThis is a much faster implementation than the default (in\n``google.auth.crypt._python_rsa``), which depends on the pure-Python\n``rsa`` library.\n\"\"\"\n\nimport cryptography.exceptions\nfrom cryptography.hazmat import backends\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.primitives.asymmetric import padding\nimport cryptography.x509\n\nfrom google.auth import _helpers\nfrom google.auth.crypt import base\n\n_CERTIFICATE_MARKER = b\"-----BEGIN CERTIFICATE-----\"\n_BACKEND = backends.default_backend()\n_PADDING = padding.PKCS1v15()\n_SHA256 = hashes.SHA256()\n\n\nclass RSAVerifier(base.Verifier):\n    \"\"\"Verifies RSA cryptographic signatures using public keys.\n\n    Args:\n        public_key (\n                cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey):\n            The public key used to verify signatures.\n    \"\"\"\n\n    def __init__(self, public_key):\n        self._pubkey = public_key\n\n    @_helpers.copy_docstring(base.Verifier)\n    def verify(self, message, signature):\n        message = _helpers.to_bytes(message)\n        try:\n            self._pubkey.verify(signature, message, _PADDING, _SHA256)\n            return True\n        except (ValueError, cryptography.exceptions.InvalidSignature):\n            return False\n\n    @classmethod\n    def from_string(cls, public_key):\n        \"\"\"Construct an Verifier instance from a public key or public\n        certificate string.\n\n        Args:\n            public_key (Union[str, bytes]): The public key in PEM format or the\n                x509 public key certificate.\n\n        Returns:\n            Verifier: The constructed verifier.\n\n        Raises:\n            ValueError: If the public key can't be parsed.\n        \"\"\"\n        public_key_data = _helpers.to_bytes(public_key)\n\n        if _CERTIFICATE_MARKER in public_key_data:\n            cert = cryptography.x509.load_pem_x509_certificate(\n                public_key_data, _BACKEND\n            )\n            pubkey = cert.public_key()\n\n        else:\n            pubkey = serialization.load_pem_public_key(public_key_data, _BACKEND)\n\n        return cls(pubkey)\n\n\nclass RSASigner(base.Signer, base.FromServiceAccountMixin):\n    \"\"\"Signs messages with an RSA private key.\n\n    Args:\n        private_key (\n                cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKey):\n            The private key to sign with.\n        key_id (str): Optional key ID used to identify this private key. This\n            can be useful to associate the private key with its associated\n            public key or certificate.\n    \"\"\"\n\n    def __init__(self, private_key, key_id=None):\n        self._key = private_key\n        self._key_id = key_id\n\n    @property  # type: ignore\n    @_helpers.copy_docstring(base.Signer)\n    def key_id(self):\n        return self._key_id\n\n    @_helpers.copy_docstring(base.Signer)\n    def sign(self, message):\n        message = _helpers.to_bytes(message)\n        return self._key.sign(message, _PADDING, _SHA256)\n\n    @classmethod\n    def from_string(cls, key, key_id=None):\n        \"\"\"Construct a RSASigner from a private key in PEM format.\n\n        Args:\n            key (Union[bytes, str]): Private key in PEM format.\n            key_id (str): An optional key id used to identify the private key.\n\n        Returns:\n            google.auth.crypt._cryptography_rsa.RSASigner: The\n            constructed signer.\n\n        Raises:\n            ValueError: If ``key`` is not ``bytes`` or ``str`` (unicode).\n            UnicodeDecodeError: If ``key`` is ``bytes`` but cannot be decoded\n                into a UTF-8 ``str``.\n            ValueError: If ``cryptography`` \"Could not deserialize key data.\"\n        \"\"\"\n        key = _helpers.to_bytes(key)\n        private_key = serialization.load_pem_private_key(\n            key, password=None, backend=_BACKEND\n        )\n        return cls(private_key, key_id=key_id)\n\n    def __getstate__(self):\n        \"\"\"Pickle helper that serializes the _key attribute.\"\"\"\n        state = self.__dict__.copy()\n        state[\"_key\"] = self._key.private_bytes(\n            encoding=serialization.Encoding.PEM,\n            format=serialization.PrivateFormat.PKCS8,\n            encryption_algorithm=serialization.NoEncryption(),\n        )\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Pickle helper that deserializes the _key attribute.\"\"\"\n        state[\"_key\"] = serialization.load_pem_private_key(state[\"_key\"], None)\n        self.__dict__.update(state)\n", "google/auth/crypt/es256.py": "# Copyright 2017 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"ECDSA (ES256) verifier and signer that use the ``cryptography`` library.\n\"\"\"\n\nfrom cryptography import utils  # type: ignore\nimport cryptography.exceptions\nfrom cryptography.hazmat import backends\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.primitives.asymmetric import ec\nfrom cryptography.hazmat.primitives.asymmetric import padding\nfrom cryptography.hazmat.primitives.asymmetric.utils import decode_dss_signature\nfrom cryptography.hazmat.primitives.asymmetric.utils import encode_dss_signature\nimport cryptography.x509\n\nfrom google.auth import _helpers\nfrom google.auth.crypt import base\n\n\n_CERTIFICATE_MARKER = b\"-----BEGIN CERTIFICATE-----\"\n_BACKEND = backends.default_backend()\n_PADDING = padding.PKCS1v15()\n\n\nclass ES256Verifier(base.Verifier):\n    \"\"\"Verifies ECDSA cryptographic signatures using public keys.\n\n    Args:\n        public_key (\n                cryptography.hazmat.primitives.asymmetric.ec.ECDSAPublicKey):\n            The public key used to verify signatures.\n    \"\"\"\n\n    def __init__(self, public_key):\n        self._pubkey = public_key\n\n    @_helpers.copy_docstring(base.Verifier)\n    def verify(self, message, signature):\n        # First convert (r||s) raw signature to ASN1 encoded signature.\n        sig_bytes = _helpers.to_bytes(signature)\n        if len(sig_bytes) != 64:\n            return False\n        r = (\n            int.from_bytes(sig_bytes[:32], byteorder=\"big\")\n            if _helpers.is_python_3()\n            else utils.int_from_bytes(sig_bytes[:32], byteorder=\"big\")\n        )\n        s = (\n            int.from_bytes(sig_bytes[32:], byteorder=\"big\")\n            if _helpers.is_python_3()\n            else utils.int_from_bytes(sig_bytes[32:], byteorder=\"big\")\n        )\n        asn1_sig = encode_dss_signature(r, s)\n\n        message = _helpers.to_bytes(message)\n        try:\n            self._pubkey.verify(asn1_sig, message, ec.ECDSA(hashes.SHA256()))\n            return True\n        except (ValueError, cryptography.exceptions.InvalidSignature):\n            return False\n\n    @classmethod\n    def from_string(cls, public_key):\n        \"\"\"Construct an Verifier instance from a public key or public\n        certificate string.\n\n        Args:\n            public_key (Union[str, bytes]): The public key in PEM format or the\n                x509 public key certificate.\n\n        Returns:\n            Verifier: The constructed verifier.\n\n        Raises:\n            ValueError: If the public key can't be parsed.\n        \"\"\"\n        public_key_data = _helpers.to_bytes(public_key)\n\n        if _CERTIFICATE_MARKER in public_key_data:\n            cert = cryptography.x509.load_pem_x509_certificate(\n                public_key_data, _BACKEND\n            )\n            pubkey = cert.public_key()\n\n        else:\n            pubkey = serialization.load_pem_public_key(public_key_data, _BACKEND)\n\n        return cls(pubkey)\n\n\nclass ES256Signer(base.Signer, base.FromServiceAccountMixin):\n    \"\"\"Signs messages with an ECDSA private key.\n\n    Args:\n        private_key (\n                cryptography.hazmat.primitives.asymmetric.ec.ECDSAPrivateKey):\n            The private key to sign with.\n        key_id (str): Optional key ID used to identify this private key. This\n            can be useful to associate the private key with its associated\n            public key or certificate.\n    \"\"\"\n\n    def __init__(self, private_key, key_id=None):\n        self._key = private_key\n        self._key_id = key_id\n\n    @property  # type: ignore\n    @_helpers.copy_docstring(base.Signer)\n    def key_id(self):\n        return self._key_id\n\n    @_helpers.copy_docstring(base.Signer)\n    def sign(self, message):\n        message = _helpers.to_bytes(message)\n        asn1_signature = self._key.sign(message, ec.ECDSA(hashes.SHA256()))\n\n        # Convert ASN1 encoded signature to (r||s) raw signature.\n        (r, s) = decode_dss_signature(asn1_signature)\n        return (\n            (r.to_bytes(32, byteorder=\"big\") + s.to_bytes(32, byteorder=\"big\"))\n            if _helpers.is_python_3()\n            else (utils.int_to_bytes(r, 32) + utils.int_to_bytes(s, 32))\n        )\n\n    @classmethod\n    def from_string(cls, key, key_id=None):\n        \"\"\"Construct a RSASigner from a private key in PEM format.\n\n        Args:\n            key (Union[bytes, str]): Private key in PEM format.\n            key_id (str): An optional key id used to identify the private key.\n\n        Returns:\n            google.auth.crypt._cryptography_rsa.RSASigner: The\n            constructed signer.\n\n        Raises:\n            ValueError: If ``key`` is not ``bytes`` or ``str`` (unicode).\n            UnicodeDecodeError: If ``key`` is ``bytes`` but cannot be decoded\n                into a UTF-8 ``str``.\n            ValueError: If ``cryptography`` \"Could not deserialize key data.\"\n        \"\"\"\n        key = _helpers.to_bytes(key)\n        private_key = serialization.load_pem_private_key(\n            key, password=None, backend=_BACKEND\n        )\n        return cls(private_key, key_id=key_id)\n\n    def __getstate__(self):\n        \"\"\"Pickle helper that serializes the _key attribute.\"\"\"\n        state = self.__dict__.copy()\n        state[\"_key\"] = self._key.private_bytes(\n            encoding=serialization.Encoding.PEM,\n            format=serialization.PrivateFormat.PKCS8,\n            encryption_algorithm=serialization.NoEncryption(),\n        )\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Pickle helper that deserializes the _key attribute.\"\"\"\n        state[\"_key\"] = serialization.load_pem_private_key(state[\"_key\"], None)\n        self.__dict__.update(state)\n", "google/auth/crypt/rsa.py": "# Copyright 2017 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"RSA cryptography signer and verifier.\"\"\"\n\n\ntry:\n    # Prefer cryptograph-based RSA implementation.\n    from google.auth.crypt import _cryptography_rsa\n\n    RSASigner = _cryptography_rsa.RSASigner\n    RSAVerifier = _cryptography_rsa.RSAVerifier\nexcept ImportError:  # pragma: NO COVER\n    # Fallback to pure-python RSA implementation if cryptography is\n    # unavailable.\n    from google.auth.crypt import _python_rsa\n\n    RSASigner = _python_rsa.RSASigner  # type: ignore\n    RSAVerifier = _python_rsa.RSAVerifier  # type: ignore\n", "google/auth/crypt/__init__.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Cryptography helpers for verifying and signing messages.\n\nThe simplest way to verify signatures is using :func:`verify_signature`::\n\n    cert = open('certs.pem').read()\n    valid = crypt.verify_signature(message, signature, cert)\n\nIf you're going to verify many messages with the same certificate, you can use\n:class:`RSAVerifier`::\n\n    cert = open('certs.pem').read()\n    verifier = crypt.RSAVerifier.from_string(cert)\n    valid = verifier.verify(message, signature)\n\nTo sign messages use :class:`RSASigner` with a private key::\n\n    private_key = open('private_key.pem').read()\n    signer = crypt.RSASigner.from_string(private_key)\n    signature = signer.sign(message)\n\nThe code above also works for :class:`ES256Signer` and :class:`ES256Verifier`.\nNote that these two classes are only available if your `cryptography` dependency\nversion is at least 1.4.0.\n\"\"\"\n\nfrom google.auth.crypt import base\nfrom google.auth.crypt import rsa\n\ntry:\n    from google.auth.crypt import es256\nexcept ImportError:  # pragma: NO COVER\n    es256 = None  # type: ignore\n\nif es256 is not None:  # pragma: NO COVER\n    __all__ = [\n        \"ES256Signer\",\n        \"ES256Verifier\",\n        \"RSASigner\",\n        \"RSAVerifier\",\n        \"Signer\",\n        \"Verifier\",\n    ]\nelse:  # pragma: NO COVER\n    __all__ = [\"RSASigner\", \"RSAVerifier\", \"Signer\", \"Verifier\"]\n\n\n# Aliases to maintain the v1.0.0 interface, as the crypt module was split\n# into submodules.\nSigner = base.Signer\nVerifier = base.Verifier\nRSASigner = rsa.RSASigner\nRSAVerifier = rsa.RSAVerifier\n\nif es256 is not None:  # pragma: NO COVER\n    ES256Signer = es256.ES256Signer\n    ES256Verifier = es256.ES256Verifier\n\n\ndef verify_signature(message, signature, certs, verifier_cls=rsa.RSAVerifier):\n    \"\"\"Verify an RSA or ECDSA cryptographic signature.\n\n    Checks that the provided ``signature`` was generated from ``bytes`` using\n    the private key associated with the ``cert``.\n\n    Args:\n        message (Union[str, bytes]): The plaintext message.\n        signature (Union[str, bytes]): The cryptographic signature to check.\n        certs (Union[Sequence, str, bytes]): The certificate or certificates\n            to use to check the signature.\n        verifier_cls (Optional[~google.auth.crypt.base.Signer]): Which verifier\n            class to use for verification. This can be used to select different\n            algorithms, such as RSA or ECDSA. Default value is :class:`RSAVerifier`.\n\n    Returns:\n        bool: True if the signature is valid, otherwise False.\n    \"\"\"\n    if isinstance(certs, (str, bytes)):\n        certs = [certs]\n\n    for cert in certs:\n        verifier = verifier_cls.from_string(cert)\n        if verifier.verify(message, signature):\n            return True\n    return False\n", "google/auth/crypt/_helpers.py": "", "google/auth/transport/grpc.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Authorization support for gRPC.\"\"\"\n\nfrom __future__ import absolute_import\n\nimport logging\nimport os\n\nfrom google.auth import environment_vars\nfrom google.auth import exceptions\nfrom google.auth.transport import _mtls_helper\nfrom google.oauth2 import service_account\n\ntry:\n    import grpc  # type: ignore\nexcept ImportError as caught_exc:  # pragma: NO COVER\n    raise ImportError(\n        \"gRPC is not installed from please install the grpcio package to use the gRPC transport.\"\n    ) from caught_exc\n\n_LOGGER = logging.getLogger(__name__)\n\n\nclass AuthMetadataPlugin(grpc.AuthMetadataPlugin):\n    \"\"\"A `gRPC AuthMetadataPlugin`_ that inserts the credentials into each\n    request.\n\n    .. _gRPC AuthMetadataPlugin:\n        http://www.grpc.io/grpc/python/grpc.html#grpc.AuthMetadataPlugin\n\n    Args:\n        credentials (google.auth.credentials.Credentials): The credentials to\n            add to requests.\n        request (google.auth.transport.Request): A HTTP transport request\n            object used to refresh credentials as needed.\n        default_host (Optional[str]): A host like \"pubsub.googleapis.com\".\n            This is used when a self-signed JWT is created from service\n            account credentials.\n    \"\"\"\n\n    def __init__(self, credentials, request, default_host=None):\n        # pylint: disable=no-value-for-parameter\n        # pylint doesn't realize that the super method takes no arguments\n        # because this class is the same name as the superclass.\n        super(AuthMetadataPlugin, self).__init__()\n        self._credentials = credentials\n        self._request = request\n        self._default_host = default_host\n\n    def _get_authorization_headers(self, context):\n        \"\"\"Gets the authorization headers for a request.\n\n        Returns:\n            Sequence[Tuple[str, str]]: A list of request headers (key, value)\n                to add to the request.\n        \"\"\"\n        headers = {}\n\n        # https://google.aip.dev/auth/4111\n        # Attempt to use self-signed JWTs when a service account is used.\n        # A default host must be explicitly provided since it cannot always\n        # be determined from the context.service_url.\n        if isinstance(self._credentials, service_account.Credentials):\n            self._credentials._create_self_signed_jwt(\n                \"https://{}/\".format(self._default_host) if self._default_host else None\n            )\n\n        self._credentials.before_request(\n            self._request, context.method_name, context.service_url, headers\n        )\n\n        return list(headers.items())\n\n    def __call__(self, context, callback):\n        \"\"\"Passes authorization metadata into the given callback.\n\n        Args:\n            context (grpc.AuthMetadataContext): The RPC context.\n            callback (grpc.AuthMetadataPluginCallback): The callback that will\n                be invoked to pass in the authorization metadata.\n        \"\"\"\n        callback(self._get_authorization_headers(context), None)\n\n\ndef secure_authorized_channel(\n    credentials,\n    request,\n    target,\n    ssl_credentials=None,\n    client_cert_callback=None,\n    **kwargs\n):\n    \"\"\"Creates a secure authorized gRPC channel.\n\n    This creates a channel with SSL and :class:`AuthMetadataPlugin`. This\n    channel can be used to create a stub that can make authorized requests.\n    Users can configure client certificate or rely on device certificates to\n    establish a mutual TLS channel, if the `GOOGLE_API_USE_CLIENT_CERTIFICATE`\n    variable is explicitly set to `true`.\n\n    Example::\n\n        import google.auth\n        import google.auth.transport.grpc\n        import google.auth.transport.requests\n        from google.cloud.speech.v1 import cloud_speech_pb2\n\n        # Get credentials.\n        credentials, _ = google.auth.default()\n\n        # Get an HTTP request function to refresh credentials.\n        request = google.auth.transport.requests.Request()\n\n        # Create a channel.\n        channel = google.auth.transport.grpc.secure_authorized_channel(\n            credentials, regular_endpoint, request,\n            ssl_credentials=grpc.ssl_channel_credentials())\n\n        # Use the channel to create a stub.\n        cloud_speech.create_Speech_stub(channel)\n\n    Usage:\n\n    There are actually a couple of options to create a channel, depending on if\n    you want to create a regular or mutual TLS channel.\n\n    First let's list the endpoints (regular vs mutual TLS) to choose from::\n\n        regular_endpoint = 'speech.googleapis.com:443'\n        mtls_endpoint = 'speech.mtls.googleapis.com:443'\n\n    Option 1: create a regular (non-mutual) TLS channel by explicitly setting\n    the ssl_credentials::\n\n        regular_ssl_credentials = grpc.ssl_channel_credentials()\n\n        channel = google.auth.transport.grpc.secure_authorized_channel(\n            credentials, regular_endpoint, request,\n            ssl_credentials=regular_ssl_credentials)\n\n    Option 2: create a mutual TLS channel by calling a callback which returns\n    the client side certificate and the key (Note that\n    `GOOGLE_API_USE_CLIENT_CERTIFICATE` environment variable must be explicitly\n    set to `true`)::\n\n        def my_client_cert_callback():\n            code_to_load_client_cert_and_key()\n            if loaded:\n                return (pem_cert_bytes, pem_key_bytes)\n            raise MyClientCertFailureException()\n\n        try:\n            channel = google.auth.transport.grpc.secure_authorized_channel(\n                credentials, mtls_endpoint, request,\n                client_cert_callback=my_client_cert_callback)\n        except MyClientCertFailureException:\n            # handle the exception\n\n    Option 3: use application default SSL credentials. It searches and uses\n    the command in a context aware metadata file, which is available on devices\n    with endpoint verification support (Note that\n    `GOOGLE_API_USE_CLIENT_CERTIFICATE` environment variable must be explicitly\n    set to `true`).\n    See https://cloud.google.com/endpoint-verification/docs/overview::\n\n        try:\n            default_ssl_credentials = SslCredentials()\n        except:\n            # Exception can be raised if the context aware metadata is malformed.\n            # See :class:`SslCredentials` for the possible exceptions.\n\n        # Choose the endpoint based on the SSL credentials type.\n        if default_ssl_credentials.is_mtls:\n            endpoint_to_use = mtls_endpoint\n        else:\n            endpoint_to_use = regular_endpoint\n        channel = google.auth.transport.grpc.secure_authorized_channel(\n            credentials, endpoint_to_use, request,\n            ssl_credentials=default_ssl_credentials)\n\n    Option 4: not setting ssl_credentials and client_cert_callback. For devices\n    without endpoint verification support or `GOOGLE_API_USE_CLIENT_CERTIFICATE`\n    environment variable is not `true`, a regular TLS channel is created;\n    otherwise, a mutual TLS channel is created, however, the call should be\n    wrapped in a try/except block in case of malformed context aware metadata.\n\n    The following code uses regular_endpoint, it works the same no matter the\n    created channle is regular or mutual TLS. Regular endpoint ignores client\n    certificate and key::\n\n        channel = google.auth.transport.grpc.secure_authorized_channel(\n            credentials, regular_endpoint, request)\n\n    The following code uses mtls_endpoint, if the created channle is regular,\n    and API mtls_endpoint is confgured to require client SSL credentials, API\n    calls using this channel will be rejected::\n\n        channel = google.auth.transport.grpc.secure_authorized_channel(\n            credentials, mtls_endpoint, request)\n\n    Args:\n        credentials (google.auth.credentials.Credentials): The credentials to\n            add to requests.\n        request (google.auth.transport.Request): A HTTP transport request\n            object used to refresh credentials as needed. Even though gRPC\n            is a separate transport, there's no way to refresh the credentials\n            without using a standard http transport.\n        target (str): The host and port of the service.\n        ssl_credentials (grpc.ChannelCredentials): Optional SSL channel\n            credentials. This can be used to specify different certificates.\n            This argument is mutually exclusive with client_cert_callback;\n            providing both will raise an exception.\n            If ssl_credentials and client_cert_callback are None, application\n            default SSL credentials are used if `GOOGLE_API_USE_CLIENT_CERTIFICATE`\n            environment variable is explicitly set to `true`, otherwise one way TLS\n            SSL credentials are used.\n        client_cert_callback (Callable[[], (bytes, bytes)]): Optional\n            callback function to obtain client certicate and key for mutual TLS\n            connection. This argument is mutually exclusive with\n            ssl_credentials; providing both will raise an exception.\n            This argument does nothing unless `GOOGLE_API_USE_CLIENT_CERTIFICATE`\n            environment variable is explicitly set to `true`.\n        kwargs: Additional arguments to pass to :func:`grpc.secure_channel`.\n\n    Returns:\n        grpc.Channel: The created gRPC channel.\n\n    Raises:\n        google.auth.exceptions.MutualTLSChannelError: If mutual TLS channel\n            creation failed for any reason.\n    \"\"\"\n    # Create the metadata plugin for inserting the authorization header.\n    metadata_plugin = AuthMetadataPlugin(credentials, request)\n\n    # Create a set of grpc.CallCredentials using the metadata plugin.\n    google_auth_credentials = grpc.metadata_call_credentials(metadata_plugin)\n\n    if ssl_credentials and client_cert_callback:\n        raise exceptions.MalformedError(\n            \"Received both ssl_credentials and client_cert_callback; \"\n            \"these are mutually exclusive.\"\n        )\n\n    # If SSL credentials are not explicitly set, try client_cert_callback and ADC.\n    if not ssl_credentials:\n        use_client_cert = os.getenv(\n            environment_vars.GOOGLE_API_USE_CLIENT_CERTIFICATE, \"false\"\n        )\n        if use_client_cert == \"true\" and client_cert_callback:\n            # Use the callback if provided.\n            cert, key = client_cert_callback()\n            ssl_credentials = grpc.ssl_channel_credentials(\n                certificate_chain=cert, private_key=key\n            )\n        elif use_client_cert == \"true\":\n            # Use application default SSL credentials.\n            adc_ssl_credentils = SslCredentials()\n            ssl_credentials = adc_ssl_credentils.ssl_credentials\n        else:\n            ssl_credentials = grpc.ssl_channel_credentials()\n\n    # Combine the ssl credentials and the authorization credentials.\n    composite_credentials = grpc.composite_channel_credentials(\n        ssl_credentials, google_auth_credentials\n    )\n\n    return grpc.secure_channel(target, composite_credentials, **kwargs)\n\n\nclass SslCredentials:\n    \"\"\"Class for application default SSL credentials.\n\n    The behavior is controlled by `GOOGLE_API_USE_CLIENT_CERTIFICATE` environment\n    variable whose default value is `false`. Client certificate will not be used\n    unless the environment variable is explicitly set to `true`. See\n    https://google.aip.dev/auth/4114\n\n    If the environment variable is `true`, then for devices with endpoint verification\n    support, a device certificate will be automatically loaded and mutual TLS will\n    be established.\n    See https://cloud.google.com/endpoint-verification/docs/overview.\n    \"\"\"\n\n    def __init__(self):\n        use_client_cert = os.getenv(\n            environment_vars.GOOGLE_API_USE_CLIENT_CERTIFICATE, \"false\"\n        )\n        if use_client_cert != \"true\":\n            self._is_mtls = False\n        else:\n            # Load client SSL credentials.\n            metadata_path = _mtls_helper._check_dca_metadata_path(\n                _mtls_helper.CONTEXT_AWARE_METADATA_PATH\n            )\n            self._is_mtls = metadata_path is not None\n\n    @property\n    def ssl_credentials(self):\n        \"\"\"Get the created SSL channel credentials.\n\n        For devices with endpoint verification support, if the device certificate\n        loading has any problems, corresponding exceptions will be raised. For\n        a device without endpoint verification support, no exceptions will be\n        raised.\n\n        Returns:\n            grpc.ChannelCredentials: The created grpc channel credentials.\n\n        Raises:\n            google.auth.exceptions.MutualTLSChannelError: If mutual TLS channel\n                creation failed for any reason.\n        \"\"\"\n        if self._is_mtls:\n            try:\n                _, cert, key, _ = _mtls_helper.get_client_ssl_credentials()\n                self._ssl_credentials = grpc.ssl_channel_credentials(\n                    certificate_chain=cert, private_key=key\n                )\n            except exceptions.ClientCertError as caught_exc:\n                new_exc = exceptions.MutualTLSChannelError(caught_exc)\n                raise new_exc from caught_exc\n        else:\n            self._ssl_credentials = grpc.ssl_channel_credentials()\n\n        return self._ssl_credentials\n\n    @property\n    def is_mtls(self):\n        \"\"\"Indicates if the created SSL channel credentials is mutual TLS.\"\"\"\n        return self._is_mtls\n", "google/auth/transport/_mtls_helper.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Helper functions for getting mTLS cert and key.\"\"\"\n\nimport json\nimport logging\nfrom os import environ, path\nimport re\nimport subprocess\n\nfrom google.auth import exceptions\n\nCONTEXT_AWARE_METADATA_PATH = \"~/.secureConnect/context_aware_metadata.json\"\n_CERTIFICATE_CONFIGURATION_DEFAULT_PATH = \"~/.config/gcloud/certificate_config.json\"\n_CERTIFICATE_CONFIGURATION_ENV = \"GOOGLE_API_CERTIFICATE_CONFIG\"\n_CERT_PROVIDER_COMMAND = \"cert_provider_command\"\n_CERT_REGEX = re.compile(\n    b\"-----BEGIN CERTIFICATE-----.+-----END CERTIFICATE-----\\r?\\n?\", re.DOTALL\n)\n\n# support various format of key files, e.g.\n# \"-----BEGIN PRIVATE KEY-----...\",\n# \"-----BEGIN EC PRIVATE KEY-----...\",\n# \"-----BEGIN RSA PRIVATE KEY-----...\"\n# \"-----BEGIN ENCRYPTED PRIVATE KEY-----\"\n_KEY_REGEX = re.compile(\n    b\"-----BEGIN [A-Z ]*PRIVATE KEY-----.+-----END [A-Z ]*PRIVATE KEY-----\\r?\\n?\",\n    re.DOTALL,\n)\n\n_LOGGER = logging.getLogger(__name__)\n\n\n_PASSPHRASE_REGEX = re.compile(\n    b\"-----BEGIN PASSPHRASE-----(.+)-----END PASSPHRASE-----\", re.DOTALL\n)\n\n\ndef _check_dca_metadata_path(metadata_path):\n    \"\"\"Checks for context aware metadata. If it exists, returns the absolute path;\n    otherwise returns None.\n\n    Args:\n        metadata_path (str): context aware metadata path.\n\n    Returns:\n        str: absolute path if exists and None otherwise.\n    \"\"\"\n    metadata_path = path.expanduser(metadata_path)\n    if not path.exists(metadata_path):\n        _LOGGER.debug(\"%s is not found, skip client SSL authentication.\", metadata_path)\n        return None\n    return metadata_path\n\n\ndef _load_json_file(path):\n    \"\"\"Reads and loads JSON from the given path. Used to read both X509 workload certificate and\n    secure connect configurations.\n\n    Args:\n        path (str): the path to read from.\n\n    Returns:\n        Dict[str, str]: The JSON stored at the file.\n\n    Raises:\n        google.auth.exceptions.ClientCertError: If failed to parse the file as JSON.\n    \"\"\"\n    try:\n        with open(path) as f:\n            json_data = json.load(f)\n    except ValueError as caught_exc:\n        new_exc = exceptions.ClientCertError(caught_exc)\n        raise new_exc from caught_exc\n\n    return json_data\n\n\ndef _get_workload_cert_and_key(certificate_config_path=None):\n    \"\"\"Read the workload identity cert and key files specified in the certificate config provided.\n    If no config path is provided, check the environment variable: \"GOOGLE_API_CERTIFICATE_CONFIG\"\n    first, then the well known gcloud location: \"~/.config/gcloud/certificate_config.json\".\n\n    Args:\n        certificate_config_path (string): The certificate config path. If no path is provided,\n        the environment variable will be checked first, then the well known gcloud location.\n\n    Returns:\n        Tuple[Optional[bytes], Optional[bytes]]: client certificate bytes in PEM format and key\n            bytes in PEM format.\n\n    Raises:\n        google.auth.exceptions.ClientCertError: if problems occurs when retrieving\n        the certificate or key information.\n    \"\"\"\n    absolute_path = _get_cert_config_path(certificate_config_path)\n    if absolute_path is None:\n        return None, None\n    data = _load_json_file(absolute_path)\n\n    if \"cert_configs\" not in data:\n        raise exceptions.ClientCertError(\n            'Certificate config file {} is in an invalid format, a \"cert configs\" object is expected'.format(\n                absolute_path\n            )\n        )\n    cert_configs = data[\"cert_configs\"]\n\n    if \"workload\" not in cert_configs:\n        raise exceptions.ClientCertError(\n            'Certificate config file {} is in an invalid format, a \"workload\" cert config is expected'.format(\n                absolute_path\n            )\n        )\n    workload = cert_configs[\"workload\"]\n\n    if \"cert_path\" not in workload:\n        raise exceptions.ClientCertError(\n            'Certificate config file {} is in an invalid format, a \"cert_path\" is expected in the workload cert config'.format(\n                absolute_path\n            )\n        )\n    cert_path = workload[\"cert_path\"]\n\n    if \"key_path\" not in workload:\n        raise exceptions.ClientCertError(\n            'Certificate config file {} is in an invalid format, a \"key_path\" is expected in the workload cert config'.format(\n                absolute_path\n            )\n        )\n    key_path = workload[\"key_path\"]\n\n    return _read_cert_and_key_files(cert_path, key_path)\n\n\ndef _get_cert_config_path(certificate_config_path=None):\n    \"\"\"Gets the certificate configuration full path using the following order of precedence:\n\n    1: Explicit override, if set\n    2: Environment variable, if set\n    3: Well-known location\n\n    Returns \"None\" if the selected config file does not exist.\n\n    Args:\n        certificate_config_path (string): The certificate config path. If provided, the well known\n        location and environment variable will be ignored.\n\n    Returns:\n        The absolute path of the certificate config file, and None if the file does not exist.\n    \"\"\"\n\n    if certificate_config_path is None:\n        env_path = environ.get(_CERTIFICATE_CONFIGURATION_ENV, None)\n        if env_path is not None and env_path != \"\":\n            certificate_config_path = env_path\n        else:\n            certificate_config_path = _CERTIFICATE_CONFIGURATION_DEFAULT_PATH\n\n    certificate_config_path = path.expanduser(certificate_config_path)\n    if not path.exists(certificate_config_path):\n        return None\n    return certificate_config_path\n\n\ndef _read_cert_and_key_files(cert_path, key_path):\n    cert_data = _read_cert_file(cert_path)\n    key_data = _read_key_file(key_path)\n\n    return cert_data, key_data\n\n\ndef _read_cert_file(cert_path):\n    with open(cert_path, \"rb\") as cert_file:\n        cert_data = cert_file.read()\n\n    cert_match = re.findall(_CERT_REGEX, cert_data)\n    if len(cert_match) != 1:\n        raise exceptions.ClientCertError(\n            \"Certificate file {} is in an invalid format, a single PEM formatted certificate is expected\".format(\n                cert_path\n            )\n        )\n    return cert_match[0]\n\n\ndef _read_key_file(key_path):\n    with open(key_path, \"rb\") as key_file:\n        key_data = key_file.read()\n\n    key_match = re.findall(_KEY_REGEX, key_data)\n    if len(key_match) != 1:\n        raise exceptions.ClientCertError(\n            \"Private key file {} is in an invalid format, a single PEM formatted private key is expected\".format(\n                key_path\n            )\n        )\n\n    return key_match[0]\n\n\ndef _run_cert_provider_command(command, expect_encrypted_key=False):\n    \"\"\"Run the provided command, and return client side mTLS cert, key and\n    passphrase.\n\n    Args:\n        command (List[str]): cert provider command.\n        expect_encrypted_key (bool): If encrypted private key is expected.\n\n    Returns:\n        Tuple[bytes, bytes, bytes]: client certificate bytes in PEM format, key\n            bytes in PEM format and passphrase bytes.\n\n    Raises:\n        google.auth.exceptions.ClientCertError: if problems occurs when running\n            the cert provider command or generating cert, key and passphrase.\n    \"\"\"\n    try:\n        process = subprocess.Popen(\n            command, stdout=subprocess.PIPE, stderr=subprocess.PIPE\n        )\n        stdout, stderr = process.communicate()\n    except OSError as caught_exc:\n        new_exc = exceptions.ClientCertError(caught_exc)\n        raise new_exc from caught_exc\n\n    # Check cert provider command execution error.\n    if process.returncode != 0:\n        raise exceptions.ClientCertError(\n            \"Cert provider command returns non-zero status code %s\" % process.returncode\n        )\n\n    # Extract certificate (chain), key and passphrase.\n    cert_match = re.findall(_CERT_REGEX, stdout)\n    if len(cert_match) != 1:\n        raise exceptions.ClientCertError(\"Client SSL certificate is missing or invalid\")\n    key_match = re.findall(_KEY_REGEX, stdout)\n    if len(key_match) != 1:\n        raise exceptions.ClientCertError(\"Client SSL key is missing or invalid\")\n    passphrase_match = re.findall(_PASSPHRASE_REGEX, stdout)\n\n    if expect_encrypted_key:\n        if len(passphrase_match) != 1:\n            raise exceptions.ClientCertError(\"Passphrase is missing or invalid\")\n        if b\"ENCRYPTED\" not in key_match[0]:\n            raise exceptions.ClientCertError(\"Encrypted private key is expected\")\n        return cert_match[0], key_match[0], passphrase_match[0].strip()\n\n    if b\"ENCRYPTED\" in key_match[0]:\n        raise exceptions.ClientCertError(\"Encrypted private key is not expected\")\n    if len(passphrase_match) > 0:\n        raise exceptions.ClientCertError(\"Passphrase is not expected\")\n    return cert_match[0], key_match[0], None\n\n\ndef get_client_ssl_credentials(\n    generate_encrypted_key=False,\n    context_aware_metadata_path=CONTEXT_AWARE_METADATA_PATH,\n):\n    \"\"\"Returns the client side certificate, private key and passphrase.\n\n    Args:\n        generate_encrypted_key (bool): If set to True, encrypted private key\n            and passphrase will be generated; otherwise, unencrypted private key\n            will be generated and passphrase will be None.\n        context_aware_metadata_path (str): The context_aware_metadata.json file path.\n\n    Returns:\n        Tuple[bool, bytes, bytes, bytes]:\n            A boolean indicating if cert, key and passphrase are obtained, the\n            cert bytes and key bytes both in PEM format, and passphrase bytes.\n\n    Raises:\n        google.auth.exceptions.ClientCertError: if problems occurs when getting\n            the cert, key and passphrase.\n    \"\"\"\n    metadata_path = _check_dca_metadata_path(context_aware_metadata_path)\n\n    if metadata_path:\n        metadata_json = _load_json_file(metadata_path)\n\n        if _CERT_PROVIDER_COMMAND not in metadata_json:\n            raise exceptions.ClientCertError(\"Cert provider command is not found\")\n\n        command = metadata_json[_CERT_PROVIDER_COMMAND]\n\n        if generate_encrypted_key and \"--with_passphrase\" not in command:\n            command.append(\"--with_passphrase\")\n\n        # Execute the command.\n        cert, key, passphrase = _run_cert_provider_command(\n            command, expect_encrypted_key=generate_encrypted_key\n        )\n        return True, cert, key, passphrase\n\n    return False, None, None, None\n\n\ndef get_client_cert_and_key(client_cert_callback=None):\n    \"\"\"Returns the client side certificate and private key. The function first\n    tries to get certificate and key from client_cert_callback; if the callback\n    is None or doesn't provide certificate and key, the function tries application\n    default SSL credentials.\n\n    Args:\n        client_cert_callback (Optional[Callable[[], (bytes, bytes)]]): An\n            optional callback which returns client certificate bytes and private\n            key bytes both in PEM format.\n\n    Returns:\n        Tuple[bool, bytes, bytes]:\n            A boolean indicating if cert and key are obtained, the cert bytes\n            and key bytes both in PEM format.\n\n    Raises:\n        google.auth.exceptions.ClientCertError: if problems occurs when getting\n            the cert and key.\n    \"\"\"\n    if client_cert_callback:\n        cert, key = client_cert_callback()\n        return True, cert, key\n\n    has_cert, cert, key, _ = get_client_ssl_credentials(generate_encrypted_key=False)\n    return has_cert, cert, key\n\n\ndef decrypt_private_key(key, passphrase):\n    \"\"\"A helper function to decrypt the private key with the given passphrase.\n    google-auth library doesn't support passphrase protected private key for\n    mutual TLS channel. This helper function can be used to decrypt the\n    passphrase protected private key in order to estalish mutual TLS channel.\n\n    For example, if you have a function which produces client cert, passphrase\n    protected private key and passphrase, you can convert it to a client cert\n    callback function accepted by google-auth::\n\n        from google.auth.transport import _mtls_helper\n\n        def your_client_cert_function():\n            return cert, encrypted_key, passphrase\n\n        # callback accepted by google-auth for mutual TLS channel.\n        def client_cert_callback():\n            cert, encrypted_key, passphrase = your_client_cert_function()\n            decrypted_key = _mtls_helper.decrypt_private_key(encrypted_key,\n                passphrase)\n            return cert, decrypted_key\n\n    Args:\n        key (bytes): The private key bytes in PEM format.\n        passphrase (bytes): The passphrase bytes.\n\n    Returns:\n        bytes: The decrypted private key in PEM format.\n\n    Raises:\n        ImportError: If pyOpenSSL is not installed.\n        OpenSSL.crypto.Error: If there is any problem decrypting the private key.\n    \"\"\"\n    from OpenSSL import crypto\n\n    # First convert encrypted_key_bytes to PKey object\n    pkey = crypto.load_privatekey(crypto.FILETYPE_PEM, key, passphrase=passphrase)\n\n    # Then dump the decrypted key bytes\n    return crypto.dump_privatekey(crypto.FILETYPE_PEM, pkey)\n", "google/auth/transport/_custom_tls_signer.py": "# Copyright 2022 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"\nCode for configuring client side TLS to offload the signing operation to\nsigning libraries.\n\"\"\"\n\nimport ctypes\nimport json\nimport logging\nimport os\nimport sys\n\nimport cffi  # type: ignore\n\nfrom google.auth import exceptions\n\n_LOGGER = logging.getLogger(__name__)\n\n# C++ offload lib requires google-auth lib to provide the following callback:\n#     using SignFunc = int (*)(unsigned char *sig, size_t *sig_len,\n#             const unsigned char *tbs, size_t tbs_len)\n# The bytes to be signed and the length are provided via `tbs` and `tbs_len`,\n# the callback computes the signature, and write the signature and its length\n# into `sig` and `sig_len`.\n# If the signing is successful, the callback returns 1, otherwise it returns 0.\nSIGN_CALLBACK_CTYPE = ctypes.CFUNCTYPE(\n    ctypes.c_int,  # return type\n    ctypes.POINTER(ctypes.c_ubyte),  # sig\n    ctypes.POINTER(ctypes.c_size_t),  # sig_len\n    ctypes.POINTER(ctypes.c_ubyte),  # tbs\n    ctypes.c_size_t,  # tbs_len\n)\n\n\n# Cast SSL_CTX* to void*\ndef _cast_ssl_ctx_to_void_p_pyopenssl(ssl_ctx):\n    return ctypes.cast(int(cffi.FFI().cast(\"intptr_t\", ssl_ctx)), ctypes.c_void_p)\n\n\n# Cast SSL_CTX* to void*\ndef _cast_ssl_ctx_to_void_p_stdlib(context):\n    return ctypes.c_void_p.from_address(\n        id(context) + ctypes.sizeof(ctypes.c_void_p) * 2\n    )\n\n\n# Load offload library and set up the function types.\ndef load_offload_lib(offload_lib_path):\n    _LOGGER.debug(\"loading offload library from %s\", offload_lib_path)\n\n    # winmode parameter is only available for python 3.8+.\n    lib = (\n        ctypes.CDLL(offload_lib_path, winmode=0)\n        if sys.version_info >= (3, 8) and os.name == \"nt\"\n        else ctypes.CDLL(offload_lib_path)\n    )\n\n    # Set up types for:\n    # int ConfigureSslContext(SignFunc sign_func, const char *cert, SSL_CTX *ctx)\n    lib.ConfigureSslContext.argtypes = [\n        SIGN_CALLBACK_CTYPE,\n        ctypes.c_char_p,\n        ctypes.c_void_p,\n    ]\n    lib.ConfigureSslContext.restype = ctypes.c_int\n\n    return lib\n\n\n# Load signer library and set up the function types.\n# See: https://github.com/googleapis/enterprise-certificate-proxy/blob/main/cshared/main.go\ndef load_signer_lib(signer_lib_path):\n    _LOGGER.debug(\"loading signer library from %s\", signer_lib_path)\n\n    # winmode parameter is only available for python 3.8+.\n    lib = (\n        ctypes.CDLL(signer_lib_path, winmode=0)\n        if sys.version_info >= (3, 8) and os.name == \"nt\"\n        else ctypes.CDLL(signer_lib_path)\n    )\n\n    # Set up types for:\n    # func GetCertPemForPython(configFilePath *C.char, certHolder *byte, certHolderLen int)\n    lib.GetCertPemForPython.argtypes = [ctypes.c_char_p, ctypes.c_char_p, ctypes.c_int]\n    # Returns: certLen\n    lib.GetCertPemForPython.restype = ctypes.c_int\n\n    # Set up types for:\n    # func SignForPython(configFilePath *C.char, digest *byte, digestLen int,\n    #     sigHolder *byte, sigHolderLen int)\n    lib.SignForPython.argtypes = [\n        ctypes.c_char_p,\n        ctypes.c_char_p,\n        ctypes.c_int,\n        ctypes.c_char_p,\n        ctypes.c_int,\n    ]\n    # Returns: the signature length\n    lib.SignForPython.restype = ctypes.c_int\n\n    return lib\n\n\ndef load_provider_lib(provider_lib_path):\n    _LOGGER.debug(\"loading provider library from %s\", provider_lib_path)\n\n    # winmode parameter is only available for python 3.8+.\n    lib = (\n        ctypes.CDLL(provider_lib_path, winmode=0)\n        if sys.version_info >= (3, 8) and os.name == \"nt\"\n        else ctypes.CDLL(provider_lib_path)\n    )\n\n    lib.ECP_attach_to_ctx.argtypes = [ctypes.c_void_p, ctypes.c_char_p]\n    lib.ECP_attach_to_ctx.restype = ctypes.c_int\n\n    return lib\n\n\n# Computes SHA256 hash.\ndef _compute_sha256_digest(to_be_signed, to_be_signed_len):\n    from cryptography.hazmat.primitives import hashes\n\n    data = ctypes.string_at(to_be_signed, to_be_signed_len)\n    hash = hashes.Hash(hashes.SHA256())\n    hash.update(data)\n    return hash.finalize()\n\n\n# Create the signing callback. The actual signing work is done by the\n# `SignForPython` method from the signer lib.\ndef get_sign_callback(signer_lib, config_file_path):\n    def sign_callback(sig, sig_len, tbs, tbs_len):\n        _LOGGER.debug(\"calling sign callback...\")\n\n        digest = _compute_sha256_digest(tbs, tbs_len)\n        digestArray = ctypes.c_char * len(digest)\n\n        # reserve 2000 bytes for the signature, shoud be more then enough.\n        # RSA signature is 256 bytes, EC signature is 70~72.\n        sig_holder_len = 2000\n        sig_holder = ctypes.create_string_buffer(sig_holder_len)\n\n        signature_len = signer_lib.SignForPython(\n            config_file_path.encode(),  # configFilePath\n            digestArray.from_buffer(bytearray(digest)),  # digest\n            len(digest),  # digestLen\n            sig_holder,  # sigHolder\n            sig_holder_len,  # sigHolderLen\n        )\n\n        if signature_len == 0:\n            # signing failed, return 0\n            return 0\n\n        sig_len[0] = signature_len\n        bs = bytearray(sig_holder)\n        for i in range(signature_len):\n            sig[i] = bs[i]\n\n        return 1\n\n    return SIGN_CALLBACK_CTYPE(sign_callback)\n\n\n# Obtain the certificate bytes by calling the `GetCertPemForPython` method from\n# the signer lib. The method is called twice, the first time is to compute the\n# cert length, then we create a buffer to hold the cert, and call it again to\n# fill the buffer.\ndef get_cert(signer_lib, config_file_path):\n    # First call to calculate the cert length\n    cert_len = signer_lib.GetCertPemForPython(\n        config_file_path.encode(),  # configFilePath\n        None,  # certHolder\n        0,  # certHolderLen\n    )\n    if cert_len == 0:\n        raise exceptions.MutualTLSChannelError(\"failed to get certificate\")\n\n    # Then we create an array to hold the cert, and call again to fill the cert\n    cert_holder = ctypes.create_string_buffer(cert_len)\n    signer_lib.GetCertPemForPython(\n        config_file_path.encode(),  # configFilePath\n        cert_holder,  # certHolder\n        cert_len,  # certHolderLen\n    )\n    return bytes(cert_holder)\n\n\nclass CustomTlsSigner(object):\n    def __init__(self, enterprise_cert_file_path):\n        \"\"\"\n        This class loads the offload and signer library, and calls APIs from\n        these libraries to obtain the cert and a signing callback, and attach\n        them to SSL context. The cert and the signing callback will be used\n        for client authentication in TLS handshake.\n\n        Args:\n            enterprise_cert_file_path (str): the path to a enterprise cert JSON\n                file. The file should contain the following field:\n\n                    {\n                        \"libs\": {\n                            \"ecp_client\": \"...\",\n                            \"tls_offload\": \"...\"\n                        }\n                    }\n        \"\"\"\n        self._enterprise_cert_file_path = enterprise_cert_file_path\n        self._cert = None\n        self._sign_callback = None\n        self._provider_lib = None\n\n    def load_libraries(self):\n        with open(self._enterprise_cert_file_path, \"r\") as f:\n            enterprise_cert_json = json.load(f)\n            libs = enterprise_cert_json.get(\"libs\", {})\n\n            signer_library = libs.get(\"ecp_client\", None)\n            offload_library = libs.get(\"tls_offload\", None)\n            provider_library = libs.get(\"ecp_provider\", None)\n\n        # Using newer provider implementation. This is mutually exclusive to the\n        # offload implementation.\n        if provider_library:\n            self._provider_lib = load_provider_lib(provider_library)\n            return\n\n        # Using old offload implementation\n        if offload_library and signer_library:\n            self._offload_lib = load_offload_lib(offload_library)\n            self._signer_lib = load_signer_lib(signer_library)\n            self.set_up_custom_key()\n            return\n\n        raise exceptions.MutualTLSChannelError(\"enterprise cert file is invalid\")\n\n    def set_up_custom_key(self):\n        # We need to keep a reference of the cert and sign callback so it won't\n        # be garbage collected, otherwise it will crash when used by signer lib.\n        self._cert = get_cert(self._signer_lib, self._enterprise_cert_file_path)\n        self._sign_callback = get_sign_callback(\n            self._signer_lib, self._enterprise_cert_file_path\n        )\n\n    def should_use_provider(self):\n        if self._provider_lib:\n            return True\n        return False\n\n    def attach_to_ssl_context(self, ctx):\n        if self.should_use_provider():\n            if not self._provider_lib.ECP_attach_to_ctx(\n                _cast_ssl_ctx_to_void_p_stdlib(ctx),\n                self._enterprise_cert_file_path.encode(\"ascii\"),\n            ):\n                raise exceptions.MutualTLSChannelError(\n                    \"failed to configure ECP Provider SSL context\"\n                )\n        elif self._offload_lib and self._signer_lib:\n            if not self._offload_lib.ConfigureSslContext(\n                self._sign_callback,\n                ctypes.c_char_p(self._cert),\n                _cast_ssl_ctx_to_void_p_pyopenssl(ctx._ctx._context),\n            ):\n                raise exceptions.MutualTLSChannelError(\n                    \"failed to configure ECP Offload SSL context\"\n                )\n        else:\n            raise exceptions.MutualTLSChannelError(\"Invalid ECP configuration.\")\n", "google/auth/transport/mtls.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Utilites for mutual TLS.\"\"\"\n\nfrom google.auth import exceptions\nfrom google.auth.transport import _mtls_helper\n\n\ndef has_default_client_cert_source():\n    \"\"\"Check if default client SSL credentials exists on the device.\n\n    Returns:\n        bool: indicating if the default client cert source exists.\n    \"\"\"\n    metadata_path = _mtls_helper._check_dca_metadata_path(\n        _mtls_helper.CONTEXT_AWARE_METADATA_PATH\n    )\n    return metadata_path is not None\n\n\ndef default_client_cert_source():\n    \"\"\"Get a callback which returns the default client SSL credentials.\n\n    Returns:\n        Callable[[], [bytes, bytes]]: A callback which returns the default\n            client certificate bytes and private key bytes, both in PEM format.\n\n    Raises:\n        google.auth.exceptions.DefaultClientCertSourceError: If the default\n            client SSL credentials don't exist or are malformed.\n    \"\"\"\n    if not has_default_client_cert_source():\n        raise exceptions.MutualTLSChannelError(\n            \"Default client cert source doesn't exist\"\n        )\n\n    def callback():\n        try:\n            _, cert_bytes, key_bytes = _mtls_helper.get_client_cert_and_key()\n        except (OSError, RuntimeError, ValueError) as caught_exc:\n            new_exc = exceptions.MutualTLSChannelError(caught_exc)\n            raise new_exc from caught_exc\n\n        return cert_bytes, key_bytes\n\n    return callback\n\n\ndef default_client_encrypted_cert_source(cert_path, key_path):\n    \"\"\"Get a callback which returns the default encrpyted client SSL credentials.\n\n    Args:\n        cert_path (str): The cert file path. The default client certificate will\n            be written to this file when the returned callback is called.\n        key_path (str): The key file path. The default encrypted client key will\n            be written to this file when the returned callback is called.\n\n    Returns:\n        Callable[[], [str, str, bytes]]: A callback which generates the default\n            client certificate, encrpyted private key and passphrase. It writes\n            the certificate and private key into the cert_path and key_path, and\n            returns the cert_path, key_path and passphrase bytes.\n\n    Raises:\n        google.auth.exceptions.DefaultClientCertSourceError: If any problem\n            occurs when loading or saving the client certificate and key.\n    \"\"\"\n    if not has_default_client_cert_source():\n        raise exceptions.MutualTLSChannelError(\n            \"Default client encrypted cert source doesn't exist\"\n        )\n\n    def callback():\n        try:\n            (\n                _,\n                cert_bytes,\n                key_bytes,\n                passphrase_bytes,\n            ) = _mtls_helper.get_client_ssl_credentials(generate_encrypted_key=True)\n            with open(cert_path, \"wb\") as cert_file:\n                cert_file.write(cert_bytes)\n            with open(key_path, \"wb\") as key_file:\n                key_file.write(key_bytes)\n        except (exceptions.ClientCertError, OSError) as caught_exc:\n            new_exc = exceptions.MutualTLSChannelError(caught_exc)\n            raise new_exc from caught_exc\n\n        return cert_path, key_path, passphrase_bytes\n\n    return callback\n", "google/auth/transport/_aiohttp_requests.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Transport adapter for Async HTTP (aiohttp).\n\nNOTE: This async support is experimental and marked internal. This surface may\nchange in minor releases.\n\"\"\"\n\nfrom __future__ import absolute_import\n\nimport asyncio\nimport functools\n\nimport aiohttp  # type: ignore\nimport urllib3  # type: ignore\n\nfrom google.auth import exceptions\nfrom google.auth import transport\nfrom google.auth.transport import requests\n\n# Timeout can be re-defined depending on async requirement. Currently made 60s more than\n# sync timeout.\n_DEFAULT_TIMEOUT = 180  # in seconds\n\n\nclass _CombinedResponse(transport.Response):\n    \"\"\"\n    In order to more closely resemble the `requests` interface, where a raw\n    and deflated content could be accessed at once, this class lazily reads the\n    stream in `transport.Response` so both return forms can be used.\n\n    The gzip and deflate transfer-encodings are automatically decoded for you\n    because the default parameter for autodecompress into the ClientSession is set\n    to False, and therefore we add this class to act as a wrapper for a user to be\n    able to access both the raw and decoded response bodies - mirroring the sync\n    implementation.\n    \"\"\"\n\n    def __init__(self, response):\n        self._response = response\n        self._raw_content = None\n\n    def _is_compressed(self):\n        headers = self._response.headers\n        return \"Content-Encoding\" in headers and (\n            headers[\"Content-Encoding\"] == \"gzip\"\n            or headers[\"Content-Encoding\"] == \"deflate\"\n        )\n\n    @property\n    def status(self):\n        return self._response.status\n\n    @property\n    def headers(self):\n        return self._response.headers\n\n    @property\n    def data(self):\n        return self._response.content\n\n    async def raw_content(self):\n        if self._raw_content is None:\n            self._raw_content = await self._response.content.read()\n        return self._raw_content\n\n    async def content(self):\n        # Load raw_content if necessary\n        await self.raw_content()\n        if self._is_compressed():\n            decoder = urllib3.response.MultiDecoder(\n                self._response.headers[\"Content-Encoding\"]\n            )\n            decompressed = decoder.decompress(self._raw_content)\n            return decompressed\n\n        return self._raw_content\n\n\nclass _Response(transport.Response):\n    \"\"\"\n    Requests transport response adapter.\n\n    Args:\n        response (requests.Response): The raw Requests response.\n    \"\"\"\n\n    def __init__(self, response):\n        self._response = response\n\n    @property\n    def status(self):\n        return self._response.status\n\n    @property\n    def headers(self):\n        return self._response.headers\n\n    @property\n    def data(self):\n        return self._response.content\n\n\nclass Request(transport.Request):\n    \"\"\"Requests request adapter.\n\n    This class is used internally for making requests using asyncio transports\n    in a consistent way. If you use :class:`AuthorizedSession` you do not need\n    to construct or use this class directly.\n\n    This class can be useful if you want to manually refresh a\n    :class:`~google.auth.credentials.Credentials` instance::\n\n        import google.auth.transport.aiohttp_requests\n\n        request = google.auth.transport.aiohttp_requests.Request()\n\n        credentials.refresh(request)\n\n    Args:\n        session (aiohttp.ClientSession): An instance :class:`aiohttp.ClientSession` used\n            to make HTTP requests. If not specified, a session will be created.\n\n    .. automethod:: __call__\n    \"\"\"\n\n    def __init__(self, session=None):\n        # TODO: Use auto_decompress property for aiohttp 3.7+\n        if session is not None and session._auto_decompress:\n            raise exceptions.InvalidOperation(\n                \"Client sessions with auto_decompress=True are not supported.\"\n            )\n        self.session = session\n\n    async def __call__(\n        self,\n        url,\n        method=\"GET\",\n        body=None,\n        headers=None,\n        timeout=_DEFAULT_TIMEOUT,\n        **kwargs,\n    ):\n        \"\"\"\n        Make an HTTP request using aiohttp.\n\n        Args:\n            url (str): The URL to be requested.\n            method (Optional[str]):\n                The HTTP method to use for the request. Defaults to 'GET'.\n            body (Optional[bytes]):\n                The payload or body in HTTP request.\n            headers (Optional[Mapping[str, str]]):\n                Request headers.\n            timeout (Optional[int]): The number of seconds to wait for a\n                response from the server. If not specified or if None, the\n                requests default timeout will be used.\n            kwargs: Additional arguments passed through to the underlying\n                requests :meth:`requests.Session.request` method.\n\n        Returns:\n            google.auth.transport.Response: The HTTP response.\n\n        Raises:\n            google.auth.exceptions.TransportError: If any exception occurred.\n        \"\"\"\n\n        try:\n            if self.session is None:  # pragma: NO COVER\n                self.session = aiohttp.ClientSession(\n                    auto_decompress=False\n                )  # pragma: NO COVER\n            requests._LOGGER.debug(\"Making request: %s %s\", method, url)\n            response = await self.session.request(\n                method, url, data=body, headers=headers, timeout=timeout, **kwargs\n            )\n            return _CombinedResponse(response)\n\n        except aiohttp.ClientError as caught_exc:\n            new_exc = exceptions.TransportError(caught_exc)\n            raise new_exc from caught_exc\n\n        except asyncio.TimeoutError as caught_exc:\n            new_exc = exceptions.TransportError(caught_exc)\n            raise new_exc from caught_exc\n\n\nclass AuthorizedSession(aiohttp.ClientSession):\n    \"\"\"This is an async implementation of the Authorized Session class. We utilize an\n    aiohttp transport instance, and the interface mirrors the google.auth.transport.requests\n    Authorized Session class, except for the change in the transport used in the async use case.\n\n    A Requests Session class with credentials.\n\n    This class is used to perform requests to API endpoints that require\n    authorization::\n\n        from google.auth.transport import aiohttp_requests\n\n        async with aiohttp_requests.AuthorizedSession(credentials) as authed_session:\n            response = await authed_session.request(\n                'GET', 'https://www.googleapis.com/storage/v1/b')\n\n    The underlying :meth:`request` implementation handles adding the\n    credentials' headers to the request and refreshing credentials as needed.\n\n    Args:\n        credentials (google.auth._credentials_async.Credentials):\n            The credentials to add to the request.\n        refresh_status_codes (Sequence[int]): Which HTTP status codes indicate\n            that credentials should be refreshed and the request should be\n            retried.\n        max_refresh_attempts (int): The maximum number of times to attempt to\n            refresh the credentials and retry the request.\n        refresh_timeout (Optional[int]): The timeout value in seconds for\n            credential refresh HTTP requests.\n        auth_request (google.auth.transport.aiohttp_requests.Request):\n            (Optional) An instance of\n            :class:`~google.auth.transport.aiohttp_requests.Request` used when\n            refreshing credentials. If not passed,\n            an instance of :class:`~google.auth.transport.aiohttp_requests.Request`\n            is created.\n        kwargs: Additional arguments passed through to the underlying\n            ClientSession :meth:`aiohttp.ClientSession` object.\n    \"\"\"\n\n    def __init__(\n        self,\n        credentials,\n        refresh_status_codes=transport.DEFAULT_REFRESH_STATUS_CODES,\n        max_refresh_attempts=transport.DEFAULT_MAX_REFRESH_ATTEMPTS,\n        refresh_timeout=None,\n        auth_request=None,\n        auto_decompress=False,\n        **kwargs,\n    ):\n        super(AuthorizedSession, self).__init__(**kwargs)\n        self.credentials = credentials\n        self._refresh_status_codes = refresh_status_codes\n        self._max_refresh_attempts = max_refresh_attempts\n        self._refresh_timeout = refresh_timeout\n        self._is_mtls = False\n        self._auth_request = auth_request\n        self._auth_request_session = None\n        self._loop = asyncio.get_event_loop()\n        self._refresh_lock = asyncio.Lock()\n        self._auto_decompress = auto_decompress\n\n    async def request(\n        self,\n        method,\n        url,\n        data=None,\n        headers=None,\n        max_allowed_time=None,\n        timeout=_DEFAULT_TIMEOUT,\n        auto_decompress=False,\n        **kwargs,\n    ):\n\n        \"\"\"Implementation of Authorized Session aiohttp request.\n\n        Args:\n            method (str):\n                The http request method used (e.g. GET, PUT, DELETE)\n            url (str):\n                The url at which the http request is sent.\n            data (Optional[dict]): Dictionary, list of tuples, bytes, or file-like\n                object to send in the body of the Request.\n            headers (Optional[dict]): Dictionary of HTTP Headers to send with the\n                Request.\n            timeout (Optional[Union[float, aiohttp.ClientTimeout]]):\n                The amount of time in seconds to wait for the server response\n                with each individual request. Can also be passed as an\n                ``aiohttp.ClientTimeout`` object.\n            max_allowed_time (Optional[float]):\n                If the method runs longer than this, a ``Timeout`` exception is\n                automatically raised. Unlike the ``timeout`` parameter, this\n                value applies to the total method execution time, even if\n                multiple requests are made under the hood.\n\n                Mind that it is not guaranteed that the timeout error is raised\n                at ``max_allowed_time``. It might take longer, for example, if\n                an underlying request takes a lot of time, but the request\n                itself does not timeout, e.g. if a large file is being\n                transmitted. The timout error will be raised after such\n                request completes.\n        \"\"\"\n        # Headers come in as bytes which isn't expected behavior, the resumable\n        # media libraries in some cases expect a str type for the header values,\n        # but sometimes the operations return these in bytes types.\n        if headers:\n            for key in headers.keys():\n                if type(headers[key]) is bytes:\n                    headers[key] = headers[key].decode(\"utf-8\")\n\n        async with aiohttp.ClientSession(\n            auto_decompress=self._auto_decompress,\n            trust_env=kwargs.get(\"trust_env\", False),\n        ) as self._auth_request_session:\n            auth_request = Request(self._auth_request_session)\n            self._auth_request = auth_request\n\n            # Use a kwarg for this instead of an attribute to maintain\n            # thread-safety.\n            _credential_refresh_attempt = kwargs.pop(\"_credential_refresh_attempt\", 0)\n            # Make a copy of the headers. They will be modified by the credentials\n            # and we want to pass the original headers if we recurse.\n            request_headers = headers.copy() if headers is not None else {}\n\n            # Do not apply the timeout unconditionally in order to not override the\n            # _auth_request's default timeout.\n            auth_request = (\n                self._auth_request\n                if timeout is None\n                else functools.partial(self._auth_request, timeout=timeout)\n            )\n\n            remaining_time = max_allowed_time\n\n            with requests.TimeoutGuard(remaining_time, asyncio.TimeoutError) as guard:\n                await self.credentials.before_request(\n                    auth_request, method, url, request_headers\n                )\n\n            with requests.TimeoutGuard(remaining_time, asyncio.TimeoutError) as guard:\n                response = await super(AuthorizedSession, self).request(\n                    method,\n                    url,\n                    data=data,\n                    headers=request_headers,\n                    timeout=timeout,\n                    **kwargs,\n                )\n\n            remaining_time = guard.remaining_timeout\n\n            if (\n                response.status in self._refresh_status_codes\n                and _credential_refresh_attempt < self._max_refresh_attempts\n            ):\n\n                requests._LOGGER.info(\n                    \"Refreshing credentials due to a %s response. Attempt %s/%s.\",\n                    response.status,\n                    _credential_refresh_attempt + 1,\n                    self._max_refresh_attempts,\n                )\n\n                # Do not apply the timeout unconditionally in order to not override the\n                # _auth_request's default timeout.\n                auth_request = (\n                    self._auth_request\n                    if timeout is None\n                    else functools.partial(self._auth_request, timeout=timeout)\n                )\n\n                with requests.TimeoutGuard(\n                    remaining_time, asyncio.TimeoutError\n                ) as guard:\n                    async with self._refresh_lock:\n                        await self._loop.run_in_executor(\n                            None, self.credentials.refresh, auth_request\n                        )\n\n                remaining_time = guard.remaining_timeout\n\n                return await self.request(\n                    method,\n                    url,\n                    data=data,\n                    headers=headers,\n                    max_allowed_time=remaining_time,\n                    timeout=timeout,\n                    _credential_refresh_attempt=_credential_refresh_attempt + 1,\n                    **kwargs,\n                )\n\n        return response\n", "google/auth/transport/requests.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Transport adapter for Requests.\"\"\"\n\nfrom __future__ import absolute_import\n\nimport functools\nimport logging\nimport numbers\nimport os\nimport time\n\ntry:\n    import requests\nexcept ImportError as caught_exc:  # pragma: NO COVER\n    raise ImportError(\n        \"The requests library is not installed from please install the requests package to use the requests transport.\"\n    ) from caught_exc\nimport requests.adapters  # pylint: disable=ungrouped-imports\nimport requests.exceptions  # pylint: disable=ungrouped-imports\nfrom requests.packages.urllib3.util.ssl_ import (  # type: ignore\n    create_urllib3_context,\n)  # pylint: disable=ungrouped-imports\n\nfrom google.auth import environment_vars\nfrom google.auth import exceptions\nfrom google.auth import transport\nimport google.auth.transport._mtls_helper\nfrom google.oauth2 import service_account\n\n_LOGGER = logging.getLogger(__name__)\n\n_DEFAULT_TIMEOUT = 120  # in seconds\n\n\nclass _Response(transport.Response):\n    \"\"\"Requests transport response adapter.\n\n    Args:\n        response (requests.Response): The raw Requests response.\n    \"\"\"\n\n    def __init__(self, response):\n        self._response = response\n\n    @property\n    def status(self):\n        return self._response.status_code\n\n    @property\n    def headers(self):\n        return self._response.headers\n\n    @property\n    def data(self):\n        return self._response.content\n\n\nclass TimeoutGuard(object):\n    \"\"\"A context manager raising an error if the suite execution took too long.\n\n    Args:\n        timeout (Union[None, Union[float, Tuple[float, float]]]):\n            The maximum number of seconds a suite can run without the context\n            manager raising a timeout exception on exit. If passed as a tuple,\n            the smaller of the values is taken as a timeout. If ``None``, a\n            timeout error is never raised.\n        timeout_error_type (Optional[Exception]):\n            The type of the error to raise on timeout. Defaults to\n            :class:`requests.exceptions.Timeout`.\n    \"\"\"\n\n    def __init__(self, timeout, timeout_error_type=requests.exceptions.Timeout):\n        self._timeout = timeout\n        self.remaining_timeout = timeout\n        self._timeout_error_type = timeout_error_type\n\n    def __enter__(self):\n        self._start = time.time()\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        if exc_value:\n            return  # let the error bubble up automatically\n\n        if self._timeout is None:\n            return  # nothing to do, the timeout was not specified\n\n        elapsed = time.time() - self._start\n        deadline_hit = False\n\n        if isinstance(self._timeout, numbers.Number):\n            self.remaining_timeout = self._timeout - elapsed\n            deadline_hit = self.remaining_timeout <= 0\n        else:\n            self.remaining_timeout = tuple(x - elapsed for x in self._timeout)\n            deadline_hit = min(self.remaining_timeout) <= 0\n\n        if deadline_hit:\n            raise self._timeout_error_type()\n\n\nclass Request(transport.Request):\n    \"\"\"Requests request adapter.\n\n    This class is used internally for making requests using various transports\n    in a consistent way. If you use :class:`AuthorizedSession` you do not need\n    to construct or use this class directly.\n\n    This class can be useful if you want to manually refresh a\n    :class:`~google.auth.credentials.Credentials` instance::\n\n        import google.auth.transport.requests\n        import requests\n\n        request = google.auth.transport.requests.Request()\n\n        credentials.refresh(request)\n\n    Args:\n        session (requests.Session): An instance :class:`requests.Session` used\n            to make HTTP requests. If not specified, a session will be created.\n\n    .. automethod:: __call__\n    \"\"\"\n\n    def __init__(self, session=None):\n        if not session:\n            session = requests.Session()\n\n        self.session = session\n\n    def __del__(self):\n        try:\n            if hasattr(self, \"session\") and self.session is not None:\n                self.session.close()\n        except TypeError:\n            # NOTE: For certain Python binary built, the queue.Empty exception\n            # might not be considered a normal Python exception causing\n            # TypeError.\n            pass\n\n    def __call__(\n        self,\n        url,\n        method=\"GET\",\n        body=None,\n        headers=None,\n        timeout=_DEFAULT_TIMEOUT,\n        **kwargs\n    ):\n        \"\"\"Make an HTTP request using requests.\n\n        Args:\n            url (str): The URI to be requested.\n            method (str): The HTTP method to use for the request. Defaults\n                to 'GET'.\n            body (bytes): The payload or body in HTTP request.\n            headers (Mapping[str, str]): Request headers.\n            timeout (Optional[int]): The number of seconds to wait for a\n                response from the server. If not specified or if None, the\n                requests default timeout will be used.\n            kwargs: Additional arguments passed through to the underlying\n                requests :meth:`~requests.Session.request` method.\n\n        Returns:\n            google.auth.transport.Response: The HTTP response.\n\n        Raises:\n            google.auth.exceptions.TransportError: If any exception occurred.\n        \"\"\"\n        try:\n            _LOGGER.debug(\"Making request: %s %s\", method, url)\n            response = self.session.request(\n                method, url, data=body, headers=headers, timeout=timeout, **kwargs\n            )\n            return _Response(response)\n        except requests.exceptions.RequestException as caught_exc:\n            new_exc = exceptions.TransportError(caught_exc)\n            raise new_exc from caught_exc\n\n\nclass _MutualTlsAdapter(requests.adapters.HTTPAdapter):\n    \"\"\"\n    A TransportAdapter that enables mutual TLS.\n\n    Args:\n        cert (bytes): client certificate in PEM format\n        key (bytes): client private key in PEM format\n\n    Raises:\n        ImportError: if certifi or pyOpenSSL is not installed\n        OpenSSL.crypto.Error: if client cert or key is invalid\n    \"\"\"\n\n    def __init__(self, cert, key):\n        import certifi\n        from OpenSSL import crypto\n        import urllib3.contrib.pyopenssl  # type: ignore\n\n        urllib3.contrib.pyopenssl.inject_into_urllib3()\n\n        pkey = crypto.load_privatekey(crypto.FILETYPE_PEM, key)\n        x509 = crypto.load_certificate(crypto.FILETYPE_PEM, cert)\n\n        ctx_poolmanager = create_urllib3_context()\n        ctx_poolmanager.load_verify_locations(cafile=certifi.where())\n        ctx_poolmanager._ctx.use_certificate(x509)\n        ctx_poolmanager._ctx.use_privatekey(pkey)\n        self._ctx_poolmanager = ctx_poolmanager\n\n        ctx_proxymanager = create_urllib3_context()\n        ctx_proxymanager.load_verify_locations(cafile=certifi.where())\n        ctx_proxymanager._ctx.use_certificate(x509)\n        ctx_proxymanager._ctx.use_privatekey(pkey)\n        self._ctx_proxymanager = ctx_proxymanager\n\n        super(_MutualTlsAdapter, self).__init__()\n\n    def init_poolmanager(self, *args, **kwargs):\n        kwargs[\"ssl_context\"] = self._ctx_poolmanager\n        super(_MutualTlsAdapter, self).init_poolmanager(*args, **kwargs)\n\n    def proxy_manager_for(self, *args, **kwargs):\n        kwargs[\"ssl_context\"] = self._ctx_proxymanager\n        return super(_MutualTlsAdapter, self).proxy_manager_for(*args, **kwargs)\n\n\nclass _MutualTlsOffloadAdapter(requests.adapters.HTTPAdapter):\n    \"\"\"\n    A TransportAdapter that enables mutual TLS and offloads the client side\n    signing operation to the signing library.\n\n    Args:\n        enterprise_cert_file_path (str): the path to a enterprise cert JSON\n            file. The file should contain the following field:\n\n                {\n                    \"libs\": {\n                        \"signer_library\": \"...\",\n                        \"offload_library\": \"...\"\n                    }\n                }\n\n    Raises:\n        ImportError: if certifi or pyOpenSSL is not installed\n        google.auth.exceptions.MutualTLSChannelError: If mutual TLS channel\n            creation failed for any reason.\n    \"\"\"\n\n    def __init__(self, enterprise_cert_file_path):\n        import certifi\n        from google.auth.transport import _custom_tls_signer\n\n        self.signer = _custom_tls_signer.CustomTlsSigner(enterprise_cert_file_path)\n        self.signer.load_libraries()\n\n        import urllib3.contrib.pyopenssl\n\n        urllib3.contrib.pyopenssl.inject_into_urllib3()\n\n        poolmanager = create_urllib3_context()\n        poolmanager.load_verify_locations(cafile=certifi.where())\n        self.signer.attach_to_ssl_context(poolmanager)\n        self._ctx_poolmanager = poolmanager\n\n        proxymanager = create_urllib3_context()\n        proxymanager.load_verify_locations(cafile=certifi.where())\n        self.signer.attach_to_ssl_context(proxymanager)\n        self._ctx_proxymanager = proxymanager\n\n        super(_MutualTlsOffloadAdapter, self).__init__()\n\n    def init_poolmanager(self, *args, **kwargs):\n        kwargs[\"ssl_context\"] = self._ctx_poolmanager\n        super(_MutualTlsOffloadAdapter, self).init_poolmanager(*args, **kwargs)\n\n    def proxy_manager_for(self, *args, **kwargs):\n        kwargs[\"ssl_context\"] = self._ctx_proxymanager\n        return super(_MutualTlsOffloadAdapter, self).proxy_manager_for(*args, **kwargs)\n\n\nclass AuthorizedSession(requests.Session):\n    \"\"\"A Requests Session class with credentials.\n\n    This class is used to perform requests to API endpoints that require\n    authorization::\n\n        from google.auth.transport.requests import AuthorizedSession\n\n        authed_session = AuthorizedSession(credentials)\n\n        response = authed_session.request(\n            'GET', 'https://www.googleapis.com/storage/v1/b')\n\n\n    The underlying :meth:`request` implementation handles adding the\n    credentials' headers to the request and refreshing credentials as needed.\n\n    This class also supports mutual TLS via :meth:`configure_mtls_channel`\n    method. In order to use this method, the `GOOGLE_API_USE_CLIENT_CERTIFICATE`\n    environment variable must be explicitly set to ``true``, otherwise it does\n    nothing. Assume the environment is set to ``true``, the method behaves in the\n    following manner:\n\n    If client_cert_callback is provided, client certificate and private\n    key are loaded using the callback; if client_cert_callback is None,\n    application default SSL credentials will be used. Exceptions are raised if\n    there are problems with the certificate, private key, or the loading process,\n    so it should be called within a try/except block.\n\n    First we set the environment variable to ``true``, then create an :class:`AuthorizedSession`\n    instance and specify the endpoints::\n\n        regular_endpoint = 'https://pubsub.googleapis.com/v1/projects/{my_project_id}/topics'\n        mtls_endpoint = 'https://pubsub.mtls.googleapis.com/v1/projects/{my_project_id}/topics'\n\n        authed_session = AuthorizedSession(credentials)\n\n    Now we can pass a callback to :meth:`configure_mtls_channel`::\n\n        def my_cert_callback():\n            # some code to load client cert bytes and private key bytes, both in\n            # PEM format.\n            some_code_to_load_client_cert_and_key()\n            if loaded:\n                return cert, key\n            raise MyClientCertFailureException()\n\n        # Always call configure_mtls_channel within a try/except block.\n        try:\n            authed_session.configure_mtls_channel(my_cert_callback)\n        except:\n            # handle exceptions.\n\n        if authed_session.is_mtls:\n            response = authed_session.request('GET', mtls_endpoint)\n        else:\n            response = authed_session.request('GET', regular_endpoint)\n\n\n    You can alternatively use application default SSL credentials like this::\n\n        try:\n            authed_session.configure_mtls_channel()\n        except:\n            # handle exceptions.\n\n    Args:\n        credentials (google.auth.credentials.Credentials): The credentials to\n            add to the request.\n        refresh_status_codes (Sequence[int]): Which HTTP status codes indicate\n            that credentials should be refreshed and the request should be\n            retried.\n        max_refresh_attempts (int): The maximum number of times to attempt to\n            refresh the credentials and retry the request.\n        refresh_timeout (Optional[int]): The timeout value in seconds for\n            credential refresh HTTP requests.\n        auth_request (google.auth.transport.requests.Request):\n            (Optional) An instance of\n            :class:`~google.auth.transport.requests.Request` used when\n            refreshing credentials. If not passed,\n            an instance of :class:`~google.auth.transport.requests.Request`\n            is created.\n        default_host (Optional[str]): A host like \"pubsub.googleapis.com\".\n            This is used when a self-signed JWT is created from service\n            account credentials.\n    \"\"\"\n\n    def __init__(\n        self,\n        credentials,\n        refresh_status_codes=transport.DEFAULT_REFRESH_STATUS_CODES,\n        max_refresh_attempts=transport.DEFAULT_MAX_REFRESH_ATTEMPTS,\n        refresh_timeout=None,\n        auth_request=None,\n        default_host=None,\n    ):\n        super(AuthorizedSession, self).__init__()\n        self.credentials = credentials\n        self._refresh_status_codes = refresh_status_codes\n        self._max_refresh_attempts = max_refresh_attempts\n        self._refresh_timeout = refresh_timeout\n        self._is_mtls = False\n        self._default_host = default_host\n\n        if auth_request is None:\n            self._auth_request_session = requests.Session()\n\n            # Using an adapter to make HTTP requests robust to network errors.\n            # This adapter retrys HTTP requests when network errors occur\n            # and the requests seems safely retryable.\n            retry_adapter = requests.adapters.HTTPAdapter(max_retries=3)\n            self._auth_request_session.mount(\"https://\", retry_adapter)\n\n            # Do not pass `self` as the session here, as it can lead to\n            # infinite recursion.\n            auth_request = Request(self._auth_request_session)\n        else:\n            self._auth_request_session = None\n\n        # Request instance used by internal methods (for example,\n        # credentials.refresh).\n        self._auth_request = auth_request\n\n        # https://google.aip.dev/auth/4111\n        # Attempt to use self-signed JWTs when a service account is used.\n        if isinstance(self.credentials, service_account.Credentials):\n            self.credentials._create_self_signed_jwt(\n                \"https://{}/\".format(self._default_host) if self._default_host else None\n            )\n\n    def configure_mtls_channel(self, client_cert_callback=None):\n        \"\"\"Configure the client certificate and key for SSL connection.\n\n        The function does nothing unless `GOOGLE_API_USE_CLIENT_CERTIFICATE` is\n        explicitly set to `true`. In this case if client certificate and key are\n        successfully obtained (from the given client_cert_callback or from application\n        default SSL credentials), a :class:`_MutualTlsAdapter` instance will be mounted\n        to \"https://\" prefix.\n\n        Args:\n            client_cert_callback (Optional[Callable[[], (bytes, bytes)]]):\n                The optional callback returns the client certificate and private\n                key bytes both in PEM format.\n                If the callback is None, application default SSL credentials\n                will be used.\n\n        Raises:\n            google.auth.exceptions.MutualTLSChannelError: If mutual TLS channel\n                creation failed for any reason.\n        \"\"\"\n        use_client_cert = os.getenv(\n            environment_vars.GOOGLE_API_USE_CLIENT_CERTIFICATE, \"false\"\n        )\n        if use_client_cert != \"true\":\n            self._is_mtls = False\n            return\n\n        try:\n            import OpenSSL\n        except ImportError as caught_exc:\n            new_exc = exceptions.MutualTLSChannelError(caught_exc)\n            raise new_exc from caught_exc\n\n        try:\n            (\n                self._is_mtls,\n                cert,\n                key,\n            ) = google.auth.transport._mtls_helper.get_client_cert_and_key(\n                client_cert_callback\n            )\n\n            if self._is_mtls:\n                mtls_adapter = _MutualTlsAdapter(cert, key)\n                self.mount(\"https://\", mtls_adapter)\n        except (\n            exceptions.ClientCertError,\n            ImportError,\n            OpenSSL.crypto.Error,\n        ) as caught_exc:\n            new_exc = exceptions.MutualTLSChannelError(caught_exc)\n            raise new_exc from caught_exc\n\n    def request(\n        self,\n        method,\n        url,\n        data=None,\n        headers=None,\n        max_allowed_time=None,\n        timeout=_DEFAULT_TIMEOUT,\n        **kwargs\n    ):\n        \"\"\"Implementation of Requests' request.\n\n        Args:\n            timeout (Optional[Union[float, Tuple[float, float]]]):\n                The amount of time in seconds to wait for the server response\n                with each individual request. Can also be passed as a tuple\n                ``(connect_timeout, read_timeout)``. See :meth:`requests.Session.request`\n                documentation for details.\n            max_allowed_time (Optional[float]):\n                If the method runs longer than this, a ``Timeout`` exception is\n                automatically raised. Unlike the ``timeout`` parameter, this\n                value applies to the total method execution time, even if\n                multiple requests are made under the hood.\n\n                Mind that it is not guaranteed that the timeout error is raised\n                at ``max_allowed_time``. It might take longer, for example, if\n                an underlying request takes a lot of time, but the request\n                itself does not timeout, e.g. if a large file is being\n                transmitted. The timout error will be raised after such\n                request completes.\n        \"\"\"\n        # pylint: disable=arguments-differ\n        # Requests has a ton of arguments to request, but only two\n        # (method, url) are required. We pass through all of the other\n        # arguments to super, so no need to exhaustively list them here.\n\n        # Use a kwarg for this instead of an attribute to maintain\n        # thread-safety.\n        _credential_refresh_attempt = kwargs.pop(\"_credential_refresh_attempt\", 0)\n\n        # Make a copy of the headers. They will be modified by the credentials\n        # and we want to pass the original headers if we recurse.\n        request_headers = headers.copy() if headers is not None else {}\n\n        # Do not apply the timeout unconditionally in order to not override the\n        # _auth_request's default timeout.\n        auth_request = (\n            self._auth_request\n            if timeout is None\n            else functools.partial(self._auth_request, timeout=timeout)\n        )\n\n        remaining_time = max_allowed_time\n\n        with TimeoutGuard(remaining_time) as guard:\n            self.credentials.before_request(auth_request, method, url, request_headers)\n        remaining_time = guard.remaining_timeout\n\n        with TimeoutGuard(remaining_time) as guard:\n            response = super(AuthorizedSession, self).request(\n                method,\n                url,\n                data=data,\n                headers=request_headers,\n                timeout=timeout,\n                **kwargs\n            )\n        remaining_time = guard.remaining_timeout\n\n        # If the response indicated that the credentials needed to be\n        # refreshed, then refresh the credentials and re-attempt the\n        # request.\n        # A stored token may expire between the time it is retrieved and\n        # the time the request is made, so we may need to try twice.\n        if (\n            response.status_code in self._refresh_status_codes\n            and _credential_refresh_attempt < self._max_refresh_attempts\n        ):\n\n            _LOGGER.info(\n                \"Refreshing credentials due to a %s response. Attempt %s/%s.\",\n                response.status_code,\n                _credential_refresh_attempt + 1,\n                self._max_refresh_attempts,\n            )\n\n            # Do not apply the timeout unconditionally in order to not override the\n            # _auth_request's default timeout.\n            auth_request = (\n                self._auth_request\n                if timeout is None\n                else functools.partial(self._auth_request, timeout=timeout)\n            )\n\n            with TimeoutGuard(remaining_time) as guard:\n                self.credentials.refresh(auth_request)\n            remaining_time = guard.remaining_timeout\n\n            # Recurse. Pass in the original headers, not our modified set, but\n            # do pass the adjusted max allowed time (i.e. the remaining total time).\n            return self.request(\n                method,\n                url,\n                data=data,\n                headers=headers,\n                max_allowed_time=remaining_time,\n                timeout=timeout,\n                _credential_refresh_attempt=_credential_refresh_attempt + 1,\n                **kwargs\n            )\n\n        return response\n\n    @property\n    def is_mtls(self):\n        \"\"\"Indicates if the created SSL channel is mutual TLS.\"\"\"\n        return self._is_mtls\n\n    def close(self):\n        if self._auth_request_session is not None:\n            self._auth_request_session.close()\n        super(AuthorizedSession, self).close()\n", "google/auth/transport/urllib3.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Transport adapter for urllib3.\"\"\"\n\nfrom __future__ import absolute_import\n\nimport logging\nimport os\nimport warnings\n\n# Certifi is Mozilla's certificate bundle. Urllib3 needs a certificate bundle\n# to verify HTTPS requests, and certifi is the recommended and most reliable\n# way to get a root certificate bundle. See\n# http://urllib3.readthedocs.io/en/latest/user-guide.html\\\n#   #certificate-verification\n# For more details.\ntry:\n    import certifi\nexcept ImportError:  # pragma: NO COVER\n    certifi = None  # type: ignore\n\ntry:\n    import urllib3  # type: ignore\n    import urllib3.exceptions  # type: ignore\nexcept ImportError as caught_exc:  # pragma: NO COVER\n    raise ImportError(\n        \"The urllib3 library is not installed from please install the \"\n        \"urllib3 package to use the urllib3 transport.\"\n    ) from caught_exc\n\nfrom packaging import version  # type: ignore\n\nfrom google.auth import environment_vars\nfrom google.auth import exceptions\nfrom google.auth import transport\nfrom google.oauth2 import service_account\n\nif version.parse(urllib3.__version__) >= version.parse(\"2.0.0\"):  # pragma: NO COVER\n    RequestMethods = urllib3._request_methods.RequestMethods  # type: ignore\nelse:  # pragma: NO COVER\n    RequestMethods = urllib3.request.RequestMethods  # type: ignore\n\n_LOGGER = logging.getLogger(__name__)\n\n\nclass _Response(transport.Response):\n    \"\"\"urllib3 transport response adapter.\n\n    Args:\n        response (urllib3.response.HTTPResponse): The raw urllib3 response.\n    \"\"\"\n\n    def __init__(self, response):\n        self._response = response\n\n    @property\n    def status(self):\n        return self._response.status\n\n    @property\n    def headers(self):\n        return self._response.headers\n\n    @property\n    def data(self):\n        return self._response.data\n\n\nclass Request(transport.Request):\n    \"\"\"urllib3 request adapter.\n\n    This class is used internally for making requests using various transports\n    in a consistent way. If you use :class:`AuthorizedHttp` you do not need\n    to construct or use this class directly.\n\n    This class can be useful if you want to manually refresh a\n    :class:`~google.auth.credentials.Credentials` instance::\n\n        import google.auth.transport.urllib3\n        import urllib3\n\n        http = urllib3.PoolManager()\n        request = google.auth.transport.urllib3.Request(http)\n\n        credentials.refresh(request)\n\n    Args:\n        http (urllib3.request.RequestMethods): An instance of any urllib3\n            class that implements :class:`~urllib3.request.RequestMethods`,\n            usually :class:`urllib3.PoolManager`.\n\n    .. automethod:: __call__\n    \"\"\"\n\n    def __init__(self, http):\n        self.http = http\n\n    def __call__(\n        self, url, method=\"GET\", body=None, headers=None, timeout=None, **kwargs\n    ):\n        \"\"\"Make an HTTP request using urllib3.\n\n        Args:\n            url (str): The URI to be requested.\n            method (str): The HTTP method to use for the request. Defaults\n                to 'GET'.\n            body (bytes): The payload / body in HTTP request.\n            headers (Mapping[str, str]): Request headers.\n            timeout (Optional[int]): The number of seconds to wait for a\n                response from the server. If not specified or if None, the\n                urllib3 default timeout will be used.\n            kwargs: Additional arguments passed throught to the underlying\n                urllib3 :meth:`urlopen` method.\n\n        Returns:\n            google.auth.transport.Response: The HTTP response.\n\n        Raises:\n            google.auth.exceptions.TransportError: If any exception occurred.\n        \"\"\"\n        # urllib3 uses a sentinel default value for timeout, so only set it if\n        # specified.\n        if timeout is not None:\n            kwargs[\"timeout\"] = timeout\n\n        try:\n            _LOGGER.debug(\"Making request: %s %s\", method, url)\n            response = self.http.request(\n                method, url, body=body, headers=headers, **kwargs\n            )\n            return _Response(response)\n        except urllib3.exceptions.HTTPError as caught_exc:\n            new_exc = exceptions.TransportError(caught_exc)\n            raise new_exc from caught_exc\n\n\ndef _make_default_http():\n    if certifi is not None:\n        return urllib3.PoolManager(cert_reqs=\"CERT_REQUIRED\", ca_certs=certifi.where())\n    else:\n        return urllib3.PoolManager()\n\n\ndef _make_mutual_tls_http(cert, key):\n    \"\"\"Create a mutual TLS HTTP connection with the given client cert and key.\n    See https://github.com/urllib3/urllib3/issues/474#issuecomment-253168415\n\n    Args:\n        cert (bytes): client certificate in PEM format\n        key (bytes): client private key in PEM format\n\n    Returns:\n        urllib3.PoolManager: Mutual TLS HTTP connection.\n\n    Raises:\n        ImportError: If certifi or pyOpenSSL is not installed.\n        OpenSSL.crypto.Error: If the cert or key is invalid.\n    \"\"\"\n    import certifi\n    from OpenSSL import crypto\n    import urllib3.contrib.pyopenssl  # type: ignore\n\n    urllib3.contrib.pyopenssl.inject_into_urllib3()\n    ctx = urllib3.util.ssl_.create_urllib3_context()\n    ctx.load_verify_locations(cafile=certifi.where())\n\n    pkey = crypto.load_privatekey(crypto.FILETYPE_PEM, key)\n    x509 = crypto.load_certificate(crypto.FILETYPE_PEM, cert)\n\n    ctx._ctx.use_certificate(x509)\n    ctx._ctx.use_privatekey(pkey)\n\n    http = urllib3.PoolManager(ssl_context=ctx)\n    return http\n\n\nclass AuthorizedHttp(RequestMethods):  # type: ignore\n    \"\"\"A urllib3 HTTP class with credentials.\n\n    This class is used to perform requests to API endpoints that require\n    authorization::\n\n        from google.auth.transport.urllib3 import AuthorizedHttp\n\n        authed_http = AuthorizedHttp(credentials)\n\n        response = authed_http.request(\n            'GET', 'https://www.googleapis.com/storage/v1/b')\n\n    This class implements :class:`urllib3.request.RequestMethods` and can be\n    used just like any other :class:`urllib3.PoolManager`.\n\n    The underlying :meth:`urlopen` implementation handles adding the\n    credentials' headers to the request and refreshing credentials as needed.\n\n    This class also supports mutual TLS via :meth:`configure_mtls_channel`\n    method. In order to use this method, the `GOOGLE_API_USE_CLIENT_CERTIFICATE`\n    environment variable must be explicitly set to `true`, otherwise it does\n    nothing. Assume the environment is set to `true`, the method behaves in the\n    following manner:\n    If client_cert_callback is provided, client certificate and private\n    key are loaded using the callback; if client_cert_callback is None,\n    application default SSL credentials will be used. Exceptions are raised if\n    there are problems with the certificate, private key, or the loading process,\n    so it should be called within a try/except block.\n\n    First we set the environment variable to `true`, then create an :class:`AuthorizedHttp`\n    instance and specify the endpoints::\n\n        regular_endpoint = 'https://pubsub.googleapis.com/v1/projects/{my_project_id}/topics'\n        mtls_endpoint = 'https://pubsub.mtls.googleapis.com/v1/projects/{my_project_id}/topics'\n\n        authed_http = AuthorizedHttp(credentials)\n\n    Now we can pass a callback to :meth:`configure_mtls_channel`::\n\n        def my_cert_callback():\n            # some code to load client cert bytes and private key bytes, both in\n            # PEM format.\n            some_code_to_load_client_cert_and_key()\n            if loaded:\n                return cert, key\n            raise MyClientCertFailureException()\n\n        # Always call configure_mtls_channel within a try/except block.\n        try:\n            is_mtls = authed_http.configure_mtls_channel(my_cert_callback)\n        except:\n            # handle exceptions.\n\n        if is_mtls:\n            response = authed_http.request('GET', mtls_endpoint)\n        else:\n            response = authed_http.request('GET', regular_endpoint)\n\n    You can alternatively use application default SSL credentials like this::\n\n        try:\n            is_mtls = authed_http.configure_mtls_channel()\n        except:\n            # handle exceptions.\n\n    Args:\n        credentials (google.auth.credentials.Credentials): The credentials to\n            add to the request.\n        http (urllib3.PoolManager): The underlying HTTP object to\n            use to make requests. If not specified, a\n            :class:`urllib3.PoolManager` instance will be constructed with\n            sane defaults.\n        refresh_status_codes (Sequence[int]): Which HTTP status codes indicate\n            that credentials should be refreshed and the request should be\n            retried.\n        max_refresh_attempts (int): The maximum number of times to attempt to\n            refresh the credentials and retry the request.\n        default_host (Optional[str]): A host like \"pubsub.googleapis.com\".\n            This is used when a self-signed JWT is created from service\n            account credentials.\n    \"\"\"\n\n    def __init__(\n        self,\n        credentials,\n        http=None,\n        refresh_status_codes=transport.DEFAULT_REFRESH_STATUS_CODES,\n        max_refresh_attempts=transport.DEFAULT_MAX_REFRESH_ATTEMPTS,\n        default_host=None,\n    ):\n        if http is None:\n            self.http = _make_default_http()\n            self._has_user_provided_http = False\n        else:\n            self.http = http\n            self._has_user_provided_http = True\n\n        self.credentials = credentials\n        self._refresh_status_codes = refresh_status_codes\n        self._max_refresh_attempts = max_refresh_attempts\n        self._default_host = default_host\n        # Request instance used by internal methods (for example,\n        # credentials.refresh).\n        self._request = Request(self.http)\n\n        # https://google.aip.dev/auth/4111\n        # Attempt to use self-signed JWTs when a service account is used.\n        if isinstance(self.credentials, service_account.Credentials):\n            self.credentials._create_self_signed_jwt(\n                \"https://{}/\".format(self._default_host) if self._default_host else None\n            )\n\n        super(AuthorizedHttp, self).__init__()\n\n    def configure_mtls_channel(self, client_cert_callback=None):\n        \"\"\"Configures mutual TLS channel using the given client_cert_callback or\n        application default SSL credentials. The behavior is controlled by\n        `GOOGLE_API_USE_CLIENT_CERTIFICATE` environment variable.\n        (1) If the environment variable value is `true`, the function returns True\n        if the channel is mutual TLS and False otherwise. The `http` provided\n        in the constructor will be overwritten.\n        (2) If the environment variable is not set or `false`, the function does\n        nothing and it always return False.\n\n        Args:\n            client_cert_callback (Optional[Callable[[], (bytes, bytes)]]):\n                The optional callback returns the client certificate and private\n                key bytes both in PEM format.\n                If the callback is None, application default SSL credentials\n                will be used.\n\n        Returns:\n            True if the channel is mutual TLS and False otherwise.\n\n        Raises:\n            google.auth.exceptions.MutualTLSChannelError: If mutual TLS channel\n                creation failed for any reason.\n        \"\"\"\n        use_client_cert = os.getenv(\n            environment_vars.GOOGLE_API_USE_CLIENT_CERTIFICATE, \"false\"\n        )\n        if use_client_cert != \"true\":\n            return False\n\n        try:\n            import OpenSSL\n        except ImportError as caught_exc:\n            new_exc = exceptions.MutualTLSChannelError(caught_exc)\n            raise new_exc from caught_exc\n\n        try:\n            found_cert_key, cert, key = transport._mtls_helper.get_client_cert_and_key(\n                client_cert_callback\n            )\n\n            if found_cert_key:\n                self.http = _make_mutual_tls_http(cert, key)\n            else:\n                self.http = _make_default_http()\n        except (\n            exceptions.ClientCertError,\n            ImportError,\n            OpenSSL.crypto.Error,\n        ) as caught_exc:\n            new_exc = exceptions.MutualTLSChannelError(caught_exc)\n            raise new_exc from caught_exc\n\n        if self._has_user_provided_http:\n            self._has_user_provided_http = False\n            warnings.warn(\n                \"`http` provided in the constructor is overwritten\", UserWarning\n            )\n\n        return found_cert_key\n\n    def urlopen(self, method, url, body=None, headers=None, **kwargs):\n        \"\"\"Implementation of urllib3's urlopen.\"\"\"\n        # pylint: disable=arguments-differ\n        # We use kwargs to collect additional args that we don't need to\n        # introspect here. However, we do explicitly collect the two\n        # positional arguments.\n\n        # Use a kwarg for this instead of an attribute to maintain\n        # thread-safety.\n        _credential_refresh_attempt = kwargs.pop(\"_credential_refresh_attempt\", 0)\n\n        if headers is None:\n            headers = self.headers\n\n        # Make a copy of the headers. They will be modified by the credentials\n        # and we want to pass the original headers if we recurse.\n        request_headers = headers.copy()\n\n        self.credentials.before_request(self._request, method, url, request_headers)\n\n        response = self.http.urlopen(\n            method, url, body=body, headers=request_headers, **kwargs\n        )\n\n        # If the response indicated that the credentials needed to be\n        # refreshed, then refresh the credentials and re-attempt the\n        # request.\n        # A stored token may expire between the time it is retrieved and\n        # the time the request is made, so we may need to try twice.\n        # The reason urllib3's retries aren't used is because they\n        # don't allow you to modify the request headers. :/\n        if (\n            response.status in self._refresh_status_codes\n            and _credential_refresh_attempt < self._max_refresh_attempts\n        ):\n\n            _LOGGER.info(\n                \"Refreshing credentials due to a %s response. Attempt %s/%s.\",\n                response.status,\n                _credential_refresh_attempt + 1,\n                self._max_refresh_attempts,\n            )\n\n            self.credentials.refresh(self._request)\n\n            # Recurse. Pass in the original headers, not our modified set.\n            return self.urlopen(\n                method,\n                url,\n                body=body,\n                headers=headers,\n                _credential_refresh_attempt=_credential_refresh_attempt + 1,\n                **kwargs\n            )\n\n        return response\n\n    # Proxy methods for compliance with the urllib3.PoolManager interface\n\n    def __enter__(self):\n        \"\"\"Proxy to ``self.http``.\"\"\"\n        return self.http.__enter__()\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Proxy to ``self.http``.\"\"\"\n        return self.http.__exit__(exc_type, exc_val, exc_tb)\n\n    def __del__(self):\n        if hasattr(self, \"http\") and self.http is not None:\n            self.http.clear()\n\n    @property\n    def headers(self):\n        \"\"\"Proxy to ``self.http``.\"\"\"\n        return self.http.headers\n\n    @headers.setter\n    def headers(self, value):\n        \"\"\"Proxy to ``self.http``.\"\"\"\n        self.http.headers = value\n", "google/auth/transport/_http_client.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Transport adapter for http.client, for internal use only.\"\"\"\n\nimport http.client as http_client\nimport logging\nimport socket\nimport urllib\n\nfrom google.auth import exceptions\nfrom google.auth import transport\n\n_LOGGER = logging.getLogger(__name__)\n\n\nclass Response(transport.Response):\n    \"\"\"http.client transport response adapter.\n\n    Args:\n        response (http.client.HTTPResponse): The raw http client response.\n    \"\"\"\n\n    def __init__(self, response):\n        self._status = response.status\n        self._headers = {key.lower(): value for key, value in response.getheaders()}\n        self._data = response.read()\n\n    @property\n    def status(self):\n        return self._status\n\n    @property\n    def headers(self):\n        return self._headers\n\n    @property\n    def data(self):\n        return self._data\n\n\nclass Request(transport.Request):\n    \"\"\"http.client transport request adapter.\"\"\"\n\n    def __call__(\n        self, url, method=\"GET\", body=None, headers=None, timeout=None, **kwargs\n    ):\n        \"\"\"Make an HTTP request using http.client.\n\n        Args:\n            url (str): The URI to be requested.\n            method (str): The HTTP method to use for the request. Defaults\n                to 'GET'.\n            body (bytes): The payload / body in HTTP request.\n            headers (Mapping): Request headers.\n            timeout (Optional(int)): The number of seconds to wait for a\n                response from the server. If not specified or if None, the\n                socket global default timeout will be used.\n            kwargs: Additional arguments passed throught to the underlying\n                :meth:`~http.client.HTTPConnection.request` method.\n\n        Returns:\n            Response: The HTTP response.\n\n        Raises:\n            google.auth.exceptions.TransportError: If any exception occurred.\n        \"\"\"\n        # socket._GLOBAL_DEFAULT_TIMEOUT is the default in http.client.\n        if timeout is None:\n            timeout = socket._GLOBAL_DEFAULT_TIMEOUT\n\n        # http.client doesn't allow None as the headers argument.\n        if headers is None:\n            headers = {}\n\n        # http.client needs the host and path parts specified separately.\n        parts = urllib.parse.urlsplit(url)\n        path = urllib.parse.urlunsplit(\n            (\"\", \"\", parts.path, parts.query, parts.fragment)\n        )\n\n        if parts.scheme != \"http\":\n            raise exceptions.TransportError(\n                \"http.client transport only supports the http scheme, {}\"\n                \"was specified\".format(parts.scheme)\n            )\n\n        connection = http_client.HTTPConnection(parts.netloc, timeout=timeout)\n\n        try:\n            _LOGGER.debug(\"Making request: %s %s\", method, url)\n\n            connection.request(method, path, body=body, headers=headers, **kwargs)\n            response = connection.getresponse()\n            return Response(response)\n\n        except (http_client.HTTPException, socket.error) as caught_exc:\n            new_exc = exceptions.TransportError(caught_exc)\n            raise new_exc from caught_exc\n\n        finally:\n            connection.close()\n", "google/auth/transport/__init__.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Transport - HTTP client library support.\n\n:mod:`google.auth` is designed to work with various HTTP client libraries such\nas urllib3 and requests. In order to work across these libraries with different\ninterfaces some abstraction is needed.\n\nThis module provides two interfaces that are implemented by transport adapters\nto support HTTP libraries. :class:`Request` defines the interface expected by\n:mod:`google.auth` to make requests. :class:`Response` defines the interface\nfor the return value of :class:`Request`.\n\"\"\"\n\nimport abc\nimport http.client as http_client\n\nDEFAULT_RETRYABLE_STATUS_CODES = (\n    http_client.INTERNAL_SERVER_ERROR,\n    http_client.SERVICE_UNAVAILABLE,\n    http_client.REQUEST_TIMEOUT,\n    http_client.TOO_MANY_REQUESTS,\n)\n\"\"\"Sequence[int]:  HTTP status codes indicating a request can be retried.\n\"\"\"\n\n\nDEFAULT_REFRESH_STATUS_CODES = (http_client.UNAUTHORIZED,)\n\"\"\"Sequence[int]:  Which HTTP status code indicate that credentials should be\nrefreshed.\n\"\"\"\n\nDEFAULT_MAX_REFRESH_ATTEMPTS = 2\n\"\"\"int: How many times to refresh the credentials and retry a request.\"\"\"\n\n\nclass Response(metaclass=abc.ABCMeta):\n    \"\"\"HTTP Response data.\"\"\"\n\n    @abc.abstractproperty\n    def status(self):\n        \"\"\"int: The HTTP status code.\"\"\"\n        raise NotImplementedError(\"status must be implemented.\")\n\n    @abc.abstractproperty\n    def headers(self):\n        \"\"\"Mapping[str, str]: The HTTP response headers.\"\"\"\n        raise NotImplementedError(\"headers must be implemented.\")\n\n    @abc.abstractproperty\n    def data(self):\n        \"\"\"bytes: The response body.\"\"\"\n        raise NotImplementedError(\"data must be implemented.\")\n\n\nclass Request(metaclass=abc.ABCMeta):\n    \"\"\"Interface for a callable that makes HTTP requests.\n\n    Specific transport implementations should provide an implementation of\n    this that adapts their specific request / response API.\n\n    .. automethod:: __call__\n    \"\"\"\n\n    @abc.abstractmethod\n    def __call__(\n        self, url, method=\"GET\", body=None, headers=None, timeout=None, **kwargs\n    ):\n        \"\"\"Make an HTTP request.\n\n        Args:\n            url (str): The URI to be requested.\n            method (str): The HTTP method to use for the request. Defaults\n                to 'GET'.\n            body (bytes): The payload / body in HTTP request.\n            headers (Mapping[str, str]): Request headers.\n            timeout (Optional[int]): The number of seconds to wait for a\n                response from the server. If not specified or if None, the\n                transport-specific default timeout will be used.\n            kwargs: Additionally arguments passed on to the transport's\n                request method.\n\n        Returns:\n            Response: The HTTP response.\n\n        Raises:\n            google.auth.exceptions.TransportError: If any exception occurred.\n        \"\"\"\n        # pylint: disable=redundant-returns-doc, missing-raises-doc\n        # (pylint doesn't play well with abstract docstrings.)\n        raise NotImplementedError(\"__call__ must be implemented.\")\n"}