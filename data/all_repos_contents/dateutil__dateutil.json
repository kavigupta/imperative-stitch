{"updatezinfo.py": "#!/usr/bin/env python\nimport os\nimport hashlib\nimport json\nimport io\n\nfrom six.moves.urllib import request\nfrom six.moves.urllib import error as urllib_error\n\ntry:\n    import dateutil\nexcept ImportError:\n    print(\"dateutil not installed locally, adding src to Python path\")\n    import sys\n    here = os.path.dirname(__file__)\n    sys.path.append(os.path.join(here, \"src\"))\n    print(sys.path)\n\nfrom dateutil.zoneinfo import rebuild\n\nMETADATA_FILE = \"zonefile_metadata.json\"\n\n\ndef main(metadata_file):\n    with io.open(metadata_file, 'r') as f:\n        metadata = json.load(f)\n\n    releases_urls = metadata['releases_url']\n    if metadata['metadata_version'] < 2.0:\n        # In later versions the releases URL is a mirror URL\n        releases_urls = [releases_urls]\n\n    if not os.path.isfile(metadata['tzdata_file']):\n\n        for ii, releases_url in enumerate(releases_urls):\n            print(\"Downloading tz file from mirror {ii}\".format(ii=ii))\n            try:\n                request.urlretrieve(os.path.join(releases_url,\n                                                 metadata['tzdata_file']),\n                                    metadata['tzdata_file'])\n            except urllib_error.URLError as e:\n                print(\"Download failed, trying next mirror.\")\n                last_error = e\n                continue\n\n            last_error = None\n            break\n\n        if last_error is not None:\n            raise last_error\n\n    with open(metadata['tzdata_file'], 'rb') as tzfile:\n        sha_hasher = hashlib.sha512()\n        sha_hasher.update(tzfile.read())\n        sha_512_file = sha_hasher.hexdigest()\n        assert metadata['tzdata_file_sha512'] == sha_512_file, \"SHA failed for\"\n    print(\"Updating timezone information...\")\n    rebuild.rebuild(metadata['tzdata_file'], zonegroups=metadata['zonegroups'],\n            metadata=metadata)\n    print(\"Done.\")\n\n\nif __name__ == \"__main__\":\n    import argparse\n    parser = argparse.ArgumentParser()\n    parser.add_argument('metadata', metavar='METADATA_FILE',\n                        default=METADATA_FILE,\n                        nargs='?')\n\n    args = parser.parse_args()\n    main(args.metadata)\n", "setup.py": "#!/usr/bin/python\nfrom os.path import isfile\nimport os\n\nimport setuptools\nfrom setuptools import setup, find_packages\nfrom setuptools.command.test import test as TestCommand\n\nfrom distutils.version import LooseVersion\nimport warnings\n\nimport io\nimport sys\n\nif isfile(\"MANIFEST\"):\n    os.unlink(\"MANIFEST\")\n\nif LooseVersion(setuptools.__version__) <= LooseVersion(\"24.3\"):\n    warnings.warn(\"python_requires requires setuptools version > 24.3\",\n                  UserWarning)\n\n\nclass Unsupported(TestCommand):\n    def run(self):\n        sys.stderr.write(\"Running 'test' with setup.py is not supported. \"\n                         \"Use 'pytest' or 'tox' to run the tests.\\n\")\n        sys.exit(1)\n\n\n###\n# Load metadata\n\ndef README():\n    with io.open('README.rst', encoding='utf-8') as f:\n        readme_lines = f.readlines()\n\n    # The .. doctest directive is not supported by PyPA\n    lines_out = []\n    for line in readme_lines:\n        if line.startswith('.. doctest'):\n            lines_out.append('.. code-block:: python3\\n')\n        else:\n            lines_out.append(line)\n\n    return ''.join(lines_out)\nREADME = README()  # NOQA\n\n\nsetup(\n      use_scm_version={\n          'write_to': 'src/dateutil/_version.py',\n      },\n      ## Needed since doctest not supported by PyPA.\n      long_description = README,\n      cmdclass={\n          \"test\": Unsupported\n      }\n      )\n", "docs/conf.py": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n#\n# dateutil documentation build configuration file, created by\n# sphinx-quickstart on Thu Nov 20 23:18:41 2014.\n#\n# This file is execfile()d with the current directory set to its\n# containing dir.\n#\n# Note that not all possible configuration values are present in this\n# autogenerated file.\n#\n# All configuration values have a default; values that are commented out\n# serve to show the default.\n\nimport sys\nimport os\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n#sys.path.insert(0, os.path.abspath('.'))\nsys.path.insert(0, os.path.abspath('../'))\n\n# -- General configuration ------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\n#needs_sphinx = '1.0'\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom\n# ones.\nextensions = [\n    'sphinx.ext.autodoc',\n    'sphinx.ext.doctest',\n    'sphinx.ext.viewcode',\n]\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = ['_templates']\n\n# The suffix of source filenames.\nsource_suffix = '.rst'\n\n# The encoding of source files.\n#source_encoding = 'utf-8-sig'\n\n# The master toctree document.\nmaster_doc = 'index'\n\n# General information about the project.\nproject = 'dateutil'\ncopyright = '2019, dateutil'\n\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nfrom dateutil import __version__ as VERSION  # Explicitly use a relative path\n\nversion = VERSION\n# The full version, including alpha/beta/rc tags.\nrelease = VERSION\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#language = None\n\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n#today = ''\n# Else, today_fmt is used as the format for a strftime call.\n#today_fmt = '%B %d, %Y'\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = ['_build']\n\n# The reST default role (used for this markup: `text`) to use for all\n# documents.\n#default_role = None\n\n# If true, '()' will be appended to :func: etc. cross-reference text.\n#add_function_parentheses = True\n\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n#add_module_names = True\n\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\n#show_authors = False\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = 'sphinx'\n\n# A list of ignored prefixes for module index sorting.\n#modindex_common_prefix = []\n\n# If true, keep warnings as \"system message\" paragraphs in the built documents.\n#keep_warnings = False\n\n\n# -- Options for HTML output ----------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\nhtml_theme = 'sphinx_rtd_theme'\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#html_theme_options = {}\n\n# Add any paths that contain custom themes here, relative to this directory.\n#html_theme_path = []\n\n# The name for this set of Sphinx documents.  If None, it defaults to\n# \"<project> v<release> documentation\".\n#html_title = None\n\n# A shorter title for the navigation bar.  Default is the same as html_title.\n#html_short_title = None\n\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n#html_logo = None\n\n# The name of an image file (within the static path) to use as favicon of the\n# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\n#html_favicon = None\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\nhtml_static_path = []\n\n# Add any extra paths that contain custom files (such as robots.txt or\n# .htaccess) here, relative to this directory. These files are copied\n# directly to the root of the documentation.\n#html_extra_path = []\n\n# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,\n# using the given strftime format.\n#html_last_updated_fmt = '%b %d, %Y'\n\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n#html_use_smartypants = True\n\n# Custom sidebar templates, maps document names to template names.\n#html_sidebars = {}\n\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n#html_additional_pages = {}\n\n# If false, no module index is generated.\n#html_domain_indices = True\n\n# If false, no index is generated.\n#html_use_index = True\n\n# If true, the index is split into individual pages for each letter.\n#html_split_index = False\n\n# If true, links to the reST sources are added to the pages.\n#html_show_sourcelink = True\n\n# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.\n#html_show_sphinx = True\n\n# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.\n#html_show_copyright = True\n\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n#html_use_opensearch = ''\n\n# This is the file name suffix for HTML files (e.g. \".xhtml\").\n#html_file_suffix = None\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = 'dateutildoc'\n\n# -- Options for autodoc -------------------------------------------------\n\nautodoc_mock_imports = ['ctypes.wintypes', 'six.moves.winreg']\n\n# Need to mock this out specifically to avoid errors\nimport ctypes\ndef pointer_mock(*args, **kwargs):\n    try:\n        return ctypes.POINTER(*args, **kwargs)\n    except Exception:\n        return None\n\nctypes.POINTER = pointer_mock\nsys.modules['ctypes'] = ctypes\n\n# -- Options for LaTeX output ---------------------------------------------\n\nlatex_elements = {\n# The paper size ('letterpaper' or 'a4paper').\n#'papersize': 'letterpaper',\n\n# The font size ('10pt', '11pt' or '12pt').\n#'pointsize': '10pt',\n\n# Additional stuff for the LaTeX preamble.\n#'preamble': '',\n}\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title,\n#  author, documentclass [howto, manual, or own class]).\nlatex_documents = [\n  ('index', 'dateutil.tex', 'dateutil Documentation',\n   'dateutil', 'manual'),\n]\n\n# The name of an image file (relative to this directory) to place at the top of\n# the title page.\n#latex_logo = None\n\n# For \"manual\" documents, if this is true, then toplevel headings are parts,\n# not chapters.\n#latex_use_parts = False\n\n# If true, show page references after internal links.\n#latex_show_pagerefs = False\n\n# If true, show URL addresses after external links.\n#latex_show_urls = False\n\n# Documents to append as an appendix to all manuals.\n#latex_appendices = []\n\n# If false, no module index is generated.\n#latex_domain_indices = True\n\n\n# -- Options for manual page output ---------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    ('index', 'dateutil', 'dateutil Documentation',\n     ['dateutil'], 1)\n]\n\n# If true, show URL addresses after external links.\n#man_show_urls = False\n\n\n# -- Options for Texinfo output -------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n  ('index', 'dateutil', 'dateutil Documentation',\n   'dateutil', 'dateutil', 'One line description of project.',\n   'Miscellaneous'),\n]\n\n# Documents to append as an appendix to all manuals.\n#texinfo_appendices = []\n\n# If false, no module index is generated.\n#texinfo_domain_indices = True\n\n# How to display URL addresses: 'footnote', 'no', or 'inline'.\n#texinfo_show_urls = 'footnote'\n\n# If true, do not generate a @detailmenu in the \"Top\" node's menu.\n#texinfo_no_detailmenu = False\n\n# -- Link checking options -------------------------------------------------\nlinkcheck_ignore = [\n    # This has been spotty lately so we're adding a mirror\n    r'https://pgp.mit.edu',\n]\n\n# Reduce problems with ephemeral failures\nlinkcheck_retries = 5\n", "docs/exercises/solutions/mlk_day_rrule_solution.py": "# ------- YOUR CODE -------------#\nfrom dateutil import rrule\nfrom datetime import datetime\n\nMLK_DAY = rrule.rrule(\n    dtstart=datetime(1986, 1, 20),      # First celebration\n    freq=rrule.YEARLY,                  # Occurs once per year\n    bymonth=1,                          # In January\n    byweekday=rrule.MO(+3),             # On the 3rd Monday\n)\n\n# -------------------------------#\n\nfrom datetime import datetime\n\nMLK_TEST_CASES = [\n    ((datetime(1970, 1, 1), datetime(1980, 1, 1)),\n     []),\n    ((datetime(1980, 1, 1), datetime(1989, 1, 1)),\n     [datetime(1986, 1, 20),\n      datetime(1987, 1, 19),\n      datetime(1988, 1, 18)]),\n    ((datetime(2017, 2, 1), datetime(2022, 2, 1)),\n     [datetime(2018, 1, 15, 0, 0),\n      datetime(2019, 1, 21, 0, 0),\n      datetime(2020, 1, 20, 0, 0),\n      datetime(2021, 1, 18, 0, 0),\n      datetime(2022, 1, 17, 0, 0)]\n     ),\n]\n\n\ndef test_mlk_day():\n    for (between_args, expected) in MLK_TEST_CASES:\n        assert MLK_DAY.between(*between_args) == expected\n\n\nif __name__ == \"__main__\":\n    test_mlk_day()\n    print('Success!')\n", "tests/test_easter.py": "from dateutil.easter import easter\nfrom dateutil.easter import EASTER_WESTERN, EASTER_ORTHODOX, EASTER_JULIAN\n\nfrom datetime import date\nimport pytest\n\n# List of easters between 1990 and 2050\nwestern_easter_dates = [\n    date(1990, 4, 15), date(1991, 3, 31), date(1992, 4, 19), date(1993, 4, 11),\n    date(1994, 4,  3), date(1995, 4, 16), date(1996, 4,  7), date(1997, 3, 30),\n    date(1998, 4, 12), date(1999, 4,  4),\n\n    date(2000, 4, 23), date(2001, 4, 15), date(2002, 3, 31), date(2003, 4, 20),\n    date(2004, 4, 11), date(2005, 3, 27), date(2006, 4, 16), date(2007, 4,  8),\n    date(2008, 3, 23), date(2009, 4, 12),\n\n    date(2010, 4,  4), date(2011, 4, 24), date(2012, 4,  8), date(2013, 3, 31),\n    date(2014, 4, 20), date(2015, 4,  5), date(2016, 3, 27), date(2017, 4, 16),\n    date(2018, 4,  1), date(2019, 4, 21),\n\n    date(2020, 4, 12), date(2021, 4,  4), date(2022, 4, 17), date(2023, 4,  9),\n    date(2024, 3, 31), date(2025, 4, 20), date(2026, 4,  5), date(2027, 3, 28),\n    date(2028, 4, 16), date(2029, 4,  1),\n\n    date(2030, 4, 21), date(2031, 4, 13), date(2032, 3, 28), date(2033, 4, 17),\n    date(2034, 4,  9), date(2035, 3, 25), date(2036, 4, 13), date(2037, 4,  5),\n    date(2038, 4, 25), date(2039, 4, 10),\n\n    date(2040, 4,  1), date(2041, 4, 21), date(2042, 4,  6), date(2043, 3, 29),\n    date(2044, 4, 17), date(2045, 4,  9), date(2046, 3, 25), date(2047, 4, 14),\n    date(2048, 4,  5), date(2049, 4, 18), date(2050, 4, 10)\n    ]\n\northodox_easter_dates = [\n    date(1990, 4, 15), date(1991, 4,  7), date(1992, 4, 26), date(1993, 4, 18),\n    date(1994, 5,  1), date(1995, 4, 23), date(1996, 4, 14), date(1997, 4, 27),\n    date(1998, 4, 19), date(1999, 4, 11),\n\n    date(2000, 4, 30), date(2001, 4, 15), date(2002, 5,  5), date(2003, 4, 27),\n    date(2004, 4, 11), date(2005, 5,  1), date(2006, 4, 23), date(2007, 4,  8),\n    date(2008, 4, 27), date(2009, 4, 19),\n\n    date(2010, 4,  4), date(2011, 4, 24), date(2012, 4, 15), date(2013, 5,  5),\n    date(2014, 4, 20), date(2015, 4, 12), date(2016, 5,  1), date(2017, 4, 16),\n    date(2018, 4,  8), date(2019, 4, 28),\n\n    date(2020, 4, 19), date(2021, 5,  2), date(2022, 4, 24), date(2023, 4, 16),\n    date(2024, 5,  5), date(2025, 4, 20), date(2026, 4, 12), date(2027, 5,  2),\n    date(2028, 4, 16), date(2029, 4,  8),\n\n    date(2030, 4, 28), date(2031, 4, 13), date(2032, 5,  2), date(2033, 4, 24),\n    date(2034, 4,  9), date(2035, 4, 29), date(2036, 4, 20), date(2037, 4,  5),\n    date(2038, 4, 25), date(2039, 4, 17),\n\n    date(2040, 5,  6), date(2041, 4, 21), date(2042, 4, 13), date(2043, 5,  3),\n    date(2044, 4, 24), date(2045, 4,  9), date(2046, 4, 29), date(2047, 4, 21),\n    date(2048, 4,  5), date(2049, 4, 25), date(2050, 4, 17)\n]\n\n# A random smattering of Julian dates.\n# Pulled values from http://www.kevinlaughery.com/east4099.html\njulian_easter_dates = [\n    date( 326, 4,  3), date( 375, 4,  5), date( 492, 4,  5), date( 552, 3, 31),\n    date( 562, 4,  9), date( 569, 4, 21), date( 597, 4, 14), date( 621, 4, 19),\n    date( 636, 3, 31), date( 655, 3, 29), date( 700, 4, 11), date( 725, 4,  8),\n    date( 750, 3, 29), date( 782, 4,  7), date( 835, 4, 18), date( 849, 4, 14),\n    date( 867, 3, 30), date( 890, 4, 12), date( 922, 4, 21), date( 934, 4,  6),\n    date(1049, 3, 26), date(1058, 4, 19), date(1113, 4,  6), date(1119, 3, 30),\n    date(1242, 4, 20), date(1255, 3, 28), date(1257, 4,  8), date(1258, 3, 24),\n    date(1261, 4, 24), date(1278, 4, 17), date(1333, 4,  4), date(1351, 4, 17),\n    date(1371, 4,  6), date(1391, 3, 26), date(1402, 3, 26), date(1412, 4,  3),\n    date(1439, 4,  5), date(1445, 3, 28), date(1531, 4,  9), date(1555, 4, 14)\n]\n\n\n@pytest.mark.parametrize(\"easter_date\", western_easter_dates)\ndef test_easter_western(easter_date):\n    assert easter_date == easter(easter_date.year, EASTER_WESTERN)\n\n\n@pytest.mark.parametrize(\"easter_date\", orthodox_easter_dates)\ndef test_easter_orthodox(easter_date):\n    assert easter_date == easter(easter_date.year, EASTER_ORTHODOX)\n\n\n@pytest.mark.parametrize(\"easter_date\", julian_easter_dates)\ndef test_easter_julian(easter_date):\n    assert easter_date == easter(easter_date.year, EASTER_JULIAN)\n\n\ndef test_easter_bad_method():\n    with pytest.raises(ValueError):\n        easter(1975, 4)\n", "tests/test_parser.py": "# -*- coding: utf-8 -*-\nfrom __future__ import unicode_literals\n\nimport itertools\nfrom datetime import datetime, timedelta\nimport unittest\nimport sys\n\nfrom dateutil import tz\nfrom dateutil.tz import tzoffset\nfrom dateutil.parser import parse, parserinfo\nfrom dateutil.parser import ParserError\nfrom dateutil.parser import UnknownTimezoneWarning\n\nfrom ._common import TZEnvContext\n\nfrom six import assertRaisesRegex, PY2\nfrom io import StringIO\n\nimport pytest\n\n# Platform info\nIS_WIN = sys.platform.startswith('win')\n\nPLATFORM_HAS_DASH_D = False\ntry:\n    if datetime.now().strftime('%-d'):\n        PLATFORM_HAS_DASH_D = True\nexcept ValueError:\n    pass\n\n\n@pytest.fixture(params=[True, False])\ndef fuzzy(request):\n    \"\"\"Fixture to pass fuzzy=True or fuzzy=False to parse\"\"\"\n    return request.param\n\n\n# Parser test cases using no keyword arguments. Format: (parsable_text, expected_datetime, assertion_message)\nPARSER_TEST_CASES = [\n    (\"Thu Sep 25 10:36:28 2003\", datetime(2003, 9, 25, 10, 36, 28), \"date command format strip\"),\n    (\"Thu Sep 25 2003\", datetime(2003, 9, 25), \"date command format strip\"),\n    (\"2003-09-25T10:49:41\", datetime(2003, 9, 25, 10, 49, 41), \"iso format strip\"),\n    (\"2003-09-25T10:49\", datetime(2003, 9, 25, 10, 49), \"iso format strip\"),\n    (\"2003-09-25T10\", datetime(2003, 9, 25, 10), \"iso format strip\"),\n    (\"2003-09-25\", datetime(2003, 9, 25), \"iso format strip\"),\n    (\"20030925T104941\", datetime(2003, 9, 25, 10, 49, 41), \"iso stripped format strip\"),\n    (\"20030925T1049\", datetime(2003, 9, 25, 10, 49, 0), \"iso stripped format strip\"),\n    (\"20030925T10\", datetime(2003, 9, 25, 10), \"iso stripped format strip\"),\n    (\"20030925\", datetime(2003, 9, 25), \"iso stripped format strip\"),\n    (\"2003-09-25 10:49:41,502\", datetime(2003, 9, 25, 10, 49, 41, 502000), \"python logger format\"),\n    (\"199709020908\", datetime(1997, 9, 2, 9, 8), \"no separator\"),\n    (\"19970902090807\", datetime(1997, 9, 2, 9, 8, 7), \"no separator\"),\n    (\"09-25-2003\", datetime(2003, 9, 25), \"date with dash\"),\n    (\"25-09-2003\", datetime(2003, 9, 25), \"date with dash\"),\n    (\"10-09-2003\", datetime(2003, 10, 9), \"date with dash\"),\n    (\"10-09-03\", datetime(2003, 10, 9), \"date with dash\"),\n    (\"2003.09.25\", datetime(2003, 9, 25), \"date with dot\"),\n    (\"09.25.2003\", datetime(2003, 9, 25), \"date with dot\"),\n    (\"25.09.2003\", datetime(2003, 9, 25), \"date with dot\"),\n    (\"10.09.2003\", datetime(2003, 10, 9), \"date with dot\"),\n    (\"10.09.03\", datetime(2003, 10, 9), \"date with dot\"),\n    (\"2003/09/25\", datetime(2003, 9, 25), \"date with slash\"),\n    (\"09/25/2003\", datetime(2003, 9, 25), \"date with slash\"),\n    (\"25/09/2003\", datetime(2003, 9, 25), \"date with slash\"),\n    (\"10/09/2003\", datetime(2003, 10, 9), \"date with slash\"),\n    (\"10/09/03\", datetime(2003, 10, 9), \"date with slash\"),\n    (\"2003 09 25\", datetime(2003, 9, 25), \"date with space\"),\n    (\"09 25 2003\", datetime(2003, 9, 25), \"date with space\"),\n    (\"25 09 2003\", datetime(2003, 9, 25), \"date with space\"),\n    (\"10 09 2003\", datetime(2003, 10, 9), \"date with space\"),\n    (\"10 09 03\", datetime(2003, 10, 9), \"date with space\"),\n    (\"25 09 03\", datetime(2003, 9, 25), \"date with space\"),\n    (\"03 25 Sep\", datetime(2003, 9, 25), \"strangely ordered date\"),\n    (\"25 03 Sep\", datetime(2025, 9, 3), \"strangely ordered date\"),\n    (\"  July   4 ,  1976   12:01:02   am  \", datetime(1976, 7, 4, 0, 1, 2), \"extra space\"),\n    (\"Wed, July 10, '96\", datetime(1996, 7, 10, 0, 0), \"random format\"),\n    (\"1996.July.10 AD 12:08 PM\", datetime(1996, 7, 10, 12, 8), \"random format\"),\n    (\"July 4, 1976\", datetime(1976, 7, 4), \"random format\"),\n    (\"7 4 1976\", datetime(1976, 7, 4), \"random format\"),\n    (\"4 jul 1976\", datetime(1976, 7, 4), \"random format\"),\n    (\"4 Jul 1976\", datetime(1976, 7, 4), \"'%-d %b %Y' format\"),\n    (\"7-4-76\", datetime(1976, 7, 4), \"random format\"),\n    (\"19760704\", datetime(1976, 7, 4), \"random format\"),\n    (\"0:01:02 on July 4, 1976\", datetime(1976, 7, 4, 0, 1, 2), \"random format\"),\n    (\"July 4, 1976 12:01:02 am\", datetime(1976, 7, 4, 0, 1, 2), \"random format\"),\n    (\"Mon Jan  2 04:24:27 1995\", datetime(1995, 1, 2, 4, 24, 27), \"random format\"),\n    (\"04.04.95 00:22\", datetime(1995, 4, 4, 0, 22), \"random format\"),\n    (\"Jan 1 1999 11:23:34.578\", datetime(1999, 1, 1, 11, 23, 34, 578000), \"random format\"),\n    (\"950404 122212\", datetime(1995, 4, 4, 12, 22, 12), \"random format\"),\n    (\"3rd of May 2001\", datetime(2001, 5, 3), \"random format\"),\n    (\"5th of March 2001\", datetime(2001, 3, 5), \"random format\"),\n    (\"1st of May 2003\", datetime(2003, 5, 1), \"random format\"),\n    ('0099-01-01T00:00:00', datetime(99, 1, 1, 0, 0), \"99 ad\"),\n    ('0031-01-01T00:00:00', datetime(31, 1, 1, 0, 0), \"31 ad\"),\n    (\"20080227T21:26:01.123456789\", datetime(2008, 2, 27, 21, 26, 1, 123456), \"high precision seconds\"),\n    ('13NOV2017', datetime(2017, 11, 13), \"dBY (See GH360)\"),\n    ('0003-03-04', datetime(3, 3, 4), \"pre 12 year same month (See GH PR #293)\"),\n    ('December.0031.30', datetime(31, 12, 30), \"BYd corner case (GH#687)\"),\n\n    # Cases with legacy h/m/s format, candidates for deprecation (GH#886)\n    (\"2016-12-21 04.2h\", datetime(2016, 12, 21, 4, 12), \"Fractional Hours\"),\n]\n# Check that we don't have any duplicates\nassert len(set([x[0] for x in PARSER_TEST_CASES])) == len(PARSER_TEST_CASES)\n\n\n@pytest.mark.parametrize(\"parsable_text,expected_datetime,assertion_message\", PARSER_TEST_CASES)\ndef test_parser(parsable_text, expected_datetime, assertion_message):\n    assert parse(parsable_text) == expected_datetime, assertion_message\n\n\n# Parser test cases using datetime(2003, 9, 25) as a default.\n# Format: (parsable_text, expected_datetime, assertion_message)\nPARSER_DEFAULT_TEST_CASES = [\n    (\"Thu Sep 25 10:36:28\", datetime(2003, 9, 25, 10, 36, 28), \"date command format strip\"),\n    (\"Thu Sep 10:36:28\", datetime(2003, 9, 25, 10, 36, 28), \"date command format strip\"),\n    (\"Thu 10:36:28\", datetime(2003, 9, 25, 10, 36, 28), \"date command format strip\"),\n    (\"Sep 10:36:28\", datetime(2003, 9, 25, 10, 36, 28), \"date command format strip\"),\n    (\"10:36:28\", datetime(2003, 9, 25, 10, 36, 28), \"date command format strip\"),\n    (\"10:36\", datetime(2003, 9, 25, 10, 36), \"date command format strip\"),\n    (\"Sep 2003\", datetime(2003, 9, 25), \"date command format strip\"),\n    (\"Sep\", datetime(2003, 9, 25), \"date command format strip\"),\n    (\"2003\", datetime(2003, 9, 25), \"date command format strip\"),\n    (\"10h36m28.5s\", datetime(2003, 9, 25, 10, 36, 28, 500000), \"hour with letters\"),\n    (\"10h36m28s\", datetime(2003, 9, 25, 10, 36, 28), \"hour with letters strip\"),\n    (\"10h36m\", datetime(2003, 9, 25, 10, 36), \"hour with letters strip\"),\n    (\"10h\", datetime(2003, 9, 25, 10), \"hour with letters strip\"),\n    (\"10 h 36\", datetime(2003, 9, 25, 10, 36), \"hour with letters strip\"),\n    (\"10 h 36.5\", datetime(2003, 9, 25, 10, 36, 30), \"hour with letter strip\"),\n    (\"36 m 5\", datetime(2003, 9, 25, 0, 36, 5), \"hour with letters spaces\"),\n    (\"36 m 5 s\", datetime(2003, 9, 25, 0, 36, 5), \"minute with letters spaces\"),\n    (\"36 m 05\", datetime(2003, 9, 25, 0, 36, 5), \"minute with letters spaces\"),\n    (\"36 m 05 s\", datetime(2003, 9, 25, 0, 36, 5), \"minutes with letters spaces\"),\n    (\"10h am\", datetime(2003, 9, 25, 10), \"hour am pm\"),\n    (\"10h pm\", datetime(2003, 9, 25, 22), \"hour am pm\"),\n    (\"10am\", datetime(2003, 9, 25, 10), \"hour am pm\"),\n    (\"10pm\", datetime(2003, 9, 25, 22), \"hour am pm\"),\n    (\"10:00 am\", datetime(2003, 9, 25, 10), \"hour am pm\"),\n    (\"10:00 pm\", datetime(2003, 9, 25, 22), \"hour am pm\"),\n    (\"10:00am\", datetime(2003, 9, 25, 10), \"hour am pm\"),\n    (\"10:00pm\", datetime(2003, 9, 25, 22), \"hour am pm\"),\n    (\"10:00a.m\", datetime(2003, 9, 25, 10), \"hour am pm\"),\n    (\"10:00p.m\", datetime(2003, 9, 25, 22), \"hour am pm\"),\n    (\"10:00a.m.\", datetime(2003, 9, 25, 10), \"hour am pm\"),\n    (\"10:00p.m.\", datetime(2003, 9, 25, 22), \"hour am pm\"),\n    (\"Wed\", datetime(2003, 10, 1), \"weekday alone\"),\n    (\"Wednesday\", datetime(2003, 10, 1), \"long weekday\"),\n    (\"October\", datetime(2003, 10, 25), \"long month\"),\n    (\"31-Dec-00\", datetime(2000, 12, 31), \"zero year\"),\n    (\"0:01:02\", datetime(2003, 9, 25, 0, 1, 2), \"random format\"),\n    (\"12h 01m02s am\", datetime(2003, 9, 25, 0, 1, 2), \"random format\"),\n    (\"12:08 PM\", datetime(2003, 9, 25, 12, 8), \"random format\"),\n    (\"01h02m03\", datetime(2003, 9, 25, 1, 2, 3), \"random format\"),\n    (\"01h02\", datetime(2003, 9, 25, 1, 2), \"random format\"),\n    (\"01h02s\", datetime(2003, 9, 25, 1, 0, 2), \"random format\"),\n    (\"01m02\", datetime(2003, 9, 25, 0, 1, 2), \"random format\"),\n    (\"01m02h\", datetime(2003, 9, 25, 2, 1), \"random format\"),\n    (\"2004 10 Apr 11h30m\", datetime(2004, 4, 10, 11, 30), \"random format\")\n]\n# Check that we don't have any duplicates\nassert len(set([x[0] for x in PARSER_DEFAULT_TEST_CASES])) == len(PARSER_DEFAULT_TEST_CASES)\n\n\n@pytest.mark.parametrize(\"parsable_text,expected_datetime,assertion_message\", PARSER_DEFAULT_TEST_CASES)\ndef test_parser_default(parsable_text, expected_datetime, assertion_message):\n    assert parse(parsable_text, default=datetime(2003, 9, 25)) == expected_datetime, assertion_message\n\n\n@pytest.mark.parametrize('sep', ['-', '.', '/', ' '])\ndef test_parse_dayfirst(sep):\n    expected = datetime(2003, 9, 10)\n    fmt = sep.join(['%d', '%m', '%Y'])\n    dstr = expected.strftime(fmt)\n    result = parse(dstr, dayfirst=True)\n    assert result == expected\n\n\n@pytest.mark.parametrize('sep', ['-', '.', '/', ' '])\ndef test_parse_yearfirst(sep):\n    expected = datetime(2010, 9, 3)\n    fmt = sep.join(['%Y', '%m', '%d'])\n    dstr = expected.strftime(fmt)\n    result = parse(dstr, yearfirst=True)\n    assert result == expected\n\n\n@pytest.mark.parametrize('dstr,expected', [\n    (\"Thu Sep 25 10:36:28 BRST 2003\", datetime(2003, 9, 25, 10, 36, 28)),\n    (\"1996.07.10 AD at 15:08:56 PDT\", datetime(1996, 7, 10, 15, 8, 56)),\n    (\"Tuesday, April 12, 1952 AD 3:30:42pm PST\",\n     datetime(1952, 4, 12, 15, 30, 42)),\n    (\"November 5, 1994, 8:15:30 am EST\", datetime(1994, 11, 5, 8, 15, 30)),\n    (\"1994-11-05T08:15:30-05:00\", datetime(1994, 11, 5, 8, 15, 30)),\n    (\"1994-11-05T08:15:30Z\", datetime(1994, 11, 5, 8, 15, 30)),\n    (\"1976-07-04T00:01:02Z\", datetime(1976, 7, 4, 0, 1, 2)),\n    (\"1986-07-05T08:15:30z\", datetime(1986, 7, 5, 8, 15, 30)),\n    (\"Tue Apr 4 00:22:12 PDT 1995\", datetime(1995, 4, 4, 0, 22, 12)),\n])\ndef test_parse_ignoretz(dstr, expected):\n    result = parse(dstr, ignoretz=True)\n    assert result == expected\n\n\n_brsttz = tzoffset(\"BRST\", -10800)\n\n\n@pytest.mark.parametrize('dstr,expected', [\n    (\"20030925T104941-0300\",\n     datetime(2003, 9, 25, 10, 49, 41, tzinfo=_brsttz)),\n    (\"Thu, 25 Sep 2003 10:49:41 -0300\",\n     datetime(2003, 9, 25, 10, 49, 41, tzinfo=_brsttz)),\n    (\"2003-09-25T10:49:41.5-03:00\",\n     datetime(2003, 9, 25, 10, 49, 41, 500000, tzinfo=_brsttz)),\n    (\"2003-09-25T10:49:41-03:00\",\n     datetime(2003, 9, 25, 10, 49, 41, tzinfo=_brsttz)),\n    (\"20030925T104941.5-0300\",\n     datetime(2003, 9, 25, 10, 49, 41, 500000, tzinfo=_brsttz)),\n])\ndef test_parse_with_tzoffset(dstr, expected):\n    # In these cases, we are _not_ passing a tzinfos arg\n    result = parse(dstr)\n    assert result == expected\n\n\nclass TestFormat(object):\n\n    def test_ybd(self):\n        # If we have a 4-digit year, a non-numeric month (abbreviated or not),\n        # and a day (1 or 2 digits), then there is no ambiguity as to which\n        # token is a year/month/day.  This holds regardless of what order the\n        # terms are in and for each of the separators below.\n\n        seps = ['-', ' ', '/', '.']\n\n        year_tokens = ['%Y']\n        month_tokens = ['%b', '%B']\n        day_tokens = ['%d']\n        if PLATFORM_HAS_DASH_D:\n            day_tokens.append('%-d')\n\n        prods = itertools.product(year_tokens, month_tokens, day_tokens)\n        perms = [y for x in prods for y in itertools.permutations(x)]\n        unambig_fmts = [sep.join(perm) for sep in seps for perm in perms]\n\n        actual = datetime(2003, 9, 25)\n\n        for fmt in unambig_fmts:\n            dstr = actual.strftime(fmt)\n            res = parse(dstr)\n            assert res == actual\n\n    # TODO: some redundancy with PARSER_TEST_CASES cases\n    @pytest.mark.parametrize(\"fmt,dstr\", [\n        (\"%a %b %d %Y\", \"Thu Sep 25 2003\"),\n        (\"%b %d %Y\", \"Sep 25 2003\"),\n        (\"%Y-%m-%d\", \"2003-09-25\"),\n        (\"%Y%m%d\", \"20030925\"),\n        (\"%Y-%b-%d\", \"2003-Sep-25\"),\n        (\"%d-%b-%Y\", \"25-Sep-2003\"),\n        (\"%b-%d-%Y\", \"Sep-25-2003\"),\n        (\"%m-%d-%Y\", \"09-25-2003\"),\n        (\"%d-%m-%Y\", \"25-09-2003\"),\n        (\"%Y.%m.%d\", \"2003.09.25\"),\n        (\"%Y.%b.%d\", \"2003.Sep.25\"),\n        (\"%d.%b.%Y\", \"25.Sep.2003\"),\n        (\"%b.%d.%Y\", \"Sep.25.2003\"),\n        (\"%m.%d.%Y\", \"09.25.2003\"),\n        (\"%d.%m.%Y\", \"25.09.2003\"),\n        (\"%Y/%m/%d\", \"2003/09/25\"),\n        (\"%Y/%b/%d\", \"2003/Sep/25\"),\n        (\"%d/%b/%Y\", \"25/Sep/2003\"),\n        (\"%b/%d/%Y\", \"Sep/25/2003\"),\n        (\"%m/%d/%Y\", \"09/25/2003\"),\n        (\"%d/%m/%Y\", \"25/09/2003\"),\n        (\"%Y %m %d\", \"2003 09 25\"),\n        (\"%Y %b %d\", \"2003 Sep 25\"),\n        (\"%d %b %Y\", \"25 Sep 2003\"),\n        (\"%m %d %Y\", \"09 25 2003\"),\n        (\"%d %m %Y\", \"25 09 2003\"),\n        (\"%y %d %b\", \"03 25 Sep\",),\n    ])\n    def test_strftime_formats_2003Sep25(self, fmt, dstr):\n        expected = datetime(2003, 9, 25)\n\n        # First check that the format strings behave as expected\n        #  (not strictly necessary, but nice to have)\n        assert expected.strftime(fmt) == dstr\n\n        res = parse(dstr)\n        assert res == expected\n\n\nclass TestInputTypes(object):\n    def test_empty_string_invalid(self):\n        with pytest.raises(ParserError):\n            parse('')\n\n    def test_none_invalid(self):\n        with pytest.raises(TypeError):\n            parse(None)\n\n    def test_int_invalid(self):\n        with pytest.raises(TypeError):\n            parse(13)\n\n    def test_duck_typing(self):\n        # We want to support arbitrary classes that implement the stream\n        # interface.\n\n        class StringPassThrough(object):\n            def __init__(self, stream):\n                self.stream = stream\n\n            def read(self, *args, **kwargs):\n                return self.stream.read(*args, **kwargs)\n\n        dstr = StringPassThrough(StringIO('2014 January 19'))\n\n        res = parse(dstr)\n        expected = datetime(2014, 1, 19)\n        assert res == expected\n\n    def test_parse_stream(self):\n        dstr = StringIO('2014 January 19')\n\n        res = parse(dstr)\n        expected = datetime(2014, 1, 19)\n        assert res == expected\n\n    def test_parse_str(self):\n        # Parser should be able to handle bytestring and unicode\n        uni_str = '2014-05-01 08:00:00'\n        bytes_str = uni_str.encode()\n\n        res = parse(bytes_str)\n        expected = parse(uni_str)\n        assert res == expected\n\n    def test_parse_bytes(self):\n        res = parse(b'2014 January 19')\n        expected = datetime(2014, 1, 19)\n        assert res == expected\n\n    def test_parse_bytearray(self):\n        # GH#417\n        res = parse(bytearray(b'2014 January 19'))\n        expected = datetime(2014, 1, 19)\n        assert res == expected\n\n\nclass TestTzinfoInputTypes(object):\n    def assert_equal_same_tz(self, dt1, dt2):\n        assert dt1 == dt2\n        assert dt1.tzinfo is dt2.tzinfo\n\n    def test_tzinfo_dict_could_return_none(self):\n        dstr = \"2017-02-03 12:40 BRST\"\n        result = parse(dstr, tzinfos={\"BRST\": None})\n        expected = datetime(2017, 2, 3, 12, 40)\n        self.assert_equal_same_tz(result, expected)\n\n    def test_tzinfos_callable_could_return_none(self):\n        dstr = \"2017-02-03 12:40 BRST\"\n        result = parse(dstr, tzinfos=lambda *args: None)\n        expected = datetime(2017, 2, 3, 12, 40)\n        self.assert_equal_same_tz(result, expected)\n\n    def test_invalid_tzinfo_input(self):\n        dstr = \"2014 January 19 09:00 UTC\"\n        # Pass an absurd tzinfos object\n        tzinfos = {\"UTC\": ValueError}\n        with pytest.raises(TypeError):\n            parse(dstr, tzinfos=tzinfos)\n\n    def test_valid_tzinfo_tzinfo_input(self):\n        dstr = \"2014 January 19 09:00 UTC\"\n        tzinfos = {\"UTC\": tz.UTC}\n        expected = datetime(2014, 1, 19, 9, tzinfo=tz.UTC)\n        res = parse(dstr, tzinfos=tzinfos)\n        self.assert_equal_same_tz(res, expected)\n\n    def test_valid_tzinfo_unicode_input(self):\n        dstr = \"2014 January 19 09:00 UTC\"\n        tzinfos = {u\"UTC\": u\"UTC+0\"}\n        expected = datetime(2014, 1, 19, 9, tzinfo=tz.tzstr(\"UTC+0\"))\n        res = parse(dstr, tzinfos=tzinfos)\n        self.assert_equal_same_tz(res, expected)\n\n    def test_valid_tzinfo_callable_input(self):\n        dstr = \"2014 January 19 09:00 UTC\"\n\n        def tzinfos(*args, **kwargs):\n            return u\"UTC+0\"\n\n        expected = datetime(2014, 1, 19, 9, tzinfo=tz.tzstr(\"UTC+0\"))\n        res = parse(dstr, tzinfos=tzinfos)\n        self.assert_equal_same_tz(res, expected)\n\n    def test_valid_tzinfo_int_input(self):\n        dstr = \"2014 January 19 09:00 UTC\"\n        tzinfos = {u\"UTC\": -28800}\n        expected = datetime(2014, 1, 19, 9, tzinfo=tz.tzoffset(u\"UTC\", -28800))\n        res = parse(dstr, tzinfos=tzinfos)\n        self.assert_equal_same_tz(res, expected)\n\n\nclass ParserTest(unittest.TestCase):\n\n    @classmethod\n    def setup_class(cls):\n        cls.tzinfos = {\"BRST\": -10800}\n        cls.brsttz = tzoffset(\"BRST\", -10800)\n        cls.default = datetime(2003, 9, 25)\n\n        # Parser should be able to handle bytestring and unicode\n        cls.uni_str = '2014-05-01 08:00:00'\n        cls.str_str = cls.uni_str.encode()\n\n    def testParserParseStr(self):\n        from dateutil.parser import parser\n\n        assert parser().parse(self.str_str) == parser().parse(self.uni_str)\n\n    def testParseUnicodeWords(self):\n\n        class rus_parserinfo(parserinfo):\n            MONTHS = [(\"\u044f\u043d\u0432\", \"\u042f\u043d\u0432\u0430\u0440\u044c\"),\n                      (\"\u0444\u0435\u0432\", \"\u0424\u0435\u0432\u0440\u0430\u043b\u044c\"),\n                      (\"\u043c\u0430\u0440\", \"\u041c\u0430\u0440\u0442\"),\n                      (\"\u0430\u043f\u0440\", \"\u0410\u043f\u0440\u0435\u043b\u044c\"),\n                      (\"\u043c\u0430\u0439\", \"\u041c\u0430\u0439\"),\n                      (\"\u0438\u044e\u043d\", \"\u0418\u044e\u043d\u044c\"),\n                      (\"\u0438\u044e\u043b\", \"\u0418\u044e\u043b\u044c\"),\n                      (\"\u0430\u0432\u0433\", \"\u0410\u0432\u0433\u0443\u0441\u0442\"),\n                      (\"\u0441\u0435\u043d\", \"\u0421\u0435\u043d\u0442\u044f\u0431\u0440\u044c\"),\n                      (\"\u043e\u043a\u0442\", \"\u041e\u043a\u0442\u044f\u0431\u0440\u044c\"),\n                      (\"\u043d\u043e\u044f\", \"\u041d\u043e\u044f\u0431\u0440\u044c\"),\n                      (\"\u0434\u0435\u043a\", \"\u0414\u0435\u043a\u0430\u0431\u0440\u044c\")]\n\n        expected = datetime(2015, 9, 10, 10, 20)\n        res = parse('10 \u0421\u0435\u043d\u0442\u044f\u0431\u0440\u044c 2015 10:20', parserinfo=rus_parserinfo())\n        assert res  == expected\n\n    def testParseWithNulls(self):\n        # This relies on the from __future__ import unicode_literals, because\n        # explicitly specifying a unicode literal is a syntax error in Py 3.2\n        # May want to switch to u'...' if we ever drop Python 3.2 support.\n        pstring = '\\x00\\x00August 29, 1924'\n\n        assert parse(pstring) == datetime(1924, 8, 29)\n\n    def testDateCommandFormat(self):\n        self.assertEqual(parse(\"Thu Sep 25 10:36:28 BRST 2003\",\n                               tzinfos=self.tzinfos),\n                         datetime(2003, 9, 25, 10, 36, 28,\n                                  tzinfo=self.brsttz))\n\n    def testDateCommandFormatReversed(self):\n        self.assertEqual(parse(\"2003 10:36:28 BRST 25 Sep Thu\",\n                               tzinfos=self.tzinfos),\n                         datetime(2003, 9, 25, 10, 36, 28,\n                                  tzinfo=self.brsttz))\n\n    def testDateCommandFormatWithLong(self):\n        if PY2:\n            self.assertEqual(parse(\"Thu Sep 25 10:36:28 BRST 2003\",\n                                   tzinfos={\"BRST\": long(-10800)}),\n                             datetime(2003, 9, 25, 10, 36, 28,\n                                      tzinfo=self.brsttz))\n\n    def testISOFormatStrip2(self):\n        self.assertEqual(parse(\"2003-09-25T10:49:41+03:00\"),\n                         datetime(2003, 9, 25, 10, 49, 41,\n                                  tzinfo=tzoffset(None, 10800)))\n\n    def testISOStrippedFormatStrip2(self):\n        self.assertEqual(parse(\"20030925T104941+0300\"),\n                         datetime(2003, 9, 25, 10, 49, 41,\n                                  tzinfo=tzoffset(None, 10800)))\n\n    def testAMPMNoHour(self):\n        with pytest.raises(ParserError):\n            parse(\"AM\")\n\n        with pytest.raises(ParserError):\n            parse(\"Jan 20, 2015 PM\")\n\n    def testAMPMRange(self):\n        with pytest.raises(ParserError):\n            parse(\"13:44 AM\")\n\n        with pytest.raises(ParserError):\n            parse(\"January 25, 1921 23:13 PM\")\n\n    def testPertain(self):\n        self.assertEqual(parse(\"Sep 03\", default=self.default),\n                         datetime(2003, 9, 3))\n        self.assertEqual(parse(\"Sep of 03\", default=self.default),\n                         datetime(2003, 9, 25))\n\n    def testFuzzy(self):\n        s = \"Today is 25 of September of 2003, exactly \" \\\n            \"at 10:49:41 with timezone -03:00.\"\n        self.assertEqual(parse(s, fuzzy=True),\n                         datetime(2003, 9, 25, 10, 49, 41,\n                                  tzinfo=self.brsttz))\n\n    def testFuzzyWithTokens(self):\n        s1 = \"Today is 25 of September of 2003, exactly \" \\\n            \"at 10:49:41 with timezone -03:00.\"\n        self.assertEqual(parse(s1, fuzzy_with_tokens=True),\n                         (datetime(2003, 9, 25, 10, 49, 41,\n                                   tzinfo=self.brsttz),\n                         ('Today is ', 'of ', ', exactly at ',\n                          ' with timezone ', '.')))\n\n        s2 = \"http://biz.yahoo.com/ipo/p/600221.html\"\n        self.assertEqual(parse(s2, fuzzy_with_tokens=True),\n                         (datetime(2060, 2, 21, 0, 0, 0),\n                         ('http://biz.yahoo.com/ipo/p/', '.html')))\n\n    def testFuzzyAMPMProblem(self):\n        # Sometimes fuzzy parsing results in AM/PM flag being set without\n        # hours - if it's fuzzy it should ignore that.\n        s1 = \"I have a meeting on March 1, 1974.\"\n        s2 = \"On June 8th, 2020, I am going to be the first man on Mars\"\n\n        # Also don't want any erroneous AM or PMs changing the parsed time\n        s3 = \"Meet me at the AM/PM on Sunset at 3:00 AM on December 3rd, 2003\"\n        s4 = \"Meet me at 3:00AM on December 3rd, 2003 at the AM/PM on Sunset\"\n\n        self.assertEqual(parse(s1, fuzzy=True), datetime(1974, 3, 1))\n        self.assertEqual(parse(s2, fuzzy=True), datetime(2020, 6, 8))\n        self.assertEqual(parse(s3, fuzzy=True), datetime(2003, 12, 3, 3))\n        self.assertEqual(parse(s4, fuzzy=True), datetime(2003, 12, 3, 3))\n\n    def testFuzzyIgnoreAMPM(self):\n        s1 = \"Jan 29, 1945 14:45 AM I going to see you there?\"\n        with pytest.warns(UnknownTimezoneWarning):\n            res = parse(s1, fuzzy=True)\n        self.assertEqual(res, datetime(1945, 1, 29, 14, 45))\n\n    def testRandomFormat24(self):\n        self.assertEqual(parse(\"0:00 PM, PST\", default=self.default,\n                               ignoretz=True),\n                         datetime(2003, 9, 25, 12, 0))\n\n    def testRandomFormat26(self):\n        with pytest.warns(UnknownTimezoneWarning):\n            res = parse(\"5:50 A.M. on June 13, 1990\")\n\n        self.assertEqual(res, datetime(1990, 6, 13, 5, 50))\n\n    def testUnspecifiedDayFallback(self):\n        # Test that for an unspecified day, the fallback behavior is correct.\n        self.assertEqual(parse(\"April 2009\", default=datetime(2010, 1, 31)),\n                         datetime(2009, 4, 30))\n\n    def testUnspecifiedDayFallbackFebNoLeapYear(self):\n        self.assertEqual(parse(\"Feb 2007\", default=datetime(2010, 1, 31)),\n                         datetime(2007, 2, 28))\n\n    def testUnspecifiedDayFallbackFebLeapYear(self):\n        self.assertEqual(parse(\"Feb 2008\", default=datetime(2010, 1, 31)),\n                         datetime(2008, 2, 29))\n\n    def testErrorType01(self):\n        with pytest.raises(ParserError):\n            parse('shouldfail')\n\n    def testCorrectErrorOnFuzzyWithTokens(self):\n        assertRaisesRegex(self, ParserError, 'Unknown string format',\n                          parse, '04/04/32/423', fuzzy_with_tokens=True)\n        assertRaisesRegex(self, ParserError, 'Unknown string format',\n                          parse, '04/04/04 +32423', fuzzy_with_tokens=True)\n        assertRaisesRegex(self, ParserError, 'Unknown string format',\n                          parse, '04/04/0d4', fuzzy_with_tokens=True)\n\n    def testIncreasingCTime(self):\n        # This test will check 200 different years, every month, every day,\n        # every hour, every minute, every second, and every weekday, using\n        # a delta of more or less 1 year, 1 month, 1 day, 1 minute and\n        # 1 second.\n        delta = timedelta(days=365+31+1, seconds=1+60+60*60)\n        dt = datetime(1900, 1, 1, 0, 0, 0, 0)\n        for i in range(200):\n            assert parse(dt.ctime()) == dt\n            dt += delta\n\n    def testIncreasingISOFormat(self):\n        delta = timedelta(days=365+31+1, seconds=1+60+60*60)\n        dt = datetime(1900, 1, 1, 0, 0, 0, 0)\n        for i in range(200):\n            assert parse(dt.isoformat()) == dt\n            dt += delta\n\n    def testMicrosecondsPrecisionError(self):\n        # Skip found out that sad precision problem. :-(\n        dt1 = parse(\"00:11:25.01\")\n        dt2 = parse(\"00:12:10.01\")\n        assert dt1.microsecond == 10000\n        assert dt2.microsecond == 10000\n\n    def testMicrosecondPrecisionErrorReturns(self):\n        # One more precision issue, discovered by Eric Brown.  This should\n        # be the last one, as we're no longer using floating points.\n        for ms in [100001, 100000, 99999, 99998,\n                    10001,  10000,  9999,  9998,\n                     1001,   1000,   999,   998,\n                      101,    100,    99,    98]:\n            dt = datetime(2008, 2, 27, 21, 26, 1, ms)\n            assert parse(dt.isoformat()) == dt\n\n    def testCustomParserInfo(self):\n        # Custom parser info wasn't working, as Michael Elsd\u00f6rfer discovered.\n        from dateutil.parser import parserinfo, parser\n\n        class myparserinfo(parserinfo):\n            MONTHS = parserinfo.MONTHS[:]\n            MONTHS[0] = (\"Foo\", \"Foo\")\n        myparser = parser(myparserinfo())\n        dt = myparser.parse(\"01/Foo/2007\")\n        assert dt == datetime(2007, 1, 1)\n\n    def testCustomParserShortDaynames(self):\n        # Horacio Hoyos discovered that day names shorter than 3 characters,\n        # for example two letter German day name abbreviations, don't work:\n        # https://github.com/dateutil/dateutil/issues/343\n        from dateutil.parser import parserinfo, parser\n\n        class GermanParserInfo(parserinfo):\n            WEEKDAYS = [(\"Mo\", \"Montag\"),\n                        (\"Di\", \"Dienstag\"),\n                        (\"Mi\", \"Mittwoch\"),\n                        (\"Do\", \"Donnerstag\"),\n                        (\"Fr\", \"Freitag\"),\n                        (\"Sa\", \"Samstag\"),\n                        (\"So\", \"Sonntag\")]\n\n        myparser = parser(GermanParserInfo())\n        dt = myparser.parse(\"Sa 21. Jan 2017\")\n        self.assertEqual(dt, datetime(2017, 1, 21))\n\n    def testNoYearFirstNoDayFirst(self):\n        dtstr = '090107'\n\n        # Should be MMDDYY\n        self.assertEqual(parse(dtstr),\n                         datetime(2007, 9, 1))\n\n        self.assertEqual(parse(dtstr, yearfirst=False, dayfirst=False),\n                         datetime(2007, 9, 1))\n\n    def testYearFirst(self):\n        dtstr = '090107'\n\n        # Should be MMDDYY\n        self.assertEqual(parse(dtstr, yearfirst=True),\n                         datetime(2009, 1, 7))\n\n        self.assertEqual(parse(dtstr, yearfirst=True, dayfirst=False),\n                         datetime(2009, 1, 7))\n\n    def testDayFirst(self):\n        dtstr = '090107'\n\n        # Should be DDMMYY\n        self.assertEqual(parse(dtstr, dayfirst=True),\n                         datetime(2007, 1, 9))\n\n        self.assertEqual(parse(dtstr, yearfirst=False, dayfirst=True),\n                         datetime(2007, 1, 9))\n\n    def testDayFirstYearFirst(self):\n        dtstr = '090107'\n        # Should be YYDDMM\n        self.assertEqual(parse(dtstr, yearfirst=True, dayfirst=True),\n                         datetime(2009, 7, 1))\n\n    def testUnambiguousYearFirst(self):\n        dtstr = '2015 09 25'\n        self.assertEqual(parse(dtstr, yearfirst=True),\n                         datetime(2015, 9, 25))\n\n    def testUnambiguousDayFirst(self):\n        dtstr = '2015 09 25'\n        self.assertEqual(parse(dtstr, dayfirst=True),\n                         datetime(2015, 9, 25))\n\n    def testUnambiguousDayFirstYearFirst(self):\n        dtstr = '2015 09 25'\n        self.assertEqual(parse(dtstr, dayfirst=True, yearfirst=True),\n                         datetime(2015, 9, 25))\n\n    def test_mstridx(self):\n        # See GH408\n        dtstr = '2015-15-May'\n        self.assertEqual(parse(dtstr),\n                         datetime(2015, 5, 15))\n\n    def test_idx_check(self):\n        dtstr = '2017-07-17 06:15:'\n        # Pre-PR, the trailing colon will cause an IndexError at 824-825\n        # when checking `i < len_l` and then accessing `l[i+1]`\n        res = parse(dtstr, fuzzy=True)\n        assert res == datetime(2017, 7, 17, 6, 15)\n\n    def test_hmBY(self):\n        # See GH#483\n        dtstr = '02:17NOV2017'\n        res = parse(dtstr, default=self.default)\n        assert res == datetime(2017, 11, self.default.day, 2, 17)\n\n    def test_validate_hour(self):\n        # See GH353\n        invalid = \"201A-01-01T23:58:39.239769+03:00\"\n        with pytest.raises(ParserError):\n            parse(invalid)\n\n    def test_era_trailing_year(self):\n        dstr = 'AD2001'\n        res = parse(dstr)\n        assert res.year == 2001, res\n\n    def test_includes_timestr(self):\n        timestr = \"2020-13-97T44:61:83\"\n\n        try:\n            parse(timestr)\n        except ParserError as e:\n            assert e.args[1] == timestr\n        else:\n            pytest.fail(\"Failed to raise ParserError\")\n\n\nclass TestOutOfBounds(object):\n\n    def test_no_year_zero(self):\n        with pytest.raises(ParserError):\n            parse(\"0000 Jun 20\")\n\n    def test_out_of_bound_day(self):\n        with pytest.raises(ParserError):\n            parse(\"Feb 30, 2007\")\n\n    def test_illegal_month_error(self):\n        with pytest.raises(ParserError):\n            parse(\"0-100\")\n\n    def test_day_sanity(self, fuzzy):\n        dstr = \"2014-15-25\"\n        with pytest.raises(ParserError):\n            parse(dstr, fuzzy=fuzzy)\n\n    def test_minute_sanity(self, fuzzy):\n        dstr = \"2014-02-28 22:64\"\n        with pytest.raises(ParserError):\n            parse(dstr, fuzzy=fuzzy)\n\n    def test_hour_sanity(self, fuzzy):\n        dstr = \"2014-02-28 25:16 PM\"\n        with pytest.raises(ParserError):\n            parse(dstr, fuzzy=fuzzy)\n\n    def test_second_sanity(self, fuzzy):\n        dstr = \"2014-02-28 22:14:64\"\n        with pytest.raises(ParserError):\n            parse(dstr, fuzzy=fuzzy)\n\n\nclass TestParseUnimplementedCases(object):\n    @pytest.mark.xfail\n    def test_somewhat_ambiguous_string(self):\n        # Ref: github issue #487\n        # The parser is choosing the wrong part for hour\n        # causing datetime to raise an exception.\n        dtstr = '1237 PM BRST Mon Oct 30 2017'\n        res = parse(dtstr, tzinfo=self.tzinfos)\n        assert res == datetime(2017, 10, 30, 12, 37, tzinfo=self.tzinfos)\n\n    @pytest.mark.xfail\n    def test_YmdH_M_S(self):\n        # found in nasdaq's ftp data\n        dstr = '1991041310:19:24'\n        expected = datetime(1991, 4, 13, 10, 19, 24)\n        res = parse(dstr)\n        assert res == expected, (res, expected)\n\n    @pytest.mark.xfail\n    def test_first_century(self):\n        dstr = '0031 Nov 03'\n        expected = datetime(31, 11, 3)\n        res = parse(dstr)\n        assert res == expected, res\n\n    @pytest.mark.xfail\n    def test_era_trailing_year_with_dots(self):\n        dstr = 'A.D.2001'\n        res = parse(dstr)\n        assert res.year == 2001, res\n\n    @pytest.mark.xfail\n    def test_ad_nospace(self):\n        expected = datetime(6, 5, 19)\n        for dstr in [' 6AD May 19', ' 06AD May 19',\n                     ' 006AD May 19', ' 0006AD May 19']:\n            res = parse(dstr)\n            assert res == expected, (dstr, res)\n\n    @pytest.mark.xfail\n    def test_four_letter_day(self):\n        dstr = 'Frid Dec 30, 2016'\n        expected = datetime(2016, 12, 30)\n        res = parse(dstr)\n        assert res == expected\n\n    @pytest.mark.xfail\n    def test_non_date_number(self):\n        dstr = '1,700'\n        with pytest.raises(ParserError):\n            parse(dstr)\n\n    @pytest.mark.xfail\n    def test_on_era(self):\n        # This could be classified as an \"eras\" test, but the relevant part\n        # about this is the ` on `\n        dstr = '2:15 PM on January 2nd 1973 A.D.'\n        expected = datetime(1973, 1, 2, 14, 15)\n        res = parse(dstr)\n        assert res == expected\n\n    @pytest.mark.xfail\n    def test_extraneous_year(self):\n        # This was found in the wild at insidertrading.org\n        dstr = \"2011 MARTIN CHILDREN'S IRREVOCABLE TRUST u/a/d NOVEMBER 7, 2012\"\n        res = parse(dstr, fuzzy_with_tokens=True)\n        expected = datetime(2012, 11, 7)\n        assert res == expected\n\n    @pytest.mark.xfail\n    def test_extraneous_year_tokens(self):\n        # This was found in the wild at insidertrading.org\n        # Unlike in the case above, identifying the first \"2012\" as the year\n        # would not be a problem, but inferring that the latter 2012 is hhmm\n        # is a problem.\n        dstr = \"2012 MARTIN CHILDREN'S IRREVOCABLE TRUST u/a/d NOVEMBER 7, 2012\"\n        expected = datetime(2012, 11, 7)\n        (res, tokens) = parse(dstr, fuzzy_with_tokens=True)\n        assert res == expected\n        assert tokens == (\"2012 MARTIN CHILDREN'S IRREVOCABLE TRUST u/a/d \",)\n\n    @pytest.mark.xfail\n    def test_extraneous_year2(self):\n        # This was found in the wild at insidertrading.org\n        dstr = (\"Berylson Amy Smith 1998 Grantor Retained Annuity Trust \"\n                \"u/d/t November 2, 1998 f/b/o Jennifer L Berylson\")\n        res = parse(dstr, fuzzy_with_tokens=True)\n        expected = datetime(1998, 11, 2)\n        assert res == expected\n\n    @pytest.mark.xfail\n    def test_extraneous_year3(self):\n        # This was found in the wild at insidertrading.org\n        dstr = \"SMITH R &  WEISS D 94 CHILD TR FBO M W SMITH UDT 12/1/1994\"\n        res = parse(dstr, fuzzy_with_tokens=True)\n        expected = datetime(1994, 12, 1)\n        assert res == expected\n\n    @pytest.mark.xfail\n    def test_unambiguous_YYYYMM(self):\n        # 171206 can be parsed as YYMMDD. However, 201712 cannot be parsed\n        # as instance of YYMMDD and parser could fallback to YYYYMM format.\n        dstr = \"201712\"\n        res = parse(dstr)\n        expected = datetime(2017, 12, 1)\n        assert res == expected\n\n    @pytest.mark.xfail\n    def test_extraneous_numerical_content(self):\n        # ref: https://github.com/dateutil/dateutil/issues/1029\n        # parser interprets price and percentage as parts of the date\n        dstr = \"\u00a314.99 (25% off, until April 20)\"\n        res = parse(dstr, fuzzy=True, default=datetime(2000, 1, 1))\n        expected = datetime(2000, 4, 20)\n        assert res == expected\n\n\n@pytest.mark.skipif(IS_WIN, reason=\"Windows does not use TZ var\")\nclass TestTZVar(object):\n    def test_parse_unambiguous_nonexistent_local(self):\n        # When dates are specified \"EST\" even when they should be \"EDT\" in the\n        # local time zone, we should still assign the local time zone\n        with TZEnvContext('EST+5EDT,M3.2.0/2,M11.1.0/2'):\n            dt_exp = datetime(2011, 8, 1, 12, 30, tzinfo=tz.tzlocal())\n            dt = parse('2011-08-01T12:30 EST')\n\n            assert dt.tzname() == 'EDT'\n            assert dt == dt_exp\n\n    def test_tzlocal_in_gmt(self):\n        # GH #318\n        with TZEnvContext('GMT0BST,M3.5.0,M10.5.0'):\n            # This is an imaginary datetime in tz.tzlocal() but should still\n            # parse using the GMT-as-alias-for-UTC rule\n            dt = parse('2004-05-01T12:00 GMT')\n            dt_exp = datetime(2004, 5, 1, 12, tzinfo=tz.UTC)\n\n            assert dt == dt_exp\n\n    def test_tzlocal_parse_fold(self):\n        # One manifestion of GH #318\n        with TZEnvContext('EST+5EDT,M3.2.0/2,M11.1.0/2'):\n            dt_exp = datetime(2011, 11, 6, 1, 30, tzinfo=tz.tzlocal())\n            dt_exp = tz.enfold(dt_exp, fold=1)\n            dt = parse('2011-11-06T01:30 EST')\n\n            # Because this is ambiguous, until `tz.tzlocal() is tz.tzlocal()`\n            # we'll just check the attributes we care about rather than\n            # dt == dt_exp\n            assert dt.tzname() == dt_exp.tzname()\n            assert dt.replace(tzinfo=None) == dt_exp.replace(tzinfo=None)\n            assert getattr(dt, 'fold') == getattr(dt_exp, 'fold')\n            assert dt.astimezone(tz.UTC) == dt_exp.astimezone(tz.UTC)\n\n\ndef test_parse_tzinfos_fold():\n    NYC = tz.gettz('America/New_York')\n    tzinfos = {'EST': NYC, 'EDT': NYC}\n\n    dt_exp = tz.enfold(datetime(2011, 11, 6, 1, 30, tzinfo=NYC), fold=1)\n    dt = parse('2011-11-06T01:30 EST', tzinfos=tzinfos)\n\n    assert dt == dt_exp\n    assert dt.tzinfo is dt_exp.tzinfo\n    assert getattr(dt, 'fold') == getattr(dt_exp, 'fold')\n    assert dt.astimezone(tz.UTC) == dt_exp.astimezone(tz.UTC)\n\n\n@pytest.mark.parametrize('dtstr,dt', [\n    ('5.6h', datetime(2003, 9, 25, 5, 36)),\n    ('5.6m', datetime(2003, 9, 25, 0, 5, 36)),\n    # '5.6s' never had a rounding problem, test added for completeness\n    ('5.6s', datetime(2003, 9, 25, 0, 0, 5, 600000))\n])\ndef test_rounding_floatlike_strings(dtstr, dt):\n    assert parse(dtstr, default=datetime(2003, 9, 25)) == dt\n\n\n@pytest.mark.parametrize('value', ['1: test', 'Nan'])\ndef test_decimal_error(value):\n    # GH 632, GH 662 - decimal.Decimal raises some non-ParserError exception\n    # when constructed with an invalid value\n    with pytest.raises(ParserError):\n        parse(value)\n\ndef test_parsererror_repr():\n    # GH 991 \u2014 the __repr__ was not properly indented and so was never defined.\n    # This tests the current behavior of the ParserError __repr__, but the\n    # precise format is not guaranteed to be stable and may change even in\n    # minor versions. This test exists to avoid regressions.\n    s = repr(ParserError(\"Problem with string: %s\", \"2019-01-01\"))\n\n    assert s == \"ParserError('Problem with string: %s', '2019-01-01')\"\n", "tests/test_imports.py": "import sys\nimport unittest\nimport pytest\nimport six\n\nMODULE_TYPE = type(sys)\n\n\n# Tests live in datetutil/test which cause a RuntimeWarning for Python2 builds.\n# But since we expect lazy imports tests to fail for Python < 3.7  we'll ignore those\n# warnings with this filter.\n\nif six.PY2:\n    filter_import_warning = pytest.mark.filterwarnings(\"ignore::RuntimeWarning\")\nelse:\n\n    def filter_import_warning(f):\n        return f\n\n\n@pytest.fixture(scope=\"function\")\ndef clean_import():\n    \"\"\"Create a somewhat clean import base for lazy import tests\"\"\"\n    du_modules = {\n        mod_name: mod\n        for mod_name, mod in sys.modules.items()\n        if mod_name.startswith(\"dateutil\")\n    }\n\n    other_modules = {\n        mod_name for mod_name in sys.modules if mod_name not in du_modules\n    }\n\n    for mod_name in du_modules:\n        del sys.modules[mod_name]\n\n    yield\n\n    # Delete anything that wasn't in the origin sys.modules list\n    for mod_name in list(sys.modules):\n        if mod_name not in other_modules:\n            del sys.modules[mod_name]\n\n    # Restore original modules\n    for mod_name, mod in du_modules.items():\n        sys.modules[mod_name] = mod\n\n\n@filter_import_warning\n@pytest.mark.parametrize(\n    \"module\",\n    [\"easter\", \"parser\", \"relativedelta\", \"rrule\", \"tz\", \"utils\", \"zoneinfo\"],\n)\ndef test_lazy_import(clean_import, module):\n    \"\"\"Test that dateutil.[submodule] works for py version > 3.7\"\"\"\n\n    import dateutil, importlib\n\n    if sys.version_info < (3, 7):\n        pytest.xfail(\"Lazy loading does not work for Python < 3.7\")\n\n    mod_obj = getattr(dateutil, module, None)\n    assert isinstance(mod_obj, MODULE_TYPE)\n\n    mod_imported = importlib.import_module(\"dateutil.%s\" % module)\n    assert mod_obj is mod_imported\n\n\nHOST_IS_WINDOWS = sys.platform.startswith('win')\n\n\ndef test_import_version_str():\n    \"\"\" Test that dateutil.__version__ can be imported\"\"\"\n    from dateutil import __version__\n\n\ndef test_import_version_root():\n    import dateutil\n    assert hasattr(dateutil, '__version__')\n\n\n# Test that dateutil.easter-related imports work properly\ndef test_import_easter_direct():\n    import dateutil.easter\n\n\ndef test_import_easter_from():\n    from dateutil import easter\n\n\ndef test_import_easter_start():\n    from dateutil.easter import easter\n\n\n#  Test that dateutil.parser-related imports work properly\ndef test_import_parser_direct():\n    import dateutil.parser\n\n\ndef test_import_parser_from():\n    from dateutil import parser\n\n\ndef test_import_parser_all():\n    # All interface\n    from dateutil.parser import parse\n    from dateutil.parser import parserinfo\n\n    # Other public classes\n    from dateutil.parser import parser\n\n    for var in (parse, parserinfo, parser):\n        assert var is not None\n\n\n# Test that dateutil.relativedelta-related imports work properly\ndef test_import_relative_delta_direct():\n    import dateutil.relativedelta\n\n\ndef test_import_relative_delta_from():\n    from dateutil import relativedelta\n\ndef test_import_relative_delta_all():\n    from dateutil.relativedelta import relativedelta\n    from dateutil.relativedelta import MO, TU, WE, TH, FR, SA, SU\n\n    for var in (relativedelta, MO, TU, WE, TH, FR, SA, SU):\n        assert var is not None\n\n    # In the public interface but not in all\n    from dateutil.relativedelta import weekday\n    assert weekday is not  None\n\n\n# Test that dateutil.rrule related imports work properly\ndef test_import_rrule_direct():\n    import dateutil.rrule\n\n\ndef test_import_rrule_from():\n    from dateutil import rrule\n\n\ndef test_import_rrule_all():\n    from dateutil.rrule import rrule\n    from dateutil.rrule import rruleset\n    from dateutil.rrule import rrulestr\n    from dateutil.rrule import YEARLY, MONTHLY, WEEKLY, DAILY\n    from dateutil.rrule import HOURLY, MINUTELY, SECONDLY\n    from dateutil.rrule import MO, TU, WE, TH, FR, SA, SU\n\n    rr_all = (rrule, rruleset, rrulestr,\n              YEARLY, MONTHLY, WEEKLY, DAILY,\n              HOURLY, MINUTELY, SECONDLY,\n              MO, TU, WE, TH, FR, SA, SU)\n\n    for var in rr_all:\n       assert var is not None\n\n    # In the public interface but not in all\n    from dateutil.rrule import weekday\n    assert weekday is not None\n\n\n# Test that dateutil.tz related imports work properly\ndef test_import_tztest_direct():\n    import dateutil.tz\n\n\ndef test_import_tz_from():\n    from dateutil import tz\n\n\ndef test_import_tz_all():\n    from dateutil.tz import tzutc\n    from dateutil.tz import tzoffset\n    from dateutil.tz import tzlocal\n    from dateutil.tz import tzfile\n    from dateutil.tz import tzrange\n    from dateutil.tz import tzstr\n    from dateutil.tz import tzical\n    from dateutil.tz import gettz\n    from dateutil.tz import tzwin\n    from dateutil.tz import tzwinlocal\n    from dateutil.tz import UTC\n    from dateutil.tz import datetime_ambiguous\n    from dateutil.tz import datetime_exists\n    from dateutil.tz import resolve_imaginary\n\n    tz_all = [\"tzutc\", \"tzoffset\", \"tzlocal\", \"tzfile\", \"tzrange\",\n              \"tzstr\", \"tzical\", \"gettz\", \"datetime_ambiguous\",\n              \"datetime_exists\", \"resolve_imaginary\", \"UTC\"]\n\n    tz_all += [\"tzwin\", \"tzwinlocal\"] if sys.platform.startswith(\"win\") else []\n    lvars = locals()\n\n    for var in tz_all:\n        assert lvars[var] is not None\n\n# Test that dateutil.tzwin related imports work properly\n@pytest.mark.skipif(not HOST_IS_WINDOWS, reason=\"Requires Windows\")\ndef test_import_tz_windows_direct():\n    import dateutil.tzwin\n\n\n@pytest.mark.skipif(not HOST_IS_WINDOWS, reason=\"Requires Windows\")\ndef test_import_tz_windows_from():\n    from dateutil import tzwin\n\n\n@pytest.mark.skipif(not HOST_IS_WINDOWS, reason=\"Requires Windows\")\ndef test_import_tz_windows_star():\n    from dateutil.tzwin import tzwin\n    from dateutil.tzwin import tzwinlocal\n\n    tzwin_all = [tzwin, tzwinlocal]\n\n    for var in tzwin_all:\n        assert var is not None\n\n\n# Test imports of Zone Info\ndef test_import_zone_info_direct():\n    import dateutil.zoneinfo\n\n\ndef test_import_zone_info_from():\n    from dateutil import zoneinfo\n\n\ndef test_import_zone_info_star():\n    from dateutil.zoneinfo import gettz\n    from dateutil.zoneinfo import gettz_db_metadata\n    from dateutil.zoneinfo import rebuild\n\n    zi_all = (gettz, gettz_db_metadata, rebuild)\n\n    for var in zi_all:\n        assert var is not None\n", "tests/_common.py": "from __future__ import unicode_literals\nimport os\nimport time\nimport subprocess\nimport warnings\nimport tempfile\nimport pickle\n\nimport pytest\n\n\nclass PicklableMixin(object):\n    def _get_nobj_bytes(self, obj, dump_kwargs, load_kwargs):\n        \"\"\"\n        Pickle and unpickle an object using ``pickle.dumps`` / ``pickle.loads``\n        \"\"\"\n        pkl = pickle.dumps(obj, **dump_kwargs)\n        return pickle.loads(pkl, **load_kwargs)\n\n    def _get_nobj_file(self, obj, dump_kwargs, load_kwargs):\n        \"\"\"\n        Pickle and unpickle an object using ``pickle.dump`` / ``pickle.load`` on\n        a temporary file.\n        \"\"\"\n        with tempfile.TemporaryFile('w+b') as pkl:\n            pickle.dump(obj, pkl, **dump_kwargs)\n            pkl.seek(0)         # Reset the file to the beginning to read it\n            nobj = pickle.load(pkl, **load_kwargs)\n\n        return nobj\n\n    def assertPicklable(self, obj, singleton=False, asfile=False,\n                        dump_kwargs=None, load_kwargs=None):\n        \"\"\"\n        Assert that an object can be pickled and unpickled. This assertion\n        assumes that the desired behavior is that the unpickled object compares\n        equal to the original object, but is not the same object.\n        \"\"\"\n        get_nobj = self._get_nobj_file if asfile else self._get_nobj_bytes\n        dump_kwargs = dump_kwargs or {}\n        load_kwargs = load_kwargs or {}\n\n        nobj = get_nobj(obj, dump_kwargs, load_kwargs)\n        if not singleton:\n            self.assertIsNot(obj, nobj)\n        self.assertEqual(obj, nobj)\n\n\nclass TZContextBase(object):\n    \"\"\"\n    Base class for a context manager which allows changing of time zones.\n\n    Subclasses may define a guard variable to either block or or allow time\n    zone changes by redefining ``_guard_var_name`` and ``_guard_allows_change``.\n    The default is that the guard variable must be affirmatively set.\n\n    Subclasses must define ``get_current_tz`` and ``set_current_tz``.\n    \"\"\"\n    _guard_var_name = \"DATEUTIL_MAY_CHANGE_TZ\"\n    _guard_allows_change = True\n\n    def __init__(self, tzval):\n        self.tzval = tzval\n        self._old_tz = None\n\n    @classmethod\n    def tz_change_allowed(cls):\n        \"\"\"\n        Class method used to query whether or not this class allows time zone\n        changes.\n        \"\"\"\n        guard = bool(os.environ.get(cls._guard_var_name, False))\n\n        # _guard_allows_change gives the \"default\" behavior - if True, the\n        # guard is overcoming a block. If false, the guard is causing a block.\n        # Whether tz_change is allowed is therefore the XNOR of the two.\n        return guard == cls._guard_allows_change\n\n    @classmethod\n    def tz_change_disallowed_message(cls):\n        \"\"\" Generate instructions on how to allow tz changes \"\"\"\n        msg = ('Changing time zone not allowed. Set {envar} to {gval} '\n               'if you would like to allow this behavior')\n\n        return msg.format(envar=cls._guard_var_name,\n                          gval=cls._guard_allows_change)\n\n    def __enter__(self):\n        if not self.tz_change_allowed():\n            msg = self.tz_change_disallowed_message()\n            pytest.skip(msg)\n\n            # If this is used outside of a test suite, we still want an error.\n            raise ValueError(msg)  # pragma: no cover\n\n        self._old_tz = self.get_current_tz()\n        self.set_current_tz(self.tzval)\n\n    def __exit__(self, type, value, traceback):\n        if self._old_tz is not None:\n            self.set_current_tz(self._old_tz)\n\n        self._old_tz = None\n\n    def get_current_tz(self):\n        raise NotImplementedError\n\n    def set_current_tz(self):\n        raise NotImplementedError\n\n\nclass TZEnvContext(TZContextBase):\n    \"\"\"\n    Context manager that temporarily sets the `TZ` variable (for use on\n    *nix-like systems). Because the effect is local to the shell anyway, this\n    will apply *unless* a guard is set.\n\n    If you do not want the TZ environment variable set, you may set the\n    ``DATEUTIL_MAY_NOT_CHANGE_TZ_VAR`` variable to a truthy value.\n    \"\"\"\n    _guard_var_name = \"DATEUTIL_MAY_NOT_CHANGE_TZ_VAR\"\n    _guard_allows_change = False\n\n    def get_current_tz(self):\n        return os.environ.get('TZ', UnsetTz)\n\n    def set_current_tz(self, tzval):\n        if tzval is UnsetTz and 'TZ' in os.environ:\n            del os.environ['TZ']\n        else:\n            os.environ['TZ'] = tzval\n\n        time.tzset()\n\n\nclass TZWinContext(TZContextBase):\n    \"\"\"\n    Context manager for changing local time zone on Windows.\n\n    Because the effect of this is system-wide and global, it may have\n    unintended side effect. Set the ``DATEUTIL_MAY_CHANGE_TZ`` environment\n    variable to a truthy value before using this context manager.\n    \"\"\"\n    def get_current_tz(self):\n        p = subprocess.Popen(['tzutil', '/g'], stdout=subprocess.PIPE)\n\n        ctzname, err = p.communicate()\n        ctzname = ctzname.decode()     # Popen returns\n\n        if p.returncode:\n            raise OSError('Failed to get current time zone: ' + err)\n\n        return ctzname\n\n    def set_current_tz(self, tzname):\n        p = subprocess.Popen('tzutil /s \"' + tzname + '\"')\n\n        out, err = p.communicate()\n\n        if p.returncode:\n            raise OSError('Failed to set current time zone: ' +\n                          (err or 'Unknown error.'))\n\n\n###\n# Utility classes\nclass NotAValueClass(object):\n    \"\"\"\n    A class analogous to NaN that has operations defined for any type.\n    \"\"\"\n    def _op(self, other):\n        return self             # Operation with NotAValue returns NotAValue\n\n    def _cmp(self, other):\n        return False\n\n    __add__ = __radd__ = _op\n    __sub__ = __rsub__ = _op\n    __mul__ = __rmul__ = _op\n    __div__ = __rdiv__ = _op\n    __truediv__ = __rtruediv__ = _op\n    __floordiv__ = __rfloordiv__ = _op\n\n    __lt__ = __rlt__ = _op\n    __gt__ = __rgt__ = _op\n    __eq__ = __req__ = _op\n    __le__ = __rle__ = _op\n    __ge__ = __rge__ = _op\n\n\nNotAValue = NotAValueClass()\n\n\nclass ComparesEqualClass(object):\n    \"\"\"\n    A class that is always equal to whatever you compare it to.\n    \"\"\"\n\n    def __eq__(self, other):\n        return True\n\n    def __ne__(self, other):\n        return False\n\n    def __le__(self, other):\n        return True\n\n    def __ge__(self, other):\n        return True\n\n    def __lt__(self, other):\n        return False\n\n    def __gt__(self, other):\n        return False\n\n    __req__ = __eq__\n    __rne__ = __ne__\n    __rle__ = __le__\n    __rge__ = __ge__\n    __rlt__ = __lt__\n    __rgt__ = __gt__\n\n\nComparesEqual = ComparesEqualClass()\n\n\nclass UnsetTzClass(object):\n    \"\"\" Sentinel class for unset time zone variable \"\"\"\n    pass\n\n\nUnsetTz = UnsetTzClass()\n", "tests/test_isoparser.py": "# -*- coding: utf-8 -*-\nfrom __future__ import unicode_literals\n\nfrom datetime import datetime, timedelta, date, time\nimport itertools as it\n\nfrom dateutil import tz\nfrom dateutil.tz import UTC\nfrom dateutil.parser import isoparser, isoparse\n\nimport pytest\nimport six\n\n\ndef _generate_tzoffsets(limited):\n    def _mkoffset(hmtuple, fmt):\n        h, m = hmtuple\n        m_td = (-1 if h < 0 else 1) * m\n\n        tzo = tz.tzoffset(None, timedelta(hours=h, minutes=m_td))\n        return tzo, fmt.format(h, m)\n\n    out = []\n    if not limited:\n        # The subset that's just hours\n        hm_out_h = [(h, 0) for h in (-23, -5, 0, 5, 23)]\n        out.extend([_mkoffset(hm, '{:+03d}') for hm in hm_out_h])\n\n        # Ones that have hours and minutes\n        hm_out = [] + hm_out_h\n        hm_out += [(-12, 15), (11, 30), (10, 2), (5, 15), (-5, 30)]\n    else:\n        hm_out = [(-5, -0)]\n\n    fmts = ['{:+03d}:{:02d}', '{:+03d}{:02d}']\n    out += [_mkoffset(hm, fmt) for hm in hm_out for fmt in fmts]\n\n    # Also add in UTC and naive\n    out.append((UTC, 'Z'))\n    out.append((None, ''))\n\n    return out\n\nFULL_TZOFFSETS = _generate_tzoffsets(False)\nFULL_TZOFFSETS_AWARE = [x for x in FULL_TZOFFSETS if x[1]]\nTZOFFSETS = _generate_tzoffsets(True)\n\nDATES = [datetime(1996, 1, 1), datetime(2017, 1, 1)]\n@pytest.mark.parametrize('dt', tuple(DATES))\ndef test_year_only(dt):\n    dtstr = dt.strftime('%Y')\n\n    assert isoparse(dtstr) == dt\n\nDATES += [datetime(2000, 2, 1), datetime(2017, 4, 1)]\n@pytest.mark.parametrize('dt', tuple(DATES))\ndef test_year_month(dt):\n    fmt   = '%Y-%m'\n    dtstr = dt.strftime(fmt)\n\n    assert isoparse(dtstr) == dt\n\nDATES += [datetime(2016, 2, 29), datetime(2018, 3, 15)]\nYMD_FMTS = ('%Y%m%d', '%Y-%m-%d')\n@pytest.mark.parametrize('dt', tuple(DATES))\n@pytest.mark.parametrize('fmt', YMD_FMTS)\ndef test_year_month_day(dt, fmt):\n    dtstr = dt.strftime(fmt)\n\n    assert isoparse(dtstr) == dt\n\ndef _isoparse_date_and_time(dt, date_fmt, time_fmt, tzoffset,\n                            microsecond_precision=None):\n    tzi, offset_str = tzoffset\n    fmt = date_fmt + 'T' + time_fmt\n    dt = dt.replace(tzinfo=tzi)\n    dtstr = dt.strftime(fmt)\n\n    if microsecond_precision is not None:\n        if not fmt.endswith('%f'):  # pragma: nocover\n            raise ValueError('Time format has no microseconds!')\n\n        if microsecond_precision != 6:\n            dtstr = dtstr[: -(6 - microsecond_precision)]\n        elif microsecond_precision > 6:  # pragma: nocover\n            raise ValueError(\"Precision must be 1-6\")\n\n    dtstr += offset_str\n\n    assert isoparse(dtstr) == dt\n\nDATETIMES = [datetime(1998, 4, 16, 12),\n             datetime(2019, 11, 18, 23),\n             datetime(2014, 12, 16, 4)]\n@pytest.mark.parametrize('dt', tuple(DATETIMES))\n@pytest.mark.parametrize('date_fmt', YMD_FMTS)\n@pytest.mark.parametrize('tzoffset', TZOFFSETS)\ndef test_ymd_h(dt, date_fmt, tzoffset):\n    _isoparse_date_and_time(dt, date_fmt, '%H', tzoffset)\n\nDATETIMES = [datetime(2012, 1, 6, 9, 37)]\n@pytest.mark.parametrize('dt', tuple(DATETIMES))\n@pytest.mark.parametrize('date_fmt', YMD_FMTS)\n@pytest.mark.parametrize('time_fmt', ('%H%M', '%H:%M'))\n@pytest.mark.parametrize('tzoffset', TZOFFSETS)\ndef test_ymd_hm(dt, date_fmt, time_fmt, tzoffset):\n    _isoparse_date_and_time(dt, date_fmt, time_fmt, tzoffset)\n\nDATETIMES = [datetime(2003, 9, 2, 22, 14, 2),\n             datetime(2003, 8, 8, 14, 9, 14),\n             datetime(2003, 4, 7, 6, 14, 59)]\nHMS_FMTS = ('%H%M%S', '%H:%M:%S')\n@pytest.mark.parametrize('dt', tuple(DATETIMES))\n@pytest.mark.parametrize('date_fmt', YMD_FMTS)\n@pytest.mark.parametrize('time_fmt', HMS_FMTS)\n@pytest.mark.parametrize('tzoffset', TZOFFSETS)\ndef test_ymd_hms(dt, date_fmt, time_fmt, tzoffset):\n    _isoparse_date_and_time(dt, date_fmt, time_fmt, tzoffset)\n\nDATETIMES = [datetime(2017, 11, 27, 6, 14, 30, 123456)]\n@pytest.mark.parametrize('dt', tuple(DATETIMES))\n@pytest.mark.parametrize('date_fmt', YMD_FMTS)\n@pytest.mark.parametrize('time_fmt', (x + sep + '%f' for x in HMS_FMTS\n                                      for sep in '.,'))\n@pytest.mark.parametrize('tzoffset', TZOFFSETS)\n@pytest.mark.parametrize('precision', list(range(3, 7)))\ndef test_ymd_hms_micro(dt, date_fmt, time_fmt, tzoffset, precision):\n    # Truncate the microseconds to the desired precision for the representation\n    dt = dt.replace(microsecond=int(round(dt.microsecond, precision-6)))\n\n    _isoparse_date_and_time(dt, date_fmt, time_fmt, tzoffset, precision)\n\n###\n# Truncation of extra digits beyond microsecond precision\n@pytest.mark.parametrize('dt_str', [\n    '2018-07-03T14:07:00.123456000001',\n    '2018-07-03T14:07:00.123456999999',\n])\ndef test_extra_subsecond_digits(dt_str):\n    assert isoparse(dt_str) == datetime(2018, 7, 3, 14, 7, 0, 123456)\n\n@pytest.mark.parametrize('tzoffset', FULL_TZOFFSETS)\ndef test_full_tzoffsets(tzoffset):\n    dt = datetime(2017, 11, 27, 6, 14, 30, 123456)\n    date_fmt = '%Y-%m-%d'\n    time_fmt = '%H:%M:%S.%f'\n\n    _isoparse_date_and_time(dt, date_fmt, time_fmt, tzoffset)\n\n@pytest.mark.parametrize('dt_str', [\n    '2014-04-11T00',\n    '2014-04-10T24',\n    '2014-04-11T00:00',\n    '2014-04-10T24:00',\n    '2014-04-11T00:00:00',\n    '2014-04-10T24:00:00',\n    '2014-04-11T00:00:00.000',\n    '2014-04-10T24:00:00.000',\n    '2014-04-11T00:00:00.000000',\n    '2014-04-10T24:00:00.000000']\n)\ndef test_datetime_midnight(dt_str):\n    assert isoparse(dt_str) == datetime(2014, 4, 11, 0, 0, 0, 0)\n\n@pytest.mark.parametrize('datestr', [\n    '2014-01-01',\n    '20140101',\n])\n@pytest.mark.parametrize('sep', [' ', 'a', 'T', '_', '-'])\ndef test_isoparse_sep_none(datestr, sep):\n    isostr = datestr + sep + '14:33:09'\n    assert isoparse(isostr) == datetime(2014, 1, 1, 14, 33, 9)\n\n##\n# Uncommon date formats\nTIME_ARGS = ('time_args',\n    ((None, time(0), None), ) + tuple(('%H:%M:%S.%f', _t, _tz)\n        for _t, _tz in it.product([time(0), time(9, 30), time(14, 47)],\n                                  TZOFFSETS)))\n\n@pytest.mark.parametrize('isocal,dt_expected',[\n    ((2017, 10), datetime(2017, 3, 6)),\n    ((2020, 1), datetime(2019, 12, 30)),    # ISO year != Cal year\n    ((2004, 53), datetime(2004, 12, 27)),   # Only half the week is in 2014\n])\ndef test_isoweek(isocal, dt_expected):\n    # TODO: Figure out how to parametrize this on formats, too\n    for fmt in ('{:04d}-W{:02d}', '{:04d}W{:02d}'):\n        dtstr = fmt.format(*isocal)\n        assert isoparse(dtstr) == dt_expected\n\n@pytest.mark.parametrize('isocal,dt_expected',[\n    ((2016, 13, 7), datetime(2016, 4, 3)),\n    ((2004, 53, 7), datetime(2005, 1, 2)),      # ISO year != Cal year\n    ((2009, 1, 2), datetime(2008, 12, 30)),     # ISO year < Cal year\n    ((2009, 53, 6), datetime(2010, 1, 2))       # ISO year > Cal year\n])\ndef test_isoweek_day(isocal, dt_expected):\n    # TODO: Figure out how to parametrize this on formats, too\n    for fmt in ('{:04d}-W{:02d}-{:d}', '{:04d}W{:02d}{:d}'):\n        dtstr = fmt.format(*isocal)\n        assert isoparse(dtstr) == dt_expected\n\n@pytest.mark.parametrize('isoord,dt_expected', [\n    ((2004, 1), datetime(2004, 1, 1)),\n    ((2016, 60), datetime(2016, 2, 29)),\n    ((2017, 60), datetime(2017, 3, 1)),\n    ((2016, 366), datetime(2016, 12, 31)),\n    ((2017, 365), datetime(2017, 12, 31))\n])\ndef test_iso_ordinal(isoord, dt_expected):\n    for fmt in ('{:04d}-{:03d}', '{:04d}{:03d}'):\n        dtstr = fmt.format(*isoord)\n\n        assert isoparse(dtstr) == dt_expected\n\n\n###\n# Acceptance of bytes\n@pytest.mark.parametrize('isostr,dt', [\n    (b'2014', datetime(2014, 1, 1)),\n    (b'20140204', datetime(2014, 2, 4)),\n    (b'2014-02-04', datetime(2014, 2, 4)),\n    (b'2014-02-04T12', datetime(2014, 2, 4, 12)),\n    (b'2014-02-04T12:30', datetime(2014, 2, 4, 12, 30)),\n    (b'2014-02-04T12:30:15', datetime(2014, 2, 4, 12, 30, 15)),\n    (b'2014-02-04T12:30:15.224', datetime(2014, 2, 4, 12, 30, 15, 224000)),\n    (b'20140204T123015.224', datetime(2014, 2, 4, 12, 30, 15, 224000)),\n    (b'2014-02-04T12:30:15.224Z', datetime(2014, 2, 4, 12, 30, 15, 224000,\n                                           UTC)),\n    (b'2014-02-04T12:30:15.224z', datetime(2014, 2, 4, 12, 30, 15, 224000,\n                                           UTC)),\n    (b'2014-02-04T12:30:15.224+05:00',\n        datetime(2014, 2, 4, 12, 30, 15, 224000,\n                 tzinfo=tz.tzoffset(None, timedelta(hours=5))))])\ndef test_bytes(isostr, dt):\n    assert isoparse(isostr) == dt\n\n\n###\n# Invalid ISO strings\n@pytest.mark.parametrize('isostr,exception', [\n    ('201', ValueError),                        # ISO string too short\n    ('2012-0425', ValueError),                  # Inconsistent date separators\n    ('201204-25', ValueError),                  # Inconsistent date separators\n    ('20120425T0120:00', ValueError),           # Inconsistent time separators\n    ('20120425T01:2000', ValueError),           # Inconsistent time separators\n    ('14:3015', ValueError),                    # Inconsistent time separator\n    ('20120425T012500-334', ValueError),        # Wrong microsecond separator\n    ('2001-1', ValueError),                     # YYYY-M not valid\n    ('2012-04-9', ValueError),                  # YYYY-MM-D not valid\n    ('201204', ValueError),                     # YYYYMM not valid\n    ('20120411T03:30+', ValueError),            # Time zone too short\n    ('20120411T03:30+1234567', ValueError),     # Time zone too long\n    ('20120411T03:30-25:40', ValueError),       # Time zone invalid\n    ('2012-1a', ValueError),                    # Invalid month\n    ('20120411T03:30+00:60', ValueError),       # Time zone invalid minutes\n    ('20120411T03:30+00:61', ValueError),       # Time zone invalid minutes\n    ('20120411T033030.123456012:00',            # No sign in time zone\n        ValueError),\n    ('2012-W00', ValueError),                   # Invalid ISO week\n    ('2012-W55', ValueError),                   # Invalid ISO week\n    ('2012-W01-0', ValueError),                 # Invalid ISO week day\n    ('2012-W01-8', ValueError),                 # Invalid ISO week day\n    ('2013-000', ValueError),                   # Invalid ordinal day\n    ('2013-366', ValueError),                   # Invalid ordinal day\n    ('2013366', ValueError),                    # Invalid ordinal day\n    ('2014-03-12\u042212:30:14', ValueError),        # Cyrillic T\n    ('2014-04-21T24:00:01', ValueError),        # Invalid use of 24 for midnight\n    ('2014_W01-1', ValueError),                 # Invalid separator\n    ('2014W01-1', ValueError),                  # Inconsistent use of dashes\n    ('2014-W011', ValueError),                  # Inconsistent use of dashes\n\n])\ndef test_iso_raises(isostr, exception):\n    with pytest.raises(exception):\n        isoparse(isostr)\n\n\n@pytest.mark.parametrize('sep_act, valid_sep, exception', [\n    ('T', 'C', ValueError),\n    ('C', 'T', ValueError),\n])\ndef test_iso_with_sep_raises(sep_act, valid_sep, exception):\n    parser = isoparser(sep=valid_sep)\n    isostr = '2012-04-25' + sep_act + '01:25:00'\n    with pytest.raises(exception):\n        parser.isoparse(isostr)\n\n\n###\n# Test ISOParser constructor\n@pytest.mark.parametrize('sep', ['  ', '9', '\ud83c\udf5b'])\ndef test_isoparser_invalid_sep(sep):\n    with pytest.raises(ValueError):\n        isoparser(sep=sep)\n\n\n# This only fails on Python 3\n@pytest.mark.xfail(not six.PY2, reason=\"Fails on Python 3 only\")\ndef test_isoparser_byte_sep():\n    dt = datetime(2017, 12, 6, 12, 30, 45)\n    dt_str = dt.isoformat(sep=str('T'))\n\n    dt_rt = isoparser(sep=b'T').isoparse(dt_str)\n\n    assert dt == dt_rt\n\n\n###\n# Test parse_tzstr\n@pytest.mark.parametrize('tzoffset', FULL_TZOFFSETS)\ndef test_parse_tzstr(tzoffset):\n    dt = datetime(2017, 11, 27, 6, 14, 30, 123456)\n    date_fmt = '%Y-%m-%d'\n    time_fmt = '%H:%M:%S.%f'\n\n    _isoparse_date_and_time(dt, date_fmt, time_fmt, tzoffset)\n\n\n@pytest.mark.parametrize('tzstr', [\n    '-00:00', '+00:00', '+00', '-00', '+0000', '-0000'\n])\n@pytest.mark.parametrize('zero_as_utc', [True, False])\ndef test_parse_tzstr_zero_as_utc(tzstr, zero_as_utc):\n    tzi = isoparser().parse_tzstr(tzstr, zero_as_utc=zero_as_utc)\n    assert tzi == UTC\n    assert (type(tzi) == tz.tzutc) == zero_as_utc\n\n\n@pytest.mark.parametrize('tzstr,exception', [\n    ('00:00', ValueError),     # No sign\n    ('05:00', ValueError),     # No sign\n    ('_00:00', ValueError),    # Invalid sign\n    ('+25:00', ValueError),    # Offset too large\n    ('00:0000', ValueError),   # String too long\n])\ndef test_parse_tzstr_fails(tzstr, exception):\n    with pytest.raises(exception):\n        isoparser().parse_tzstr(tzstr)\n\n###\n# Test parse_isodate\ndef __make_date_examples():\n    dates_no_day = [\n        date(1999, 12, 1),\n        date(2016, 2, 1)\n    ]\n\n    if not six.PY2:\n        # strftime does not support dates before 1900 in Python 2\n        dates_no_day.append(date(1000, 11, 1))\n\n    # Only one supported format for dates with no day\n    o = zip(dates_no_day, it.repeat('%Y-%m'))\n\n    dates_w_day = [\n        date(1969, 12, 31),\n        date(1900, 1, 1),\n        date(2016, 2, 29),\n        date(2017, 11, 14)\n    ]\n\n    dates_w_day_fmts = ('%Y%m%d', '%Y-%m-%d')\n    o = it.chain(o, it.product(dates_w_day, dates_w_day_fmts))\n\n    return list(o)\n\n\n@pytest.mark.parametrize('d,dt_fmt', __make_date_examples())\n@pytest.mark.parametrize('as_bytes', [True, False])\ndef test_parse_isodate(d, dt_fmt, as_bytes):\n    d_str = d.strftime(dt_fmt)\n    if isinstance(d_str, six.text_type) and as_bytes:\n        d_str = d_str.encode('ascii')\n    elif isinstance(d_str, bytes) and not as_bytes:\n        d_str = d_str.decode('ascii')\n\n    iparser = isoparser()\n    assert iparser.parse_isodate(d_str) == d\n\n\n@pytest.mark.parametrize('isostr,exception', [\n    ('243', ValueError),                        # ISO string too short\n    ('2014-0423', ValueError),                  # Inconsistent date separators\n    ('201404-23', ValueError),                  # Inconsistent date separators\n    ('2014\u65e503\u670814', ValueError),                # Not ASCII\n    ('2013-02-29', ValueError),                 # Not a leap year\n    ('2014/12/03', ValueError),                 # Wrong separators\n    ('2014-04-19T', ValueError),                # Unknown components\n    ('201202', ValueError),                     # Invalid format\n])\ndef test_isodate_raises(isostr, exception):\n    with pytest.raises(exception):\n        isoparser().parse_isodate(isostr)\n\n\ndef test_parse_isodate_error_text():\n    with pytest.raises(ValueError) as excinfo:\n        isoparser().parse_isodate('2014-0423')\n\n    # ensure the error message does not contain b' prefixes\n    if six.PY2:\n        expected_error = \"String contains unknown ISO components: u'2014-0423'\"\n    else:\n        expected_error = \"String contains unknown ISO components: '2014-0423'\"\n    assert expected_error == str(excinfo.value)\n\n\n###\n# Test parse_isotime\ndef __make_time_examples():\n    outputs = []\n\n    # HH\n    time_h = [time(0), time(8), time(22)]\n    time_h_fmts = ['%H']\n\n    outputs.append(it.product(time_h, time_h_fmts))\n\n    # HHMM / HH:MM\n    time_hm = [time(0, 0), time(0, 30), time(8, 47), time(16, 1)]\n    time_hm_fmts = ['%H%M', '%H:%M']\n\n    outputs.append(it.product(time_hm, time_hm_fmts))\n\n    # HHMMSS / HH:MM:SS\n    time_hms = [time(0, 0, 0), time(0, 15, 30),\n                time(8, 2, 16), time(12, 0), time(16, 2), time(20, 45)]\n\n    time_hms_fmts = ['%H%M%S', '%H:%M:%S']\n\n    outputs.append(it.product(time_hms, time_hms_fmts))\n\n    # HHMMSS.ffffff / HH:MM:SS.ffffff\n    time_hmsu = [time(0, 0, 0, 0), time(4, 15, 3, 247993),\n                 time(14, 21, 59, 948730),\n                 time(23, 59, 59, 999999)]\n\n    time_hmsu_fmts = ['%H%M%S.%f', '%H:%M:%S.%f']\n\n    outputs.append(it.product(time_hmsu, time_hmsu_fmts))\n\n    outputs = list(map(list, outputs))\n\n    # Time zones\n    ex_naive = list(it.chain.from_iterable(x[0:2] for x in outputs))\n    o = it.product(ex_naive, TZOFFSETS)    # ((time, fmt), (tzinfo, offsetstr))\n    o = ((t.replace(tzinfo=tzi), fmt + off_str)\n         for (t, fmt), (tzi, off_str) in o)\n\n    outputs.append(o)\n\n    return list(it.chain.from_iterable(outputs))\n\n\n@pytest.mark.parametrize('time_val,time_fmt', __make_time_examples())\n@pytest.mark.parametrize('as_bytes', [True, False])\ndef test_isotime(time_val, time_fmt, as_bytes):\n    tstr = time_val.strftime(time_fmt)\n    if isinstance(tstr, six.text_type) and as_bytes:\n        tstr = tstr.encode('ascii')\n    elif isinstance(tstr, bytes) and not as_bytes:\n        tstr = tstr.decode('ascii')\n\n    iparser = isoparser()\n\n    assert iparser.parse_isotime(tstr) == time_val\n\n\n@pytest.mark.parametrize('isostr', [\n    '24:00',\n    '2400',\n    '24:00:00',\n    '240000',\n    '24:00:00.000',\n    '24:00:00,000',\n    '24:00:00.000000',\n    '24:00:00,000000',\n])\ndef test_isotime_midnight(isostr):\n    iparser = isoparser()\n    assert iparser.parse_isotime(isostr) == time(0, 0, 0, 0)\n\n\n@pytest.mark.parametrize('isostr,exception', [\n    ('3', ValueError),                          # ISO string too short\n    ('14\u664230\u520615\u79d2', ValueError),                # Not ASCII\n    ('14_30_15', ValueError),                   # Invalid separators\n    ('1430:15', ValueError),                    # Inconsistent separator use\n    ('25', ValueError),                         # Invalid hours\n    ('25:15', ValueError),                      # Invalid hours\n    ('14:60', ValueError),                      # Invalid minutes\n    ('14:59:61', ValueError),                   # Invalid seconds\n    ('14:30:15.34468305:00', ValueError),       # No sign in time zone\n    ('14:30:15+', ValueError),                  # Time zone too short\n    ('14:30:15+1234567', ValueError),           # Time zone invalid\n    ('14:59:59+25:00', ValueError),             # Invalid tz hours\n    ('14:59:59+12:62', ValueError),             # Invalid tz minutes\n    ('14:59:30_344583', ValueError),            # Invalid microsecond separator\n    ('24:01', ValueError),                      # 24 used for non-midnight time\n    ('24:00:01', ValueError),                   # 24 used for non-midnight time\n    ('24:00:00.001', ValueError),               # 24 used for non-midnight time\n    ('24:00:00.000001', ValueError),            # 24 used for non-midnight time\n])\ndef test_isotime_raises(isostr, exception):\n    iparser = isoparser()\n    with pytest.raises(exception):\n        iparser.parse_isotime(isostr)\n", "tests/conftest.py": "import os\nimport pytest\n\n\n# Configure pytest to ignore xfailing tests\n# See: https://stackoverflow.com/a/53198349/467366\ndef pytest_collection_modifyitems(items):\n    for item in items:\n        marker_getter = getattr(item, 'get_closest_marker', None)\n\n        # Python 3.3 support\n        if marker_getter is None:\n            marker_getter = item.get_marker\n\n        marker = marker_getter('xfail')\n\n        # Need to query the args because conditional xfail tests still have\n        # the xfail mark even if they are not expected to fail\n        if marker and (not marker.args or marker.args[0]):\n            item.add_marker(pytest.mark.no_cover)\n\n\ndef set_tzpath():\n    \"\"\"\n    Sets the TZPATH variable if it's specified in an environment variable.\n    \"\"\"\n    tzpath = os.environ.get('DATEUTIL_TZPATH', None)\n\n    if tzpath is None:\n        return\n\n    path_components = tzpath.split(':')\n\n    print(\"Setting TZPATH to {}\".format(path_components))\n\n    from dateutil import tz\n    tz.TZPATHS.clear()\n    tz.TZPATHS.extend(path_components)\n\n\nset_tzpath()\n", "tests/test_import_star.py": "\"\"\"Test for the \"import *\" functionality.\n\nAs import * can be only done at module level, it has been added in a separate file\n\"\"\"\nimport pytest\n\nprev_locals = list(locals())\nfrom dateutil import *\nnew_locals = {name:value for name,value in locals().items()\n              if name not in prev_locals}\nnew_locals.pop('prev_locals')\n\n\n@pytest.mark.import_star\ndef test_imported_modules():\n    \"\"\" Test that `from dateutil import *` adds modules in __all__ locally \"\"\"\n    import dateutil.easter\n    import dateutil.parser\n    import dateutil.relativedelta\n    import dateutil.rrule\n    import dateutil.tz\n    import dateutil.utils\n    import dateutil.zoneinfo\n\n    assert dateutil.easter == new_locals.pop(\"easter\")\n    assert dateutil.parser == new_locals.pop(\"parser\")\n    assert dateutil.relativedelta == new_locals.pop(\"relativedelta\")\n    assert dateutil.rrule == new_locals.pop(\"rrule\")\n    assert dateutil.tz == new_locals.pop(\"tz\")\n    assert dateutil.utils == new_locals.pop(\"utils\")\n    assert dateutil.zoneinfo == new_locals.pop(\"zoneinfo\")\n\n    assert not new_locals\n", "tests/test_tz.py": "# -*- coding: utf-8 -*-\nfrom __future__ import unicode_literals\nfrom ._common import PicklableMixin\nfrom ._common import TZEnvContext, TZWinContext\nfrom ._common import ComparesEqual\n\nfrom datetime import datetime, timedelta\nfrom datetime import time as dt_time\nfrom datetime import tzinfo\nfrom six import PY2\nfrom io import BytesIO, StringIO\nimport unittest\n\nimport sys\nimport base64\nimport copy\nimport gc\nimport weakref\n\nfrom functools import partial\n\nIS_WIN = sys.platform.startswith('win')\n\nimport pytest\n\n# dateutil imports\nfrom dateutil.relativedelta import relativedelta, SU, TH\nfrom dateutil.parser import parse\nfrom dateutil import tz as tz\nfrom dateutil import zoneinfo\n\ntry:\n    from dateutil import tzwin\nexcept ImportError as e:\n    if IS_WIN:\n        raise e\n    else:\n        pass\n\nMISSING_TARBALL = (\"This test fails if you don't have the dateutil \"\n                   \"timezone file installed. Please read the README\")\n\nTZFILE_EST5EDT = b\"\"\"\nVFppZgAAAAAAAAAAAAAAAAAAAAAAAAAEAAAABAAAAAAAAADrAAAABAAAABCeph5wn7rrYKCGAHCh\nms1gomXicKOD6eCkaq5wpTWnYKZTyvCnFYlgqDOs8Kj+peCqE47wqt6H4KvzcPCsvmngrdNS8K6e\nS+CvszTwsH4t4LGcUXCyZ0pgs3wzcLRHLGC1XBVwticOYLc793C4BvBguRvZcLnm0mC7BPXwu8a0\nYLzk1/C9r9DgvsS58L+PsuDApJvwwW+U4MKEffDDT3bgxGRf8MUvWODGTXxwxw864MgtXnDI+Fdg\nyg1AcMrYOWDLiPBw0iP0cNJg++DTdeTw1EDd4NVVxvDWIL/g1zWo8NgAoeDZFYrw2eCD4Nr+p3Db\nwGXg3N6JcN2pgmDevmtw34lkYOCeTXDhaUZg4n4vcONJKGDkXhFw5Vcu4OZHLfDnNxDg6CcP8OkW\n8uDqBvHw6vbU4Ovm0/Ds1rbg7ca18O6/02Dvr9Jw8J+1YPGPtHDyf5dg82+WcPRfeWD1T3hw9j9b\nYPcvWnD4KHfg+Q88cPoIWeD6+Fjw++g74PzYOvD9yB3g/rgc8P+n/+AAl/7wAYfh4AJ34PADcP5g\nBGD9cAVQ4GAGQN9wBzDCYAeNGXAJEKRgCa2U8ArwhmAL4IVwDNmi4A3AZ3AOuYTgD6mD8BCZZuAR\niWXwEnlI4BNpR/AUWSrgFUkp8BY5DOAXKQvwGCIpYBkI7fAaAgtgGvIKcBvh7WAc0exwHcHPYB6x\nznAfobFgIHYA8CGBk2AiVeLwI2qv4CQ1xPAlSpHgJhWm8Ccqc+An/sNwKQpV4CnepXAq6jfgK76H\ncCzTVGAtnmlwLrM2YC9+S3AwkxhgMWdn8DJy+mAzR0nwNFLcYDUnK/A2Mr5gNwcN8Dgb2uA45u/w\nOfu84DrG0fA7257gPK/ucD27gOA+j9BwP5ti4EBvsnBBhH9gQk+UcENkYWBEL3ZwRURDYEYPWHBH\nJCVgR/h08EkEB2BJ2FbwSuPpYEu4OPBMzQXgTZga8E6s5+BPd/zwUIzJ4FFhGXBSbKvgU0D7cFRM\njeBVIN1wVixv4FcAv3BYFYxgWOChcFn1bmBawINwW9VQYFypn/BdtTJgXomB8F+VFGBgaWPwYX4w\n4GJJRfBjXhLgZCkn8GU99OBmEkRwZx3W4GfyJnBo/bjgadIIcGrdmuBrsepwbMa3YG2RzHBupplg\nb3GucHCGe2BxWsrwcmZdYHM6rPB0Rj9gdRqO8HYvW+B2+nDweA894HjaUvB57x/gero08HvPAeB8\no1Fwfa7j4H6DM3B/jsXgAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAB\nAAEAAQABAgMBAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAB\nAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEA\nAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAB\nAAEAAQABAAEAAQABAAEAAQABAAEAAf//x8ABAP//ubAABP//x8ABCP//x8ABDEVEVABFU1QARVdU\nAEVQVAAAAAABAAAAAQ==\n\"\"\"\n\nEUROPE_HELSINKI = b\"\"\"\nVFppZgAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABQAAAAAAAAB1AAAABQAAAA2kc28Yy85RYMy/hdAV\nI+uQFhPckBcDzZAX876QGOOvkBnToJAaw5GQG7y9EBysrhAdnJ8QHoyQEB98gRAgbHIQIVxjECJM\nVBAjPEUQJCw2ECUcJxAmDBgQJwVDkCf1NJAo5SWQKdUWkCrFB5ArtPiQLKTpkC2U2pAuhMuQL3S8\nkDBkrZAxXdkQMnK0EDM9uxA0UpYQNR2dEDYyeBA2/X8QOBuUkDjdYRA5+3aQOr1DEDvbWJA8pl+Q\nPbs6kD6GQZA/mxyQQGYjkEGEORBCRgWQQ2QbEEQl55BFQ/0QRgXJkEcj3xBH7uYQSQPBEEnOyBBK\n46MQS66qEEzMv5BNjowQTqyhkE9ubhBQjIOQUVeKkFJsZZBTN2yQVExHkFUXTpBWLCmQVvcwkFgV\nRhBY1xKQWfUoEFq29JBb1QoQXKAREF207BBef/MQX5TOEGBf1RBhfeqQYj+3EGNdzJBkH5kQZT2u\nkGYItZBnHZCQZ+iXkGj9cpBpyHmQat1UkGuoW5BsxnEQbYg9kG6mUxBvaB+QcIY1EHFRPBByZhcQ\nczEeEHRF+RB1EQAQdi8VkHbw4hB4DveQeNDEEHnu2ZB6sKYQe867kHyZwpB9rp2QfnmkkH+Of5AC\nAQIDBAMEAwQDBAMEAwQDBAMEAwQDBAMEAwQDBAMEAwQDBAMEAwQDBAMEAwQDBAMEAwQDBAMEAwQD\nBAMEAwQDBAMEAwQDBAMEAwQDBAMEAwQDBAMEAwQDBAMEAwQDBAMEAwQDBAMEAwQDBAMEAwQDBAME\nAwQAABdoAAAAACowAQQAABwgAAkAACowAQQAABwgAAlITVQARUVTVABFRVQAAAAAAQEAAAABAQ==\n\"\"\"\n\nNEW_YORK = b\"\"\"\nVFppZgAAAAAAAAAAAAAAAAAAAAAAAAAEAAAABAAAABcAAADrAAAABAAAABCeph5wn7rrYKCGAHCh\nms1gomXicKOD6eCkaq5wpTWnYKZTyvCnFYlgqDOs8Kj+peCqE47wqt6H4KvzcPCsvmngrdNS8K6e\nS+CvszTwsH4t4LGcUXCyZ0pgs3wzcLRHLGC1XBVwticOYLc793C4BvBguRvZcLnm0mC7BPXwu8a0\nYLzk1/C9r9DgvsS58L+PsuDApJvwwW+U4MKEffDDT3bgxGRf8MUvWODGTXxwxw864MgtXnDI+Fdg\nyg1AcMrYOWDLiPBw0iP0cNJg++DTdeTw1EDd4NVVxvDWIL/g1zWo8NgAoeDZFYrw2eCD4Nr+p3Db\nwGXg3N6JcN2pgmDevmtw34lkYOCeTXDhaUZg4n4vcONJKGDkXhFw5Vcu4OZHLfDnNxDg6CcP8OkW\n8uDqBvHw6vbU4Ovm0/Ds1rbg7ca18O6/02Dvr9Jw8J+1YPGPtHDyf5dg82+WcPRfeWD1T3hw9j9b\nYPcvWnD4KHfg+Q88cPoIWeD6+Fjw++g74PzYOvD9yB3g/rgc8P+n/+AAl/7wAYfh4AJ34PADcP5g\nBGD9cAVQ4GEGQN9yBzDCYgeNGXMJEKRjCa2U9ArwhmQL4IV1DNmi5Q3AZ3YOuYTmD6mD9xCZZucR\niWX4EnlI6BNpR/kUWSrpFUkp+RY5DOoXKQv6GCIpaxkI7fsaAgtsGvIKfBvh7Wwc0ex8HcHPbR6x\nzn0fobFtIHYA/SGBk20iVeL+I2qv7iQ1xP4lSpHuJhWm/ycqc+8n/sOAKQpV8CnepYAq6jfxK76H\ngSzTVHItnmmCLrM2cy9+S4MwkxhzMWdoBDJy+nQzR0oENFLcdTUnLAU2Mr51NwcOBjgb2vY45vAG\nOfu89jrG0gY72572PK/uhj27gPY+j9CGP5ti9kBvsoZBhH92Qk+UhkNkYXZEL3aHRURDd0XzqQdH\nLV/3R9OLB0kNQfdJs20HSu0j90uciYdM1kB3TXxrh062IndPXE2HUJYEd1E8L4dSdeZ3UxwRh1RV\nyHdU+/OHVjWqd1blEAdYHsb3WMTyB1n+qPdapNQHW96K91yEtgddvmz3XmSYB1+eTvdgTbSHYYdr\nd2ItlodjZ013ZA14h2VHL3dl7VqHZycRd2fNPIdpBvN3aa0eh2rm1XdrljsHbM/x9212HQdur9P3\nb1X/B3CPtfdxNeEHcm+X93MVwwd0T3n3dP7fh3Y4lnd23sGHeBh4d3i+o4d5+Fp3ep6Fh3vYPHd8\nfmeHfbged35eSYd/mAB3AAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAB\nAAEAAQABAgMBAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAB\nAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEA\nAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAB\nAAEAAQABAAEAAQABAAEAAQABAAEAAf//x8ABAP//ubAABP//x8ABCP//x8ABDEVEVABFU1QARVdU\nAEVQVAAEslgAAAAAAQWk7AEAAAACB4YfggAAAAMJZ1MDAAAABAtIhoQAAAAFDSsLhQAAAAYPDD8G\nAAAABxDtcocAAAAIEs6mCAAAAAkVn8qJAAAACheA/goAAAALGWIxiwAAAAwdJeoMAAAADSHa5Q0A\nAAAOJZ6djgAAAA8nf9EPAAAAECpQ9ZAAAAARLDIpEQAAABIuE1ySAAAAEzDnJBMAAAAUM7hIlAAA\nABU2jBAVAAAAFkO3G5YAAAAXAAAAAQAAAAE=\n\"\"\"\n\nTZICAL_EST5EDT = \"\"\"\nBEGIN:VTIMEZONE\nTZID:US-Eastern\nLAST-MODIFIED:19870101T000000Z\nTZURL:http://zones.stds_r_us.net/tz/US-Eastern\nBEGIN:STANDARD\nDTSTART:19671029T020000\nRRULE:FREQ=YEARLY;BYDAY=-1SU;BYMONTH=10\nTZOFFSETFROM:-0400\nTZOFFSETTO:-0500\nTZNAME:EST\nEND:STANDARD\nBEGIN:DAYLIGHT\nDTSTART:19870405T020000\nRRULE:FREQ=YEARLY;BYDAY=1SU;BYMONTH=4\nTZOFFSETFROM:-0500\nTZOFFSETTO:-0400\nTZNAME:EDT\nEND:DAYLIGHT\nEND:VTIMEZONE\n\"\"\"\n\nTZICAL_PST8PDT = \"\"\"\nBEGIN:VTIMEZONE\nTZID:US-Pacific\nLAST-MODIFIED:19870101T000000Z\nBEGIN:STANDARD\nDTSTART:19671029T020000\nRRULE:FREQ=YEARLY;BYDAY=-1SU;BYMONTH=10\nTZOFFSETFROM:-0700\nTZOFFSETTO:-0800\nTZNAME:PST\nEND:STANDARD\nBEGIN:DAYLIGHT\nDTSTART:19870405T020000\nRRULE:FREQ=YEARLY;BYDAY=1SU;BYMONTH=4\nTZOFFSETFROM:-0800\nTZOFFSETTO:-0700\nTZNAME:PDT\nEND:DAYLIGHT\nEND:VTIMEZONE\n\"\"\"\n\nEST_TUPLE = ('EST', timedelta(hours=-5), timedelta(hours=0))\nEDT_TUPLE = ('EDT', timedelta(hours=-4), timedelta(hours=1))\n\nSUPPORTS_SUB_MINUTE_OFFSETS = sys.version_info >= (3, 6)\n\n\n###\n# Helper functions\ndef get_timezone_tuple(dt):\n    \"\"\"Retrieve a (tzname, utcoffset, dst) tuple for a given DST\"\"\"\n    return dt.tzname(), dt.utcoffset(), dt.dst()\n\n\n###\n# Mix-ins\nclass context_passthrough(object):\n    def __init__(*args, **kwargs):\n        pass\n\n    def __enter__(*args, **kwargs):\n        pass\n\n    def __exit__(*args, **kwargs):\n        pass\n\n\nclass TzFoldMixin(object):\n    \"\"\" Mix-in class for testing ambiguous times \"\"\"\n    def gettz(self, tzname):\n        raise NotImplementedError\n\n    def _get_tzname(self, tzname):\n        return tzname\n\n    def _gettz_context(self, tzname):\n        return context_passthrough()\n\n    def testFoldPositiveUTCOffset(self):\n        # Test that we can resolve ambiguous times\n        tzname = self._get_tzname('Australia/Sydney')\n\n        with self._gettz_context(tzname):\n            SYD = self.gettz(tzname)\n\n            t0_u = datetime(2012, 3, 31, 15, 30, tzinfo=tz.UTC)  # AEST\n            t1_u = datetime(2012, 3, 31, 16, 30, tzinfo=tz.UTC)  # AEDT\n\n            t0_syd0 = t0_u.astimezone(SYD)\n            t1_syd1 = t1_u.astimezone(SYD)\n\n            self.assertEqual(t0_syd0.replace(tzinfo=None),\n                             datetime(2012, 4, 1, 2, 30))\n\n            self.assertEqual(t1_syd1.replace(tzinfo=None),\n                             datetime(2012, 4, 1, 2, 30))\n\n            self.assertEqual(t0_syd0.utcoffset(), timedelta(hours=11))\n            self.assertEqual(t1_syd1.utcoffset(), timedelta(hours=10))\n\n    def testGapPositiveUTCOffset(self):\n        # Test that we don't have a problem around gaps.\n        tzname = self._get_tzname('Australia/Sydney')\n\n        with self._gettz_context(tzname):\n            SYD = self.gettz(tzname)\n\n            t0_u = datetime(2012, 10, 6, 15, 30, tzinfo=tz.UTC)  # AEST\n            t1_u = datetime(2012, 10, 6, 16, 30, tzinfo=tz.UTC)  # AEDT\n\n            t0 = t0_u.astimezone(SYD)\n            t1 = t1_u.astimezone(SYD)\n\n            self.assertEqual(t0.replace(tzinfo=None),\n                             datetime(2012, 10, 7, 1, 30))\n\n            self.assertEqual(t1.replace(tzinfo=None),\n                             datetime(2012, 10, 7, 3, 30))\n\n            self.assertEqual(t0.utcoffset(), timedelta(hours=10))\n            self.assertEqual(t1.utcoffset(), timedelta(hours=11))\n\n    def testFoldNegativeUTCOffset(self):\n            # Test that we can resolve ambiguous times\n            tzname = self._get_tzname('America/Toronto')\n\n            with self._gettz_context(tzname):\n                TOR = self.gettz(tzname)\n\n                t0_u = datetime(2011, 11, 6, 5, 30, tzinfo=tz.UTC)\n                t1_u = datetime(2011, 11, 6, 6, 30, tzinfo=tz.UTC)\n\n                t0_tor = t0_u.astimezone(TOR)\n                t1_tor = t1_u.astimezone(TOR)\n\n                self.assertEqual(t0_tor.replace(tzinfo=None),\n                                 datetime(2011, 11, 6, 1, 30))\n\n                self.assertEqual(t1_tor.replace(tzinfo=None),\n                                 datetime(2011, 11, 6, 1, 30))\n\n                self.assertNotEqual(t0_tor.tzname(), t1_tor.tzname())\n                self.assertEqual(t0_tor.utcoffset(), timedelta(hours=-4.0))\n                self.assertEqual(t1_tor.utcoffset(), timedelta(hours=-5.0))\n\n    def testGapNegativeUTCOffset(self):\n        # Test that we don't have a problem around gaps.\n        tzname = self._get_tzname('America/Toronto')\n\n        with self._gettz_context(tzname):\n            TOR = self.gettz(tzname)\n\n            t0_u = datetime(2011, 3, 13, 6, 30, tzinfo=tz.UTC)\n            t1_u = datetime(2011, 3, 13, 7, 30, tzinfo=tz.UTC)\n\n            t0 = t0_u.astimezone(TOR)\n            t1 = t1_u.astimezone(TOR)\n\n            self.assertEqual(t0.replace(tzinfo=None),\n                             datetime(2011, 3, 13, 1, 30))\n\n            self.assertEqual(t1.replace(tzinfo=None),\n                             datetime(2011, 3, 13, 3, 30))\n\n            self.assertNotEqual(t0, t1)\n            self.assertEqual(t0.utcoffset(), timedelta(hours=-5.0))\n            self.assertEqual(t1.utcoffset(), timedelta(hours=-4.0))\n\n    def testFoldLondon(self):\n        tzname = self._get_tzname('Europe/London')\n\n        with self._gettz_context(tzname):\n            LON = self.gettz(tzname)\n            UTC = tz.UTC\n\n            t0_u = datetime(2013, 10, 27, 0, 30, tzinfo=UTC)   # BST\n            t1_u = datetime(2013, 10, 27, 1, 30, tzinfo=UTC)   # GMT\n\n            t0 = t0_u.astimezone(LON)\n            t1 = t1_u.astimezone(LON)\n\n            self.assertEqual(t0.replace(tzinfo=None),\n                             datetime(2013, 10, 27, 1, 30))\n\n            self.assertEqual(t1.replace(tzinfo=None),\n                             datetime(2013, 10, 27, 1, 30))\n\n            self.assertEqual(t0.utcoffset(), timedelta(hours=1))\n            self.assertEqual(t1.utcoffset(), timedelta(hours=0))\n\n    def testFoldIndependence(self):\n        tzname = self._get_tzname('America/New_York')\n\n        with self._gettz_context(tzname):\n            NYC = self.gettz(tzname)\n            UTC = tz.UTC\n            hour = timedelta(hours=1)\n\n            # Firmly 2015-11-01 0:30 EDT-4\n            pre_dst = datetime(2015, 11, 1, 0, 30, tzinfo=NYC)\n\n            # Ambiguous between 2015-11-01 1:30 EDT-4 and 2015-11-01 1:30 EST-5\n            in_dst = pre_dst + hour\n            in_dst_tzname_0 = in_dst.tzname()     # Stash the tzname - EDT\n\n            # Doing the arithmetic in UTC creates a date that is unambiguously\n            # 2015-11-01 1:30 EDT-5\n            in_dst_via_utc = (pre_dst.astimezone(UTC) + 2*hour).astimezone(NYC)\n\n            # Make sure the dates are actually ambiguous\n            self.assertEqual(in_dst, in_dst_via_utc)\n\n            # Make sure we got the right folding behavior\n            self.assertNotEqual(in_dst_via_utc.tzname(), in_dst_tzname_0)\n\n            # Now check to make sure in_dst's tzname hasn't changed\n            self.assertEqual(in_dst_tzname_0, in_dst.tzname())\n\n    def testInZoneFoldEquality(self):\n        # Two datetimes in the same zone are considered to be equal if their\n        # wall times are equal, even if they have different absolute times.\n\n        tzname = self._get_tzname('America/New_York')\n\n        with self._gettz_context(tzname):\n            NYC = self.gettz(tzname)\n            UTC = tz.UTC\n\n            dt0 = datetime(2011, 11, 6, 1, 30, tzinfo=NYC)\n            dt1 = tz.enfold(dt0, fold=1)\n\n            # Make sure these actually represent different times\n            self.assertNotEqual(dt0.astimezone(UTC), dt1.astimezone(UTC))\n\n            # Test that they compare equal\n            self.assertEqual(dt0, dt1)\n\n    def _test_ambiguous_time(self, dt, tzid, ambiguous):\n        # This is a test to check that the individual is_ambiguous values\n        # on the _tzinfo subclasses work.\n        tzname = self._get_tzname(tzid)\n\n        with self._gettz_context(tzname):\n            tzi = self.gettz(tzname)\n\n            self.assertEqual(tz.datetime_ambiguous(dt, tz=tzi), ambiguous)\n\n    def testAmbiguousNegativeUTCOffset(self):\n        self._test_ambiguous_time(datetime(2015, 11, 1, 1, 30),\n                                  'America/New_York', True)\n\n    def testAmbiguousPositiveUTCOffset(self):\n        self._test_ambiguous_time(datetime(2012, 4, 1, 2, 30),\n                                  'Australia/Sydney', True)\n\n    def testUnambiguousNegativeUTCOffset(self):\n        self._test_ambiguous_time(datetime(2015, 11, 1, 2, 30),\n                                  'America/New_York', False)\n\n    def testUnambiguousPositiveUTCOffset(self):\n        self._test_ambiguous_time(datetime(2012, 4, 1, 3, 30),\n                                  'Australia/Sydney', False)\n\n    def testUnambiguousGapNegativeUTCOffset(self):\n        # Imaginary time\n        self._test_ambiguous_time(datetime(2011, 3, 13, 2, 30),\n                                  'America/New_York', False)\n\n    def testUnambiguousGapPositiveUTCOffset(self):\n        # Imaginary time\n        self._test_ambiguous_time(datetime(2012, 10, 7, 2, 30),\n                                  'Australia/Sydney', False)\n\n    def _test_imaginary_time(self, dt, tzid, exists):\n        tzname = self._get_tzname(tzid)\n        with self._gettz_context(tzname):\n            tzi = self.gettz(tzname)\n\n            self.assertEqual(tz.datetime_exists(dt, tz=tzi), exists)\n\n    def testImaginaryNegativeUTCOffset(self):\n        self._test_imaginary_time(datetime(2011, 3, 13, 2, 30),\n                                  'America/New_York', False)\n\n    def testNotImaginaryNegativeUTCOffset(self):\n        self._test_imaginary_time(datetime(2011, 3, 13, 1, 30),\n                                  'America/New_York', True)\n\n    def testImaginaryPositiveUTCOffset(self):\n        self._test_imaginary_time(datetime(2012, 10, 7, 2, 30),\n                                  'Australia/Sydney', False)\n\n    def testNotImaginaryPositiveUTCOffset(self):\n        self._test_imaginary_time(datetime(2012, 10, 7, 1, 30),\n                                  'Australia/Sydney', True)\n\n    def testNotImaginaryFoldNegativeUTCOffset(self):\n        self._test_imaginary_time(datetime(2015, 11, 1, 1, 30),\n                                  'America/New_York', True)\n\n    def testNotImaginaryFoldPositiveUTCOffset(self):\n        self._test_imaginary_time(datetime(2012, 4, 1, 3, 30),\n                                  'Australia/Sydney', True)\n\n    @unittest.skip(\"Known failure in Python 3.6.\")\n    def testEqualAmbiguousComparison(self):\n        tzname = self._get_tzname('Australia/Sydney')\n\n        with self._gettz_context(tzname):\n            SYD0 = self.gettz(tzname)\n            SYD1 = self.gettz(tzname)\n\n            t0_u = datetime(2012, 3, 31, 14, 30, tzinfo=tz.UTC)  # AEST\n\n            t0_syd0 = t0_u.astimezone(SYD0)\n            t0_syd1 = t0_u.astimezone(SYD1)\n\n            # This is considered an \"inter-zone comparison\" because it's an\n            # ambiguous datetime.\n            self.assertEqual(t0_syd0, t0_syd1)\n\n\nclass TzWinFoldMixin(object):\n    def get_args(self, tzname):\n        return (tzname, )\n\n    class context(object):\n        def __init__(*args, **kwargs):\n            pass\n\n        def __enter__(*args, **kwargs):\n            pass\n\n        def __exit__(*args, **kwargs):\n            pass\n\n    def get_utc_transitions(self, tzi, year, gap):\n        dston, dstoff = tzi.transitions(year)\n        if gap:\n            t_n = dston - timedelta(minutes=30)\n\n            t0_u = t_n.replace(tzinfo=tzi).astimezone(tz.UTC)\n            t1_u = t0_u + timedelta(hours=1)\n        else:\n            # Get 1 hour before the first ambiguous date\n            t_n = dstoff - timedelta(minutes=30)\n\n            t0_u = t_n.replace(tzinfo=tzi).astimezone(tz.UTC)\n            t_n += timedelta(hours=1)                   # Naive ambiguous date\n            t0_u = t0_u + timedelta(hours=1)            # First ambiguous date\n            t1_u = t0_u + timedelta(hours=1)            # Second ambiguous date\n\n        return t_n, t0_u, t1_u\n\n    def testFoldPositiveUTCOffset(self):\n        # Test that we can resolve ambiguous times\n        tzname = 'AUS Eastern Standard Time'\n        args = self.get_args(tzname)\n\n        with self.context(tzname):\n            # Calling fromutc() alters the tzfile object\n            SYD = self.tzclass(*args)\n\n            # Get the transition time in UTC from the object, because\n            # Windows doesn't store historical info\n            t_n, t0_u, t1_u = self.get_utc_transitions(SYD, 2012, False)\n\n            # Using fresh tzfiles\n            t0_syd = t0_u.astimezone(SYD)\n            t1_syd = t1_u.astimezone(SYD)\n\n            self.assertEqual(t0_syd.replace(tzinfo=None), t_n)\n\n            self.assertEqual(t1_syd.replace(tzinfo=None), t_n)\n\n            self.assertEqual(t0_syd.utcoffset(), timedelta(hours=11))\n            self.assertEqual(t1_syd.utcoffset(), timedelta(hours=10))\n            self.assertNotEqual(t0_syd.tzname(), t1_syd.tzname())\n\n    def testGapPositiveUTCOffset(self):\n        # Test that we don't have a problem around gaps.\n        tzname = 'AUS Eastern Standard Time'\n        args = self.get_args(tzname)\n\n        with self.context(tzname):\n            SYD = self.tzclass(*args)\n\n            t_n, t0_u, t1_u = self.get_utc_transitions(SYD, 2012, True)\n\n            t0 = t0_u.astimezone(SYD)\n            t1 = t1_u.astimezone(SYD)\n\n            self.assertEqual(t0.replace(tzinfo=None), t_n)\n\n            self.assertEqual(t1.replace(tzinfo=None), t_n + timedelta(hours=2))\n\n            self.assertEqual(t0.utcoffset(), timedelta(hours=10))\n            self.assertEqual(t1.utcoffset(), timedelta(hours=11))\n\n    def testFoldNegativeUTCOffset(self):\n        # Test that we can resolve ambiguous times\n        tzname = 'Eastern Standard Time'\n        args = self.get_args(tzname)\n\n        with self.context(tzname):\n            TOR = self.tzclass(*args)\n\n            t_n, t0_u, t1_u = self.get_utc_transitions(TOR, 2011, False)\n\n            t0_tor = t0_u.astimezone(TOR)\n            t1_tor = t1_u.astimezone(TOR)\n\n            self.assertEqual(t0_tor.replace(tzinfo=None), t_n)\n            self.assertEqual(t1_tor.replace(tzinfo=None), t_n)\n\n            self.assertNotEqual(t0_tor.tzname(), t1_tor.tzname())\n            self.assertEqual(t0_tor.utcoffset(), timedelta(hours=-4.0))\n            self.assertEqual(t1_tor.utcoffset(), timedelta(hours=-5.0))\n\n    def testGapNegativeUTCOffset(self):\n        # Test that we don't have a problem around gaps.\n        tzname = 'Eastern Standard Time'\n        args = self.get_args(tzname)\n\n        with self.context(tzname):\n            TOR = self.tzclass(*args)\n\n            t_n, t0_u, t1_u = self.get_utc_transitions(TOR, 2011, True)\n\n            t0 = t0_u.astimezone(TOR)\n            t1 = t1_u.astimezone(TOR)\n\n            self.assertEqual(t0.replace(tzinfo=None),\n                             t_n)\n\n            self.assertEqual(t1.replace(tzinfo=None),\n                             t_n + timedelta(hours=2))\n\n            self.assertNotEqual(t0.tzname(), t1.tzname())\n            self.assertEqual(t0.utcoffset(), timedelta(hours=-5.0))\n            self.assertEqual(t1.utcoffset(), timedelta(hours=-4.0))\n\n    def testFoldIndependence(self):\n        tzname = 'Eastern Standard Time'\n        args = self.get_args(tzname)\n\n        with self.context(tzname):\n            NYC = self.tzclass(*args)\n            UTC = tz.UTC\n            hour = timedelta(hours=1)\n\n            # Firmly 2015-11-01 0:30 EDT-4\n            t_n, t0_u, t1_u = self.get_utc_transitions(NYC, 2015, False)\n\n            pre_dst = (t_n - hour).replace(tzinfo=NYC)\n\n            # Currently, there's no way around the fact that this resolves to an\n            # ambiguous date, which defaults to EST. I'm not hard-coding in the\n            # answer, though, because the preferred behavior would be that this\n            # results in a time on the EDT side.\n\n            # Ambiguous between 2015-11-01 1:30 EDT-4 and 2015-11-01 1:30 EST-5\n            in_dst = pre_dst + hour\n            in_dst_tzname_0 = in_dst.tzname()     # Stash the tzname - EDT\n\n            # Doing the arithmetic in UTC creates a date that is unambiguously\n            # 2015-11-01 1:30 EDT-5\n            in_dst_via_utc = (pre_dst.astimezone(UTC) + 2*hour).astimezone(NYC)\n\n            # Make sure we got the right folding behavior\n            self.assertNotEqual(in_dst_via_utc.tzname(), in_dst_tzname_0)\n\n            # Now check to make sure in_dst's tzname hasn't changed\n            self.assertEqual(in_dst_tzname_0, in_dst.tzname())\n\n    def testInZoneFoldEquality(self):\n        # Two datetimes in the same zone are considered to be equal if their\n        # wall times are equal, even if they have different absolute times.\n        tzname = 'Eastern Standard Time'\n        args = self.get_args(tzname)\n\n        with self.context(tzname):\n            NYC = self.tzclass(*args)\n            UTC = tz.UTC\n\n            t_n, t0_u, t1_u = self.get_utc_transitions(NYC, 2011, False)\n\n            dt0 = t_n.replace(tzinfo=NYC)\n            dt1 = tz.enfold(dt0, fold=1)\n\n            # Make sure these actually represent different times\n            self.assertNotEqual(dt0.astimezone(UTC), dt1.astimezone(UTC))\n\n            # Test that they compare equal\n            self.assertEqual(dt0, dt1)\n\n###\n# Test Cases\nclass TzUTCTest(unittest.TestCase):\n    def testSingleton(self):\n        UTC_0 = tz.tzutc()\n        UTC_1 = tz.tzutc()\n\n        self.assertIs(UTC_0, UTC_1)\n\n    def testOffset(self):\n        ct = datetime(2009, 4, 1, 12, 11, 13, tzinfo=tz.tzutc())\n\n        self.assertEqual(ct.utcoffset(), timedelta(seconds=0))\n\n    def testDst(self):\n        ct = datetime(2009, 4, 1, 12, 11, 13, tzinfo=tz.tzutc())\n\n        self.assertEqual(ct.dst(), timedelta(seconds=0))\n\n    def testTzName(self):\n        ct = datetime(2009, 4, 1, 12, 11, 13, tzinfo=tz.tzutc())\n        self.assertEqual(ct.tzname(), 'UTC')\n\n    def testEquality(self):\n        UTC0 = tz.tzutc()\n        UTC1 = tz.tzutc()\n\n        self.assertEqual(UTC0, UTC1)\n\n    def testInequality(self):\n        UTC = tz.tzutc()\n        UTCp4 = tz.tzoffset('UTC+4', 14400)\n\n        self.assertNotEqual(UTC, UTCp4)\n\n    def testInequalityInteger(self):\n        self.assertFalse(tz.tzutc() == 7)\n        self.assertNotEqual(tz.tzutc(), 7)\n\n    def testInequalityUnsupported(self):\n        self.assertEqual(tz.tzutc(), ComparesEqual)\n\n    def testRepr(self):\n        UTC = tz.tzutc()\n        self.assertEqual(repr(UTC), 'tzutc()')\n\n    def testTimeOnlyUTC(self):\n        # https://github.com/dateutil/dateutil/issues/132\n        # tzutc doesn't care\n        tz_utc = tz.tzutc()\n        self.assertEqual(dt_time(13, 20, tzinfo=tz_utc).utcoffset(),\n                         timedelta(0))\n\n    def testAmbiguity(self):\n        # Pick an arbitrary datetime, this should always return False.\n        dt = datetime(2011, 9, 1, 2, 30, tzinfo=tz.tzutc())\n\n        self.assertFalse(tz.datetime_ambiguous(dt))\n\n\n@pytest.mark.tzoffset\nclass TzOffsetTest(unittest.TestCase):\n    def testTimedeltaOffset(self):\n        est = tz.tzoffset('EST', timedelta(hours=-5))\n        est_s = tz.tzoffset('EST', -18000)\n\n        self.assertEqual(est, est_s)\n\n    def testTzNameNone(self):\n        gmt5 = tz.tzoffset(None, -18000)       # -5:00\n        self.assertIs(datetime(2003, 10, 26, 0, 0, tzinfo=gmt5).tzname(),\n                      None)\n\n    def testTimeOnlyOffset(self):\n        # tzoffset doesn't care\n        tz_offset = tz.tzoffset('+3', 3600)\n        self.assertEqual(dt_time(13, 20, tzinfo=tz_offset).utcoffset(),\n                         timedelta(seconds=3600))\n\n    def testTzOffsetRepr(self):\n        tname = 'EST'\n        tzo = tz.tzoffset(tname, -5 * 3600)\n        self.assertEqual(repr(tzo), \"tzoffset(\" + repr(tname) + \", -18000)\")\n\n    def testEquality(self):\n        utc = tz.tzoffset('UTC', 0)\n        gmt = tz.tzoffset('GMT', 0)\n\n        self.assertEqual(utc, gmt)\n\n    def testUTCEquality(self):\n        utc = tz.UTC\n        o_utc = tz.tzoffset('UTC', 0)\n\n        self.assertEqual(utc, o_utc)\n        self.assertEqual(o_utc, utc)\n\n    def testInequalityInvalid(self):\n        tzo = tz.tzoffset('-3', -3 * 3600)\n        self.assertFalse(tzo == -3)\n        self.assertNotEqual(tzo, -3)\n\n    def testInequalityUnsupported(self):\n        tzo = tz.tzoffset('-5', -5 * 3600)\n\n        self.assertTrue(tzo == ComparesEqual)\n        self.assertFalse(tzo != ComparesEqual)\n        self.assertEqual(tzo, ComparesEqual)\n\n    def testAmbiguity(self):\n        # Pick an arbitrary datetime, this should always return False.\n        dt = datetime(2011, 9, 1, 2, 30, tzinfo=tz.tzoffset(\"EST\", -5 * 3600))\n\n        self.assertFalse(tz.datetime_ambiguous(dt))\n\n    def testTzOffsetInstance(self):\n        tz1 = tz.tzoffset.instance('EST', timedelta(hours=-5))\n        tz2 = tz.tzoffset.instance('EST', timedelta(hours=-5))\n\n        assert tz1 is not tz2\n\n    def testTzOffsetSingletonDifferent(self):\n        tz1 = tz.tzoffset('EST', timedelta(hours=-5))\n        tz2 = tz.tzoffset('EST', -18000)\n\n        assert tz1 is tz2\n\n\n@pytest.mark.smoke\n@pytest.mark.tzoffset\ndef test_tzoffset_weakref():\n    UTC1 = tz.tzoffset('UTC', 0)\n    UTC_ref = weakref.ref(tz.tzoffset('UTC', 0))\n    UTC1 is UTC_ref()\n    del UTC1\n    gc.collect()\n\n    assert UTC_ref() is not None    # Should be in the strong cache\n    assert UTC_ref() is tz.tzoffset('UTC', 0)\n\n    # Fill the strong cache with other items\n    for offset in range(5,15):\n        tz.tzoffset('RandomZone', offset)\n\n    gc.collect()\n    assert UTC_ref() is  None\n    assert UTC_ref() is not tz.tzoffset('UTC', 0)\n\n\n@pytest.mark.tzoffset\n@pytest.mark.parametrize('args', [\n    ('UTC', 0),\n    ('EST', -18000),\n    ('EST', timedelta(hours=-5)),\n    (None, timedelta(hours=3)),\n])\ndef test_tzoffset_singleton(args):\n    tz1 = tz.tzoffset(*args)\n    tz2 = tz.tzoffset(*args)\n\n    assert tz1 is tz2\n\n\n@pytest.mark.tzoffset\n@pytest.mark.skipif(not SUPPORTS_SUB_MINUTE_OFFSETS,\n                    reason='Sub-minute offsets not supported')\ndef test_tzoffset_sub_minute():\n    delta = timedelta(hours=12, seconds=30)\n    test_datetime = datetime(2000, 1, 1, tzinfo=tz.tzoffset(None, delta))\n    assert test_datetime.utcoffset() == delta\n\n\n@pytest.mark.tzoffset\n@pytest.mark.skipif(SUPPORTS_SUB_MINUTE_OFFSETS,\n                    reason='Sub-minute offsets supported')\ndef test_tzoffset_sub_minute_rounding():\n    delta = timedelta(hours=12, seconds=30)\n    test_date = datetime(2000, 1, 1, tzinfo=tz.tzoffset(None, delta))\n    assert test_date.utcoffset() == timedelta(hours=12, minutes=1)\n\n\n@pytest.mark.tzlocal\nclass TzLocalTest(unittest.TestCase):\n    def testEquality(self):\n        tz1 = tz.tzlocal()\n        tz2 = tz.tzlocal()\n\n        # Explicitly calling == and != here to ensure the operators work\n        self.assertTrue(tz1 == tz2)\n        self.assertFalse(tz1 != tz2)\n\n    def testInequalityFixedOffset(self):\n        tzl = tz.tzlocal()\n        tzos = tz.tzoffset('LST', tzl._std_offset.total_seconds())\n        tzod = tz.tzoffset('LDT', tzl._std_offset.total_seconds())\n\n        self.assertFalse(tzl == tzos)\n        self.assertFalse(tzl == tzod)\n        self.assertTrue(tzl != tzos)\n        self.assertTrue(tzl != tzod)\n\n    def testInequalityInvalid(self):\n        tzl = tz.tzlocal()\n\n        self.assertTrue(tzl != 1)\n        self.assertFalse(tzl == 1)\n\n        # TODO: Use some sort of universal local mocking so that it's clear\n        # that we're expecting tzlocal to *not* be Pacific/Kiritimati\n        LINT = tz.gettz('Pacific/Kiritimati')\n        self.assertTrue(tzl != LINT)\n        self.assertFalse(tzl == LINT)\n\n    def testInequalityUnsupported(self):\n        tzl = tz.tzlocal()\n\n        self.assertTrue(tzl == ComparesEqual)\n        self.assertFalse(tzl != ComparesEqual)\n\n    def testRepr(self):\n        tzl = tz.tzlocal()\n\n        self.assertEqual(repr(tzl), 'tzlocal()')\n\n\n@pytest.mark.parametrize('args,kwargs', [\n    (('EST', -18000), {}),\n    (('EST', timedelta(hours=-5)), {}),\n    (('EST',), {'offset': -18000}),\n    (('EST',), {'offset': timedelta(hours=-5)}),\n    (tuple(), {'name': 'EST', 'offset': -18000})\n])\ndef test_tzoffset_is(args, kwargs):\n    tz_ref = tz.tzoffset('EST', -18000)\n    assert tz.tzoffset(*args, **kwargs) is tz_ref\n\n\ndef test_tzoffset_is_not():\n    assert tz.tzoffset('EDT', -14400) is not tz.tzoffset('EST', -18000)\n\n\n@pytest.mark.tzlocal\n@unittest.skipIf(IS_WIN, \"requires Unix\")\nclass TzLocalNixTest(unittest.TestCase, TzFoldMixin):\n    # This is a set of tests for `tzlocal()` on *nix systems\n\n    # POSIX string indicating change to summer time on the 2nd Sunday in March\n    # at 2AM, and ending the 1st Sunday in November at 2AM. (valid >= 2007)\n    TZ_EST = 'EST+5EDT,M3.2.0/2,M11.1.0/2'\n\n    # POSIX string for AEST/AEDT (valid >= 2008)\n    TZ_AEST = 'AEST-10AEDT,M10.1.0/2,M4.1.0/3'\n\n    # POSIX string for BST/GMT\n    TZ_LON = 'GMT0BST,M3.5.0,M10.5.0'\n\n    # POSIX string for UTC\n    UTC = 'UTC'\n\n    def gettz(self, tzname):\n        # Actual time zone changes are handled by the _gettz_context function\n        return tz.tzlocal()\n\n    def _gettz_context(self, tzname):\n        tzname_map = {'Australia/Sydney': self.TZ_AEST,\n                      'America/Toronto': self.TZ_EST,\n                      'America/New_York': self.TZ_EST,\n                      'Europe/London': self.TZ_LON}\n\n        return TZEnvContext(tzname_map.get(tzname, tzname))\n\n    def _testTzFunc(self, tzval, func, std_val, dst_val):\n        \"\"\"\n        This generates tests about how the behavior of a function ``func``\n        changes between STD and DST (e.g. utcoffset, tzname, dst).\n\n        It assume that DST starts the 2nd Sunday in March and ends the 1st\n        Sunday in November\n        \"\"\"\n        with TZEnvContext(tzval):\n            dt1 = datetime(2015, 2, 1, 12, 0, tzinfo=tz.tzlocal())  # STD\n            dt2 = datetime(2015, 5, 1, 12, 0, tzinfo=tz.tzlocal())  # DST\n\n            self.assertEqual(func(dt1), std_val)\n            self.assertEqual(func(dt2), dst_val)\n\n    def _testTzName(self, tzval, std_name, dst_name):\n        func = datetime.tzname\n\n        self._testTzFunc(tzval, func, std_name, dst_name)\n\n    def testTzNameDST(self):\n        # Test tzname in a zone with DST\n        self._testTzName(self.TZ_EST, 'EST', 'EDT')\n\n    def testTzNameUTC(self):\n        # Test tzname in a zone without DST\n        self._testTzName(self.UTC, 'UTC', 'UTC')\n\n    def _testOffset(self, tzval, std_off, dst_off):\n        func = datetime.utcoffset\n\n        self._testTzFunc(tzval, func, std_off, dst_off)\n\n    def testOffsetDST(self):\n        self._testOffset(self.TZ_EST, timedelta(hours=-5), timedelta(hours=-4))\n\n    def testOffsetUTC(self):\n        self._testOffset(self.UTC, timedelta(0), timedelta(0))\n\n    def _testDST(self, tzval, dst_dst):\n        func = datetime.dst\n        std_dst = timedelta(0)\n\n        self._testTzFunc(tzval, func, std_dst, dst_dst)\n\n    def testDSTDST(self):\n        self._testDST(self.TZ_EST, timedelta(hours=1))\n\n    def testDSTUTC(self):\n        self._testDST(self.UTC, timedelta(0))\n\n    def testTimeOnlyOffsetLocalUTC(self):\n        with TZEnvContext(self.UTC):\n            self.assertEqual(dt_time(13, 20, tzinfo=tz.tzlocal()).utcoffset(),\n                             timedelta(0))\n\n    def testTimeOnlyOffsetLocalDST(self):\n        with TZEnvContext(self.TZ_EST):\n            self.assertIs(dt_time(13, 20, tzinfo=tz.tzlocal()).utcoffset(),\n                          None)\n\n    def testTimeOnlyDSTLocalUTC(self):\n        with TZEnvContext(self.UTC):\n            self.assertEqual(dt_time(13, 20, tzinfo=tz.tzlocal()).dst(),\n                             timedelta(0))\n\n    def testTimeOnlyDSTLocalDST(self):\n        with TZEnvContext(self.TZ_EST):\n            self.assertIs(dt_time(13, 20, tzinfo=tz.tzlocal()).dst(),\n                          None)\n\n    def testUTCEquality(self):\n        with TZEnvContext(self.UTC):\n            assert tz.tzlocal() == tz.UTC\n\n\n# TODO: Maybe a better hack than this?\ndef mark_tzlocal_nix(f):\n    marks = [\n        pytest.mark.tzlocal,\n        pytest.mark.skipif(IS_WIN, reason='requires Unix'),\n    ]\n\n    for mark in reversed(marks):\n        f = mark(f)\n\n    return f\n\n\n@mark_tzlocal_nix\n@pytest.mark.parametrize('tzvar', ['UTC', 'GMT0', 'UTC0'])\ndef test_tzlocal_utc_equal(tzvar):\n    with TZEnvContext(tzvar):\n        assert tz.tzlocal() == tz.UTC\n\n\n@mark_tzlocal_nix\n@pytest.mark.parametrize('tzvar', [\n    'Europe/London', 'America/New_York',\n    'GMT0BST', 'EST5EDT'])\ndef test_tzlocal_utc_unequal(tzvar):\n    with TZEnvContext(tzvar):\n        assert tz.tzlocal() != tz.UTC\n\n\n@mark_tzlocal_nix\ndef test_tzlocal_local_time_trim_colon():\n    with TZEnvContext(':/etc/localtime'):\n        assert tz.gettz() is not None\n\n\n@mark_tzlocal_nix\n@pytest.mark.parametrize('tzvar, tzoff', [\n    ('EST5', tz.tzoffset('EST', -18000)),\n    ('GMT0', tz.tzoffset('GMT', 0)),\n    ('YAKT-9', tz.tzoffset('YAKT', timedelta(hours=9))),\n    ('JST-9', tz.tzoffset('JST', timedelta(hours=9))),\n])\ndef test_tzlocal_offset_equal(tzvar, tzoff):\n    with TZEnvContext(tzvar):\n        # Including both to test both __eq__ and __ne__\n        assert tz.tzlocal() == tzoff\n        assert not (tz.tzlocal() != tzoff)\n\n\n@mark_tzlocal_nix\n@pytest.mark.parametrize('tzvar, tzoff', [\n    ('EST5EDT', tz.tzoffset('EST', -18000)),\n    ('GMT0BST', tz.tzoffset('GMT', 0)),\n    ('EST5', tz.tzoffset('EST', -14400)),\n    ('YAKT-9', tz.tzoffset('JST', timedelta(hours=9))),\n    ('JST-9', tz.tzoffset('YAKT', timedelta(hours=9))),\n])\ndef test_tzlocal_offset_unequal(tzvar, tzoff):\n    with TZEnvContext(tzvar):\n        # Including both to test both __eq__ and __ne__\n        assert tz.tzlocal() != tzoff\n        assert not (tz.tzlocal() == tzoff)\n\n\n@pytest.mark.gettz\nclass GettzTest(unittest.TestCase, TzFoldMixin):\n    gettz = staticmethod(tz.gettz)\n\n    def testGettz(self):\n        # bug 892569\n        str(self.gettz('UTC'))\n\n    def testGetTzEquality(self):\n        self.assertEqual(self.gettz('UTC'), self.gettz('UTC'))\n\n    def testTimeOnlyGettz(self):\n        # gettz returns None\n        tz_get = self.gettz('Europe/Minsk')\n        self.assertIs(dt_time(13, 20, tzinfo=tz_get).utcoffset(), None)\n\n    def testTimeOnlyGettzDST(self):\n        # gettz returns None\n        tz_get = self.gettz('Europe/Minsk')\n        self.assertIs(dt_time(13, 20, tzinfo=tz_get).dst(), None)\n\n    def testTimeOnlyGettzTzName(self):\n        tz_get = self.gettz('Europe/Minsk')\n        self.assertIs(dt_time(13, 20, tzinfo=tz_get).tzname(), None)\n\n    def testTimeOnlyFormatZ(self):\n        tz_get = self.gettz('Europe/Minsk')\n        t = dt_time(13, 20, tzinfo=tz_get)\n\n        self.assertEqual(t.strftime('%H%M%Z'), '1320')\n\n    def testPortugalDST(self):\n        # In 1996, Portugal changed from CET to WET\n        PORTUGAL = self.gettz('Portugal')\n\n        t_cet = datetime(1996, 3, 31, 1, 59, tzinfo=PORTUGAL)\n\n        self.assertEqual(t_cet.tzname(), 'CET')\n        self.assertEqual(t_cet.utcoffset(), timedelta(hours=1))\n        self.assertEqual(t_cet.dst(), timedelta(0))\n\n        t_west = datetime(1996, 3, 31, 2, 1, tzinfo=PORTUGAL)\n\n        self.assertEqual(t_west.tzname(), 'WEST')\n        self.assertEqual(t_west.utcoffset(), timedelta(hours=1))\n        self.assertEqual(t_west.dst(), timedelta(hours=1))\n\n    def testGettzCacheTzFile(self):\n        NYC1 = tz.gettz('America/New_York')\n        NYC2 = tz.gettz('America/New_York')\n\n        assert NYC1 is NYC2\n\n    def testGettzCacheTzLocal(self):\n        local1 = tz.gettz()\n        local2 = tz.gettz()\n\n        assert local1 is not local2\n\n\n@pytest.mark.gettz\ndef test_gettz_same_result_for_none_and_empty_string():\n    local_from_none = tz.gettz()\n    local_from_empty_string = tz.gettz(\"\")\n    assert local_from_none is not None\n    assert local_from_empty_string is not None\n    assert local_from_none == local_from_empty_string\n\n\n@pytest.mark.gettz\n@pytest.mark.parametrize('badzone', [\n    'Fake.Region/Abcdefghijklmnop',  # Violates several tz project name rules\n])\ndef test_gettz_badzone(badzone):\n    # Make sure passing a bad TZ string to gettz returns None (GH #800)\n    tzi = tz.gettz(badzone)\n    assert tzi is None\n\n\n@pytest.mark.gettz\ndef test_gettz_badzone_unicode():\n    # Make sure a unicode string can be passed to TZ (GH #802)\n    # When fixed, combine this with test_gettz_badzone\n    tzi = tz.gettz('\ud83d\udc3c')\n    assert tzi is None\n\n\n@pytest.mark.gettz\n@pytest.mark.parametrize(\n    \"badzone,exc_reason\",\n    [\n        pytest.param(\n            b\"America/New_York\",\n            \".*should be str, not bytes.*\",\n            id=\"bytes on Python 3\",\n            marks=[\n                pytest.mark.skipif(\n                    PY2, reason=\"bytes arguments accepted in Python 2\"\n                )\n            ],\n        ),\n        pytest.param(\n            object(),\n            None,\n            id=\"no startswith()\",\n            marks=[\n                pytest.mark.xfail(reason=\"AttributeError instead of TypeError\",\n                                  raises=AttributeError),\n            ],\n        ),\n    ],\n)\ndef test_gettz_zone_wrong_type(badzone, exc_reason):\n    with pytest.raises(TypeError, match=exc_reason):\n        tz.gettz(badzone)\n\n\n@pytest.mark.gettz\n@pytest.mark.xfail(IS_WIN, reason='zoneinfo separately cached')\ndef test_gettz_cache_clear():\n    NYC1 = tz.gettz('America/New_York')\n    tz.gettz.cache_clear()\n\n    NYC2 = tz.gettz('America/New_York')\n\n    assert NYC1 is not NYC2\n\n@pytest.mark.gettz\n@pytest.mark.xfail(IS_WIN, reason='zoneinfo separately cached')\ndef test_gettz_set_cache_size():\n    tz.gettz.cache_clear()\n    tz.gettz.set_cache_size(3)\n\n    MONACO_ref = weakref.ref(tz.gettz('Europe/Monaco'))\n    EASTER_ref = weakref.ref(tz.gettz('Pacific/Easter'))\n    CURRIE_ref = weakref.ref(tz.gettz('Australia/Currie'))\n\n    gc.collect()\n\n    assert MONACO_ref() is not None\n    assert EASTER_ref() is not None\n    assert CURRIE_ref() is not None\n\n    tz.gettz.set_cache_size(2)\n    gc.collect()\n\n    assert MONACO_ref() is None\n\n@pytest.mark.xfail(IS_WIN, reason=\"Windows does not use system zoneinfo\")\n@pytest.mark.smoke\n@pytest.mark.gettz\ndef test_gettz_weakref():\n    tz.gettz.cache_clear()\n    tz.gettz.set_cache_size(2)\n    NYC1 = tz.gettz('America/New_York')\n    NYC_ref = weakref.ref(tz.gettz('America/New_York'))\n\n    assert NYC1 is NYC_ref()\n\n    del NYC1\n    gc.collect()\n\n    assert NYC_ref() is not None        # Should still be in the strong cache\n    assert tz.gettz('America/New_York') is NYC_ref()\n\n    # Populate strong cache with other timezones\n    tz.gettz('Europe/Monaco')\n    tz.gettz('Pacific/Easter')\n    tz.gettz('Australia/Currie')\n\n    gc.collect()\n    assert NYC_ref() is None    # Should have been pushed out\n    assert tz.gettz('America/New_York') is not NYC_ref()\n\nclass ZoneInfoGettzTest(GettzTest):\n    def gettz(self, name):\n        zoneinfo_file = zoneinfo.get_zonefile_instance()\n        return zoneinfo_file.get(name)\n\n    def testZoneInfoFileStart1(self):\n        tz = self.gettz(\"EST5EDT\")\n        self.assertEqual(datetime(2003, 4, 6, 1, 59, tzinfo=tz).tzname(), \"EST\",\n                         MISSING_TARBALL)\n        self.assertEqual(datetime(2003, 4, 6, 2, 00, tzinfo=tz).tzname(), \"EDT\")\n\n    def testZoneInfoFileEnd1(self):\n        tzc = self.gettz(\"EST5EDT\")\n        self.assertEqual(datetime(2003, 10, 26, 0, 59, tzinfo=tzc).tzname(),\n                         \"EDT\", MISSING_TARBALL)\n\n        end_est = tz.enfold(datetime(2003, 10, 26, 1, 00, tzinfo=tzc), fold=1)\n        self.assertEqual(end_est.tzname(), \"EST\")\n\n    def testZoneInfoOffsetSignal(self):\n        utc = self.gettz(\"UTC\")\n        nyc = self.gettz(\"America/New_York\")\n        self.assertNotEqual(utc, None, MISSING_TARBALL)\n        self.assertNotEqual(nyc, None)\n        t0 = datetime(2007, 11, 4, 0, 30, tzinfo=nyc)\n        t1 = t0.astimezone(utc)\n        t2 = t1.astimezone(nyc)\n        self.assertEqual(t0, t2)\n        self.assertEqual(nyc.dst(t0), timedelta(hours=1))\n\n    def testZoneInfoCopy(self):\n        # copy.copy() called on a ZoneInfo file was returning the same instance\n        CHI = self.gettz('America/Chicago')\n        CHI_COPY = copy.copy(CHI)\n\n        self.assertIsNot(CHI, CHI_COPY)\n        self.assertEqual(CHI, CHI_COPY)\n\n    def testZoneInfoDeepCopy(self):\n        CHI = self.gettz('America/Chicago')\n        CHI_COPY = copy.deepcopy(CHI)\n\n        self.assertIsNot(CHI, CHI_COPY)\n        self.assertEqual(CHI, CHI_COPY)\n\n    def testZoneInfoInstanceCaching(self):\n        zif_0 = zoneinfo.get_zonefile_instance()\n        zif_1 = zoneinfo.get_zonefile_instance()\n\n        self.assertIs(zif_0, zif_1)\n\n    def testZoneInfoNewInstance(self):\n        zif_0 = zoneinfo.get_zonefile_instance()\n        zif_1 = zoneinfo.get_zonefile_instance(new_instance=True)\n        zif_2 = zoneinfo.get_zonefile_instance()\n\n        self.assertIsNot(zif_0, zif_1)\n        self.assertIs(zif_1, zif_2)\n\n    def testZoneInfoDeprecated(self):\n        with pytest.warns(DeprecationWarning):\n            zoneinfo.gettz('US/Eastern')\n\n    def testZoneInfoMetadataDeprecated(self):\n        with pytest.warns(DeprecationWarning):\n            zoneinfo.gettz_db_metadata()\n\n\nclass TZRangeTest(unittest.TestCase, TzFoldMixin):\n    TZ_EST = tz.tzrange('EST', timedelta(hours=-5),\n                        'EDT', timedelta(hours=-4),\n                        start=relativedelta(month=3, day=1, hour=2,\n                                            weekday=SU(+2)),\n                        end=relativedelta(month=11, day=1, hour=1,\n                                          weekday=SU(+1)))\n\n    TZ_AEST = tz.tzrange('AEST', timedelta(hours=10),\n                         'AEDT', timedelta(hours=11),\n                         start=relativedelta(month=10, day=1, hour=2,\n                                             weekday=SU(+1)),\n                         end=relativedelta(month=4, day=1, hour=2,\n                                           weekday=SU(+1)))\n\n    TZ_LON = tz.tzrange('GMT', timedelta(hours=0),\n                        'BST', timedelta(hours=1),\n                        start=relativedelta(month=3, day=31, weekday=SU(-1),\n                                            hours=2),\n                        end=relativedelta(month=10, day=31, weekday=SU(-1),\n                                          hours=1))\n    # POSIX string for UTC\n    UTC = 'UTC'\n\n    def gettz(self, tzname):\n        tzname_map = {'Australia/Sydney': self.TZ_AEST,\n                      'America/Toronto': self.TZ_EST,\n                      'America/New_York': self.TZ_EST,\n                      'Europe/London': self.TZ_LON}\n\n        return tzname_map[tzname]\n\n    def testRangeCmp1(self):\n        self.assertEqual(tz.tzstr(\"EST5EDT\"),\n                         tz.tzrange(\"EST\", -18000, \"EDT\", -14400,\n                                 relativedelta(hours=+2,\n                                               month=4, day=1,\n                                               weekday=SU(+1)),\n                                 relativedelta(hours=+1,\n                                               month=10, day=31,\n                                               weekday=SU(-1))))\n\n    def testRangeCmp2(self):\n        self.assertEqual(tz.tzstr(\"EST5EDT\"),\n                         tz.tzrange(\"EST\", -18000, \"EDT\"))\n\n    def testRangeOffsets(self):\n        TZR = tz.tzrange('EST', -18000, 'EDT', -14400,\n                         start=relativedelta(hours=2, month=4, day=1,\n                                             weekday=SU(+2)),\n                         end=relativedelta(hours=1, month=10, day=31,\n                                           weekday=SU(-1)))\n\n        dt_std = datetime(2014, 4, 11, 12, 0, tzinfo=TZR)  # STD\n        dt_dst = datetime(2016, 4, 11, 12, 0, tzinfo=TZR)  # DST\n\n        dst_zero = timedelta(0)\n        dst_hour = timedelta(hours=1)\n\n        std_offset = timedelta(hours=-5)\n        dst_offset = timedelta(hours=-4)\n\n        # Check dst()\n        self.assertEqual(dt_std.dst(), dst_zero)\n        self.assertEqual(dt_dst.dst(), dst_hour)\n\n        # Check utcoffset()\n        self.assertEqual(dt_std.utcoffset(), std_offset)\n        self.assertEqual(dt_dst.utcoffset(), dst_offset)\n\n        # Check tzname\n        self.assertEqual(dt_std.tzname(), 'EST')\n        self.assertEqual(dt_dst.tzname(), 'EDT')\n\n    def testTimeOnlyRangeFixed(self):\n        # This is a fixed-offset zone, so tzrange allows this\n        tz_range = tz.tzrange('dflt', stdoffset=timedelta(hours=-3))\n        self.assertEqual(dt_time(13, 20, tzinfo=tz_range).utcoffset(),\n                         timedelta(hours=-3))\n\n    def testTimeOnlyRange(self):\n        # tzrange returns None because this zone has DST\n        tz_range = tz.tzrange('EST', timedelta(hours=-5),\n                              'EDT', timedelta(hours=-4))\n        self.assertIs(dt_time(13, 20, tzinfo=tz_range).utcoffset(), None)\n\n    def testBrokenIsDstHandling(self):\n        # tzrange._isdst() was using a date() rather than a datetime().\n        # Issue reported by Lennart Regebro.\n        dt = datetime(2007, 8, 6, 4, 10, tzinfo=tz.UTC)\n        self.assertEqual(dt.astimezone(tz=tz.gettz(\"GMT+2\")),\n                          datetime(2007, 8, 6, 6, 10, tzinfo=tz.tzstr(\"GMT+2\")))\n\n    def testRangeTimeDelta(self):\n        # Test that tzrange can be specified with a timedelta instead of an int.\n        EST5EDT_td = tz.tzrange('EST', timedelta(hours=-5),\n                                'EDT', timedelta(hours=-4))\n\n        EST5EDT_sec = tz.tzrange('EST', -18000,\n                                 'EDT', -14400)\n\n        self.assertEqual(EST5EDT_td, EST5EDT_sec)\n\n    def testRangeEquality(self):\n        TZR1 = tz.tzrange('EST', -18000, 'EDT', -14400)\n\n        # Standard abbreviation different\n        TZR2 = tz.tzrange('ET', -18000, 'EDT', -14400)\n        self.assertNotEqual(TZR1, TZR2)\n\n        # DST abbreviation different\n        TZR3 = tz.tzrange('EST', -18000, 'EMT', -14400)\n        self.assertNotEqual(TZR1, TZR3)\n\n        # STD offset different\n        TZR4 = tz.tzrange('EST', -14000, 'EDT', -14400)\n        self.assertNotEqual(TZR1, TZR4)\n\n        # DST offset different\n        TZR5 = tz.tzrange('EST', -18000, 'EDT', -18000)\n        self.assertNotEqual(TZR1, TZR5)\n\n        # Start delta different\n        TZR6 = tz.tzrange('EST', -18000, 'EDT', -14400,\n                          start=relativedelta(hours=+1, month=3,\n                                              day=1, weekday=SU(+2)))\n        self.assertNotEqual(TZR1, TZR6)\n\n        # End delta different\n        TZR7 = tz.tzrange('EST', -18000, 'EDT', -14400,\n            end=relativedelta(hours=+1, month=11,\n                              day=1, weekday=SU(+2)))\n        self.assertNotEqual(TZR1, TZR7)\n\n    def testRangeInequalityUnsupported(self):\n        TZR = tz.tzrange('EST', -18000, 'EDT', -14400)\n\n        self.assertFalse(TZR == 4)\n        self.assertTrue(TZR == ComparesEqual)\n        self.assertFalse(TZR != ComparesEqual)\n\n\n@pytest.mark.tzstr\nclass TZStrTest(unittest.TestCase, TzFoldMixin):\n    # POSIX string indicating change to summer time on the 2nd Sunday in March\n    # at 2AM, and ending the 1st Sunday in November at 2AM. (valid >= 2007)\n    TZ_EST = 'EST+5EDT,M3.2.0/2,M11.1.0/2'\n\n    # POSIX string for AEST/AEDT (valid >= 2008)\n    TZ_AEST = 'AEST-10AEDT,M10.1.0/2,M4.1.0/3'\n\n    # POSIX string for GMT/BST\n    TZ_LON = 'GMT0BST,M3.5.0,M10.5.0'\n\n    def gettz(self, tzname):\n        # Actual time zone changes are handled by the _gettz_context function\n        tzname_map = {'Australia/Sydney': self.TZ_AEST,\n                      'America/Toronto': self.TZ_EST,\n                      'America/New_York': self.TZ_EST,\n                      'Europe/London': self.TZ_LON}\n\n        return tz.tzstr(tzname_map[tzname])\n\n    def testStrStr(self):\n        # Test that tz.tzstr() won't throw an error if given a str instead\n        # of a unicode literal.\n        self.assertEqual(datetime(2003, 4, 6, 1, 59,\n                                  tzinfo=tz.tzstr(str(\"EST5EDT\"))).tzname(), \"EST\")\n        self.assertEqual(datetime(2003, 4, 6, 2, 00,\n                                  tzinfo=tz.tzstr(str(\"EST5EDT\"))).tzname(), \"EDT\")\n\n    def testStrInequality(self):\n        TZS1 = tz.tzstr('EST5EDT4')\n\n        # Standard abbreviation different\n        TZS2 = tz.tzstr('ET5EDT4')\n        self.assertNotEqual(TZS1, TZS2)\n\n        # DST abbreviation different\n        TZS3 = tz.tzstr('EST5EMT')\n        self.assertNotEqual(TZS1, TZS3)\n\n        # STD offset different\n        TZS4 = tz.tzstr('EST4EDT4')\n        self.assertNotEqual(TZS1, TZS4)\n\n        # DST offset different\n        TZS5 = tz.tzstr('EST5EDT3')\n        self.assertNotEqual(TZS1, TZS5)\n\n    def testStrInequalityStartEnd(self):\n        TZS1 = tz.tzstr('EST5EDT4')\n\n        # Start delta different\n        TZS2 = tz.tzstr('EST5EDT4,M4.2.0/02:00:00,M10-5-0/02:00')\n        self.assertNotEqual(TZS1, TZS2)\n\n        # End delta different\n        TZS3 = tz.tzstr('EST5EDT4,M4.2.0/02:00:00,M11-5-0/02:00')\n        self.assertNotEqual(TZS1, TZS3)\n\n    def testPosixOffset(self):\n        TZ1 = tz.tzstr('UTC-3')\n        self.assertEqual(datetime(2015, 1, 1, tzinfo=TZ1).utcoffset(),\n                         timedelta(hours=-3))\n\n        TZ2 = tz.tzstr('UTC-3', posix_offset=True)\n        self.assertEqual(datetime(2015, 1, 1, tzinfo=TZ2).utcoffset(),\n                         timedelta(hours=+3))\n\n    def testStrInequalityUnsupported(self):\n        TZS = tz.tzstr('EST5EDT')\n\n        self.assertFalse(TZS == 4)\n        self.assertTrue(TZS == ComparesEqual)\n        self.assertFalse(TZS != ComparesEqual)\n\n    def testTzStrRepr(self):\n        TZS1 = tz.tzstr('EST5EDT4')\n        TZS2 = tz.tzstr('EST')\n\n        self.assertEqual(repr(TZS1), \"tzstr(\" + repr('EST5EDT4') + \")\")\n        self.assertEqual(repr(TZS2), \"tzstr(\" + repr('EST') + \")\")\n\n    def testTzStrFailure(self):\n        with self.assertRaises(ValueError):\n            tz.tzstr('InvalidString;439999')\n\n    def testTzStrSingleton(self):\n        tz1 = tz.tzstr('EST5EDT')\n        tz2 = tz.tzstr('CST4CST')\n        tz3 = tz.tzstr('EST5EDT')\n\n        self.assertIsNot(tz1, tz2)\n        self.assertIs(tz1, tz3)\n\n    def testTzStrSingletonPosix(self):\n        tz_t1 = tz.tzstr('GMT+3', posix_offset=True)\n        tz_f1 = tz.tzstr('GMT+3', posix_offset=False)\n\n        tz_t2 = tz.tzstr('GMT+3', posix_offset=True)\n        tz_f2 = tz.tzstr('GMT+3', posix_offset=False)\n\n        self.assertIs(tz_t1, tz_t2)\n        self.assertIsNot(tz_t1, tz_f1)\n\n        self.assertIs(tz_f1, tz_f2)\n\n    def testTzStrInstance(self):\n        tz1 = tz.tzstr('EST5EDT')\n        tz2 = tz.tzstr.instance('EST5EDT')\n        tz3 = tz.tzstr.instance('EST5EDT')\n\n        assert tz1 is not tz2\n        assert tz2 is not tz3\n\n        # Ensure that these still are all the same zone\n        assert tz1 == tz2 == tz3\n\n\n@pytest.mark.smoke\n@pytest.mark.tzstr\ndef test_tzstr_weakref():\n    tz_t1 = tz.tzstr('EST5EDT')\n    tz_t2_ref = weakref.ref(tz.tzstr('EST5EDT'))\n    assert tz_t1 is tz_t2_ref()\n\n    del tz_t1\n    gc.collect()\n\n    assert tz_t2_ref() is not None\n    assert tz.tzstr('EST5EDT') is tz_t2_ref()\n\n    for offset in range(5,15):\n        tz.tzstr('GMT+{}'.format(offset))\n    gc.collect()\n\n    assert tz_t2_ref() is None\n    assert tz.tzstr('EST5EDT') is not tz_t2_ref()\n\n\n@pytest.mark.tzstr\n@pytest.mark.parametrize('tz_str,expected', [\n    # From https://www.gnu.org/software/libc/manual/html_node/TZ-Variable.html\n    ('', tz.tzrange(None)),     # TODO: Should change this so tz.tzrange('') works\n    ('EST+5EDT,M3.2.0/2,M11.1.0/12',\n     tz.tzrange('EST', -18000, 'EDT', -14400,\n        start=relativedelta(month=3, day=1, weekday=SU(2), hours=2),\n        end=relativedelta(month=11, day=1, weekday=SU(1), hours=11))),\n    ('WART4WARST,J1/0,J365/25',  # This is DST all year, Western Argentina Summer Time\n     tz.tzrange('WART', timedelta(hours=-4), 'WARST',\n        start=relativedelta(month=1, day=1, hours=0),\n        end=relativedelta(month=12, day=31, days=1))),\n    ('IST-2IDT,M3.4.4/26,M10.5.0',      # Israel Standard / Daylight Time\n     tz.tzrange('IST', timedelta(hours=2), 'IDT',\n        start=relativedelta(month=3, day=1, weekday=TH(4), days=1, hours=2),\n        end=relativedelta(month=10, day=31, weekday=SU(-1), hours=1))),\n    ('WGT3WGST,M3.5.0/2,M10.5.0/1',\n     tz.tzrange('WGT', timedelta(hours=-3), 'WGST',\n        start=relativedelta(month=3, day=31, weekday=SU(-1), hours=2),\n        end=relativedelta(month=10, day=31, weekday=SU(-1), hours=0))),\n\n    # Different offset specifications\n    ('WGT0300WGST',\n     tz.tzrange('WGT', timedelta(hours=-3), 'WGST')),\n    ('WGT03:00WGST',\n     tz.tzrange('WGT', timedelta(hours=-3), 'WGST')),\n    ('AEST-1100AEDT',\n     tz.tzrange('AEST', timedelta(hours=11), 'AEDT')),\n    ('AEST-11:00AEDT',\n     tz.tzrange('AEST', timedelta(hours=11), 'AEDT')),\n\n    # Different time formats\n    ('EST5EDT,M3.2.0/4:00,M11.1.0/3:00',\n     tz.tzrange('EST', timedelta(hours=-5), 'EDT',\n        start=relativedelta(month=3, day=1, weekday=SU(2), hours=4),\n        end=relativedelta(month=11, day=1, weekday=SU(1), hours=2))),\n    ('EST5EDT,M3.2.0/04:00,M11.1.0/03:00',\n     tz.tzrange('EST', timedelta(hours=-5), 'EDT',\n        start=relativedelta(month=3, day=1, weekday=SU(2), hours=4),\n        end=relativedelta(month=11, day=1, weekday=SU(1), hours=2))),\n    ('EST5EDT,M3.2.0/0400,M11.1.0/0300',\n     tz.tzrange('EST', timedelta(hours=-5), 'EDT',\n        start=relativedelta(month=3, day=1, weekday=SU(2), hours=4),\n        end=relativedelta(month=11, day=1, weekday=SU(1), hours=2))),\n])\ndef test_valid_GNU_tzstr(tz_str, expected):\n    tzi = tz.tzstr(tz_str)\n\n    assert tzi == expected\n\n\n@pytest.mark.tzstr\n@pytest.mark.parametrize('tz_str, expected', [\n    ('EST5EDT,5,4,0,7200,11,3,0,7200',\n     tz.tzrange('EST', timedelta(hours=-5), 'EDT',\n        start=relativedelta(month=5, day=1, weekday=SU(+4), hours=+2),\n        end=relativedelta(month=11, day=1, weekday=SU(+3), hours=+1))),\n    ('EST5EDT,5,-4,0,7200,11,3,0,7200',\n     tz.tzrange('EST', timedelta(hours=-5), 'EDT',\n        start=relativedelta(hours=+2, month=5, day=31, weekday=SU(-4)),\n        end=relativedelta(hours=+1, month=11, day=1, weekday=SU(+3)))),\n    ('EST5EDT,5,4,0,7200,11,-3,0,7200',\n     tz.tzrange('EST', timedelta(hours=-5), 'EDT',\n        start=relativedelta(hours=+2, month=5, day=1, weekday=SU(+4)),\n        end=relativedelta(hours=+1, month=11, day=31, weekday=SU(-3)))),\n    ('EST5EDT,5,4,0,7200,11,-3,0,7200,3600',\n     tz.tzrange('EST', timedelta(hours=-5), 'EDT',\n        start=relativedelta(hours=+2, month=5, day=1, weekday=SU(+4)),\n        end=relativedelta(hours=+1, month=11, day=31, weekday=SU(-3)))),\n    ('EST5EDT,5,4,0,7200,11,-3,0,7200,3600',\n     tz.tzrange('EST', timedelta(hours=-5), 'EDT',\n        start=relativedelta(hours=+2, month=5, day=1, weekday=SU(+4)),\n        end=relativedelta(hours=+1, month=11, day=31, weekday=SU(-3)))),\n    ('EST5EDT,5,4,0,7200,11,-3,0,7200,-3600',\n     tz.tzrange('EST', timedelta(hours=-5), 'EDT', timedelta(hours=-6),\n        start=relativedelta(hours=+2, month=5, day=1, weekday=SU(+4)),\n        end=relativedelta(hours=+3, month=11, day=31, weekday=SU(-3)))),\n    ('EST5EDT,5,4,0,7200,11,-3,0,7200,+7200',\n     tz.tzrange('EST', timedelta(hours=-5), 'EDT', timedelta(hours=-3),\n        start=relativedelta(hours=+2, month=5, day=1, weekday=SU(+4)),\n        end=relativedelta(hours=0, month=11, day=31, weekday=SU(-3)))),\n    ('EST5EDT,5,4,0,7200,11,-3,0,7200,+3600',\n     tz.tzrange('EST', timedelta(hours=-5), 'EDT',\n        start=relativedelta(hours=+2, month=5, day=1, weekday=SU(+4)),\n        end=relativedelta(hours=+1, month=11, day=31, weekday=SU(-3)))),\n])\ndef test_valid_dateutil_format(tz_str, expected):\n    # This tests the dateutil-specific format that is used widely in the tests\n    # and examples. It is unclear where this format originated from.\n    with pytest.warns(tz.DeprecatedTzFormatWarning):\n        tzi = tz.tzstr.instance(tz_str)\n\n    assert tzi == expected\n\n\n@pytest.mark.tzstr\n@pytest.mark.parametrize('tz_str', [\n    'hdfiughdfuig,dfughdfuigpu87\u00f1::',\n    ',dfughdfuigpu87\u00f1::',\n    '-1:WART4WARST,J1,J365/25',\n    'WART4WARST,J1,J365/-25',\n    'IST-2IDT,M3.4.-1/26,M10.5.0',\n    'IST-2IDT,M3,2000,1/26,M10,5,0'\n])\ndef test_invalid_GNU_tzstr(tz_str):\n    with pytest.raises(ValueError):\n        tz.tzstr(tz_str)\n\n\n# Different representations of the same default rule set\nDEFAULT_TZSTR_RULES_EQUIV_2003 = [\n    'EST5EDT',\n    'EST5EDT4,M4.1.0/02:00:00,M10-5-0/02:00',\n    'EST5EDT4,95/02:00:00,298/02:00',\n    'EST5EDT4,J96/02:00:00,J299/02:00',\n    'EST5EDT4,J96/02:00:00,J299/02'\n]\n\n\n@pytest.mark.tzstr\n@pytest.mark.parametrize('tz_str', DEFAULT_TZSTR_RULES_EQUIV_2003)\ndef test_tzstr_default_start(tz_str):\n    tzi = tz.tzstr(tz_str)\n    dt_std = datetime(2003, 4, 6, 1, 59, tzinfo=tzi)\n    dt_dst = datetime(2003, 4, 6, 2, 00, tzinfo=tzi)\n\n    assert get_timezone_tuple(dt_std) == EST_TUPLE\n    assert get_timezone_tuple(dt_dst) == EDT_TUPLE\n\n\n@pytest.mark.tzstr\n@pytest.mark.parametrize('tz_str', DEFAULT_TZSTR_RULES_EQUIV_2003)\ndef test_tzstr_default_end(tz_str):\n    tzi = tz.tzstr(tz_str)\n    dt_dst = datetime(2003, 10, 26, 0, 59, tzinfo=tzi)\n    dt_dst_ambig = datetime(2003, 10, 26, 1, 00, tzinfo=tzi)\n    dt_std_ambig = tz.enfold(dt_dst_ambig, fold=1)\n    dt_std = datetime(2003, 10, 26, 2, 00, tzinfo=tzi)\n\n    assert get_timezone_tuple(dt_dst) == EDT_TUPLE\n    assert get_timezone_tuple(dt_dst_ambig) == EDT_TUPLE\n    assert get_timezone_tuple(dt_std_ambig) == EST_TUPLE\n    assert get_timezone_tuple(dt_std) == EST_TUPLE\n\n\n@pytest.mark.tzstr\n@pytest.mark.parametrize('tzstr_1', ['EST5EDT',\n                                     'EST5EDT4,M4.1.0/02:00:00,M10-5-0/02:00'])\n@pytest.mark.parametrize('tzstr_2', ['EST5EDT',\n                                     'EST5EDT4,M4.1.0/02:00:00,M10-5-0/02:00'])\ndef test_tzstr_default_cmp(tzstr_1, tzstr_2):\n    tz1 = tz.tzstr(tzstr_1)\n    tz2 = tz.tzstr(tzstr_2)\n\n    assert tz1 == tz2\n\nclass TZICalTest(unittest.TestCase, TzFoldMixin):\n    def _gettz_str_tuple(self, tzname):\n        TZ_EST = (\n            'BEGIN:VTIMEZONE',\n            'TZID:US-Eastern',\n            'BEGIN:STANDARD',\n            'DTSTART:19971029T020000',\n            'RRULE:FREQ=YEARLY;BYDAY=+1SU;BYMONTH=11',\n            'TZOFFSETFROM:-0400',\n            'TZOFFSETTO:-0500',\n            'TZNAME:EST',\n            'END:STANDARD',\n            'BEGIN:DAYLIGHT',\n            'DTSTART:19980301T020000',\n            'RRULE:FREQ=YEARLY;BYDAY=+2SU;BYMONTH=03',\n            'TZOFFSETFROM:-0500',\n            'TZOFFSETTO:-0400',\n            'TZNAME:EDT',\n            'END:DAYLIGHT',\n            'END:VTIMEZONE'\n        )\n\n        TZ_PST = (\n            'BEGIN:VTIMEZONE',\n            'TZID:US-Pacific',\n            'BEGIN:STANDARD',\n            'DTSTART:19971029T020000',\n            'RRULE:FREQ=YEARLY;BYDAY=+1SU;BYMONTH=11',\n            'TZOFFSETFROM:-0700',\n            'TZOFFSETTO:-0800',\n            'TZNAME:PST',\n            'END:STANDARD',\n            'BEGIN:DAYLIGHT',\n            'DTSTART:19980301T020000',\n            'RRULE:FREQ=YEARLY;BYDAY=+2SU;BYMONTH=03',\n            'TZOFFSETFROM:-0800',\n            'TZOFFSETTO:-0700',\n            'TZNAME:PDT',\n            'END:DAYLIGHT',\n            'END:VTIMEZONE'\n        )\n\n        TZ_AEST = (\n            'BEGIN:VTIMEZONE',\n            'TZID:Australia-Sydney',\n            'BEGIN:STANDARD',\n            'DTSTART:19980301T030000',\n            'RRULE:FREQ=YEARLY;BYDAY=+1SU;BYMONTH=04',\n            'TZOFFSETFROM:+1100',\n            'TZOFFSETTO:+1000',\n            'TZNAME:AEST',\n            'END:STANDARD',\n            'BEGIN:DAYLIGHT',\n            'DTSTART:19971029T020000',\n            'RRULE:FREQ=YEARLY;BYDAY=+1SU;BYMONTH=10',\n            'TZOFFSETFROM:+1000',\n            'TZOFFSETTO:+1100',\n            'TZNAME:AEDT',\n            'END:DAYLIGHT',\n            'END:VTIMEZONE'\n        )\n\n        TZ_LON = (\n            'BEGIN:VTIMEZONE',\n            'TZID:Europe-London',\n            'BEGIN:STANDARD',\n            'DTSTART:19810301T030000',\n            'RRULE:FREQ=YEARLY;BYDAY=-1SU;BYMONTH=10;BYHOUR=02',\n            'TZOFFSETFROM:+0100',\n            'TZOFFSETTO:+0000',\n            'TZNAME:GMT',\n            'END:STANDARD',\n            'BEGIN:DAYLIGHT',\n            'DTSTART:19961001T030000',\n            'RRULE:FREQ=YEARLY;BYDAY=-1SU;BYMONTH=03;BYHOUR=01',\n            'TZOFFSETFROM:+0000',\n            'TZOFFSETTO:+0100',\n            'TZNAME:BST',\n            'END:DAYLIGHT',\n            'END:VTIMEZONE'\n        )\n\n        tzname_map = {'Australia/Sydney': TZ_AEST,\n                      'America/Toronto': TZ_EST,\n                      'America/New_York': TZ_EST,\n                      'America/Los_Angeles': TZ_PST,\n                      'Europe/London': TZ_LON}\n\n        return tzname_map[tzname]\n\n    def _gettz_str(self, tzname):\n        return '\\n'.join(self._gettz_str_tuple(tzname))\n\n    def _tzstr_dtstart_with_params(self, tzname, param_str):\n        # Adds parameters to the DTSTART values of a given tzstr\n        tz_str_tuple = self._gettz_str_tuple(tzname)\n\n        out_tz = []\n        for line in tz_str_tuple:\n            if line.startswith('DTSTART'):\n                name, value = line.split(':', 1)\n                line = name + ';' + param_str + ':' + value\n\n            out_tz.append(line)\n\n        return '\\n'.join(out_tz)\n\n    def gettz(self, tzname):\n        tz_str = self._gettz_str(tzname)\n\n        tzc = tz.tzical(StringIO(tz_str)).get()\n\n        return tzc\n\n    def testRepr(self):\n        instr = StringIO(TZICAL_PST8PDT)\n        instr.name = 'StringIO(PST8PDT)'\n        tzc = tz.tzical(instr)\n\n        self.assertEqual(repr(tzc), \"tzical(\" + repr(instr.name) + \")\")\n\n    # Test performance\n    def _test_us_zone(self, tzc, func, values, start):\n        if start:\n            dt1 = datetime(2003, 3, 9, 1, 59)\n            dt2 = datetime(2003, 3, 9, 2, 00)\n            fold = [0, 0]\n        else:\n            dt1 = datetime(2003, 11, 2, 0, 59)\n            dt2 = datetime(2003, 11, 2, 1, 00)\n            fold = [0, 1]\n\n        dts = (tz.enfold(dt.replace(tzinfo=tzc), fold=f)\n               for dt, f in zip((dt1, dt2), fold))\n\n        for value, dt in zip(values, dts):\n            self.assertEqual(func(dt), value)\n\n    def _test_multi_zones(self, tzstrs, tzids, func, values, start):\n        tzic = tz.tzical(StringIO('\\n'.join(tzstrs)))\n        for tzid, vals in zip(tzids, values):\n            tzc = tzic.get(tzid)\n\n            self._test_us_zone(tzc, func, vals, start)\n\n    def _prepare_EST(self):\n        tz_str = self._gettz_str('America/New_York')\n        return tz.tzical(StringIO(tz_str)).get()\n\n    def _testEST(self, start, test_type, tzc=None):\n        if tzc is None:\n            tzc = self._prepare_EST()\n\n        argdict = {\n            'name':   (datetime.tzname, ('EST', 'EDT')),\n            'offset': (datetime.utcoffset, (timedelta(hours=-5),\n                                            timedelta(hours=-4))),\n            'dst':    (datetime.dst, (timedelta(hours=0),\n                                      timedelta(hours=1)))\n        }\n\n        func, values = argdict[test_type]\n\n        if not start:\n            values = reversed(values)\n\n        self._test_us_zone(tzc, func, values, start=start)\n\n    def testESTStartName(self):\n        self._testEST(start=True, test_type='name')\n\n    def testESTEndName(self):\n        self._testEST(start=False, test_type='name')\n\n    def testESTStartOffset(self):\n        self._testEST(start=True, test_type='offset')\n\n    def testESTEndOffset(self):\n        self._testEST(start=False, test_type='offset')\n\n    def testESTStartDST(self):\n        self._testEST(start=True, test_type='dst')\n\n    def testESTEndDST(self):\n        self._testEST(start=False, test_type='dst')\n\n    def testESTValueDatetime(self):\n        # Violating one-test-per-test rule because we're not set up to do\n        # parameterized tests and the manual proliferation is getting a bit\n        # out of hand.\n        tz_str = self._tzstr_dtstart_with_params('America/New_York',\n                                                 'VALUE=DATE-TIME')\n\n        tzc = tz.tzical(StringIO(tz_str)).get()\n\n        for start in (True, False):\n            for test_type in ('name', 'offset', 'dst'):\n                self._testEST(start=start, test_type=test_type, tzc=tzc)\n\n    def _testMultizone(self, start, test_type):\n        tzstrs = (self._gettz_str('America/New_York'),\n                  self._gettz_str('America/Los_Angeles'))\n        tzids = ('US-Eastern', 'US-Pacific')\n\n        argdict = {\n            'name':   (datetime.tzname, (('EST', 'EDT'),\n                                         ('PST', 'PDT'))),\n            'offset': (datetime.utcoffset, ((timedelta(hours=-5),\n                                             timedelta(hours=-4)),\n                                            (timedelta(hours=-8),\n                                             timedelta(hours=-7)))),\n            'dst':    (datetime.dst, ((timedelta(hours=0),\n                                       timedelta(hours=1)),\n                                      (timedelta(hours=0),\n                                       timedelta(hours=1))))\n        }\n\n        func, values = argdict[test_type]\n\n        if not start:\n            values = map(reversed, values)\n\n        self._test_multi_zones(tzstrs, tzids, func, values, start)\n\n    def testMultiZoneStartName(self):\n        self._testMultizone(start=True, test_type='name')\n\n    def testMultiZoneEndName(self):\n        self._testMultizone(start=False, test_type='name')\n\n    def testMultiZoneStartOffset(self):\n        self._testMultizone(start=True, test_type='offset')\n\n    def testMultiZoneEndOffset(self):\n        self._testMultizone(start=False, test_type='offset')\n\n    def testMultiZoneStartDST(self):\n        self._testMultizone(start=True, test_type='dst')\n\n    def testMultiZoneEndDST(self):\n        self._testMultizone(start=False, test_type='dst')\n\n    def testMultiZoneKeys(self):\n        est_str = self._gettz_str('America/New_York')\n        pst_str = self._gettz_str('America/Los_Angeles')\n        tzic = tz.tzical(StringIO('\\n'.join((est_str, pst_str))))\n\n        # Sort keys because they are in a random order, being dictionary keys\n        keys = sorted(tzic.keys())\n\n        self.assertEqual(keys, ['US-Eastern', 'US-Pacific'])\n\n    # Test error conditions\n    def testEmptyString(self):\n        with self.assertRaises(ValueError):\n            tz.tzical(StringIO(\"\"))\n\n    def testMultiZoneGet(self):\n        tzic = tz.tzical(StringIO(TZICAL_EST5EDT + TZICAL_PST8PDT))\n\n        with self.assertRaises(ValueError):\n            tzic.get()\n\n    def testDtstartDate(self):\n        tz_str = self._tzstr_dtstart_with_params('America/New_York',\n                                                 'VALUE=DATE')\n        with self.assertRaises(ValueError):\n            tz.tzical(StringIO(tz_str))\n\n    def testDtstartTzid(self):\n        tz_str = self._tzstr_dtstart_with_params('America/New_York',\n                                                 'TZID=UTC')\n        with self.assertRaises(ValueError):\n            tz.tzical(StringIO(tz_str))\n\n    def testDtstartBadParam(self):\n        tz_str = self._tzstr_dtstart_with_params('America/New_York',\n                                                 'FOO=BAR')\n        with self.assertRaises(ValueError):\n            tz.tzical(StringIO(tz_str))\n\n    # Test Parsing\n    def testGap(self):\n        tzic = tz.tzical(StringIO('\\n'.join((TZICAL_EST5EDT, TZICAL_PST8PDT))))\n\n        keys = sorted(tzic.keys())\n        self.assertEqual(keys, ['US-Eastern', 'US-Pacific'])\n\n\nclass TZTest(unittest.TestCase):\n    def testFileStart1(self):\n        tzc = tz.tzfile(BytesIO(base64.b64decode(TZFILE_EST5EDT)))\n        self.assertEqual(datetime(2003, 4, 6, 1, 59, tzinfo=tzc).tzname(), \"EST\")\n        self.assertEqual(datetime(2003, 4, 6, 2, 00, tzinfo=tzc).tzname(), \"EDT\")\n\n    def testFileEnd1(self):\n        tzc = tz.tzfile(BytesIO(base64.b64decode(TZFILE_EST5EDT)))\n        self.assertEqual(datetime(2003, 10, 26, 0, 59, tzinfo=tzc).tzname(),\n                         \"EDT\")\n        end_est = tz.enfold(datetime(2003, 10, 26, 1, 00, tzinfo=tzc))\n        self.assertEqual(end_est.tzname(), \"EST\")\n\n    def testFileLastTransition(self):\n        # After the last transition, it goes to standard time in perpetuity\n        tzc = tz.tzfile(BytesIO(base64.b64decode(TZFILE_EST5EDT)))\n        self.assertEqual(datetime(2037, 10, 25, 0, 59, tzinfo=tzc).tzname(),\n                         \"EDT\")\n\n        last_date = tz.enfold(datetime(2037, 10, 25, 1, 00, tzinfo=tzc), fold=1)\n        self.assertEqual(last_date.tzname(),\n                         \"EST\")\n\n        self.assertEqual(datetime(2038, 5, 25, 12, 0, tzinfo=tzc).tzname(),\n                         \"EST\")\n\n    def testInvalidFile(self):\n        # Should throw a ValueError if an invalid file is passed\n        with self.assertRaises(ValueError):\n            tz.tzfile(BytesIO(b'BadFile'))\n\n    def testFilestreamWithNameRepr(self):\n        # If fileobj is a filestream with a \"name\" attribute this name should\n        # be reflected in the tz object's repr\n        fileobj = BytesIO(base64.b64decode(TZFILE_EST5EDT))\n        fileobj.name = 'foo'\n        tzc = tz.tzfile(fileobj)\n        self.assertEqual(repr(tzc), 'tzfile(' + repr('foo') + ')')\n\n    def testLeapCountDecodesProperly(self):\n        # This timezone has leapcnt, and failed to decode until\n        # Eugene Oden notified about the issue.\n\n        # As leap information is currently unused (and unstored) by tzfile() we\n        # can only indirectly test this: Take advantage of tzfile() not closing\n        # the input file if handed in as an opened file and assert that the\n        # full file content has been read by tzfile(). Note: For this test to\n        # work NEW_YORK must be in TZif version 1 format i.e. no more data\n        # after TZif v1 header + data has been read\n        fileobj = BytesIO(base64.b64decode(NEW_YORK))\n        tz.tzfile(fileobj)\n        # we expect no remaining file content now, i.e. zero-length; if there's\n        # still data we haven't read the file format correctly\n        remaining_tzfile_content = fileobj.read()\n        self.assertEqual(len(remaining_tzfile_content), 0)\n\n    def testIsStd(self):\n        # NEW_YORK tzfile contains this isstd information:\n        isstd_expected = (0, 0, 0, 1)\n        tzc = tz.tzfile(BytesIO(base64.b64decode(NEW_YORK)))\n        # gather the actual information as parsed by the tzfile class\n        isstd = []\n        for ttinfo in tzc._ttinfo_list:\n            # ttinfo objects contain boolean values\n            isstd.append(int(ttinfo.isstd))\n        # ttinfo list may contain more entries than isstd file content\n        isstd = tuple(isstd[:len(isstd_expected)])\n        self.assertEqual(\n            isstd_expected, isstd,\n            \"isstd UTC/local indicators parsed: %s != tzfile contents: %s\"\n            % (isstd, isstd_expected))\n\n    def testGMTHasNoDaylight(self):\n        # tz.tzstr(\"GMT+2\") improperly considered daylight saving time.\n        # Issue reported by Lennart Regebro.\n        dt = datetime(2007, 8, 6, 4, 10)\n        self.assertEqual(tz.gettz(\"GMT+2\").dst(dt), timedelta(0))\n\n    def testGMTOffset(self):\n        # GMT and UTC offsets have inverted signal when compared to the\n        # usual TZ variable handling.\n        dt = datetime(2007, 8, 6, 4, 10, tzinfo=tz.UTC)\n        self.assertEqual(dt.astimezone(tz=tz.tzstr(\"GMT+2\")),\n                          datetime(2007, 8, 6, 6, 10, tzinfo=tz.tzstr(\"GMT+2\")))\n        self.assertEqual(dt.astimezone(tz=tz.gettz(\"UTC-2\")),\n                          datetime(2007, 8, 6, 2, 10, tzinfo=tz.tzstr(\"UTC-2\")))\n\n    @unittest.skipIf(IS_WIN, \"requires Unix\")\n    def testTZSetDoesntCorrupt(self):\n        # if we start in non-UTC then tzset UTC make sure parse doesn't get\n        # confused\n        with TZEnvContext('UTC'):\n            # this should parse to UTC timezone not the original timezone\n            dt = parse('2014-07-20T12:34:56+00:00')\n            self.assertEqual(str(dt), '2014-07-20 12:34:56+00:00')\n\n\n@pytest.mark.tzfile\n@pytest.mark.skipif(not SUPPORTS_SUB_MINUTE_OFFSETS,\n                    reason='Sub-minute offsets not supported')\ndef test_tzfile_sub_minute_offset():\n    # If user running python 3.6 or newer, exact offset is used\n    tzc = tz.tzfile(BytesIO(base64.b64decode(EUROPE_HELSINKI)))\n    offset = timedelta(hours=1, minutes=39, seconds=52)\n    assert datetime(1900, 1, 1, 0, 0, tzinfo=tzc).utcoffset() == offset\n\n\n@pytest.mark.tzfile\n@pytest.mark.skipif(SUPPORTS_SUB_MINUTE_OFFSETS,\n                    reason='Sub-minute offsets supported.')\ndef test_sub_minute_rounding_tzfile():\n    # This timezone has an offset of 5992 seconds in 1900-01-01.\n    # For python version pre-3.6, this will be rounded\n    tzc = tz.tzfile(BytesIO(base64.b64decode(EUROPE_HELSINKI)))\n    offset = timedelta(hours=1, minutes=40)\n    assert datetime(1900, 1, 1, 0, 0, tzinfo=tzc).utcoffset() == offset\n\n\n@pytest.mark.tzfile\ndef test_samoa_transition():\n    # utcoffset() was erroneously returning +14:00 an hour early (GH #812)\n    APIA = tz.gettz('Pacific/Apia')\n    dt = datetime(2011, 12, 29, 23, 59, tzinfo=APIA)\n    assert dt.utcoffset() == timedelta(hours=-10)\n\n    # Make sure the transition actually works, too\n    dt_after = (dt.astimezone(tz.UTC) + timedelta(minutes=1)).astimezone(APIA)\n    assert dt_after == datetime(2011, 12, 31, tzinfo=APIA)\n    assert dt_after.utcoffset() == timedelta(hours=14)\n\n\n@unittest.skipUnless(IS_WIN, \"Requires Windows\")\nclass TzWinTest(unittest.TestCase, TzWinFoldMixin):\n    def setUp(self):\n        self.tzclass = tzwin.tzwin\n\n    def testTzResLoadName(self):\n        # This may not work right on non-US locales.\n        tzr = tzwin.tzres()\n        self.assertEqual(tzr.load_name(112), \"Eastern Standard Time\")\n\n    def testTzResNameFromString(self):\n        tzr = tzwin.tzres()\n        self.assertEqual(tzr.name_from_string('@tzres.dll,-221'),\n                         'Alaskan Daylight Time')\n\n        self.assertEqual(tzr.name_from_string('Samoa Daylight Time'),\n                         'Samoa Daylight Time')\n\n        with self.assertRaises(ValueError):\n            tzr.name_from_string('@tzres.dll,100')\n\n    def testIsdstZoneWithNoDaylightSaving(self):\n        tz = tzwin.tzwin(\"UTC\")\n        dt = parse(\"2013-03-06 19:08:15\")\n        self.assertFalse(tz._isdst(dt))\n\n    def testOffset(self):\n        tz = tzwin.tzwin(\"Cape Verde Standard Time\")\n        self.assertEqual(tz.utcoffset(datetime(1995, 5, 21, 12, 9, 13)),\n                         timedelta(-1, 82800))\n\n    def testTzwinName(self):\n        # https://github.com/dateutil/dateutil/issues/143\n        tw = tz.tzwin('Eastern Standard Time')\n\n        # Cover the transitions for at least two years.\n        ESTs = 'Eastern Standard Time'\n        EDTs = 'Eastern Daylight Time'\n        transition_dates = [(datetime(2015, 3, 8, 0, 59), ESTs),\n                            (datetime(2015, 3, 8, 3, 1), EDTs),\n                            (datetime(2015, 11, 1, 0, 59), EDTs),\n                            (datetime(2015, 11, 1, 3, 1), ESTs),\n                            (datetime(2016, 3, 13, 0, 59), ESTs),\n                            (datetime(2016, 3, 13, 3, 1), EDTs),\n                            (datetime(2016, 11, 6, 0, 59), EDTs),\n                            (datetime(2016, 11, 6, 3, 1), ESTs)]\n\n        for t_date, expected in transition_dates:\n            self.assertEqual(t_date.replace(tzinfo=tw).tzname(), expected)\n\n    def testTzwinRepr(self):\n        tw = tz.tzwin('Yakutsk Standard Time')\n        self.assertEqual(repr(tw), 'tzwin(' +\n                                   repr('Yakutsk Standard Time') + ')')\n\n    def testTzWinEquality(self):\n        # https://github.com/dateutil/dateutil/issues/151\n        tzwin_names = ('Eastern Standard Time',\n                       'West Pacific Standard Time',\n                       'Yakutsk Standard Time',\n                       'Iran Standard Time',\n                       'UTC')\n\n        for tzwin_name in tzwin_names:\n            # Get two different instances to compare\n            tw1 = tz.tzwin(tzwin_name)\n            tw2 = tz.tzwin(tzwin_name)\n\n            self.assertEqual(tw1, tw2)\n\n    def testTzWinInequality(self):\n        # https://github.com/dateutil/dateutil/issues/151\n        # Note these last two currently differ only in their name.\n        tzwin_names = (('Eastern Standard Time', 'Yakutsk Standard Time'),\n                       ('Greenwich Standard Time', 'GMT Standard Time'),\n                       ('GMT Standard Time', 'UTC'),\n                       ('E. South America Standard Time',\n                        'Argentina Standard Time'))\n\n        for tzwn1, tzwn2 in tzwin_names:\n            # Get two different instances to compare\n            tw1 = tz.tzwin(tzwn1)\n            tw2 = tz.tzwin(tzwn2)\n\n            self.assertNotEqual(tw1, tw2)\n\n    def testTzWinEqualityInvalid(self):\n        # Compare to objects that do not implement comparison with this\n        # (should default to False)\n        UTC = tz.UTC\n        EST = tz.tzwin('Eastern Standard Time')\n\n        self.assertFalse(EST == UTC)\n        self.assertFalse(EST == 1)\n        self.assertFalse(UTC == EST)\n\n        self.assertTrue(EST != UTC)\n        self.assertTrue(EST != 1)\n\n    def testTzWinInequalityUnsupported(self):\n        # Compare it to an object that is promiscuous about equality, but for\n        # which tzwin does not implement an equality operator.\n        EST = tz.tzwin('Eastern Standard Time')\n        self.assertTrue(EST == ComparesEqual)\n        self.assertFalse(EST != ComparesEqual)\n\n    def testTzwinTimeOnlyDST(self):\n        # For zones with DST, .dst() should return None\n        tw_est = tz.tzwin('Eastern Standard Time')\n        self.assertIs(dt_time(14, 10, tzinfo=tw_est).dst(), None)\n\n        # This zone has no DST, so .dst() can return 0\n        tw_sast = tz.tzwin('South Africa Standard Time')\n        self.assertEqual(dt_time(14, 10, tzinfo=tw_sast).dst(),\n                         timedelta(0))\n\n    def testTzwinTimeOnlyUTCOffset(self):\n        # For zones with DST, .utcoffset() should return None\n        tw_est = tz.tzwin('Eastern Standard Time')\n        self.assertIs(dt_time(14, 10, tzinfo=tw_est).utcoffset(), None)\n\n        # This zone has no DST, so .utcoffset() returns standard offset\n        tw_sast = tz.tzwin('South Africa Standard Time')\n        self.assertEqual(dt_time(14, 10, tzinfo=tw_sast).utcoffset(),\n                         timedelta(hours=2))\n\n    def testTzwinTimeOnlyTZName(self):\n        # For zones with DST, the name defaults to standard time\n        tw_est = tz.tzwin('Eastern Standard Time')\n        self.assertEqual(dt_time(14, 10, tzinfo=tw_est).tzname(),\n                         'Eastern Standard Time')\n\n        # For zones with no DST, this should work normally.\n        tw_sast = tz.tzwin('South Africa Standard Time')\n        self.assertEqual(dt_time(14, 10, tzinfo=tw_sast).tzname(),\n                         'South Africa Standard Time')\n\n\n@unittest.skipUnless(IS_WIN, \"Requires Windows\")\nclass TzWinLocalTest(unittest.TestCase, TzWinFoldMixin):\n\n    def setUp(self):\n        self.tzclass = tzwin.tzwinlocal\n        self.context = TZWinContext\n\n    def get_args(self, tzname):\n        return ()\n\n    def testLocal(self):\n        # Not sure how to pin a local time zone, so for now we're just going\n        # to run this and make sure it doesn't raise an error\n        # See GitHub Issue #135: https://github.com/dateutil/dateutil/issues/135\n        datetime.now(tzwin.tzwinlocal())\n\n    def testTzwinLocalUTCOffset(self):\n        with TZWinContext('Eastern Standard Time'):\n            tzwl = tzwin.tzwinlocal()\n            self.assertEqual(datetime(2014, 3, 11, tzinfo=tzwl).utcoffset(),\n                             timedelta(hours=-4))\n\n    def testTzwinLocalName(self):\n        # https://github.com/dateutil/dateutil/issues/143\n        ESTs = 'Eastern Standard Time'\n        EDTs = 'Eastern Daylight Time'\n        transition_dates = [(datetime(2015, 3, 8, 0, 59), ESTs),\n                            (datetime(2015, 3, 8, 3, 1), EDTs),\n                            (datetime(2015, 11, 1, 0, 59), EDTs),\n                            (datetime(2015, 11, 1, 3, 1), ESTs),\n                            (datetime(2016, 3, 13, 0, 59), ESTs),\n                            (datetime(2016, 3, 13, 3, 1), EDTs),\n                            (datetime(2016, 11, 6, 0, 59), EDTs),\n                            (datetime(2016, 11, 6, 3, 1), ESTs)]\n\n        with TZWinContext('Eastern Standard Time'):\n            tw = tz.tzwinlocal()\n\n            for t_date, expected in transition_dates:\n                self.assertEqual(t_date.replace(tzinfo=tw).tzname(), expected)\n\n    def testTzWinLocalRepr(self):\n        tw = tz.tzwinlocal()\n        self.assertEqual(repr(tw), 'tzwinlocal()')\n\n    def testTzwinLocalRepr(self):\n        # https://github.com/dateutil/dateutil/issues/143\n        with TZWinContext('Eastern Standard Time'):\n            tw = tz.tzwinlocal()\n\n            self.assertEqual(str(tw), 'tzwinlocal(' +\n                                      repr('Eastern Standard Time') + ')')\n\n        with TZWinContext('Pacific Standard Time'):\n            tw = tz.tzwinlocal()\n\n            self.assertEqual(str(tw), 'tzwinlocal(' +\n                                      repr('Pacific Standard Time') + ')')\n\n    def testTzwinLocalEquality(self):\n        tw_est = tz.tzwin('Eastern Standard Time')\n        tw_pst = tz.tzwin('Pacific Standard Time')\n\n        with TZWinContext('Eastern Standard Time'):\n            twl1 = tz.tzwinlocal()\n            twl2 = tz.tzwinlocal()\n\n            self.assertEqual(twl1, twl2)\n            self.assertEqual(twl1, tw_est)\n            self.assertNotEqual(twl1, tw_pst)\n\n        with TZWinContext('Pacific Standard Time'):\n            twl1 = tz.tzwinlocal()\n            twl2 = tz.tzwinlocal()\n            tw = tz.tzwin('Pacific Standard Time')\n\n            self.assertEqual(twl1, twl2)\n            self.assertEqual(twl1, tw)\n            self.assertEqual(twl1, tw_pst)\n            self.assertNotEqual(twl1, tw_est)\n\n    def testTzwinLocalTimeOnlyDST(self):\n        # For zones with DST, .dst() should return None\n        with TZWinContext('Eastern Standard Time'):\n            twl = tz.tzwinlocal()\n            self.assertIs(dt_time(14, 10, tzinfo=twl).dst(), None)\n\n        # This zone has no DST, so .dst() can return 0\n        with TZWinContext('South Africa Standard Time'):\n            twl = tz.tzwinlocal()\n            self.assertEqual(dt_time(14, 10, tzinfo=twl).dst(), timedelta(0))\n\n    def testTzwinLocalTimeOnlyUTCOffset(self):\n        # For zones with DST, .utcoffset() should return None\n        with TZWinContext('Eastern Standard Time'):\n            twl = tz.tzwinlocal()\n            self.assertIs(dt_time(14, 10, tzinfo=twl).utcoffset(), None)\n\n        # This zone has no DST, so .utcoffset() returns standard offset\n        with TZWinContext('South Africa Standard Time'):\n            twl = tz.tzwinlocal()\n            self.assertEqual(dt_time(14, 10, tzinfo=twl).utcoffset(),\n                             timedelta(hours=2))\n\n    def testTzwinLocalTimeOnlyTZName(self):\n        # For zones with DST, the name defaults to standard time\n        with TZWinContext('Eastern Standard Time'):\n            twl = tz.tzwinlocal()\n            self.assertEqual(dt_time(14, 10, tzinfo=twl).tzname(),\n                             'Eastern Standard Time')\n\n        # For zones with no DST, this should work normally.\n        with TZWinContext('South Africa Standard Time'):\n            twl = tz.tzwinlocal()\n            self.assertEqual(dt_time(14, 10, tzinfo=twl).tzname(),\n                             'South Africa Standard Time')\n\n\nclass TzPickleTest(PicklableMixin, unittest.TestCase):\n    _asfile = False\n\n    def setUp(self):\n        self.assertPicklable = partial(self.assertPicklable,\n                                       asfile=self._asfile)\n\n    def testPickleTzUTC(self):\n        self.assertPicklable(tz.tzutc(), singleton=True)\n\n    def testPickleTzOffsetZero(self):\n        self.assertPicklable(tz.tzoffset('UTC', 0), singleton=True)\n\n    def testPickleTzOffsetPos(self):\n        self.assertPicklable(tz.tzoffset('UTC+1', 3600), singleton=True)\n\n    def testPickleTzOffsetNeg(self):\n        self.assertPicklable(tz.tzoffset('UTC-1', -3600), singleton=True)\n\n    @pytest.mark.tzlocal\n    def testPickleTzLocal(self):\n        self.assertPicklable(tz.tzlocal())\n\n    def testPickleTzFileEST5EDT(self):\n        tzc = tz.tzfile(BytesIO(base64.b64decode(TZFILE_EST5EDT)))\n        self.assertPicklable(tzc)\n\n    def testPickleTzFileEurope_Helsinki(self):\n        tzc = tz.tzfile(BytesIO(base64.b64decode(EUROPE_HELSINKI)))\n        self.assertPicklable(tzc)\n\n    def testPickleTzFileNew_York(self):\n        tzc = tz.tzfile(BytesIO(base64.b64decode(NEW_YORK)))\n        self.assertPicklable(tzc)\n\n    @unittest.skip(\"Known failure\")\n    def testPickleTzICal(self):\n        tzc = tz.tzical(StringIO(TZICAL_EST5EDT)).get()\n        self.assertPicklable(tzc)\n\n    def testPickleTzGettz(self):\n        self.assertPicklable(tz.gettz('America/New_York'))\n\n    def testPickleZoneFileGettz(self):\n        zoneinfo_file = zoneinfo.get_zonefile_instance()\n        tzi = zoneinfo_file.get('America/New_York')\n        self.assertIsNot(tzi, None)\n        self.assertPicklable(tzi)\n\n\nclass TzPickleFileTest(TzPickleTest):\n    \"\"\" Run all the TzPickleTest tests, using a temporary file \"\"\"\n    _asfile = True\n\n\nclass DatetimeAmbiguousTest(unittest.TestCase):\n    \"\"\" Test the datetime_exists / datetime_ambiguous functions \"\"\"\n\n    def testNoTzSpecified(self):\n        with self.assertRaises(ValueError):\n            tz.datetime_ambiguous(datetime(2016, 4, 1, 2, 9))\n\n    def _get_no_support_tzinfo_class(self, dt_start, dt_end, dst_only=False):\n        # Generates a class of tzinfo with no support for is_ambiguous\n        # where dates between dt_start and dt_end are ambiguous.\n\n        class FoldingTzInfo(tzinfo):\n            def utcoffset(self, dt):\n                if not dst_only:\n                    dt_n = dt.replace(tzinfo=None)\n\n                    if dt_start <= dt_n < dt_end and getattr(dt_n, 'fold', 0):\n                        return timedelta(hours=-1)\n\n                return timedelta(hours=0)\n\n            def dst(self, dt):\n                dt_n = dt.replace(tzinfo=None)\n\n                if dt_start <= dt_n < dt_end and getattr(dt_n, 'fold', 0):\n                    return timedelta(hours=1)\n                else:\n                    return timedelta(0)\n\n        return FoldingTzInfo\n\n    def _get_no_support_tzinfo(self, dt_start, dt_end, dst_only=False):\n        return self._get_no_support_tzinfo_class(dt_start, dt_end, dst_only)()\n\n    def testNoSupportAmbiguityFoldNaive(self):\n        dt_start = datetime(2018, 9, 1, 1, 0)\n        dt_end = datetime(2018, 9, 1, 2, 0)\n\n        tzi = self._get_no_support_tzinfo(dt_start, dt_end)\n\n        self.assertTrue(tz.datetime_ambiguous(datetime(2018, 9, 1, 1, 30),\n                                              tz=tzi))\n\n    def testNoSupportAmbiguityFoldAware(self):\n        dt_start = datetime(2018, 9, 1, 1, 0)\n        dt_end = datetime(2018, 9, 1, 2, 0)\n\n        tzi = self._get_no_support_tzinfo(dt_start, dt_end)\n\n        self.assertTrue(tz.datetime_ambiguous(datetime(2018, 9, 1, 1, 30,\n                                                       tzinfo=tzi)))\n\n    def testNoSupportAmbiguityUnambiguousNaive(self):\n        dt_start = datetime(2018, 9, 1, 1, 0)\n        dt_end = datetime(2018, 9, 1, 2, 0)\n\n        tzi = self._get_no_support_tzinfo(dt_start, dt_end)\n\n        self.assertFalse(tz.datetime_ambiguous(datetime(2018, 10, 1, 12, 30),\n                                              tz=tzi))\n\n    def testNoSupportAmbiguityUnambiguousAware(self):\n        dt_start = datetime(2018, 9, 1, 1, 0)\n        dt_end = datetime(2018, 9, 1, 2, 0)\n\n        tzi = self._get_no_support_tzinfo(dt_start, dt_end)\n\n        self.assertFalse(tz.datetime_ambiguous(datetime(2018, 10, 1, 12, 30,\n                                                        tzinfo=tzi)))\n\n    def testNoSupportAmbiguityFoldDSTOnly(self):\n        dt_start = datetime(2018, 9, 1, 1, 0)\n        dt_end = datetime(2018, 9, 1, 2, 0)\n\n        tzi = self._get_no_support_tzinfo(dt_start, dt_end, dst_only=True)\n\n        self.assertTrue(tz.datetime_ambiguous(datetime(2018, 9, 1, 1, 30),\n                                              tz=tzi))\n\n    def testNoSupportAmbiguityUnambiguousDSTOnly(self):\n        dt_start = datetime(2018, 9, 1, 1, 0)\n        dt_end = datetime(2018, 9, 1, 2, 0)\n\n        tzi = self._get_no_support_tzinfo(dt_start, dt_end, dst_only=True)\n\n        self.assertFalse(tz.datetime_ambiguous(datetime(2018, 10, 1, 12, 30),\n                                               tz=tzi))\n\n    def testSupportAmbiguityFoldNaive(self):\n        tzi = tz.gettz('US/Eastern')\n\n        dt = datetime(2011, 11, 6, 1, 30)\n\n        self.assertTrue(tz.datetime_ambiguous(dt, tz=tzi))\n\n    def testSupportAmbiguityFoldAware(self):\n        tzi = tz.gettz('US/Eastern')\n\n        dt = datetime(2011, 11, 6, 1, 30, tzinfo=tzi)\n\n        self.assertTrue(tz.datetime_ambiguous(dt))\n\n    def testSupportAmbiguityUnambiguousAware(self):\n        tzi = tz.gettz('US/Eastern')\n\n        dt = datetime(2011, 11, 6, 4, 30)\n\n        self.assertFalse(tz.datetime_ambiguous(dt, tz=tzi))\n\n    def testSupportAmbiguityUnambiguousNaive(self):\n        tzi = tz.gettz('US/Eastern')\n\n        dt = datetime(2011, 11, 6, 4, 30, tzinfo=tzi)\n\n        self.assertFalse(tz.datetime_ambiguous(dt))\n\n    def _get_ambig_error_tzinfo(self, dt_start, dt_end, dst_only=False):\n        cTzInfo = self._get_no_support_tzinfo_class(dt_start, dt_end, dst_only)\n\n        # Takes the wrong number of arguments and raises an error anyway.\n        class FoldTzInfoRaises(cTzInfo):\n            def is_ambiguous(self, dt, other_arg):\n                raise NotImplementedError('This is not implemented')\n\n        return FoldTzInfoRaises()\n\n    def testIncompatibleAmbiguityFoldNaive(self):\n        dt_start = datetime(2018, 9, 1, 1, 0)\n        dt_end = datetime(2018, 9, 1, 2, 0)\n\n        tzi = self._get_ambig_error_tzinfo(dt_start, dt_end)\n\n        self.assertTrue(tz.datetime_ambiguous(datetime(2018, 9, 1, 1, 30),\n                                              tz=tzi))\n\n    def testIncompatibleAmbiguityFoldAware(self):\n        dt_start = datetime(2018, 9, 1, 1, 0)\n        dt_end = datetime(2018, 9, 1, 2, 0)\n\n        tzi = self._get_ambig_error_tzinfo(dt_start, dt_end)\n\n        self.assertTrue(tz.datetime_ambiguous(datetime(2018, 9, 1, 1, 30,\n                                                       tzinfo=tzi)))\n\n    def testIncompatibleAmbiguityUnambiguousNaive(self):\n        dt_start = datetime(2018, 9, 1, 1, 0)\n        dt_end = datetime(2018, 9, 1, 2, 0)\n\n        tzi = self._get_ambig_error_tzinfo(dt_start, dt_end)\n\n        self.assertFalse(tz.datetime_ambiguous(datetime(2018, 10, 1, 12, 30),\n                                              tz=tzi))\n\n    def testIncompatibleAmbiguityUnambiguousAware(self):\n        dt_start = datetime(2018, 9, 1, 1, 0)\n        dt_end = datetime(2018, 9, 1, 2, 0)\n\n        tzi = self._get_ambig_error_tzinfo(dt_start, dt_end)\n\n        self.assertFalse(tz.datetime_ambiguous(datetime(2018, 10, 1, 12, 30,\n                                                        tzinfo=tzi)))\n\n    def testIncompatibleAmbiguityFoldDSTOnly(self):\n        dt_start = datetime(2018, 9, 1, 1, 0)\n        dt_end = datetime(2018, 9, 1, 2, 0)\n\n        tzi = self._get_ambig_error_tzinfo(dt_start, dt_end, dst_only=True)\n\n        self.assertTrue(tz.datetime_ambiguous(datetime(2018, 9, 1, 1, 30),\n                                              tz=tzi))\n\n    def testIncompatibleAmbiguityUnambiguousDSTOnly(self):\n        dt_start = datetime(2018, 9, 1, 1, 0)\n        dt_end = datetime(2018, 9, 1, 2, 0)\n\n        tzi = self._get_ambig_error_tzinfo(dt_start, dt_end, dst_only=True)\n\n        self.assertFalse(tz.datetime_ambiguous(datetime(2018, 10, 1, 12, 30),\n                                               tz=tzi))\n\n    def testSpecifiedTzOverridesAttached(self):\n        # If a tz is specified, the datetime will be treated as naive.\n\n        # This is not ambiguous in the local zone\n        dt = datetime(2011, 11, 6, 1, 30, tzinfo=tz.gettz('Australia/Sydney'))\n\n        self.assertFalse(tz.datetime_ambiguous(dt))\n\n        tzi = tz.gettz('US/Eastern')\n        self.assertTrue(tz.datetime_ambiguous(dt, tz=tzi))\n\n\nclass DatetimeExistsTest(unittest.TestCase):\n    def testNoTzSpecified(self):\n        with self.assertRaises(ValueError):\n            tz.datetime_exists(datetime(2016, 4, 1, 2, 9))\n\n    def testInGapNaive(self):\n        tzi = tz.gettz('Australia/Sydney')\n\n        dt = datetime(2012, 10, 7, 2, 30)\n\n        self.assertFalse(tz.datetime_exists(dt, tz=tzi))\n\n    def testInGapAware(self):\n        tzi = tz.gettz('Australia/Sydney')\n\n        dt = datetime(2012, 10, 7, 2, 30, tzinfo=tzi)\n\n        self.assertFalse(tz.datetime_exists(dt))\n\n    def testExistsNaive(self):\n        tzi = tz.gettz('Australia/Sydney')\n\n        dt = datetime(2012, 10, 7, 10, 30)\n\n        self.assertTrue(tz.datetime_exists(dt, tz=tzi))\n\n    def testExistsAware(self):\n        tzi = tz.gettz('Australia/Sydney')\n\n        dt = datetime(2012, 10, 7, 10, 30, tzinfo=tzi)\n\n        self.assertTrue(tz.datetime_exists(dt))\n\n    def testSpecifiedTzOverridesAttached(self):\n        EST = tz.gettz('US/Eastern')\n        AEST = tz.gettz('Australia/Sydney')\n\n        dt = datetime(2012, 10, 7, 2, 30, tzinfo=EST)  # This time exists\n\n        self.assertFalse(tz.datetime_exists(dt, tz=AEST))\n\n\nclass TestEnfold:\n    def test_enter_fold_default(self):\n        dt = tz.enfold(datetime(2020, 1, 19, 3, 32))\n\n        assert dt.fold == 1\n\n    def test_enter_fold(self):\n        dt = tz.enfold(datetime(2020, 1, 19, 3, 32), fold=1)\n\n        assert dt.fold == 1\n\n    def test_exit_fold(self):\n        dt = tz.enfold(datetime(2020, 1, 19, 3, 32), fold=0)\n\n        # Before Python 3.6, dt.fold won't exist if fold is 0.\n        assert getattr(dt, 'fold', 0) == 0\n\n    def test_defold(self):\n        dt = tz.enfold(datetime(2020, 1, 19, 3, 32), fold=1)\n\n        dt2 = tz.enfold(dt, fold=0)\n\n        assert getattr(dt2, 'fold', 0) == 0\n\n    def test_fold_replace_args(self):\n        # This test can be dropped when Python < 3.6 is dropped, since it\n        # is mainly to cover the `replace` method on _DatetimeWithFold\n        dt = tz.enfold(datetime(1950, 1, 2, 12, 30, 15, 8), fold=1)\n\n        dt2 = dt.replace(1952, 2, 3, 13, 31, 16, 9)\n        assert dt2 == tz.enfold(datetime(1952, 2, 3, 13, 31, 16, 9), fold=1)\n        assert dt2.fold == 1\n\n    def test_fold_replace_exception_duplicate_args(self):\n        dt = tz.enfold(datetime(1999, 1, 3), fold=1)\n\n        with pytest.raises(TypeError):\n            dt.replace(1950, year=2000)\n\n\n@pytest.mark.tz_resolve_imaginary\nclass ImaginaryDateTest(unittest.TestCase):\n    def testCanberraForward(self):\n        tzi = tz.gettz('Australia/Canberra')\n        dt = datetime(2018, 10, 7, 2, 30, tzinfo=tzi)\n        dt_act = tz.resolve_imaginary(dt)\n        dt_exp = datetime(2018, 10, 7, 3, 30, tzinfo=tzi)\n        self.assertEqual(dt_act, dt_exp)\n\n    def testLondonForward(self):\n        tzi = tz.gettz('Europe/London')\n        dt = datetime(2018, 3, 25, 1, 30, tzinfo=tzi)\n        dt_act = tz.resolve_imaginary(dt)\n        dt_exp = datetime(2018, 3, 25, 2, 30, tzinfo=tzi)\n        self.assertEqual(dt_act, dt_exp)\n\n    def testKeivForward(self):\n        tzi = tz.gettz('Europe/Kiev')\n        dt = datetime(2018, 3, 25, 3, 30, tzinfo=tzi)\n        dt_act = tz.resolve_imaginary(dt)\n        dt_exp = datetime(2018, 3, 25, 4, 30, tzinfo=tzi)\n        self.assertEqual(dt_act, dt_exp)\n\n\n@pytest.mark.tz_resolve_imaginary\n@pytest.mark.parametrize('dt', [\n    datetime(2017, 11, 5, 1, 30, tzinfo=tz.gettz('America/New_York')),\n    datetime(2018, 10, 28, 1, 30, tzinfo=tz.gettz('Europe/London')),\n    datetime(2017, 4, 2, 2, 30, tzinfo=tz.gettz('Australia/Sydney')),\n])\ndef test_resolve_imaginary_ambiguous(dt):\n    assert tz.resolve_imaginary(dt) is dt\n\n    dt_f = tz.enfold(dt)\n    assert dt is not dt_f\n    assert tz.resolve_imaginary(dt_f) is dt_f\n\n\n@pytest.mark.tz_resolve_imaginary\n@pytest.mark.parametrize('dt', [\n    datetime(2017, 6, 2, 12, 30, tzinfo=tz.gettz('America/New_York')),\n    datetime(2018, 4, 2, 9, 30, tzinfo=tz.gettz('Europe/London')),\n    datetime(2017, 2, 2, 16, 30, tzinfo=tz.gettz('Australia/Sydney')),\n    datetime(2017, 12, 2, 12, 30, tzinfo=tz.gettz('America/New_York')),\n    datetime(2018, 12, 2, 9, 30, tzinfo=tz.gettz('Europe/London')),\n    datetime(2017, 6, 2, 16, 30, tzinfo=tz.gettz('Australia/Sydney')),\n    datetime(2025, 9, 25, 1, 17, tzinfo=tz.UTC),\n    datetime(2025, 9, 25, 1, 17, tzinfo=tz.tzoffset('EST', -18000)),\n    datetime(2019, 3, 4, tzinfo=None)\n])\ndef test_resolve_imaginary_existing(dt):\n    assert tz.resolve_imaginary(dt) is dt\n\n\ndef __get_kiritimati_resolve_imaginary_test():\n    # In the 2018d release of the IANA database, the Kiritimati \"imaginary day\"\n    # data was corrected, so if the system zoneinfo is older than 2018d, the\n    # Kiritimati test will fail.\n\n    tzi = tz.gettz('Pacific/Kiritimati')\n    new_version = False\n    if not tz.datetime_exists(datetime(1995, 1, 1, 12, 30), tzi):\n        zif = zoneinfo.get_zonefile_instance()\n        if zif.metadata is not None:\n            new_version = zif.metadata['tzversion'] >= '2018d'\n\n        if new_version:\n            tzi = zif.get('Pacific/Kiritimati')\n    else:\n        new_version = True\n\n    if new_version:\n        dates = (datetime(1994, 12, 31, 12, 30), datetime(1995, 1, 1, 12, 30))\n    else:\n        dates = (datetime(1995, 1, 1, 12, 30), datetime(1995, 1, 2, 12, 30))\n\n    return (tzi, ) + dates\n\n\nresolve_imaginary_tests = [\n    (tz.gettz('Europe/London'),\n     datetime(2018, 3, 25, 1, 30), datetime(2018, 3, 25, 2, 30)),\n    (tz.gettz('America/New_York'),\n     datetime(2017, 3, 12, 2, 30), datetime(2017, 3, 12, 3, 30)),\n    (tz.gettz('Australia/Sydney'),\n     datetime(2014, 10, 5, 2, 0), datetime(2014, 10, 5, 3, 0)),\n    __get_kiritimati_resolve_imaginary_test(),\n]\n\n\nif SUPPORTS_SUB_MINUTE_OFFSETS:\n    resolve_imaginary_tests.append(\n        (tz.gettz('Africa/Monrovia'),\n         datetime(1972, 1, 7, 0, 30), datetime(1972, 1, 7, 1, 14, 30)))\n\n\n@pytest.mark.tz_resolve_imaginary\n@pytest.mark.parametrize('tzi, dt, dt_exp', resolve_imaginary_tests)\ndef test_resolve_imaginary(tzi, dt, dt_exp):\n    dt = dt.replace(tzinfo=tzi)\n    dt_exp = dt_exp.replace(tzinfo=tzi)\n\n    dt_r = tz.resolve_imaginary(dt)\n    assert dt_r == dt_exp\n    assert dt_r.tzname() == dt_exp.tzname()\n    assert dt_r.utcoffset() == dt_exp.utcoffset()\n", "tests/test_relativedelta.py": "# -*- coding: utf-8 -*-\nfrom __future__ import unicode_literals\nfrom ._common import NotAValue\n\nimport calendar\nfrom datetime import datetime, date, timedelta\nimport unittest\n\nimport pytest\n\nfrom dateutil.relativedelta import relativedelta, MO, TU, WE, FR, SU\n\n\nclass RelativeDeltaTest(unittest.TestCase):\n    now = datetime(2003, 9, 17, 20, 54, 47, 282310)\n    today = date(2003, 9, 17)\n\n    def testInheritance(self):\n        # Ensure that relativedelta is inheritance-friendly.\n        class rdChildClass(relativedelta):\n            pass\n\n        ccRD = rdChildClass(years=1, months=1, days=1, leapdays=1, weeks=1,\n                            hours=1, minutes=1, seconds=1, microseconds=1)\n\n        rd = relativedelta(years=1, months=1, days=1, leapdays=1, weeks=1,\n                           hours=1, minutes=1, seconds=1, microseconds=1)\n\n        self.assertEqual(type(ccRD + rd), type(ccRD),\n                         msg='Addition does not inherit type.')\n\n        self.assertEqual(type(ccRD - rd), type(ccRD),\n                         msg='Subtraction does not inherit type.')\n\n        self.assertEqual(type(-ccRD), type(ccRD),\n                         msg='Negation does not inherit type.')\n\n        self.assertEqual(type(ccRD * 5.0), type(ccRD),\n                         msg='Multiplication does not inherit type.')\n\n        self.assertEqual(type(ccRD / 5.0), type(ccRD),\n                         msg='Division does not inherit type.')\n\n    def testMonthEndMonthBeginning(self):\n        self.assertEqual(relativedelta(datetime(2003, 1, 31, 23, 59, 59),\n                                       datetime(2003, 3, 1, 0, 0, 0)),\n                         relativedelta(months=-1, seconds=-1))\n\n        self.assertEqual(relativedelta(datetime(2003, 3, 1, 0, 0, 0),\n                                       datetime(2003, 1, 31, 23, 59, 59)),\n                         relativedelta(months=1, seconds=1))\n\n    def testMonthEndMonthBeginningLeapYear(self):\n        self.assertEqual(relativedelta(datetime(2012, 1, 31, 23, 59, 59),\n                                       datetime(2012, 3, 1, 0, 0, 0)),\n                         relativedelta(months=-1, seconds=-1))\n\n        self.assertEqual(relativedelta(datetime(2003, 3, 1, 0, 0, 0),\n                                       datetime(2003, 1, 31, 23, 59, 59)),\n                         relativedelta(months=1, seconds=1))\n\n    def testNextMonth(self):\n        self.assertEqual(self.now+relativedelta(months=+1),\n                         datetime(2003, 10, 17, 20, 54, 47, 282310))\n\n    def testNextMonthPlusOneWeek(self):\n        self.assertEqual(self.now+relativedelta(months=+1, weeks=+1),\n                         datetime(2003, 10, 24, 20, 54, 47, 282310))\n\n    def testNextMonthPlusOneWeek10am(self):\n        self.assertEqual(self.today +\n                         relativedelta(months=+1, weeks=+1, hour=10),\n                         datetime(2003, 10, 24, 10, 0))\n\n    def testNextMonthPlusOneWeek10amDiff(self):\n        self.assertEqual(relativedelta(datetime(2003, 10, 24, 10, 0),\n                                       self.today),\n                         relativedelta(months=+1, days=+7, hours=+10))\n\n    def testOneMonthBeforeOneYear(self):\n        self.assertEqual(self.now+relativedelta(years=+1, months=-1),\n                         datetime(2004, 8, 17, 20, 54, 47, 282310))\n\n    def testMonthsOfDiffNumOfDays(self):\n        self.assertEqual(date(2003, 1, 27)+relativedelta(months=+1),\n                         date(2003, 2, 27))\n        self.assertEqual(date(2003, 1, 31)+relativedelta(months=+1),\n                         date(2003, 2, 28))\n        self.assertEqual(date(2003, 1, 31)+relativedelta(months=+2),\n                         date(2003, 3, 31))\n\n    def testMonthsOfDiffNumOfDaysWithYears(self):\n        self.assertEqual(date(2000, 2, 28)+relativedelta(years=+1),\n                         date(2001, 2, 28))\n        self.assertEqual(date(2000, 2, 29)+relativedelta(years=+1),\n                         date(2001, 2, 28))\n\n        self.assertEqual(date(1999, 2, 28)+relativedelta(years=+1),\n                         date(2000, 2, 28))\n        self.assertEqual(date(1999, 3, 1)+relativedelta(years=+1),\n                         date(2000, 3, 1))\n        self.assertEqual(date(1999, 3, 1)+relativedelta(years=+1),\n                         date(2000, 3, 1))\n\n        self.assertEqual(date(2001, 2, 28)+relativedelta(years=-1),\n                         date(2000, 2, 28))\n        self.assertEqual(date(2001, 3, 1)+relativedelta(years=-1),\n                         date(2000, 3, 1))\n\n    def testNextFriday(self):\n        self.assertEqual(self.today+relativedelta(weekday=FR),\n                         date(2003, 9, 19))\n\n    def testNextFridayInt(self):\n        self.assertEqual(self.today+relativedelta(weekday=calendar.FRIDAY),\n                         date(2003, 9, 19))\n\n    def testLastFridayInThisMonth(self):\n        self.assertEqual(self.today+relativedelta(day=31, weekday=FR(-1)),\n                         date(2003, 9, 26))\n\n    def testLastDayOfFebruary(self):\n        self.assertEqual(date(2021, 2, 1) + relativedelta(day=31),\n                         date(2021, 2, 28))\n\n    def testLastDayOfFebruaryLeapYear(self):\n        self.assertEqual(date(2020, 2, 1) + relativedelta(day=31),\n                         date(2020, 2, 29))\n\n    def testNextWednesdayIsToday(self):\n        self.assertEqual(self.today+relativedelta(weekday=WE),\n                         date(2003, 9, 17))\n\n    def testNextWednesdayNotToday(self):\n        self.assertEqual(self.today+relativedelta(days=+1, weekday=WE),\n                         date(2003, 9, 24))\n\n    def testAddMoreThan12Months(self):\n        self.assertEqual(date(2003, 12, 1) + relativedelta(months=+13),\n                         date(2005, 1, 1))\n\n    def testAddNegativeMonths(self):\n        self.assertEqual(date(2003, 1, 1) + relativedelta(months=-2),\n                         date(2002, 11, 1))\n\n    def test15thISOYearWeek(self):\n        self.assertEqual(date(2003, 1, 1) +\n                         relativedelta(day=4, weeks=+14, weekday=MO(-1)),\n                         date(2003, 4, 7))\n\n    def testMillenniumAge(self):\n        self.assertEqual(relativedelta(self.now, date(2001, 1, 1)),\n                         relativedelta(years=+2, months=+8, days=+16,\n                                       hours=+20, minutes=+54, seconds=+47,\n                                       microseconds=+282310))\n\n    def testJohnAge(self):\n        self.assertEqual(relativedelta(self.now,\n                                       datetime(1978, 4, 5, 12, 0)),\n                         relativedelta(years=+25, months=+5, days=+12,\n                                       hours=+8, minutes=+54, seconds=+47,\n                                       microseconds=+282310))\n\n    def testJohnAgeWithDate(self):\n        self.assertEqual(relativedelta(self.today,\n                                       datetime(1978, 4, 5, 12, 0)),\n                         relativedelta(years=+25, months=+5, days=+11,\n                                       hours=+12))\n\n    def testYearDay(self):\n        self.assertEqual(date(2003, 1, 1)+relativedelta(yearday=260),\n                         date(2003, 9, 17))\n        self.assertEqual(date(2002, 1, 1)+relativedelta(yearday=260),\n                         date(2002, 9, 17))\n        self.assertEqual(date(2000, 1, 1)+relativedelta(yearday=260),\n                         date(2000, 9, 16))\n        self.assertEqual(self.today+relativedelta(yearday=261),\n                         date(2003, 9, 18))\n\n    def testYearDayBug(self):\n        # Tests a problem reported by Adam Ryan.\n        self.assertEqual(date(2010, 1, 1)+relativedelta(yearday=15),\n                         date(2010, 1, 15))\n\n    def testNonLeapYearDay(self):\n        self.assertEqual(date(2003, 1, 1)+relativedelta(nlyearday=260),\n                         date(2003, 9, 17))\n        self.assertEqual(date(2002, 1, 1)+relativedelta(nlyearday=260),\n                         date(2002, 9, 17))\n        self.assertEqual(date(2000, 1, 1)+relativedelta(nlyearday=260),\n                         date(2000, 9, 17))\n        self.assertEqual(self.today+relativedelta(yearday=261),\n                         date(2003, 9, 18))\n\n    def testAddition(self):\n        self.assertEqual(relativedelta(days=10) +\n                         relativedelta(years=1, months=2, days=3, hours=4,\n                                       minutes=5, microseconds=6),\n                         relativedelta(years=1, months=2, days=13, hours=4,\n                                       minutes=5, microseconds=6))\n\n    def testAbsoluteAddition(self):\n        self.assertEqual(relativedelta() + relativedelta(day=0, hour=0),\n                         relativedelta(day=0, hour=0))\n        self.assertEqual(relativedelta(day=0, hour=0) + relativedelta(),\n                         relativedelta(day=0, hour=0))\n\n    def testAdditionToDatetime(self):\n        self.assertEqual(datetime(2000, 1, 1) + relativedelta(days=1),\n                         datetime(2000, 1, 2))\n\n    def testRightAdditionToDatetime(self):\n        self.assertEqual(relativedelta(days=1) + datetime(2000, 1, 1),\n                         datetime(2000, 1, 2))\n\n    def testAdditionInvalidType(self):\n        with self.assertRaises(TypeError):\n            relativedelta(days=3) + 9\n\n    def testAdditionUnsupportedType(self):\n        # For unsupported types that define their own comparators, etc.\n        self.assertIs(relativedelta(days=1) + NotAValue, NotAValue)\n\n    def testAdditionFloatValue(self):\n        self.assertEqual(datetime(2000, 1, 1) + relativedelta(days=float(1)),\n                         datetime(2000, 1, 2))\n        self.assertEqual(datetime(2000, 1, 1) + relativedelta(months=float(1)),\n                         datetime(2000, 2, 1))\n        self.assertEqual(datetime(2000, 1, 1) + relativedelta(years=float(1)),\n                         datetime(2001, 1, 1))\n\n    def testAdditionFloatFractionals(self):\n        self.assertEqual(datetime(2000, 1, 1, 0) +\n                         relativedelta(days=float(0.5)),\n                         datetime(2000, 1, 1, 12))\n        self.assertEqual(datetime(2000, 1, 1, 0, 0) +\n                         relativedelta(hours=float(0.5)),\n                         datetime(2000, 1, 1, 0, 30))\n        self.assertEqual(datetime(2000, 1, 1, 0, 0, 0) +\n                         relativedelta(minutes=float(0.5)),\n                         datetime(2000, 1, 1, 0, 0, 30))\n        self.assertEqual(datetime(2000, 1, 1, 0, 0, 0, 0) +\n                         relativedelta(seconds=float(0.5)),\n                         datetime(2000, 1, 1, 0, 0, 0, 500000))\n        self.assertEqual(datetime(2000, 1, 1, 0, 0, 0, 0) +\n                         relativedelta(microseconds=float(500000.25)),\n                         datetime(2000, 1, 1, 0, 0, 0, 500000))\n\n    def testSubtraction(self):\n        self.assertEqual(relativedelta(days=10) -\n                         relativedelta(years=1, months=2, days=3, hours=4,\n                                       minutes=5, microseconds=6),\n                         relativedelta(years=-1, months=-2, days=7, hours=-4,\n                                       minutes=-5, microseconds=-6))\n\n    def testRightSubtractionFromDatetime(self):\n        self.assertEqual(datetime(2000, 1, 2) - relativedelta(days=1),\n                         datetime(2000, 1, 1))\n\n    def testSubractionWithDatetime(self):\n        self.assertRaises(TypeError, lambda x, y: x - y,\n                          (relativedelta(days=1), datetime(2000, 1, 1)))\n\n    def testSubtractionInvalidType(self):\n        with self.assertRaises(TypeError):\n            relativedelta(hours=12) - 14\n\n    def testSubtractionUnsupportedType(self):\n        self.assertIs(relativedelta(days=1) + NotAValue, NotAValue)\n\n    def testMultiplication(self):\n        self.assertEqual(datetime(2000, 1, 1) + relativedelta(days=1) * 28,\n                         datetime(2000, 1, 29))\n        self.assertEqual(datetime(2000, 1, 1) + 28 * relativedelta(days=1),\n                         datetime(2000, 1, 29))\n\n    def testMultiplicationUnsupportedType(self):\n        self.assertIs(relativedelta(days=1) * NotAValue, NotAValue)\n\n    def testDivision(self):\n        self.assertEqual(datetime(2000, 1, 1) + relativedelta(days=28) / 28,\n                         datetime(2000, 1, 2))\n\n    def testDivisionUnsupportedType(self):\n        self.assertIs(relativedelta(days=1) / NotAValue, NotAValue)\n\n    def testBoolean(self):\n        self.assertFalse(relativedelta(days=0))\n        self.assertTrue(relativedelta(days=1))\n\n    def testAbsoluteValueNegative(self):\n        rd_base = relativedelta(years=-1, months=-5, days=-2, hours=-3,\n                                minutes=-5, seconds=-2, microseconds=-12)\n        rd_expected = relativedelta(years=1, months=5, days=2, hours=3,\n                                    minutes=5, seconds=2, microseconds=12)\n        self.assertEqual(abs(rd_base), rd_expected)\n\n    def testAbsoluteValuePositive(self):\n        rd_base = relativedelta(years=1, months=5, days=2, hours=3,\n                                minutes=5, seconds=2, microseconds=12)\n        rd_expected = rd_base\n\n        self.assertEqual(abs(rd_base), rd_expected)\n\n    def testComparison(self):\n        d1 = relativedelta(years=1, months=1, days=1, leapdays=0, hours=1,\n                           minutes=1, seconds=1, microseconds=1)\n        d2 = relativedelta(years=1, months=1, days=1, leapdays=0, hours=1,\n                           minutes=1, seconds=1, microseconds=1)\n        d3 = relativedelta(years=1, months=1, days=1, leapdays=0, hours=1,\n                           minutes=1, seconds=1, microseconds=2)\n\n        self.assertEqual(d1, d2)\n        self.assertNotEqual(d1, d3)\n\n    def testInequalityTypeMismatch(self):\n        # Different type\n        self.assertFalse(relativedelta(year=1) == 19)\n\n    def testInequalityUnsupportedType(self):\n        self.assertIs(relativedelta(hours=3) == NotAValue, NotAValue)\n\n    def testInequalityWeekdays(self):\n        # Different weekdays\n        no_wday = relativedelta(year=1997, month=4)\n        wday_mo_1 = relativedelta(year=1997, month=4, weekday=MO(+1))\n        wday_mo_2 = relativedelta(year=1997, month=4, weekday=MO(+2))\n        wday_tu = relativedelta(year=1997, month=4, weekday=TU)\n\n        self.assertTrue(wday_mo_1 == wday_mo_1)\n\n        self.assertFalse(no_wday == wday_mo_1)\n        self.assertFalse(wday_mo_1 == no_wday)\n\n        self.assertFalse(wday_mo_1 == wday_mo_2)\n        self.assertFalse(wday_mo_2 == wday_mo_1)\n\n        self.assertFalse(wday_mo_1 == wday_tu)\n        self.assertFalse(wday_tu == wday_mo_1)\n\n    def testMonthOverflow(self):\n        self.assertEqual(relativedelta(months=273),\n                         relativedelta(years=22, months=9))\n\n    def testWeeks(self):\n        # Test that the weeks property is working properly.\n        rd = relativedelta(years=4, months=2, weeks=8, days=6)\n        self.assertEqual((rd.weeks, rd.days), (8, 8 * 7 + 6))\n\n        rd.weeks = 3\n        self.assertEqual((rd.weeks, rd.days), (3, 3 * 7 + 6))\n\n    def testRelativeDeltaRepr(self):\n        self.assertEqual(repr(relativedelta(years=1, months=-1, days=15)),\n                         'relativedelta(years=+1, months=-1, days=+15)')\n\n        self.assertEqual(repr(relativedelta(months=14, seconds=-25)),\n                         'relativedelta(years=+1, months=+2, seconds=-25)')\n\n        self.assertEqual(repr(relativedelta(month=3, hour=3, weekday=SU(3))),\n                         'relativedelta(month=3, weekday=SU(+3), hour=3)')\n\n    def testRelativeDeltaFractionalYear(self):\n        with self.assertRaises(ValueError):\n            relativedelta(years=1.5)\n\n    def testRelativeDeltaFractionalMonth(self):\n        with self.assertRaises(ValueError):\n            relativedelta(months=1.5)\n\n    def testRelativeDeltaInvalidDatetimeObject(self):\n        with self.assertRaises(TypeError):\n            relativedelta(dt1='2018-01-01', dt2='2018-01-02')\n\n        with self.assertRaises(TypeError):\n            relativedelta(dt1=datetime(2018, 1, 1), dt2='2018-01-02')\n\n        with self.assertRaises(TypeError):\n            relativedelta(dt1='2018-01-01', dt2=datetime(2018, 1, 2))\n\n    def testRelativeDeltaFractionalAbsolutes(self):\n        # Fractional absolute values will soon be unsupported,\n        # check for the deprecation warning.\n        with pytest.warns(DeprecationWarning):\n            relativedelta(year=2.86)\n\n        with pytest.warns(DeprecationWarning):\n            relativedelta(month=1.29)\n\n        with pytest.warns(DeprecationWarning):\n            relativedelta(day=0.44)\n\n        with pytest.warns(DeprecationWarning):\n            relativedelta(hour=23.98)\n\n        with pytest.warns(DeprecationWarning):\n            relativedelta(minute=45.21)\n\n        with pytest.warns(DeprecationWarning):\n            relativedelta(second=13.2)\n\n        with pytest.warns(DeprecationWarning):\n            relativedelta(microsecond=157221.93)\n\n    def testRelativeDeltaFractionalRepr(self):\n        rd = relativedelta(years=3, months=-2, days=1.25)\n\n        self.assertEqual(repr(rd),\n                         'relativedelta(years=+3, months=-2, days=+1.25)')\n\n        rd = relativedelta(hours=0.5, seconds=9.22)\n        self.assertEqual(repr(rd),\n                         'relativedelta(hours=+0.5, seconds=+9.22)')\n\n    def testRelativeDeltaFractionalWeeks(self):\n        # Equivalent to days=8, hours=18\n        rd = relativedelta(weeks=1.25)\n        d1 = datetime(2009, 9, 3, 0, 0)\n        self.assertEqual(d1 + rd,\n                         datetime(2009, 9, 11, 18))\n\n    def testRelativeDeltaFractionalDays(self):\n        rd1 = relativedelta(days=1.48)\n\n        d1 = datetime(2009, 9, 3, 0, 0)\n        self.assertEqual(d1 + rd1,\n                         datetime(2009, 9, 4, 11, 31, 12))\n\n        rd2 = relativedelta(days=1.5)\n        self.assertEqual(d1 + rd2,\n                         datetime(2009, 9, 4, 12, 0, 0))\n\n    def testRelativeDeltaFractionalHours(self):\n        rd = relativedelta(days=1, hours=12.5)\n        d1 = datetime(2009, 9, 3, 0, 0)\n        self.assertEqual(d1 + rd,\n                         datetime(2009, 9, 4, 12, 30, 0))\n\n    def testRelativeDeltaFractionalMinutes(self):\n        rd = relativedelta(hours=1, minutes=30.5)\n        d1 = datetime(2009, 9, 3, 0, 0)\n        self.assertEqual(d1 + rd,\n                         datetime(2009, 9, 3, 1, 30, 30))\n\n    def testRelativeDeltaFractionalSeconds(self):\n        rd = relativedelta(hours=5, minutes=30, seconds=30.5)\n        d1 = datetime(2009, 9, 3, 0, 0)\n        self.assertEqual(d1 + rd,\n                         datetime(2009, 9, 3, 5, 30, 30, 500000))\n\n    def testRelativeDeltaFractionalPositiveOverflow(self):\n        # Equivalent to (days=1, hours=14)\n        rd1 = relativedelta(days=1.5, hours=2)\n        d1 = datetime(2009, 9, 3, 0, 0)\n        self.assertEqual(d1 + rd1,\n                         datetime(2009, 9, 4, 14, 0, 0))\n\n        # Equivalent to (days=1, hours=14, minutes=45)\n        rd2 = relativedelta(days=1.5, hours=2.5, minutes=15)\n        d1 = datetime(2009, 9, 3, 0, 0)\n        self.assertEqual(d1 + rd2,\n                         datetime(2009, 9, 4, 14, 45))\n\n        # Carry back up - equivalent to (days=2, hours=2, minutes=0, seconds=1)\n        rd3 = relativedelta(days=1.5, hours=13, minutes=59.5, seconds=31)\n        self.assertEqual(d1 + rd3,\n                         datetime(2009, 9, 5, 2, 0, 1))\n\n    def testRelativeDeltaFractionalNegativeDays(self):\n        # Equivalent to (days=-1, hours=-1)\n        rd1 = relativedelta(days=-1.5, hours=11)\n        d1 = datetime(2009, 9, 3, 12, 0)\n        self.assertEqual(d1 + rd1,\n                         datetime(2009, 9, 2, 11, 0, 0))\n\n        # Equivalent to (days=-1, hours=-9)\n        rd2 = relativedelta(days=-1.25, hours=-3)\n        self.assertEqual(d1 + rd2,\n            datetime(2009, 9, 2, 3))\n\n    def testRelativeDeltaNormalizeFractionalDays(self):\n        # Equivalent to (days=2, hours=18)\n        rd1 = relativedelta(days=2.75)\n\n        self.assertEqual(rd1.normalized(), relativedelta(days=2, hours=18))\n\n        # Equivalent to (days=1, hours=11, minutes=31, seconds=12)\n        rd2 = relativedelta(days=1.48)\n\n        self.assertEqual(rd2.normalized(),\n            relativedelta(days=1, hours=11, minutes=31, seconds=12))\n\n    def testRelativeDeltaNormalizeFractionalDays2(self):\n        # Equivalent to (hours=1, minutes=30)\n        rd1 = relativedelta(hours=1.5)\n\n        self.assertEqual(rd1.normalized(), relativedelta(hours=1, minutes=30))\n\n        # Equivalent to (hours=3, minutes=17, seconds=5, microseconds=100)\n        rd2 = relativedelta(hours=3.28472225)\n\n        self.assertEqual(rd2.normalized(),\n            relativedelta(hours=3, minutes=17, seconds=5, microseconds=100))\n\n    def testRelativeDeltaNormalizeFractionalMinutes(self):\n        # Equivalent to (minutes=15, seconds=36)\n        rd1 = relativedelta(minutes=15.6)\n\n        self.assertEqual(rd1.normalized(),\n            relativedelta(minutes=15, seconds=36))\n\n        # Equivalent to (minutes=25, seconds=20, microseconds=25000)\n        rd2 = relativedelta(minutes=25.33375)\n\n        self.assertEqual(rd2.normalized(),\n            relativedelta(minutes=25, seconds=20, microseconds=25000))\n\n    def testRelativeDeltaNormalizeFractionalSeconds(self):\n        # Equivalent to (seconds=45, microseconds=25000)\n        rd1 = relativedelta(seconds=45.025)\n        self.assertEqual(rd1.normalized(),\n            relativedelta(seconds=45, microseconds=25000))\n\n    def testRelativeDeltaFractionalPositiveOverflow2(self):\n        # Equivalent to (days=1, hours=14)\n        rd1 = relativedelta(days=1.5, hours=2)\n        self.assertEqual(rd1.normalized(),\n            relativedelta(days=1, hours=14))\n\n        # Equivalent to (days=1, hours=14, minutes=45)\n        rd2 = relativedelta(days=1.5, hours=2.5, minutes=15)\n        self.assertEqual(rd2.normalized(),\n            relativedelta(days=1, hours=14, minutes=45))\n\n        # Carry back up - equivalent to:\n        # (days=2, hours=2, minutes=0, seconds=2, microseconds=3)\n        rd3 = relativedelta(days=1.5, hours=13, minutes=59.50045,\n                            seconds=31.473, microseconds=500003)\n        self.assertEqual(rd3.normalized(),\n            relativedelta(days=2, hours=2, minutes=0,\n                          seconds=2, microseconds=3))\n\n    def testRelativeDeltaFractionalNegativeOverflow(self):\n        # Equivalent to (days=-1)\n        rd1 = relativedelta(days=-0.5, hours=-12)\n        self.assertEqual(rd1.normalized(),\n            relativedelta(days=-1))\n\n        # Equivalent to (days=-1)\n        rd2 = relativedelta(days=-1.5, hours=12)\n        self.assertEqual(rd2.normalized(),\n            relativedelta(days=-1))\n\n        # Equivalent to (days=-1, hours=-14, minutes=-45)\n        rd3 = relativedelta(days=-1.5, hours=-2.5, minutes=-15)\n        self.assertEqual(rd3.normalized(),\n            relativedelta(days=-1, hours=-14, minutes=-45))\n\n        # Equivalent to (days=-1, hours=-14, minutes=+15)\n        rd4 = relativedelta(days=-1.5, hours=-2.5, minutes=45)\n        self.assertEqual(rd4.normalized(),\n            relativedelta(days=-1, hours=-14, minutes=+15))\n\n        # Carry back up - equivalent to:\n        # (days=-2, hours=-2, minutes=0, seconds=-2, microseconds=-3)\n        rd3 = relativedelta(days=-1.5, hours=-13, minutes=-59.50045,\n                            seconds=-31.473, microseconds=-500003)\n        self.assertEqual(rd3.normalized(),\n            relativedelta(days=-2, hours=-2, minutes=0,\n                          seconds=-2, microseconds=-3))\n\n    def testInvalidYearDay(self):\n        with self.assertRaises(ValueError):\n            relativedelta(yearday=367)\n\n    def testAddTimedeltaToUnpopulatedRelativedelta(self):\n        td = timedelta(\n            days=1,\n            seconds=1,\n            microseconds=1,\n            milliseconds=1,\n            minutes=1,\n            hours=1,\n            weeks=1\n        )\n\n        expected = relativedelta(\n            weeks=1,\n            days=1,\n            hours=1,\n            minutes=1,\n            seconds=1,\n            microseconds=1001\n        )\n\n        self.assertEqual(expected, relativedelta() + td)\n\n    def testAddTimedeltaToPopulatedRelativeDelta(self):\n        td = timedelta(\n            days=1,\n            seconds=1,\n            microseconds=1,\n            milliseconds=1,\n            minutes=1,\n            hours=1,\n            weeks=1\n        )\n\n        rd = relativedelta(\n            year=1,\n            month=1,\n            day=1,\n            hour=1,\n            minute=1,\n            second=1,\n            microsecond=1,\n            years=1,\n            months=1,\n            days=1,\n            weeks=1,\n            hours=1,\n            minutes=1,\n            seconds=1,\n            microseconds=1\n        )\n\n        expected = relativedelta(\n            year=1,\n            month=1,\n            day=1,\n            hour=1,\n            minute=1,\n            second=1,\n            microsecond=1,\n            years=1,\n            months=1,\n            weeks=2,\n            days=2,\n            hours=2,\n            minutes=2,\n            seconds=2,\n            microseconds=1002,\n        )\n\n        self.assertEqual(expected, rd + td)\n\n    def testHashable(self):\n        try:\n            {relativedelta(minute=1): 'test'}\n        except:\n            self.fail(\"relativedelta() failed to hash!\")\n\n    def testDayOfMonthPlus(self):\n        assert [\n            date(2021, 1, 28) + relativedelta(months=1),\n            date(2021, 2, 27) + relativedelta(months=1),\n            date(2021, 4, 29) + relativedelta(months=1),\n            date(2021, 5, 30) + relativedelta(months=1),\n        ] == [\n            date(2021, 2, 28),\n            date(2021, 3, 27),\n            date(2021, 5, 29),\n            date(2021, 6, 30),\n        ]\n\n    def testLastDayOfMonthPlus(self):\n        assert [\n            date(2021, 1, 31) + relativedelta(months=1),\n            date(2021, 1, 30) + relativedelta(months=1),\n            date(2021, 1, 29) + relativedelta(months=1),\n            date(2021, 1, 28) + relativedelta(months=1),\n            date(2021, 2, 28) + relativedelta(months=1),\n            date(2021, 4, 30) + relativedelta(months=1),\n            date(2021, 5, 31) + relativedelta(months=1),\n        ] == [\n            date(2021, 2, 28),\n            date(2021, 2, 28),\n            date(2021, 2, 28),\n            date(2021, 2, 28),\n            date(2021, 3, 28),\n            date(2021, 5, 30),\n            date(2021, 6, 30),\n        ]\n\n    def testDayOfMonthMinus(self):\n        assert [\n           date(2021, 2, 27) - relativedelta(months=1),\n           date(2021, 3, 30) - relativedelta(months=1),\n           date(2021, 3, 29) - relativedelta(months=1),\n           date(2021, 3, 28) - relativedelta(months=1),\n           date(2021, 5, 30) - relativedelta(months=1),\n           date(2021, 6, 29) - relativedelta(months=1),\n        ] == [\n            date(2021, 1, 27),\n            date(2021, 2, 28),\n            date(2021, 2, 28),\n            date(2021, 2, 28),\n            date(2021, 4, 30),\n            date(2021, 5, 29),\n        ]\n\n    def testLastDayOfMonthMinus(self):\n        assert [\n            date(2021, 2, 28) - relativedelta(months=1),\n            date(2021, 3, 31) - relativedelta(months=1),\n            date(2021, 5, 31) - relativedelta(months=1),\n            date(2021, 6, 30) - relativedelta(months=1),\n        ] == [\n            date(2021, 1, 28),\n            date(2021, 2, 28),\n            date(2021, 4, 30),\n            date(2021, 5, 30),\n        ]\n\nclass RelativeDeltaWeeksPropertyGetterTest(unittest.TestCase):\n    \"\"\"Test the weeks property getter\"\"\"\n\n    def test_one_day(self):\n        rd = relativedelta(days=1)\n        self.assertEqual(rd.days, 1)\n        self.assertEqual(rd.weeks, 0)\n\n    def test_minus_one_day(self):\n        rd = relativedelta(days=-1)\n        self.assertEqual(rd.days, -1)\n        self.assertEqual(rd.weeks, 0)\n\n    def test_height_days(self):\n        rd = relativedelta(days=8)\n        self.assertEqual(rd.days, 8)\n        self.assertEqual(rd.weeks, 1)\n\n    def test_minus_height_days(self):\n        rd = relativedelta(days=-8)\n        self.assertEqual(rd.days, -8)\n        self.assertEqual(rd.weeks, -1)\n\n\nclass RelativeDeltaWeeksPropertySetterTest(unittest.TestCase):\n    \"\"\"Test the weeks setter which makes a \"smart\" update of the days attribute\"\"\"\n\n    def test_one_day_set_one_week(self):\n        rd = relativedelta(days=1)\n        rd.weeks = 1  # add 7 days\n        self.assertEqual(rd.days, 8)\n        self.assertEqual(rd.weeks, 1)\n\n    def test_minus_one_day_set_one_week(self):\n        rd = relativedelta(days=-1)\n        rd.weeks = 1  # add 7 days\n        self.assertEqual(rd.days, 6)\n        self.assertEqual(rd.weeks, 0)\n\n    def test_height_days_set_minus_one_week(self):\n        rd = relativedelta(days=8)\n        rd.weeks = -1  # change from 1 week, 1 day to -1 week, 1 day\n        self.assertEqual(rd.days, -6)\n        self.assertEqual(rd.weeks, 0)\n\n    def test_minus_height_days_set_minus_one_week(self):\n        rd = relativedelta(days=-8)\n        rd.weeks = -1  # does not change anything\n        self.assertEqual(rd.days, -8)\n        self.assertEqual(rd.weeks, -1)\n\n\n# vim:ts=4:sw=4:et\n", "tests/__init__.py": "", "tests/test_internals.py": "# -*- coding: utf-8 -*-\n\"\"\"\nTests for implementation details, not necessarily part of the user-facing\nAPI.\n\nThe motivating case for these tests is #483, where we want to smoke-test\ncode that may be difficult to reach through the standard API calls.\n\"\"\"\n\nimport sys\nimport pytest\nimport warnings\n\nfrom dateutil.parser._parser import _ymd\nfrom dateutil import tz\n\nIS_PY32 = sys.version_info[0:2] == (3, 2)\n\n\n@pytest.mark.smoke\ndef test_YMD_could_be_day():\n    ymd = _ymd('foo bar 124 baz')\n\n    ymd.append(2, 'M')\n    assert ymd.has_month\n    assert not ymd.has_year\n    assert ymd.could_be_day(4)\n    assert not ymd.could_be_day(-6)\n    assert not ymd.could_be_day(32)\n\n    # Assumes leap year\n    assert ymd.could_be_day(29)\n\n    ymd.append(1999)\n    assert ymd.has_year\n    assert not ymd.could_be_day(29)\n\n    ymd.append(16, 'D')\n    assert ymd.has_day\n    assert not ymd.could_be_day(1)\n\n    ymd = _ymd('foo bar 124 baz')\n    ymd.append(1999)\n    assert ymd.could_be_day(31)\n\n\n###\n# Test that private interfaces in _parser are deprecated properly\n@pytest.mark.skipif(IS_PY32, reason='pytest.warns not supported on Python 3.2')\ndef test_parser_private_warns():\n    from dateutil.parser import _timelex, _tzparser\n    from dateutil.parser import _parsetz\n\n    with pytest.warns(DeprecationWarning):\n        _tzparser()\n\n    with pytest.warns(DeprecationWarning):\n        _timelex('2014-03-03')\n\n    with pytest.warns(DeprecationWarning):\n        _parsetz('+05:00')\n\n\n@pytest.mark.skipif(IS_PY32, reason='pytest.warns not supported on Python 3.2')\ndef test_parser_parser_private_not_warns():\n    from dateutil.parser._parser import _timelex, _tzparser\n    from dateutil.parser._parser import _parsetz\n\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"error\")\n        _tzparser()\n\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"error\")\n        _timelex('2014-03-03')\n\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"error\")\n        _parsetz('+05:00')\n\n\n@pytest.mark.tzstr\ndef test_tzstr_internal_timedeltas():\n    with pytest.warns(tz.DeprecatedTzFormatWarning):\n        tz1 = tz.tzstr(\"EST5EDT,5,4,0,7200,11,-3,0,7200\")\n\n    with pytest.warns(tz.DeprecatedTzFormatWarning):\n        tz2 = tz.tzstr(\"EST5EDT,4,1,0,7200,10,-1,0,7200\")\n\n    assert tz1._start_delta != tz2._start_delta\n    assert tz1._end_delta != tz2._end_delta\n", "tests/test_rrule.py": "# -*- coding: utf-8 -*-\nfrom __future__ import unicode_literals\n\nfrom datetime import datetime, date\nimport unittest\nfrom six import PY2\n\nfrom dateutil import tz\nfrom dateutil.rrule import (\n    rrule, rruleset, rrulestr,\n    YEARLY, MONTHLY, WEEKLY, DAILY,\n    HOURLY, MINUTELY, SECONDLY,\n    MO, TU, WE, TH, FR, SA, SU\n)\n\nfrom freezegun import freeze_time\n\nimport pytest\n\n\n@pytest.mark.rrule\nclass RRuleTest(unittest.TestCase):\n    def _rrulestr_reverse_test(self, rule):\n        \"\"\"\n        Call with an `rrule` and it will test that `str(rrule)` generates a\n        string which generates the same `rrule` as the input when passed to\n        `rrulestr()`\n        \"\"\"\n        rr_str = str(rule)\n        rrulestr_rrule = rrulestr(rr_str)\n\n        self.assertEqual(list(rule), list(rrulestr_rrule))\n\n    def testStrAppendRRULEToken(self):\n        # `_rrulestr_reverse_test` does not check if the \"RRULE:\" prefix\n        # property is appended properly, so give it a dedicated test\n        self.assertEqual(str(rrule(YEARLY,\n                             count=5,\n                             dtstart=datetime(1997, 9, 2, 9, 0))),\n                         \"DTSTART:19970902T090000\\n\"\n                         \"RRULE:FREQ=YEARLY;COUNT=5\")\n\n        rr_str = (\n          'DTSTART:19970105T083000\\nRRULE:FREQ=YEARLY;INTERVAL=2'\n        )\n        self.assertEqual(str(rrulestr(rr_str)), rr_str)\n\n    def testYearly(self):\n        self.assertEqual(list(rrule(YEARLY,\n                              count=3,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1998, 9, 2, 9, 0),\n                          datetime(1999, 9, 2, 9, 0)])\n\n    def testYearlyInterval(self):\n        self.assertEqual(list(rrule(YEARLY,\n                              count=3,\n                              interval=2,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1999, 9, 2, 9, 0),\n                          datetime(2001, 9, 2, 9, 0)])\n\n    def testYearlyIntervalLarge(self):\n        self.assertEqual(list(rrule(YEARLY,\n                              count=3,\n                              interval=100,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(2097, 9, 2, 9, 0),\n                          datetime(2197, 9, 2, 9, 0)])\n\n    def testYearlyByMonth(self):\n        self.assertEqual(list(rrule(YEARLY,\n                              count=3,\n                              bymonth=(1, 3),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 1, 2, 9, 0),\n                          datetime(1998, 3, 2, 9, 0),\n                          datetime(1999, 1, 2, 9, 0)])\n\n    def testYearlyByMonthDay(self):\n        self.assertEqual(list(rrule(YEARLY,\n                              count=3,\n                              bymonthday=(1, 3),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 3, 9, 0),\n                          datetime(1997, 10, 1, 9, 0),\n                          datetime(1997, 10, 3, 9, 0)])\n\n    def testYearlyByMonthAndMonthDay(self):\n        self.assertEqual(list(rrule(YEARLY,\n                              count=3,\n                              bymonth=(1, 3),\n                              bymonthday=(5, 7),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 1, 5, 9, 0),\n                          datetime(1998, 1, 7, 9, 0),\n                          datetime(1998, 3, 5, 9, 0)])\n\n    def testYearlyByWeekDay(self):\n        self.assertEqual(list(rrule(YEARLY,\n                              count=3,\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1997, 9, 4, 9, 0),\n                          datetime(1997, 9, 9, 9, 0)])\n\n    def testYearlyByNWeekDay(self):\n        self.assertEqual(list(rrule(YEARLY,\n                              count=3,\n                              byweekday=(TU(1), TH(-1)),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 12, 25, 9, 0),\n                          datetime(1998, 1, 6, 9, 0),\n                          datetime(1998, 12, 31, 9, 0)])\n\n    def testYearlyByNWeekDayLarge(self):\n        self.assertEqual(list(rrule(YEARLY,\n                              count=3,\n                              byweekday=(TU(3), TH(-3)),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 12, 11, 9, 0),\n                          datetime(1998, 1, 20, 9, 0),\n                          datetime(1998, 12, 17, 9, 0)])\n\n    def testYearlyByMonthAndWeekDay(self):\n        self.assertEqual(list(rrule(YEARLY,\n                              count=3,\n                              bymonth=(1, 3),\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 1, 1, 9, 0),\n                          datetime(1998, 1, 6, 9, 0),\n                          datetime(1998, 1, 8, 9, 0)])\n\n    def testYearlyByMonthAndNWeekDay(self):\n        self.assertEqual(list(rrule(YEARLY,\n                              count=3,\n                              bymonth=(1, 3),\n                              byweekday=(TU(1), TH(-1)),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 1, 6, 9, 0),\n                          datetime(1998, 1, 29, 9, 0),\n                          datetime(1998, 3, 3, 9, 0)])\n\n    def testYearlyByMonthAndNWeekDayLarge(self):\n        # This is interesting because the TH(-3) ends up before\n        # the TU(3).\n        self.assertEqual(list(rrule(YEARLY,\n                              count=3,\n                              bymonth=(1, 3),\n                              byweekday=(TU(3), TH(-3)),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 1, 15, 9, 0),\n                          datetime(1998, 1, 20, 9, 0),\n                          datetime(1998, 3, 12, 9, 0)])\n\n    def testYearlyByMonthDayAndWeekDay(self):\n        self.assertEqual(list(rrule(YEARLY,\n                              count=3,\n                              bymonthday=(1, 3),\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 1, 1, 9, 0),\n                          datetime(1998, 2, 3, 9, 0),\n                          datetime(1998, 3, 3, 9, 0)])\n\n    def testYearlyByMonthAndMonthDayAndWeekDay(self):\n        self.assertEqual(list(rrule(YEARLY,\n                              count=3,\n                              bymonth=(1, 3),\n                              bymonthday=(1, 3),\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 1, 1, 9, 0),\n                          datetime(1998, 3, 3, 9, 0),\n                          datetime(2001, 3, 1, 9, 0)])\n\n    def testYearlyByYearDay(self):\n        self.assertEqual(list(rrule(YEARLY,\n                              count=4,\n                              byyearday=(1, 100, 200, 365),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 12, 31, 9, 0),\n                          datetime(1998, 1, 1, 9, 0),\n                          datetime(1998, 4, 10, 9, 0),\n                          datetime(1998, 7, 19, 9, 0)])\n\n    def testYearlyByYearDayNeg(self):\n        self.assertEqual(list(rrule(YEARLY,\n                              count=4,\n                              byyearday=(-365, -266, -166, -1),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 12, 31, 9, 0),\n                          datetime(1998, 1, 1, 9, 0),\n                          datetime(1998, 4, 10, 9, 0),\n                          datetime(1998, 7, 19, 9, 0)])\n\n    def testYearlyByMonthAndYearDay(self):\n        self.assertEqual(list(rrule(YEARLY,\n                              count=4,\n                              bymonth=(4, 7),\n                              byyearday=(1, 100, 200, 365),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 4, 10, 9, 0),\n                          datetime(1998, 7, 19, 9, 0),\n                          datetime(1999, 4, 10, 9, 0),\n                          datetime(1999, 7, 19, 9, 0)])\n\n    def testYearlyByMonthAndYearDayNeg(self):\n        self.assertEqual(list(rrule(YEARLY,\n                              count=4,\n                              bymonth=(4, 7),\n                              byyearday=(-365, -266, -166, -1),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 4, 10, 9, 0),\n                          datetime(1998, 7, 19, 9, 0),\n                          datetime(1999, 4, 10, 9, 0),\n                          datetime(1999, 7, 19, 9, 0)])\n\n    def testYearlyByWeekNo(self):\n        self.assertEqual(list(rrule(YEARLY,\n                              count=3,\n                              byweekno=20,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 5, 11, 9, 0),\n                          datetime(1998, 5, 12, 9, 0),\n                          datetime(1998, 5, 13, 9, 0)])\n\n    def testYearlyByWeekNoAndWeekDay(self):\n        # That's a nice one. The first days of week number one\n        # may be in the last year.\n        self.assertEqual(list(rrule(YEARLY,\n                              count=3,\n                              byweekno=1,\n                              byweekday=MO,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 12, 29, 9, 0),\n                          datetime(1999, 1, 4, 9, 0),\n                          datetime(2000, 1, 3, 9, 0)])\n\n    def testYearlyByWeekNoAndWeekDayLarge(self):\n        # Another nice test. The last days of week number 52/53\n        # may be in the next year.\n        self.assertEqual(list(rrule(YEARLY,\n                              count=3,\n                              byweekno=52,\n                              byweekday=SU,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 12, 28, 9, 0),\n                          datetime(1998, 12, 27, 9, 0),\n                          datetime(2000, 1, 2, 9, 0)])\n\n    def testYearlyByWeekNoAndWeekDayLast(self):\n        self.assertEqual(list(rrule(YEARLY,\n                              count=3,\n                              byweekno=-1,\n                              byweekday=SU,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 12, 28, 9, 0),\n                          datetime(1999, 1, 3, 9, 0),\n                          datetime(2000, 1, 2, 9, 0)])\n\n    def testYearlyByEaster(self):\n        self.assertEqual(list(rrule(YEARLY,\n                              count=3,\n                              byeaster=0,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 4, 12, 9, 0),\n                          datetime(1999, 4, 4, 9, 0),\n                          datetime(2000, 4, 23, 9, 0)])\n\n    def testYearlyByEasterPos(self):\n        self.assertEqual(list(rrule(YEARLY,\n                              count=3,\n                              byeaster=1,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 4, 13, 9, 0),\n                          datetime(1999, 4, 5, 9, 0),\n                          datetime(2000, 4, 24, 9, 0)])\n\n    def testYearlyByEasterNeg(self):\n        self.assertEqual(list(rrule(YEARLY,\n                              count=3,\n                              byeaster=-1,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 4, 11, 9, 0),\n                          datetime(1999, 4, 3, 9, 0),\n                          datetime(2000, 4, 22, 9, 0)])\n\n    def testYearlyByWeekNoAndWeekDay53(self):\n        self.assertEqual(list(rrule(YEARLY,\n                              count=3,\n                              byweekno=53,\n                              byweekday=MO,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 12, 28, 9, 0),\n                          datetime(2004, 12, 27, 9, 0),\n                          datetime(2009, 12, 28, 9, 0)])\n\n    def testYearlyByHour(self):\n        self.assertEqual(list(rrule(YEARLY,\n                              count=3,\n                              byhour=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 18, 0),\n                          datetime(1998, 9, 2, 6, 0),\n                          datetime(1998, 9, 2, 18, 0)])\n\n    def testYearlyByMinute(self):\n        self.assertEqual(list(rrule(YEARLY,\n                              count=3,\n                              byminute=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 6),\n                          datetime(1997, 9, 2, 9, 18),\n                          datetime(1998, 9, 2, 9, 6)])\n\n    def testYearlyBySecond(self):\n        self.assertEqual(list(rrule(YEARLY,\n                              count=3,\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 0, 6),\n                          datetime(1997, 9, 2, 9, 0, 18),\n                          datetime(1998, 9, 2, 9, 0, 6)])\n\n    def testYearlyByHourAndMinute(self):\n        self.assertEqual(list(rrule(YEARLY,\n                              count=3,\n                              byhour=(6, 18),\n                              byminute=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 18, 6),\n                          datetime(1997, 9, 2, 18, 18),\n                          datetime(1998, 9, 2, 6, 6)])\n\n    def testYearlyByHourAndSecond(self):\n        self.assertEqual(list(rrule(YEARLY,\n                              count=3,\n                              byhour=(6, 18),\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 18, 0, 6),\n                          datetime(1997, 9, 2, 18, 0, 18),\n                          datetime(1998, 9, 2, 6, 0, 6)])\n\n    def testYearlyByMinuteAndSecond(self):\n        self.assertEqual(list(rrule(YEARLY,\n                              count=3,\n                              byminute=(6, 18),\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 6, 6),\n                          datetime(1997, 9, 2, 9, 6, 18),\n                          datetime(1997, 9, 2, 9, 18, 6)])\n\n    def testYearlyByHourAndMinuteAndSecond(self):\n        self.assertEqual(list(rrule(YEARLY,\n                              count=3,\n                              byhour=(6, 18),\n                              byminute=(6, 18),\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 18, 6, 6),\n                          datetime(1997, 9, 2, 18, 6, 18),\n                          datetime(1997, 9, 2, 18, 18, 6)])\n\n    def testYearlyBySetPos(self):\n        self.assertEqual(list(rrule(YEARLY,\n                              count=3,\n                              bymonthday=15,\n                              byhour=(6, 18),\n                              bysetpos=(3, -3),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 11, 15, 18, 0),\n                          datetime(1998, 2, 15, 6, 0),\n                          datetime(1998, 11, 15, 18, 0)])\n\n    def testMonthly(self):\n        self.assertEqual(list(rrule(MONTHLY,\n                              count=3,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1997, 10, 2, 9, 0),\n                          datetime(1997, 11, 2, 9, 0)])\n\n    def testMonthlyInterval(self):\n        self.assertEqual(list(rrule(MONTHLY,\n                              count=3,\n                              interval=2,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1997, 11, 2, 9, 0),\n                          datetime(1998, 1, 2, 9, 0)])\n\n    def testMonthlyIntervalLarge(self):\n        self.assertEqual(list(rrule(MONTHLY,\n                              count=3,\n                              interval=18,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1999, 3, 2, 9, 0),\n                          datetime(2000, 9, 2, 9, 0)])\n\n    def testMonthlyByMonth(self):\n        self.assertEqual(list(rrule(MONTHLY,\n                              count=3,\n                              bymonth=(1, 3),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 1, 2, 9, 0),\n                          datetime(1998, 3, 2, 9, 0),\n                          datetime(1999, 1, 2, 9, 0)])\n\n    def testMonthlyByMonthDay(self):\n        self.assertEqual(list(rrule(MONTHLY,\n                              count=3,\n                              bymonthday=(1, 3),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 3, 9, 0),\n                          datetime(1997, 10, 1, 9, 0),\n                          datetime(1997, 10, 3, 9, 0)])\n\n    def testMonthlyByMonthAndMonthDay(self):\n        self.assertEqual(list(rrule(MONTHLY,\n                              count=3,\n                              bymonth=(1, 3),\n                              bymonthday=(5, 7),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 1, 5, 9, 0),\n                          datetime(1998, 1, 7, 9, 0),\n                          datetime(1998, 3, 5, 9, 0)])\n\n    def testMonthlyByWeekDay(self):\n        self.assertEqual(list(rrule(MONTHLY,\n                              count=3,\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1997, 9, 4, 9, 0),\n                          datetime(1997, 9, 9, 9, 0)])\n\n        # Third Monday of the month\n        self.assertEqual(rrule(MONTHLY,\n                         byweekday=(MO(+3)),\n                         dtstart=datetime(1997, 9, 1)).between(datetime(1997, 9, 1),\n                                                               datetime(1997, 12, 1)),\n                         [datetime(1997, 9, 15, 0, 0),\n                          datetime(1997, 10, 20, 0, 0),\n                          datetime(1997, 11, 17, 0, 0)])\n\n    def testMonthlyByNWeekDay(self):\n        self.assertEqual(list(rrule(MONTHLY,\n                              count=3,\n                              byweekday=(TU(1), TH(-1)),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1997, 9, 25, 9, 0),\n                          datetime(1997, 10, 7, 9, 0)])\n\n    def testMonthlyByNWeekDayLarge(self):\n        self.assertEqual(list(rrule(MONTHLY,\n                              count=3,\n                              byweekday=(TU(3), TH(-3)),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 11, 9, 0),\n                          datetime(1997, 9, 16, 9, 0),\n                          datetime(1997, 10, 16, 9, 0)])\n\n    def testMonthlyByMonthAndWeekDay(self):\n        self.assertEqual(list(rrule(MONTHLY,\n                              count=3,\n                              bymonth=(1, 3),\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 1, 1, 9, 0),\n                          datetime(1998, 1, 6, 9, 0),\n                          datetime(1998, 1, 8, 9, 0)])\n\n    def testMonthlyByMonthAndNWeekDay(self):\n        self.assertEqual(list(rrule(MONTHLY,\n                              count=3,\n                              bymonth=(1, 3),\n                              byweekday=(TU(1), TH(-1)),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 1, 6, 9, 0),\n                          datetime(1998, 1, 29, 9, 0),\n                          datetime(1998, 3, 3, 9, 0)])\n\n    def testMonthlyByMonthAndNWeekDayLarge(self):\n        self.assertEqual(list(rrule(MONTHLY,\n                              count=3,\n                              bymonth=(1, 3),\n                              byweekday=(TU(3), TH(-3)),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 1, 15, 9, 0),\n                          datetime(1998, 1, 20, 9, 0),\n                          datetime(1998, 3, 12, 9, 0)])\n\n    def testMonthlyByMonthDayAndWeekDay(self):\n        self.assertEqual(list(rrule(MONTHLY,\n                              count=3,\n                              bymonthday=(1, 3),\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 1, 1, 9, 0),\n                          datetime(1998, 2, 3, 9, 0),\n                          datetime(1998, 3, 3, 9, 0)])\n\n    def testMonthlyByMonthAndMonthDayAndWeekDay(self):\n        self.assertEqual(list(rrule(MONTHLY,\n                              count=3,\n                              bymonth=(1, 3),\n                              bymonthday=(1, 3),\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 1, 1, 9, 0),\n                          datetime(1998, 3, 3, 9, 0),\n                          datetime(2001, 3, 1, 9, 0)])\n\n    def testMonthlyByYearDay(self):\n        self.assertEqual(list(rrule(MONTHLY,\n                              count=4,\n                              byyearday=(1, 100, 200, 365),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 12, 31, 9, 0),\n                          datetime(1998, 1, 1, 9, 0),\n                          datetime(1998, 4, 10, 9, 0),\n                          datetime(1998, 7, 19, 9, 0)])\n\n    def testMonthlyByYearDayNeg(self):\n        self.assertEqual(list(rrule(MONTHLY,\n                              count=4,\n                              byyearday=(-365, -266, -166, -1),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 12, 31, 9, 0),\n                          datetime(1998, 1, 1, 9, 0),\n                          datetime(1998, 4, 10, 9, 0),\n                          datetime(1998, 7, 19, 9, 0)])\n\n    def testMonthlyByMonthAndYearDay(self):\n        self.assertEqual(list(rrule(MONTHLY,\n                              count=4,\n                              bymonth=(4, 7),\n                              byyearday=(1, 100, 200, 365),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 4, 10, 9, 0),\n                          datetime(1998, 7, 19, 9, 0),\n                          datetime(1999, 4, 10, 9, 0),\n                          datetime(1999, 7, 19, 9, 0)])\n\n    def testMonthlyByMonthAndYearDayNeg(self):\n        self.assertEqual(list(rrule(MONTHLY,\n                              count=4,\n                              bymonth=(4, 7),\n                              byyearday=(-365, -266, -166, -1),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 4, 10, 9, 0),\n                          datetime(1998, 7, 19, 9, 0),\n                          datetime(1999, 4, 10, 9, 0),\n                          datetime(1999, 7, 19, 9, 0)])\n\n    def testMonthlyByWeekNo(self):\n        self.assertEqual(list(rrule(MONTHLY,\n                              count=3,\n                              byweekno=20,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 5, 11, 9, 0),\n                          datetime(1998, 5, 12, 9, 0),\n                          datetime(1998, 5, 13, 9, 0)])\n\n    def testMonthlyByWeekNoAndWeekDay(self):\n        # That's a nice one. The first days of week number one\n        # may be in the last year.\n        self.assertEqual(list(rrule(MONTHLY,\n                              count=3,\n                              byweekno=1,\n                              byweekday=MO,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 12, 29, 9, 0),\n                          datetime(1999, 1, 4, 9, 0),\n                          datetime(2000, 1, 3, 9, 0)])\n\n    def testMonthlyByWeekNoAndWeekDayLarge(self):\n        # Another nice test. The last days of week number 52/53\n        # may be in the next year.\n        self.assertEqual(list(rrule(MONTHLY,\n                              count=3,\n                              byweekno=52,\n                              byweekday=SU,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 12, 28, 9, 0),\n                          datetime(1998, 12, 27, 9, 0),\n                          datetime(2000, 1, 2, 9, 0)])\n\n    def testMonthlyByWeekNoAndWeekDayLast(self):\n        self.assertEqual(list(rrule(MONTHLY,\n                              count=3,\n                              byweekno=-1,\n                              byweekday=SU,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 12, 28, 9, 0),\n                          datetime(1999, 1, 3, 9, 0),\n                          datetime(2000, 1, 2, 9, 0)])\n\n    def testMonthlyByWeekNoAndWeekDay53(self):\n        self.assertEqual(list(rrule(MONTHLY,\n                              count=3,\n                              byweekno=53,\n                              byweekday=MO,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 12, 28, 9, 0),\n                          datetime(2004, 12, 27, 9, 0),\n                          datetime(2009, 12, 28, 9, 0)])\n\n    def testMonthlyByEaster(self):\n        self.assertEqual(list(rrule(MONTHLY,\n                              count=3,\n                              byeaster=0,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 4, 12, 9, 0),\n                          datetime(1999, 4, 4, 9, 0),\n                          datetime(2000, 4, 23, 9, 0)])\n\n    def testMonthlyByEasterPos(self):\n        self.assertEqual(list(rrule(MONTHLY,\n                              count=3,\n                              byeaster=1,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 4, 13, 9, 0),\n                          datetime(1999, 4, 5, 9, 0),\n                          datetime(2000, 4, 24, 9, 0)])\n\n    def testMonthlyByEasterNeg(self):\n        self.assertEqual(list(rrule(MONTHLY,\n                              count=3,\n                              byeaster=-1,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 4, 11, 9, 0),\n                          datetime(1999, 4, 3, 9, 0),\n                          datetime(2000, 4, 22, 9, 0)])\n\n    def testMonthlyByHour(self):\n        self.assertEqual(list(rrule(MONTHLY,\n                              count=3,\n                              byhour=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 18, 0),\n                          datetime(1997, 10, 2, 6, 0),\n                          datetime(1997, 10, 2, 18, 0)])\n\n    def testMonthlyByMinute(self):\n        self.assertEqual(list(rrule(MONTHLY,\n                              count=3,\n                              byminute=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 6),\n                          datetime(1997, 9, 2, 9, 18),\n                          datetime(1997, 10, 2, 9, 6)])\n\n    def testMonthlyBySecond(self):\n        self.assertEqual(list(rrule(MONTHLY,\n                              count=3,\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 0, 6),\n                          datetime(1997, 9, 2, 9, 0, 18),\n                          datetime(1997, 10, 2, 9, 0, 6)])\n\n    def testMonthlyByHourAndMinute(self):\n        self.assertEqual(list(rrule(MONTHLY,\n                              count=3,\n                              byhour=(6, 18),\n                              byminute=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 18, 6),\n                          datetime(1997, 9, 2, 18, 18),\n                          datetime(1997, 10, 2, 6, 6)])\n\n    def testMonthlyByHourAndSecond(self):\n        self.assertEqual(list(rrule(MONTHLY,\n                              count=3,\n                              byhour=(6, 18),\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 18, 0, 6),\n                          datetime(1997, 9, 2, 18, 0, 18),\n                          datetime(1997, 10, 2, 6, 0, 6)])\n\n    def testMonthlyByMinuteAndSecond(self):\n        self.assertEqual(list(rrule(MONTHLY,\n                              count=3,\n                              byminute=(6, 18),\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 6, 6),\n                          datetime(1997, 9, 2, 9, 6, 18),\n                          datetime(1997, 9, 2, 9, 18, 6)])\n\n    def testMonthlyByHourAndMinuteAndSecond(self):\n        self.assertEqual(list(rrule(MONTHLY,\n                              count=3,\n                              byhour=(6, 18),\n                              byminute=(6, 18),\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 18, 6, 6),\n                          datetime(1997, 9, 2, 18, 6, 18),\n                          datetime(1997, 9, 2, 18, 18, 6)])\n\n    def testMonthlyBySetPos(self):\n        self.assertEqual(list(rrule(MONTHLY,\n                              count=3,\n                              bymonthday=(13, 17),\n                              byhour=(6, 18),\n                              bysetpos=(3, -3),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 13, 18, 0),\n                          datetime(1997, 9, 17, 6, 0),\n                          datetime(1997, 10, 13, 18, 0)])\n\n    def testWeekly(self):\n        self.assertEqual(list(rrule(WEEKLY,\n                              count=3,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1997, 9, 9, 9, 0),\n                          datetime(1997, 9, 16, 9, 0)])\n\n    def testWeeklyInterval(self):\n        self.assertEqual(list(rrule(WEEKLY,\n                              count=3,\n                              interval=2,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1997, 9, 16, 9, 0),\n                          datetime(1997, 9, 30, 9, 0)])\n\n    def testWeeklyIntervalLarge(self):\n        self.assertEqual(list(rrule(WEEKLY,\n                              count=3,\n                              interval=20,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1998, 1, 20, 9, 0),\n                          datetime(1998, 6, 9, 9, 0)])\n\n    def testWeeklyByMonth(self):\n        self.assertEqual(list(rrule(WEEKLY,\n                              count=3,\n                              bymonth=(1, 3),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 1, 6, 9, 0),\n                          datetime(1998, 1, 13, 9, 0),\n                          datetime(1998, 1, 20, 9, 0)])\n\n    def testWeeklyByMonthDay(self):\n        self.assertEqual(list(rrule(WEEKLY,\n                              count=3,\n                              bymonthday=(1, 3),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 3, 9, 0),\n                          datetime(1997, 10, 1, 9, 0),\n                          datetime(1997, 10, 3, 9, 0)])\n\n    def testWeeklyByMonthAndMonthDay(self):\n        self.assertEqual(list(rrule(WEEKLY,\n                              count=3,\n                              bymonth=(1, 3),\n                              bymonthday=(5, 7),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 1, 5, 9, 0),\n                          datetime(1998, 1, 7, 9, 0),\n                          datetime(1998, 3, 5, 9, 0)])\n\n    def testWeeklyByWeekDay(self):\n        self.assertEqual(list(rrule(WEEKLY,\n                              count=3,\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1997, 9, 4, 9, 0),\n                          datetime(1997, 9, 9, 9, 0)])\n\n    def testWeeklyByNWeekDay(self):\n        self.assertEqual(list(rrule(WEEKLY,\n                              count=3,\n                              byweekday=(TU(1), TH(-1)),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1997, 9, 4, 9, 0),\n                          datetime(1997, 9, 9, 9, 0)])\n\n    def testWeeklyByMonthAndWeekDay(self):\n        # This test is interesting, because it crosses the year\n        # boundary in a weekly period to find day '1' as a\n        # valid recurrence.\n        self.assertEqual(list(rrule(WEEKLY,\n                              count=3,\n                              bymonth=(1, 3),\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 1, 1, 9, 0),\n                          datetime(1998, 1, 6, 9, 0),\n                          datetime(1998, 1, 8, 9, 0)])\n\n    def testWeeklyByMonthAndNWeekDay(self):\n        self.assertEqual(list(rrule(WEEKLY,\n                              count=3,\n                              bymonth=(1, 3),\n                              byweekday=(TU(1), TH(-1)),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 1, 1, 9, 0),\n                          datetime(1998, 1, 6, 9, 0),\n                          datetime(1998, 1, 8, 9, 0)])\n\n    def testWeeklyByMonthDayAndWeekDay(self):\n        self.assertEqual(list(rrule(WEEKLY,\n                              count=3,\n                              bymonthday=(1, 3),\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 1, 1, 9, 0),\n                          datetime(1998, 2, 3, 9, 0),\n                          datetime(1998, 3, 3, 9, 0)])\n\n    def testWeeklyByMonthAndMonthDayAndWeekDay(self):\n        self.assertEqual(list(rrule(WEEKLY,\n                              count=3,\n                              bymonth=(1, 3),\n                              bymonthday=(1, 3),\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 1, 1, 9, 0),\n                          datetime(1998, 3, 3, 9, 0),\n                          datetime(2001, 3, 1, 9, 0)])\n\n    def testWeeklyByYearDay(self):\n        self.assertEqual(list(rrule(WEEKLY,\n                              count=4,\n                              byyearday=(1, 100, 200, 365),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 12, 31, 9, 0),\n                          datetime(1998, 1, 1, 9, 0),\n                          datetime(1998, 4, 10, 9, 0),\n                          datetime(1998, 7, 19, 9, 0)])\n\n    def testWeeklyByYearDayNeg(self):\n        self.assertEqual(list(rrule(WEEKLY,\n                              count=4,\n                              byyearday=(-365, -266, -166, -1),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 12, 31, 9, 0),\n                          datetime(1998, 1, 1, 9, 0),\n                          datetime(1998, 4, 10, 9, 0),\n                          datetime(1998, 7, 19, 9, 0)])\n\n    def testWeeklyByMonthAndYearDay(self):\n        self.assertEqual(list(rrule(WEEKLY,\n                              count=4,\n                              bymonth=(1, 7),\n                              byyearday=(1, 100, 200, 365),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 1, 1, 9, 0),\n                          datetime(1998, 7, 19, 9, 0),\n                          datetime(1999, 1, 1, 9, 0),\n                          datetime(1999, 7, 19, 9, 0)])\n\n    def testWeeklyByMonthAndYearDayNeg(self):\n        self.assertEqual(list(rrule(WEEKLY,\n                              count=4,\n                              bymonth=(1, 7),\n                              byyearday=(-365, -266, -166, -1),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 1, 1, 9, 0),\n                          datetime(1998, 7, 19, 9, 0),\n                          datetime(1999, 1, 1, 9, 0),\n                          datetime(1999, 7, 19, 9, 0)])\n\n    def testWeeklyByWeekNo(self):\n        self.assertEqual(list(rrule(WEEKLY,\n                              count=3,\n                              byweekno=20,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 5, 11, 9, 0),\n                          datetime(1998, 5, 12, 9, 0),\n                          datetime(1998, 5, 13, 9, 0)])\n\n    def testWeeklyByWeekNoAndWeekDay(self):\n        # That's a nice one. The first days of week number one\n        # may be in the last year.\n        self.assertEqual(list(rrule(WEEKLY,\n                              count=3,\n                              byweekno=1,\n                              byweekday=MO,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 12, 29, 9, 0),\n                          datetime(1999, 1, 4, 9, 0),\n                          datetime(2000, 1, 3, 9, 0)])\n\n    def testWeeklyByWeekNoAndWeekDayLarge(self):\n        # Another nice test. The last days of week number 52/53\n        # may be in the next year.\n        self.assertEqual(list(rrule(WEEKLY,\n                              count=3,\n                              byweekno=52,\n                              byweekday=SU,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 12, 28, 9, 0),\n                          datetime(1998, 12, 27, 9, 0),\n                          datetime(2000, 1, 2, 9, 0)])\n\n    def testWeeklyByWeekNoAndWeekDayLast(self):\n        self.assertEqual(list(rrule(WEEKLY,\n                              count=3,\n                              byweekno=-1,\n                              byweekday=SU,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 12, 28, 9, 0),\n                          datetime(1999, 1, 3, 9, 0),\n                          datetime(2000, 1, 2, 9, 0)])\n\n    def testWeeklyByWeekNoAndWeekDay53(self):\n        self.assertEqual(list(rrule(WEEKLY,\n                              count=3,\n                              byweekno=53,\n                              byweekday=MO,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 12, 28, 9, 0),\n                          datetime(2004, 12, 27, 9, 0),\n                          datetime(2009, 12, 28, 9, 0)])\n\n    def testWeeklyByEaster(self):\n        self.assertEqual(list(rrule(WEEKLY,\n                              count=3,\n                              byeaster=0,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 4, 12, 9, 0),\n                          datetime(1999, 4, 4, 9, 0),\n                          datetime(2000, 4, 23, 9, 0)])\n\n    def testWeeklyByEasterPos(self):\n        self.assertEqual(list(rrule(WEEKLY,\n                              count=3,\n                              byeaster=1,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 4, 13, 9, 0),\n                          datetime(1999, 4, 5, 9, 0),\n                          datetime(2000, 4, 24, 9, 0)])\n\n    def testWeeklyByEasterNeg(self):\n        self.assertEqual(list(rrule(WEEKLY,\n                              count=3,\n                              byeaster=-1,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 4, 11, 9, 0),\n                          datetime(1999, 4, 3, 9, 0),\n                          datetime(2000, 4, 22, 9, 0)])\n\n    def testWeeklyByHour(self):\n        self.assertEqual(list(rrule(WEEKLY,\n                              count=3,\n                              byhour=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 18, 0),\n                          datetime(1997, 9, 9, 6, 0),\n                          datetime(1997, 9, 9, 18, 0)])\n\n    def testWeeklyByMinute(self):\n        self.assertEqual(list(rrule(WEEKLY,\n                              count=3,\n                              byminute=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 6),\n                          datetime(1997, 9, 2, 9, 18),\n                          datetime(1997, 9, 9, 9, 6)])\n\n    def testWeeklyBySecond(self):\n        self.assertEqual(list(rrule(WEEKLY,\n                              count=3,\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 0, 6),\n                          datetime(1997, 9, 2, 9, 0, 18),\n                          datetime(1997, 9, 9, 9, 0, 6)])\n\n    def testWeeklyByHourAndMinute(self):\n        self.assertEqual(list(rrule(WEEKLY,\n                              count=3,\n                              byhour=(6, 18),\n                              byminute=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 18, 6),\n                          datetime(1997, 9, 2, 18, 18),\n                          datetime(1997, 9, 9, 6, 6)])\n\n    def testWeeklyByHourAndSecond(self):\n        self.assertEqual(list(rrule(WEEKLY,\n                              count=3,\n                              byhour=(6, 18),\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 18, 0, 6),\n                          datetime(1997, 9, 2, 18, 0, 18),\n                          datetime(1997, 9, 9, 6, 0, 6)])\n\n    def testWeeklyByMinuteAndSecond(self):\n        self.assertEqual(list(rrule(WEEKLY,\n                              count=3,\n                              byminute=(6, 18),\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 6, 6),\n                          datetime(1997, 9, 2, 9, 6, 18),\n                          datetime(1997, 9, 2, 9, 18, 6)])\n\n    def testWeeklyByHourAndMinuteAndSecond(self):\n        self.assertEqual(list(rrule(WEEKLY,\n                              count=3,\n                              byhour=(6, 18),\n                              byminute=(6, 18),\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 18, 6, 6),\n                          datetime(1997, 9, 2, 18, 6, 18),\n                          datetime(1997, 9, 2, 18, 18, 6)])\n\n    def testWeeklyBySetPos(self):\n        self.assertEqual(list(rrule(WEEKLY,\n                              count=3,\n                              byweekday=(TU, TH),\n                              byhour=(6, 18),\n                              bysetpos=(3, -3),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 18, 0),\n                          datetime(1997, 9, 4, 6, 0),\n                          datetime(1997, 9, 9, 18, 0)])\n\n    def testDaily(self):\n        self.assertEqual(list(rrule(DAILY,\n                              count=3,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1997, 9, 3, 9, 0),\n                          datetime(1997, 9, 4, 9, 0)])\n\n    def testDailyInterval(self):\n        self.assertEqual(list(rrule(DAILY,\n                              count=3,\n                              interval=2,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1997, 9, 4, 9, 0),\n                          datetime(1997, 9, 6, 9, 0)])\n\n    def testDailyIntervalLarge(self):\n        self.assertEqual(list(rrule(DAILY,\n                              count=3,\n                              interval=92,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1997, 12, 3, 9, 0),\n                          datetime(1998, 3, 5, 9, 0)])\n\n    def testDailyByMonth(self):\n        self.assertEqual(list(rrule(DAILY,\n                              count=3,\n                              bymonth=(1, 3),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 1, 1, 9, 0),\n                          datetime(1998, 1, 2, 9, 0),\n                          datetime(1998, 1, 3, 9, 0)])\n\n    def testDailyByMonthDay(self):\n        self.assertEqual(list(rrule(DAILY,\n                              count=3,\n                              bymonthday=(1, 3),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 3, 9, 0),\n                          datetime(1997, 10, 1, 9, 0),\n                          datetime(1997, 10, 3, 9, 0)])\n\n    def testDailyByMonthAndMonthDay(self):\n        self.assertEqual(list(rrule(DAILY,\n                              count=3,\n                              bymonth=(1, 3),\n                              bymonthday=(5, 7),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 1, 5, 9, 0),\n                          datetime(1998, 1, 7, 9, 0),\n                          datetime(1998, 3, 5, 9, 0)])\n\n    def testDailyByWeekDay(self):\n        self.assertEqual(list(rrule(DAILY,\n                              count=3,\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1997, 9, 4, 9, 0),\n                          datetime(1997, 9, 9, 9, 0)])\n\n    def testDailyByNWeekDay(self):\n        self.assertEqual(list(rrule(DAILY,\n                              count=3,\n                              byweekday=(TU(1), TH(-1)),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1997, 9, 4, 9, 0),\n                          datetime(1997, 9, 9, 9, 0)])\n\n    def testDailyByMonthAndWeekDay(self):\n        self.assertEqual(list(rrule(DAILY,\n                              count=3,\n                              bymonth=(1, 3),\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 1, 1, 9, 0),\n                          datetime(1998, 1, 6, 9, 0),\n                          datetime(1998, 1, 8, 9, 0)])\n\n    def testDailyByMonthAndNWeekDay(self):\n        self.assertEqual(list(rrule(DAILY,\n                              count=3,\n                              bymonth=(1, 3),\n                              byweekday=(TU(1), TH(-1)),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 1, 1, 9, 0),\n                          datetime(1998, 1, 6, 9, 0),\n                          datetime(1998, 1, 8, 9, 0)])\n\n    def testDailyByMonthDayAndWeekDay(self):\n        self.assertEqual(list(rrule(DAILY,\n                              count=3,\n                              bymonthday=(1, 3),\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 1, 1, 9, 0),\n                          datetime(1998, 2, 3, 9, 0),\n                          datetime(1998, 3, 3, 9, 0)])\n\n    def testDailyByMonthAndMonthDayAndWeekDay(self):\n        self.assertEqual(list(rrule(DAILY,\n                              count=3,\n                              bymonth=(1, 3),\n                              bymonthday=(1, 3),\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 1, 1, 9, 0),\n                          datetime(1998, 3, 3, 9, 0),\n                          datetime(2001, 3, 1, 9, 0)])\n\n    def testDailyByYearDay(self):\n        self.assertEqual(list(rrule(DAILY,\n                              count=4,\n                              byyearday=(1, 100, 200, 365),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 12, 31, 9, 0),\n                          datetime(1998, 1, 1, 9, 0),\n                          datetime(1998, 4, 10, 9, 0),\n                          datetime(1998, 7, 19, 9, 0)])\n\n    def testDailyByYearDayNeg(self):\n        self.assertEqual(list(rrule(DAILY,\n                              count=4,\n                              byyearday=(-365, -266, -166, -1),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 12, 31, 9, 0),\n                          datetime(1998, 1, 1, 9, 0),\n                          datetime(1998, 4, 10, 9, 0),\n                          datetime(1998, 7, 19, 9, 0)])\n\n    def testDailyByMonthAndYearDay(self):\n        self.assertEqual(list(rrule(DAILY,\n                              count=4,\n                              bymonth=(1, 7),\n                              byyearday=(1, 100, 200, 365),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 1, 1, 9, 0),\n                          datetime(1998, 7, 19, 9, 0),\n                          datetime(1999, 1, 1, 9, 0),\n                          datetime(1999, 7, 19, 9, 0)])\n\n    def testDailyByMonthAndYearDayNeg(self):\n        self.assertEqual(list(rrule(DAILY,\n                              count=4,\n                              bymonth=(1, 7),\n                              byyearday=(-365, -266, -166, -1),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 1, 1, 9, 0),\n                          datetime(1998, 7, 19, 9, 0),\n                          datetime(1999, 1, 1, 9, 0),\n                          datetime(1999, 7, 19, 9, 0)])\n\n    def testDailyByWeekNo(self):\n        self.assertEqual(list(rrule(DAILY,\n                              count=3,\n                              byweekno=20,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 5, 11, 9, 0),\n                          datetime(1998, 5, 12, 9, 0),\n                          datetime(1998, 5, 13, 9, 0)])\n\n    def testDailyByWeekNoAndWeekDay(self):\n        # That's a nice one. The first days of week number one\n        # may be in the last year.\n        self.assertEqual(list(rrule(DAILY,\n                              count=3,\n                              byweekno=1,\n                              byweekday=MO,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 12, 29, 9, 0),\n                          datetime(1999, 1, 4, 9, 0),\n                          datetime(2000, 1, 3, 9, 0)])\n\n    def testDailyByWeekNoAndWeekDayLarge(self):\n        # Another nice test. The last days of week number 52/53\n        # may be in the next year.\n        self.assertEqual(list(rrule(DAILY,\n                              count=3,\n                              byweekno=52,\n                              byweekday=SU,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 12, 28, 9, 0),\n                          datetime(1998, 12, 27, 9, 0),\n                          datetime(2000, 1, 2, 9, 0)])\n\n    def testDailyByWeekNoAndWeekDayLast(self):\n        self.assertEqual(list(rrule(DAILY,\n                              count=3,\n                              byweekno=-1,\n                              byweekday=SU,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 12, 28, 9, 0),\n                          datetime(1999, 1, 3, 9, 0),\n                          datetime(2000, 1, 2, 9, 0)])\n\n    def testDailyByWeekNoAndWeekDay53(self):\n        self.assertEqual(list(rrule(DAILY,\n                              count=3,\n                              byweekno=53,\n                              byweekday=MO,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 12, 28, 9, 0),\n                          datetime(2004, 12, 27, 9, 0),\n                          datetime(2009, 12, 28, 9, 0)])\n\n    def testDailyByEaster(self):\n        self.assertEqual(list(rrule(DAILY,\n                              count=3,\n                              byeaster=0,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 4, 12, 9, 0),\n                          datetime(1999, 4, 4, 9, 0),\n                          datetime(2000, 4, 23, 9, 0)])\n\n    def testDailyByEasterPos(self):\n        self.assertEqual(list(rrule(DAILY,\n                              count=3,\n                              byeaster=1,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 4, 13, 9, 0),\n                          datetime(1999, 4, 5, 9, 0),\n                          datetime(2000, 4, 24, 9, 0)])\n\n    def testDailyByEasterNeg(self):\n        self.assertEqual(list(rrule(DAILY,\n                              count=3,\n                              byeaster=-1,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 4, 11, 9, 0),\n                          datetime(1999, 4, 3, 9, 0),\n                          datetime(2000, 4, 22, 9, 0)])\n\n    def testDailyByHour(self):\n        self.assertEqual(list(rrule(DAILY,\n                              count=3,\n                              byhour=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 18, 0),\n                          datetime(1997, 9, 3, 6, 0),\n                          datetime(1997, 9, 3, 18, 0)])\n\n    def testDailyByMinute(self):\n        self.assertEqual(list(rrule(DAILY,\n                              count=3,\n                              byminute=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 6),\n                          datetime(1997, 9, 2, 9, 18),\n                          datetime(1997, 9, 3, 9, 6)])\n\n    def testDailyBySecond(self):\n        self.assertEqual(list(rrule(DAILY,\n                              count=3,\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 0, 6),\n                          datetime(1997, 9, 2, 9, 0, 18),\n                          datetime(1997, 9, 3, 9, 0, 6)])\n\n    def testDailyByHourAndMinute(self):\n        self.assertEqual(list(rrule(DAILY,\n                              count=3,\n                              byhour=(6, 18),\n                              byminute=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 18, 6),\n                          datetime(1997, 9, 2, 18, 18),\n                          datetime(1997, 9, 3, 6, 6)])\n\n    def testDailyByHourAndSecond(self):\n        self.assertEqual(list(rrule(DAILY,\n                              count=3,\n                              byhour=(6, 18),\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 18, 0, 6),\n                          datetime(1997, 9, 2, 18, 0, 18),\n                          datetime(1997, 9, 3, 6, 0, 6)])\n\n    def testDailyByMinuteAndSecond(self):\n        self.assertEqual(list(rrule(DAILY,\n                              count=3,\n                              byminute=(6, 18),\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 6, 6),\n                          datetime(1997, 9, 2, 9, 6, 18),\n                          datetime(1997, 9, 2, 9, 18, 6)])\n\n    def testDailyByHourAndMinuteAndSecond(self):\n        self.assertEqual(list(rrule(DAILY,\n                              count=3,\n                              byhour=(6, 18),\n                              byminute=(6, 18),\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 18, 6, 6),\n                          datetime(1997, 9, 2, 18, 6, 18),\n                          datetime(1997, 9, 2, 18, 18, 6)])\n\n    def testDailyBySetPos(self):\n        self.assertEqual(list(rrule(DAILY,\n                              count=3,\n                              byhour=(6, 18),\n                              byminute=(15, 45),\n                              bysetpos=(3, -3),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 18, 15),\n                          datetime(1997, 9, 3, 6, 45),\n                          datetime(1997, 9, 3, 18, 15)])\n\n    def testHourly(self):\n        self.assertEqual(list(rrule(HOURLY,\n                              count=3,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1997, 9, 2, 10, 0),\n                          datetime(1997, 9, 2, 11, 0)])\n\n    def testHourlyInterval(self):\n        self.assertEqual(list(rrule(HOURLY,\n                              count=3,\n                              interval=2,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1997, 9, 2, 11, 0),\n                          datetime(1997, 9, 2, 13, 0)])\n\n    def testHourlyIntervalLarge(self):\n        self.assertEqual(list(rrule(HOURLY,\n                              count=3,\n                              interval=769,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1997, 10, 4, 10, 0),\n                          datetime(1997, 11, 5, 11, 0)])\n\n    def testHourlyByMonth(self):\n        self.assertEqual(list(rrule(HOURLY,\n                              count=3,\n                              bymonth=(1, 3),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 1, 1, 0, 0),\n                          datetime(1998, 1, 1, 1, 0),\n                          datetime(1998, 1, 1, 2, 0)])\n\n    def testHourlyByMonthDay(self):\n        self.assertEqual(list(rrule(HOURLY,\n                              count=3,\n                              bymonthday=(1, 3),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 3, 0, 0),\n                          datetime(1997, 9, 3, 1, 0),\n                          datetime(1997, 9, 3, 2, 0)])\n\n    def testHourlyByMonthAndMonthDay(self):\n        self.assertEqual(list(rrule(HOURLY,\n                              count=3,\n                              bymonth=(1, 3),\n                              bymonthday=(5, 7),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 1, 5, 0, 0),\n                          datetime(1998, 1, 5, 1, 0),\n                          datetime(1998, 1, 5, 2, 0)])\n\n    def testHourlyByWeekDay(self):\n        self.assertEqual(list(rrule(HOURLY,\n                              count=3,\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1997, 9, 2, 10, 0),\n                          datetime(1997, 9, 2, 11, 0)])\n\n    def testHourlyByNWeekDay(self):\n        self.assertEqual(list(rrule(HOURLY,\n                              count=3,\n                              byweekday=(TU(1), TH(-1)),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1997, 9, 2, 10, 0),\n                          datetime(1997, 9, 2, 11, 0)])\n\n    def testHourlyByMonthAndWeekDay(self):\n        self.assertEqual(list(rrule(HOURLY,\n                              count=3,\n                              bymonth=(1, 3),\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 1, 1, 0, 0),\n                          datetime(1998, 1, 1, 1, 0),\n                          datetime(1998, 1, 1, 2, 0)])\n\n    def testHourlyByMonthAndNWeekDay(self):\n        self.assertEqual(list(rrule(HOURLY,\n                              count=3,\n                              bymonth=(1, 3),\n                              byweekday=(TU(1), TH(-1)),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 1, 1, 0, 0),\n                          datetime(1998, 1, 1, 1, 0),\n                          datetime(1998, 1, 1, 2, 0)])\n\n    def testHourlyByMonthDayAndWeekDay(self):\n        self.assertEqual(list(rrule(HOURLY,\n                              count=3,\n                              bymonthday=(1, 3),\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 1, 1, 0, 0),\n                          datetime(1998, 1, 1, 1, 0),\n                          datetime(1998, 1, 1, 2, 0)])\n\n    def testHourlyByMonthAndMonthDayAndWeekDay(self):\n        self.assertEqual(list(rrule(HOURLY,\n                              count=3,\n                              bymonth=(1, 3),\n                              bymonthday=(1, 3),\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 1, 1, 0, 0),\n                          datetime(1998, 1, 1, 1, 0),\n                          datetime(1998, 1, 1, 2, 0)])\n\n    def testHourlyByYearDay(self):\n        self.assertEqual(list(rrule(HOURLY,\n                              count=4,\n                              byyearday=(1, 100, 200, 365),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 12, 31, 0, 0),\n                          datetime(1997, 12, 31, 1, 0),\n                          datetime(1997, 12, 31, 2, 0),\n                          datetime(1997, 12, 31, 3, 0)])\n\n    def testHourlyByYearDayNeg(self):\n        self.assertEqual(list(rrule(HOURLY,\n                              count=4,\n                              byyearday=(-365, -266, -166, -1),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 12, 31, 0, 0),\n                          datetime(1997, 12, 31, 1, 0),\n                          datetime(1997, 12, 31, 2, 0),\n                          datetime(1997, 12, 31, 3, 0)])\n\n    def testHourlyByMonthAndYearDay(self):\n        self.assertEqual(list(rrule(HOURLY,\n                              count=4,\n                              bymonth=(4, 7),\n                              byyearday=(1, 100, 200, 365),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 4, 10, 0, 0),\n                          datetime(1998, 4, 10, 1, 0),\n                          datetime(1998, 4, 10, 2, 0),\n                          datetime(1998, 4, 10, 3, 0)])\n\n    def testHourlyByMonthAndYearDayNeg(self):\n        self.assertEqual(list(rrule(HOURLY,\n                              count=4,\n                              bymonth=(4, 7),\n                              byyearday=(-365, -266, -166, -1),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 4, 10, 0, 0),\n                          datetime(1998, 4, 10, 1, 0),\n                          datetime(1998, 4, 10, 2, 0),\n                          datetime(1998, 4, 10, 3, 0)])\n\n    def testHourlyByWeekNo(self):\n        self.assertEqual(list(rrule(HOURLY,\n                              count=3,\n                              byweekno=20,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 5, 11, 0, 0),\n                          datetime(1998, 5, 11, 1, 0),\n                          datetime(1998, 5, 11, 2, 0)])\n\n    def testHourlyByWeekNoAndWeekDay(self):\n        self.assertEqual(list(rrule(HOURLY,\n                              count=3,\n                              byweekno=1,\n                              byweekday=MO,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 12, 29, 0, 0),\n                          datetime(1997, 12, 29, 1, 0),\n                          datetime(1997, 12, 29, 2, 0)])\n\n    def testHourlyByWeekNoAndWeekDayLarge(self):\n        self.assertEqual(list(rrule(HOURLY,\n                              count=3,\n                              byweekno=52,\n                              byweekday=SU,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 12, 28, 0, 0),\n                          datetime(1997, 12, 28, 1, 0),\n                          datetime(1997, 12, 28, 2, 0)])\n\n    def testHourlyByWeekNoAndWeekDayLast(self):\n        self.assertEqual(list(rrule(HOURLY,\n                              count=3,\n                              byweekno=-1,\n                              byweekday=SU,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 12, 28, 0, 0),\n                          datetime(1997, 12, 28, 1, 0),\n                          datetime(1997, 12, 28, 2, 0)])\n\n    def testHourlyByWeekNoAndWeekDay53(self):\n        self.assertEqual(list(rrule(HOURLY,\n                              count=3,\n                              byweekno=53,\n                              byweekday=MO,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 12, 28, 0, 0),\n                          datetime(1998, 12, 28, 1, 0),\n                          datetime(1998, 12, 28, 2, 0)])\n\n    def testHourlyByEaster(self):\n        self.assertEqual(list(rrule(HOURLY,\n                              count=3,\n                              byeaster=0,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 4, 12, 0, 0),\n                          datetime(1998, 4, 12, 1, 0),\n                          datetime(1998, 4, 12, 2, 0)])\n\n    def testHourlyByEasterPos(self):\n        self.assertEqual(list(rrule(HOURLY,\n                              count=3,\n                              byeaster=1,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 4, 13, 0, 0),\n                          datetime(1998, 4, 13, 1, 0),\n                          datetime(1998, 4, 13, 2, 0)])\n\n    def testHourlyByEasterNeg(self):\n        self.assertEqual(list(rrule(HOURLY,\n                              count=3,\n                              byeaster=-1,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 4, 11, 0, 0),\n                          datetime(1998, 4, 11, 1, 0),\n                          datetime(1998, 4, 11, 2, 0)])\n\n    def testHourlyByHour(self):\n        self.assertEqual(list(rrule(HOURLY,\n                              count=3,\n                              byhour=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 18, 0),\n                          datetime(1997, 9, 3, 6, 0),\n                          datetime(1997, 9, 3, 18, 0)])\n\n    def testHourlyByMinute(self):\n        self.assertEqual(list(rrule(HOURLY,\n                              count=3,\n                              byminute=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 6),\n                          datetime(1997, 9, 2, 9, 18),\n                          datetime(1997, 9, 2, 10, 6)])\n\n    def testHourlyBySecond(self):\n        self.assertEqual(list(rrule(HOURLY,\n                              count=3,\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 0, 6),\n                          datetime(1997, 9, 2, 9, 0, 18),\n                          datetime(1997, 9, 2, 10, 0, 6)])\n\n    def testHourlyByHourAndMinute(self):\n        self.assertEqual(list(rrule(HOURLY,\n                              count=3,\n                              byhour=(6, 18),\n                              byminute=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 18, 6),\n                          datetime(1997, 9, 2, 18, 18),\n                          datetime(1997, 9, 3, 6, 6)])\n\n    def testHourlyByHourAndSecond(self):\n        self.assertEqual(list(rrule(HOURLY,\n                              count=3,\n                              byhour=(6, 18),\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 18, 0, 6),\n                          datetime(1997, 9, 2, 18, 0, 18),\n                          datetime(1997, 9, 3, 6, 0, 6)])\n\n    def testHourlyByMinuteAndSecond(self):\n        self.assertEqual(list(rrule(HOURLY,\n                              count=3,\n                              byminute=(6, 18),\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 6, 6),\n                          datetime(1997, 9, 2, 9, 6, 18),\n                          datetime(1997, 9, 2, 9, 18, 6)])\n\n    def testHourlyByHourAndMinuteAndSecond(self):\n        self.assertEqual(list(rrule(HOURLY,\n                              count=3,\n                              byhour=(6, 18),\n                              byminute=(6, 18),\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 18, 6, 6),\n                          datetime(1997, 9, 2, 18, 6, 18),\n                          datetime(1997, 9, 2, 18, 18, 6)])\n\n    def testHourlyBySetPos(self):\n        self.assertEqual(list(rrule(HOURLY,\n                              count=3,\n                              byminute=(15, 45),\n                              bysecond=(15, 45),\n                              bysetpos=(3, -3),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 15, 45),\n                          datetime(1997, 9, 2, 9, 45, 15),\n                          datetime(1997, 9, 2, 10, 15, 45)])\n\n    def testMinutely(self):\n        self.assertEqual(list(rrule(MINUTELY,\n                              count=3,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1997, 9, 2, 9, 1),\n                          datetime(1997, 9, 2, 9, 2)])\n\n    def testMinutelyInterval(self):\n        self.assertEqual(list(rrule(MINUTELY,\n                              count=3,\n                              interval=2,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1997, 9, 2, 9, 2),\n                          datetime(1997, 9, 2, 9, 4)])\n\n    def testMinutelyIntervalLarge(self):\n        self.assertEqual(list(rrule(MINUTELY,\n                              count=3,\n                              interval=1501,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1997, 9, 3, 10, 1),\n                          datetime(1997, 9, 4, 11, 2)])\n\n    def testMinutelyByMonth(self):\n        self.assertEqual(list(rrule(MINUTELY,\n                              count=3,\n                              bymonth=(1, 3),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 1, 1, 0, 0),\n                          datetime(1998, 1, 1, 0, 1),\n                          datetime(1998, 1, 1, 0, 2)])\n\n    def testMinutelyByMonthDay(self):\n        self.assertEqual(list(rrule(MINUTELY,\n                              count=3,\n                              bymonthday=(1, 3),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 3, 0, 0),\n                          datetime(1997, 9, 3, 0, 1),\n                          datetime(1997, 9, 3, 0, 2)])\n\n    def testMinutelyByMonthAndMonthDay(self):\n        self.assertEqual(list(rrule(MINUTELY,\n                              count=3,\n                              bymonth=(1, 3),\n                              bymonthday=(5, 7),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 1, 5, 0, 0),\n                          datetime(1998, 1, 5, 0, 1),\n                          datetime(1998, 1, 5, 0, 2)])\n\n    def testMinutelyByWeekDay(self):\n        self.assertEqual(list(rrule(MINUTELY,\n                              count=3,\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1997, 9, 2, 9, 1),\n                          datetime(1997, 9, 2, 9, 2)])\n\n    def testMinutelyByNWeekDay(self):\n        self.assertEqual(list(rrule(MINUTELY,\n                              count=3,\n                              byweekday=(TU(1), TH(-1)),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1997, 9, 2, 9, 1),\n                          datetime(1997, 9, 2, 9, 2)])\n\n    def testMinutelyByMonthAndWeekDay(self):\n        self.assertEqual(list(rrule(MINUTELY,\n                              count=3,\n                              bymonth=(1, 3),\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 1, 1, 0, 0),\n                          datetime(1998, 1, 1, 0, 1),\n                          datetime(1998, 1, 1, 0, 2)])\n\n    def testMinutelyByMonthAndNWeekDay(self):\n        self.assertEqual(list(rrule(MINUTELY,\n                              count=3,\n                              bymonth=(1, 3),\n                              byweekday=(TU(1), TH(-1)),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 1, 1, 0, 0),\n                          datetime(1998, 1, 1, 0, 1),\n                          datetime(1998, 1, 1, 0, 2)])\n\n    def testMinutelyByMonthDayAndWeekDay(self):\n        self.assertEqual(list(rrule(MINUTELY,\n                              count=3,\n                              bymonthday=(1, 3),\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 1, 1, 0, 0),\n                          datetime(1998, 1, 1, 0, 1),\n                          datetime(1998, 1, 1, 0, 2)])\n\n    def testMinutelyByMonthAndMonthDayAndWeekDay(self):\n        self.assertEqual(list(rrule(MINUTELY,\n                              count=3,\n                              bymonth=(1, 3),\n                              bymonthday=(1, 3),\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 1, 1, 0, 0),\n                          datetime(1998, 1, 1, 0, 1),\n                          datetime(1998, 1, 1, 0, 2)])\n\n    def testMinutelyByYearDay(self):\n        self.assertEqual(list(rrule(MINUTELY,\n                              count=4,\n                              byyearday=(1, 100, 200, 365),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 12, 31, 0, 0),\n                          datetime(1997, 12, 31, 0, 1),\n                          datetime(1997, 12, 31, 0, 2),\n                          datetime(1997, 12, 31, 0, 3)])\n\n    def testMinutelyByYearDayNeg(self):\n        self.assertEqual(list(rrule(MINUTELY,\n                              count=4,\n                              byyearday=(-365, -266, -166, -1),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 12, 31, 0, 0),\n                          datetime(1997, 12, 31, 0, 1),\n                          datetime(1997, 12, 31, 0, 2),\n                          datetime(1997, 12, 31, 0, 3)])\n\n    def testMinutelyByMonthAndYearDay(self):\n        self.assertEqual(list(rrule(MINUTELY,\n                              count=4,\n                              bymonth=(4, 7),\n                              byyearday=(1, 100, 200, 365),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 4, 10, 0, 0),\n                          datetime(1998, 4, 10, 0, 1),\n                          datetime(1998, 4, 10, 0, 2),\n                          datetime(1998, 4, 10, 0, 3)])\n\n    def testMinutelyByMonthAndYearDayNeg(self):\n        self.assertEqual(list(rrule(MINUTELY,\n                              count=4,\n                              bymonth=(4, 7),\n                              byyearday=(-365, -266, -166, -1),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 4, 10, 0, 0),\n                          datetime(1998, 4, 10, 0, 1),\n                          datetime(1998, 4, 10, 0, 2),\n                          datetime(1998, 4, 10, 0, 3)])\n\n    def testMinutelyByWeekNo(self):\n        self.assertEqual(list(rrule(MINUTELY,\n                              count=3,\n                              byweekno=20,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 5, 11, 0, 0),\n                          datetime(1998, 5, 11, 0, 1),\n                          datetime(1998, 5, 11, 0, 2)])\n\n    def testMinutelyByWeekNoAndWeekDay(self):\n        self.assertEqual(list(rrule(MINUTELY,\n                              count=3,\n                              byweekno=1,\n                              byweekday=MO,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 12, 29, 0, 0),\n                          datetime(1997, 12, 29, 0, 1),\n                          datetime(1997, 12, 29, 0, 2)])\n\n    def testMinutelyByWeekNoAndWeekDayLarge(self):\n        self.assertEqual(list(rrule(MINUTELY,\n                              count=3,\n                              byweekno=52,\n                              byweekday=SU,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 12, 28, 0, 0),\n                          datetime(1997, 12, 28, 0, 1),\n                          datetime(1997, 12, 28, 0, 2)])\n\n    def testMinutelyByWeekNoAndWeekDayLast(self):\n        self.assertEqual(list(rrule(MINUTELY,\n                              count=3,\n                              byweekno=-1,\n                              byweekday=SU,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 12, 28, 0, 0),\n                          datetime(1997, 12, 28, 0, 1),\n                          datetime(1997, 12, 28, 0, 2)])\n\n    def testMinutelyByWeekNoAndWeekDay53(self):\n        self.assertEqual(list(rrule(MINUTELY,\n                              count=3,\n                              byweekno=53,\n                              byweekday=MO,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 12, 28, 0, 0),\n                          datetime(1998, 12, 28, 0, 1),\n                          datetime(1998, 12, 28, 0, 2)])\n\n    def testMinutelyByEaster(self):\n        self.assertEqual(list(rrule(MINUTELY,\n                              count=3,\n                              byeaster=0,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 4, 12, 0, 0),\n                          datetime(1998, 4, 12, 0, 1),\n                          datetime(1998, 4, 12, 0, 2)])\n\n    def testMinutelyByEasterPos(self):\n        self.assertEqual(list(rrule(MINUTELY,\n                              count=3,\n                              byeaster=1,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 4, 13, 0, 0),\n                          datetime(1998, 4, 13, 0, 1),\n                          datetime(1998, 4, 13, 0, 2)])\n\n    def testMinutelyByEasterNeg(self):\n        self.assertEqual(list(rrule(MINUTELY,\n                              count=3,\n                              byeaster=-1,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 4, 11, 0, 0),\n                          datetime(1998, 4, 11, 0, 1),\n                          datetime(1998, 4, 11, 0, 2)])\n\n    def testMinutelyByHour(self):\n        self.assertEqual(list(rrule(MINUTELY,\n                              count=3,\n                              byhour=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 18, 0),\n                          datetime(1997, 9, 2, 18, 1),\n                          datetime(1997, 9, 2, 18, 2)])\n\n    def testMinutelyByMinute(self):\n        self.assertEqual(list(rrule(MINUTELY,\n                              count=3,\n                              byminute=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 6),\n                          datetime(1997, 9, 2, 9, 18),\n                          datetime(1997, 9, 2, 10, 6)])\n\n    def testMinutelyBySecond(self):\n        self.assertEqual(list(rrule(MINUTELY,\n                              count=3,\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 0, 6),\n                          datetime(1997, 9, 2, 9, 0, 18),\n                          datetime(1997, 9, 2, 9, 1, 6)])\n\n    def testMinutelyByHourAndMinute(self):\n        self.assertEqual(list(rrule(MINUTELY,\n                              count=3,\n                              byhour=(6, 18),\n                              byminute=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 18, 6),\n                          datetime(1997, 9, 2, 18, 18),\n                          datetime(1997, 9, 3, 6, 6)])\n\n    def testMinutelyByHourAndSecond(self):\n        self.assertEqual(list(rrule(MINUTELY,\n                              count=3,\n                              byhour=(6, 18),\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 18, 0, 6),\n                          datetime(1997, 9, 2, 18, 0, 18),\n                          datetime(1997, 9, 2, 18, 1, 6)])\n\n    def testMinutelyByMinuteAndSecond(self):\n        self.assertEqual(list(rrule(MINUTELY,\n                              count=3,\n                              byminute=(6, 18),\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 6, 6),\n                          datetime(1997, 9, 2, 9, 6, 18),\n                          datetime(1997, 9, 2, 9, 18, 6)])\n\n    def testMinutelyByHourAndMinuteAndSecond(self):\n        self.assertEqual(list(rrule(MINUTELY,\n                              count=3,\n                              byhour=(6, 18),\n                              byminute=(6, 18),\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 18, 6, 6),\n                          datetime(1997, 9, 2, 18, 6, 18),\n                          datetime(1997, 9, 2, 18, 18, 6)])\n\n    def testMinutelyBySetPos(self):\n        self.assertEqual(list(rrule(MINUTELY,\n                              count=3,\n                              bysecond=(15, 30, 45),\n                              bysetpos=(3, -3),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 0, 15),\n                          datetime(1997, 9, 2, 9, 0, 45),\n                          datetime(1997, 9, 2, 9, 1, 15)])\n\n    def testSecondly(self):\n        self.assertEqual(list(rrule(SECONDLY,\n                              count=3,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 0, 0),\n                          datetime(1997, 9, 2, 9, 0, 1),\n                          datetime(1997, 9, 2, 9, 0, 2)])\n\n    def testSecondlyInterval(self):\n        self.assertEqual(list(rrule(SECONDLY,\n                              count=3,\n                              interval=2,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 0, 0),\n                          datetime(1997, 9, 2, 9, 0, 2),\n                          datetime(1997, 9, 2, 9, 0, 4)])\n\n    def testSecondlyIntervalLarge(self):\n        self.assertEqual(list(rrule(SECONDLY,\n                              count=3,\n                              interval=90061,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 0, 0),\n                          datetime(1997, 9, 3, 10, 1, 1),\n                          datetime(1997, 9, 4, 11, 2, 2)])\n\n    def testSecondlyByMonth(self):\n        self.assertEqual(list(rrule(SECONDLY,\n                              count=3,\n                              bymonth=(1, 3),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 1, 1, 0, 0, 0),\n                          datetime(1998, 1, 1, 0, 0, 1),\n                          datetime(1998, 1, 1, 0, 0, 2)])\n\n    def testSecondlyByMonthDay(self):\n        self.assertEqual(list(rrule(SECONDLY,\n                              count=3,\n                              bymonthday=(1, 3),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 3, 0, 0, 0),\n                          datetime(1997, 9, 3, 0, 0, 1),\n                          datetime(1997, 9, 3, 0, 0, 2)])\n\n    def testSecondlyByMonthAndMonthDay(self):\n        self.assertEqual(list(rrule(SECONDLY,\n                              count=3,\n                              bymonth=(1, 3),\n                              bymonthday=(5, 7),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 1, 5, 0, 0, 0),\n                          datetime(1998, 1, 5, 0, 0, 1),\n                          datetime(1998, 1, 5, 0, 0, 2)])\n\n    def testSecondlyByWeekDay(self):\n        self.assertEqual(list(rrule(SECONDLY,\n                              count=3,\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 0, 0),\n                          datetime(1997, 9, 2, 9, 0, 1),\n                          datetime(1997, 9, 2, 9, 0, 2)])\n\n    def testSecondlyByNWeekDay(self):\n        self.assertEqual(list(rrule(SECONDLY,\n                              count=3,\n                              byweekday=(TU(1), TH(-1)),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 0, 0),\n                          datetime(1997, 9, 2, 9, 0, 1),\n                          datetime(1997, 9, 2, 9, 0, 2)])\n\n    def testSecondlyByMonthAndWeekDay(self):\n        self.assertEqual(list(rrule(SECONDLY,\n                              count=3,\n                              bymonth=(1, 3),\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 1, 1, 0, 0, 0),\n                          datetime(1998, 1, 1, 0, 0, 1),\n                          datetime(1998, 1, 1, 0, 0, 2)])\n\n    def testSecondlyByMonthAndNWeekDay(self):\n        self.assertEqual(list(rrule(SECONDLY,\n                              count=3,\n                              bymonth=(1, 3),\n                              byweekday=(TU(1), TH(-1)),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 1, 1, 0, 0, 0),\n                          datetime(1998, 1, 1, 0, 0, 1),\n                          datetime(1998, 1, 1, 0, 0, 2)])\n\n    def testSecondlyByMonthDayAndWeekDay(self):\n        self.assertEqual(list(rrule(SECONDLY,\n                              count=3,\n                              bymonthday=(1, 3),\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 1, 1, 0, 0, 0),\n                          datetime(1998, 1, 1, 0, 0, 1),\n                          datetime(1998, 1, 1, 0, 0, 2)])\n\n    def testSecondlyByMonthAndMonthDayAndWeekDay(self):\n        self.assertEqual(list(rrule(SECONDLY,\n                              count=3,\n                              bymonth=(1, 3),\n                              bymonthday=(1, 3),\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 1, 1, 0, 0, 0),\n                          datetime(1998, 1, 1, 0, 0, 1),\n                          datetime(1998, 1, 1, 0, 0, 2)])\n\n    def testSecondlyByYearDay(self):\n        self.assertEqual(list(rrule(SECONDLY,\n                              count=4,\n                              byyearday=(1, 100, 200, 365),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 12, 31, 0, 0, 0),\n                          datetime(1997, 12, 31, 0, 0, 1),\n                          datetime(1997, 12, 31, 0, 0, 2),\n                          datetime(1997, 12, 31, 0, 0, 3)])\n\n    def testSecondlyByYearDayNeg(self):\n        self.assertEqual(list(rrule(SECONDLY,\n                              count=4,\n                              byyearday=(-365, -266, -166, -1),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 12, 31, 0, 0, 0),\n                          datetime(1997, 12, 31, 0, 0, 1),\n                          datetime(1997, 12, 31, 0, 0, 2),\n                          datetime(1997, 12, 31, 0, 0, 3)])\n\n    def testSecondlyByMonthAndYearDay(self):\n        self.assertEqual(list(rrule(SECONDLY,\n                              count=4,\n                              bymonth=(4, 7),\n                              byyearday=(1, 100, 200, 365),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 4, 10, 0, 0, 0),\n                          datetime(1998, 4, 10, 0, 0, 1),\n                          datetime(1998, 4, 10, 0, 0, 2),\n                          datetime(1998, 4, 10, 0, 0, 3)])\n\n    def testSecondlyByMonthAndYearDayNeg(self):\n        self.assertEqual(list(rrule(SECONDLY,\n                              count=4,\n                              bymonth=(4, 7),\n                              byyearday=(-365, -266, -166, -1),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 4, 10, 0, 0, 0),\n                          datetime(1998, 4, 10, 0, 0, 1),\n                          datetime(1998, 4, 10, 0, 0, 2),\n                          datetime(1998, 4, 10, 0, 0, 3)])\n\n    def testSecondlyByWeekNo(self):\n        self.assertEqual(list(rrule(SECONDLY,\n                              count=3,\n                              byweekno=20,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 5, 11, 0, 0, 0),\n                          datetime(1998, 5, 11, 0, 0, 1),\n                          datetime(1998, 5, 11, 0, 0, 2)])\n\n    def testSecondlyByWeekNoAndWeekDay(self):\n        self.assertEqual(list(rrule(SECONDLY,\n                              count=3,\n                              byweekno=1,\n                              byweekday=MO,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 12, 29, 0, 0, 0),\n                          datetime(1997, 12, 29, 0, 0, 1),\n                          datetime(1997, 12, 29, 0, 0, 2)])\n\n    def testSecondlyByWeekNoAndWeekDayLarge(self):\n        self.assertEqual(list(rrule(SECONDLY,\n                              count=3,\n                              byweekno=52,\n                              byweekday=SU,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 12, 28, 0, 0, 0),\n                          datetime(1997, 12, 28, 0, 0, 1),\n                          datetime(1997, 12, 28, 0, 0, 2)])\n\n    def testSecondlyByWeekNoAndWeekDayLast(self):\n        self.assertEqual(list(rrule(SECONDLY,\n                              count=3,\n                              byweekno=-1,\n                              byweekday=SU,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 12, 28, 0, 0, 0),\n                          datetime(1997, 12, 28, 0, 0, 1),\n                          datetime(1997, 12, 28, 0, 0, 2)])\n\n    def testSecondlyByWeekNoAndWeekDay53(self):\n        self.assertEqual(list(rrule(SECONDLY,\n                              count=3,\n                              byweekno=53,\n                              byweekday=MO,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 12, 28, 0, 0, 0),\n                          datetime(1998, 12, 28, 0, 0, 1),\n                          datetime(1998, 12, 28, 0, 0, 2)])\n\n    def testSecondlyByEaster(self):\n        self.assertEqual(list(rrule(SECONDLY,\n                              count=3,\n                              byeaster=0,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 4, 12, 0, 0, 0),\n                          datetime(1998, 4, 12, 0, 0, 1),\n                          datetime(1998, 4, 12, 0, 0, 2)])\n\n    def testSecondlyByEasterPos(self):\n        self.assertEqual(list(rrule(SECONDLY,\n                              count=3,\n                              byeaster=1,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 4, 13, 0, 0, 0),\n                          datetime(1998, 4, 13, 0, 0, 1),\n                          datetime(1998, 4, 13, 0, 0, 2)])\n\n    def testSecondlyByEasterNeg(self):\n        self.assertEqual(list(rrule(SECONDLY,\n                              count=3,\n                              byeaster=-1,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1998, 4, 11, 0, 0, 0),\n                          datetime(1998, 4, 11, 0, 0, 1),\n                          datetime(1998, 4, 11, 0, 0, 2)])\n\n    def testSecondlyByHour(self):\n        self.assertEqual(list(rrule(SECONDLY,\n                              count=3,\n                              byhour=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 18, 0, 0),\n                          datetime(1997, 9, 2, 18, 0, 1),\n                          datetime(1997, 9, 2, 18, 0, 2)])\n\n    def testSecondlyByMinute(self):\n        self.assertEqual(list(rrule(SECONDLY,\n                              count=3,\n                              byminute=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 6, 0),\n                          datetime(1997, 9, 2, 9, 6, 1),\n                          datetime(1997, 9, 2, 9, 6, 2)])\n\n    def testSecondlyBySecond(self):\n        self.assertEqual(list(rrule(SECONDLY,\n                              count=3,\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 0, 6),\n                          datetime(1997, 9, 2, 9, 0, 18),\n                          datetime(1997, 9, 2, 9, 1, 6)])\n\n    def testSecondlyByHourAndMinute(self):\n        self.assertEqual(list(rrule(SECONDLY,\n                              count=3,\n                              byhour=(6, 18),\n                              byminute=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 18, 6, 0),\n                          datetime(1997, 9, 2, 18, 6, 1),\n                          datetime(1997, 9, 2, 18, 6, 2)])\n\n    def testSecondlyByHourAndSecond(self):\n        self.assertEqual(list(rrule(SECONDLY,\n                              count=3,\n                              byhour=(6, 18),\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 18, 0, 6),\n                          datetime(1997, 9, 2, 18, 0, 18),\n                          datetime(1997, 9, 2, 18, 1, 6)])\n\n    def testSecondlyByMinuteAndSecond(self):\n        self.assertEqual(list(rrule(SECONDLY,\n                              count=3,\n                              byminute=(6, 18),\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 6, 6),\n                          datetime(1997, 9, 2, 9, 6, 18),\n                          datetime(1997, 9, 2, 9, 18, 6)])\n\n    def testSecondlyByHourAndMinuteAndSecond(self):\n        self.assertEqual(list(rrule(SECONDLY,\n                              count=3,\n                              byhour=(6, 18),\n                              byminute=(6, 18),\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 18, 6, 6),\n                          datetime(1997, 9, 2, 18, 6, 18),\n                          datetime(1997, 9, 2, 18, 18, 6)])\n\n    def testSecondlyByHourAndMinuteAndSecondBug(self):\n        # This explores a bug found by Mathieu Bridon.\n        self.assertEqual(list(rrule(SECONDLY,\n                              count=3,\n                              bysecond=(0,),\n                              byminute=(1,),\n                              dtstart=datetime(2010, 3, 22, 12, 1))),\n                         [datetime(2010, 3, 22, 12, 1),\n                          datetime(2010, 3, 22, 13, 1),\n                          datetime(2010, 3, 22, 14, 1)])\n\n    def testLongIntegers(self):\n        if PY2:  # There are no longs in python3\n            self.assertEqual(list(rrule(MINUTELY,\n                                  count=long(2),\n                                  interval=long(2),\n                                  bymonth=long(2),\n                                  byweekday=long(3),\n                                  byhour=long(6),\n                                  byminute=long(6),\n                                  bysecond=long(6),\n                                  dtstart=datetime(1997, 9, 2, 9, 0))),\n                             [datetime(1998, 2, 5, 6, 6, 6),\n                              datetime(1998, 2, 12, 6, 6, 6)])\n            self.assertEqual(list(rrule(YEARLY,\n                                  count=long(2),\n                                  bymonthday=long(5),\n                                  byweekno=long(2),\n                                  dtstart=datetime(1997, 9, 2, 9, 0))),\n                             [datetime(1998, 1, 5, 9, 0),\n                              datetime(2004, 1, 5, 9, 0)])\n\n    def testHourlyBadRRule(self):\n        \"\"\"\n        When `byhour` is specified with `freq=HOURLY`, there are certain\n        combinations of `dtstart` and `byhour` which result in an rrule with no\n        valid values.\n\n        See https://github.com/dateutil/dateutil/issues/4\n        \"\"\"\n\n        self.assertRaises(ValueError, rrule, HOURLY,\n                          **dict(interval=4, byhour=(7, 11, 15, 19),\n                                 dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testMinutelyBadRRule(self):\n        \"\"\"\n        See :func:`testHourlyBadRRule` for details.\n        \"\"\"\n\n        self.assertRaises(ValueError, rrule, MINUTELY,\n                          **dict(interval=12, byminute=(10, 11, 25, 39, 50),\n                                 dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testSecondlyBadRRule(self):\n        \"\"\"\n        See :func:`testHourlyBadRRule` for details.\n        \"\"\"\n\n        self.assertRaises(ValueError, rrule, SECONDLY,\n                          **dict(interval=10, bysecond=(2, 15, 37, 42, 59),\n                                 dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testMinutelyBadComboRRule(self):\n        \"\"\"\n        Certain values of :param:`interval` in :class:`rrule`, when combined\n        with certain values of :param:`byhour` create rules which apply to no\n        valid dates. The library should detect this case in the iterator and\n        raise a :exception:`ValueError`.\n        \"\"\"\n\n        # In Python 2.7 you can use a context manager for this.\n        def make_bad_rrule():\n            list(rrule(MINUTELY, interval=120, byhour=(10, 12, 14, 16),\n                 count=2, dtstart=datetime(1997, 9, 2, 9, 0)))\n\n        self.assertRaises(ValueError, make_bad_rrule)\n\n    def testSecondlyBadComboRRule(self):\n        \"\"\"\n        See :func:`testMinutelyBadComboRRule' for details.\n        \"\"\"\n\n        # In Python 2.7 you can use a context manager for this.\n        def make_bad_minute_rrule():\n            list(rrule(SECONDLY, interval=360, byminute=(10, 28, 49),\n                 count=4, dtstart=datetime(1997, 9, 2, 9, 0)))\n\n        def make_bad_hour_rrule():\n            list(rrule(SECONDLY, interval=43200, byhour=(2, 10, 18, 23),\n                 count=4, dtstart=datetime(1997, 9, 2, 9, 0)))\n\n        self.assertRaises(ValueError, make_bad_minute_rrule)\n        self.assertRaises(ValueError, make_bad_hour_rrule)\n\n    def testBadUntilCountRRule(self):\n        \"\"\"\n        See rfc-5545 3.3.10 - This checks for the deprecation warning, and will\n        eventually check for an error.\n        \"\"\"\n        with pytest.warns(DeprecationWarning):\n            rrule(DAILY, dtstart=datetime(1997, 9, 2, 9, 0),\n                         count=3, until=datetime(1997, 9, 4, 9, 0))\n\n    def testUntilNotMatching(self):\n        self.assertEqual(list(rrule(DAILY,\n                              dtstart=datetime(1997, 9, 2, 9, 0),\n                              until=datetime(1997, 9, 5, 8, 0))),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1997, 9, 3, 9, 0),\n                          datetime(1997, 9, 4, 9, 0)])\n\n    def testUntilMatching(self):\n        self.assertEqual(list(rrule(DAILY,\n                              dtstart=datetime(1997, 9, 2, 9, 0),\n                              until=datetime(1997, 9, 4, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1997, 9, 3, 9, 0),\n                          datetime(1997, 9, 4, 9, 0)])\n\n    def testUntilSingle(self):\n        self.assertEqual(list(rrule(DAILY,\n                              dtstart=datetime(1997, 9, 2, 9, 0),\n                              until=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 0)])\n\n    def testUntilEmpty(self):\n        self.assertEqual(list(rrule(DAILY,\n                              dtstart=datetime(1997, 9, 2, 9, 0),\n                              until=datetime(1997, 9, 1, 9, 0))),\n                         [])\n\n    def testUntilWithDate(self):\n        self.assertEqual(list(rrule(DAILY,\n                              dtstart=datetime(1997, 9, 2, 9, 0),\n                              until=date(1997, 9, 5))),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1997, 9, 3, 9, 0),\n                          datetime(1997, 9, 4, 9, 0)])\n\n    def testWkStIntervalMO(self):\n        self.assertEqual(list(rrule(WEEKLY,\n                              count=3,\n                              interval=2,\n                              byweekday=(TU, SU),\n                              wkst=MO,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1997, 9, 7, 9, 0),\n                          datetime(1997, 9, 16, 9, 0)])\n\n    def testWkStIntervalSU(self):\n        self.assertEqual(list(rrule(WEEKLY,\n                              count=3,\n                              interval=2,\n                              byweekday=(TU, SU),\n                              wkst=SU,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1997, 9, 14, 9, 0),\n                          datetime(1997, 9, 16, 9, 0)])\n\n    def testDTStartIsDate(self):\n        self.assertEqual(list(rrule(DAILY,\n                              count=3,\n                              dtstart=date(1997, 9, 2))),\n                         [datetime(1997, 9, 2, 0, 0),\n                          datetime(1997, 9, 3, 0, 0),\n                          datetime(1997, 9, 4, 0, 0)])\n\n    def testDTStartWithMicroseconds(self):\n        self.assertEqual(list(rrule(DAILY,\n                              count=3,\n                              dtstart=datetime(1997, 9, 2, 9, 0, 0, 500000))),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1997, 9, 3, 9, 0),\n                          datetime(1997, 9, 4, 9, 0)])\n\n    def testMaxYear(self):\n        self.assertEqual(list(rrule(YEARLY,\n                              count=3,\n                              bymonth=2,\n                              bymonthday=31,\n                              dtstart=datetime(9997, 9, 2, 9, 0, 0))),\n                         [])\n\n    def testGetItem(self):\n        self.assertEqual(rrule(DAILY,\n                               count=3,\n                               dtstart=datetime(1997, 9, 2, 9, 0))[0],\n                         datetime(1997, 9, 2, 9, 0))\n\n    def testGetItemNeg(self):\n        self.assertEqual(rrule(DAILY,\n                               count=3,\n                               dtstart=datetime(1997, 9, 2, 9, 0))[-1],\n                         datetime(1997, 9, 4, 9, 0))\n\n    def testGetItemSlice(self):\n        self.assertEqual(rrule(DAILY,\n                               # count=3,\n                               dtstart=datetime(1997, 9, 2, 9, 0))[1:2],\n                         [datetime(1997, 9, 3, 9, 0)])\n\n    def testGetItemSliceEmpty(self):\n        self.assertEqual(rrule(DAILY,\n                               count=3,\n                               dtstart=datetime(1997, 9, 2, 9, 0))[:],\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1997, 9, 3, 9, 0),\n                          datetime(1997, 9, 4, 9, 0)])\n\n    def testGetItemSliceStep(self):\n        self.assertEqual(rrule(DAILY,\n                               count=3,\n                               dtstart=datetime(1997, 9, 2, 9, 0))[::-2],\n                         [datetime(1997, 9, 4, 9, 0),\n                          datetime(1997, 9, 2, 9, 0)])\n\n    def testCount(self):\n        self.assertEqual(rrule(DAILY,\n                               count=3,\n                               dtstart=datetime(1997, 9, 2, 9, 0)).count(),\n                         3)\n\n    def testCountZero(self):\n        self.assertEqual(rrule(YEARLY,\n                               count=0,\n                               dtstart=datetime(1997, 9, 2, 9, 0)).count(),\n                         0)\n\n    def testContains(self):\n        rr = rrule(DAILY, count=3, dtstart=datetime(1997, 9, 2, 9, 0))\n        self.assertEqual(datetime(1997, 9, 3, 9, 0) in rr, True)\n\n    def testContainsNot(self):\n        rr = rrule(DAILY, count=3, dtstart=datetime(1997, 9, 2, 9, 0))\n        self.assertEqual(datetime(1997, 9, 3, 9, 0) not in rr, False)\n\n    def testBefore(self):\n        self.assertEqual(rrule(DAILY,  # count=5\n            dtstart=datetime(1997, 9, 2, 9, 0)).before(datetime(1997, 9, 5, 9, 0)),\n                         datetime(1997, 9, 4, 9, 0))\n\n    def testBeforeInc(self):\n        self.assertEqual(rrule(DAILY,\n                               #count=5,\n                               dtstart=datetime(1997, 9, 2, 9, 0))\n                               .before(datetime(1997, 9, 5, 9, 0), inc=True),\n                         datetime(1997, 9, 5, 9, 0))\n\n    def testAfter(self):\n        self.assertEqual(rrule(DAILY,\n                               #count=5,\n                               dtstart=datetime(1997, 9, 2, 9, 0))\n                               .after(datetime(1997, 9, 4, 9, 0)),\n                         datetime(1997, 9, 5, 9, 0))\n\n    def testAfterInc(self):\n        self.assertEqual(rrule(DAILY,\n                               #count=5,\n                               dtstart=datetime(1997, 9, 2, 9, 0))\n                               .after(datetime(1997, 9, 4, 9, 0), inc=True),\n                         datetime(1997, 9, 4, 9, 0))\n\n    def testXAfter(self):\n        self.assertEqual(list(rrule(DAILY,\n                                    dtstart=datetime(1997, 9, 2, 9, 0))\n                                    .xafter(datetime(1997, 9, 8, 9, 0), count=12)),\n                                    [datetime(1997, 9, 9, 9, 0),\n                                     datetime(1997, 9, 10, 9, 0),\n                                     datetime(1997, 9, 11, 9, 0),\n                                     datetime(1997, 9, 12, 9, 0),\n                                     datetime(1997, 9, 13, 9, 0),\n                                     datetime(1997, 9, 14, 9, 0),\n                                     datetime(1997, 9, 15, 9, 0),\n                                     datetime(1997, 9, 16, 9, 0),\n                                     datetime(1997, 9, 17, 9, 0),\n                                     datetime(1997, 9, 18, 9, 0),\n                                     datetime(1997, 9, 19, 9, 0),\n                                     datetime(1997, 9, 20, 9, 0)])\n\n    def testXAfterInc(self):\n        self.assertEqual(list(rrule(DAILY,\n                                    dtstart=datetime(1997, 9, 2, 9, 0))\n                                    .xafter(datetime(1997, 9, 8, 9, 0), count=12, inc=True)),\n                                    [datetime(1997, 9, 8, 9, 0),\n                                     datetime(1997, 9, 9, 9, 0),\n                                     datetime(1997, 9, 10, 9, 0),\n                                     datetime(1997, 9, 11, 9, 0),\n                                     datetime(1997, 9, 12, 9, 0),\n                                     datetime(1997, 9, 13, 9, 0),\n                                     datetime(1997, 9, 14, 9, 0),\n                                     datetime(1997, 9, 15, 9, 0),\n                                     datetime(1997, 9, 16, 9, 0),\n                                     datetime(1997, 9, 17, 9, 0),\n                                     datetime(1997, 9, 18, 9, 0),\n                                     datetime(1997, 9, 19, 9, 0)])\n\n    def testBetween(self):\n        self.assertEqual(rrule(DAILY,\n                               #count=5,\n                               dtstart=datetime(1997, 9, 2, 9, 0))\n                               .between(datetime(1997, 9, 2, 9, 0),\n                                        datetime(1997, 9, 6, 9, 0)),\n                         [datetime(1997, 9, 3, 9, 0),\n                          datetime(1997, 9, 4, 9, 0),\n                          datetime(1997, 9, 5, 9, 0)])\n\n    def testBetweenInc(self):\n        self.assertEqual(rrule(DAILY,\n                               #count=5,\n                               dtstart=datetime(1997, 9, 2, 9, 0))\n                               .between(datetime(1997, 9, 2, 9, 0),\n                                        datetime(1997, 9, 6, 9, 0), inc=True),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1997, 9, 3, 9, 0),\n                          datetime(1997, 9, 4, 9, 0),\n                          datetime(1997, 9, 5, 9, 0),\n                          datetime(1997, 9, 6, 9, 0)])\n\n    def testCachePre(self):\n        rr = rrule(DAILY, count=15, cache=True,\n                   dtstart=datetime(1997, 9, 2, 9, 0))\n        self.assertEqual(list(rr),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1997, 9, 3, 9, 0),\n                          datetime(1997, 9, 4, 9, 0),\n                          datetime(1997, 9, 5, 9, 0),\n                          datetime(1997, 9, 6, 9, 0),\n                          datetime(1997, 9, 7, 9, 0),\n                          datetime(1997, 9, 8, 9, 0),\n                          datetime(1997, 9, 9, 9, 0),\n                          datetime(1997, 9, 10, 9, 0),\n                          datetime(1997, 9, 11, 9, 0),\n                          datetime(1997, 9, 12, 9, 0),\n                          datetime(1997, 9, 13, 9, 0),\n                          datetime(1997, 9, 14, 9, 0),\n                          datetime(1997, 9, 15, 9, 0),\n                          datetime(1997, 9, 16, 9, 0)])\n\n    def testCachePost(self):\n        rr = rrule(DAILY, count=15, cache=True,\n                   dtstart=datetime(1997, 9, 2, 9, 0))\n        for x in rr: pass\n        self.assertEqual(list(rr),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1997, 9, 3, 9, 0),\n                          datetime(1997, 9, 4, 9, 0),\n                          datetime(1997, 9, 5, 9, 0),\n                          datetime(1997, 9, 6, 9, 0),\n                          datetime(1997, 9, 7, 9, 0),\n                          datetime(1997, 9, 8, 9, 0),\n                          datetime(1997, 9, 9, 9, 0),\n                          datetime(1997, 9, 10, 9, 0),\n                          datetime(1997, 9, 11, 9, 0),\n                          datetime(1997, 9, 12, 9, 0),\n                          datetime(1997, 9, 13, 9, 0),\n                          datetime(1997, 9, 14, 9, 0),\n                          datetime(1997, 9, 15, 9, 0),\n                          datetime(1997, 9, 16, 9, 0)])\n\n    def testCachePostInternal(self):\n        rr = rrule(DAILY, count=15, cache=True,\n                   dtstart=datetime(1997, 9, 2, 9, 0))\n        for x in rr: pass\n        self.assertEqual(rr._cache,\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1997, 9, 3, 9, 0),\n                          datetime(1997, 9, 4, 9, 0),\n                          datetime(1997, 9, 5, 9, 0),\n                          datetime(1997, 9, 6, 9, 0),\n                          datetime(1997, 9, 7, 9, 0),\n                          datetime(1997, 9, 8, 9, 0),\n                          datetime(1997, 9, 9, 9, 0),\n                          datetime(1997, 9, 10, 9, 0),\n                          datetime(1997, 9, 11, 9, 0),\n                          datetime(1997, 9, 12, 9, 0),\n                          datetime(1997, 9, 13, 9, 0),\n                          datetime(1997, 9, 14, 9, 0),\n                          datetime(1997, 9, 15, 9, 0),\n                          datetime(1997, 9, 16, 9, 0)])\n\n    def testCachePreContains(self):\n        rr = rrule(DAILY, count=3, cache=True,\n                   dtstart=datetime(1997, 9, 2, 9, 0))\n        self.assertEqual(datetime(1997, 9, 3, 9, 0) in rr, True)\n\n    def testCachePostContains(self):\n        rr = rrule(DAILY, count=3, cache=True,\n                   dtstart=datetime(1997, 9, 2, 9, 0))\n        for x in rr: pass\n        self.assertEqual(datetime(1997, 9, 3, 9, 0) in rr, True)\n\n    def testStr(self):\n        self.assertEqual(list(rrulestr(\n                              \"DTSTART:19970902T090000\\n\"\n                              \"RRULE:FREQ=YEARLY;COUNT=3\\n\"\n                              )),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1998, 9, 2, 9, 0),\n                          datetime(1999, 9, 2, 9, 0)])\n\n    def testStrWithTZID(self):\n        NYC = tz.gettz('America/New_York')\n        self.assertEqual(list(rrulestr(\n                              \"DTSTART;TZID=America/New_York:19970902T090000\\n\"\n                              \"RRULE:FREQ=YEARLY;COUNT=3\\n\"\n                              )),\n                         [datetime(1997, 9, 2, 9, 0, tzinfo=NYC),\n                          datetime(1998, 9, 2, 9, 0, tzinfo=NYC),\n                          datetime(1999, 9, 2, 9, 0, tzinfo=NYC)])\n\n    def testStrWithTZIDMapping(self):\n        rrstr = (\"DTSTART;TZID=Eastern:19970902T090000\\n\" +\n                 \"RRULE:FREQ=YEARLY;COUNT=3\")\n\n        NYC = tz.gettz('America/New_York')\n        rr = rrulestr(rrstr, tzids={'Eastern': NYC})\n        exp = [datetime(1997, 9, 2, 9, 0, tzinfo=NYC),\n               datetime(1998, 9, 2, 9, 0, tzinfo=NYC),\n               datetime(1999, 9, 2, 9, 0, tzinfo=NYC)]\n\n        self.assertEqual(list(rr), exp)\n\n    def testStrWithTZIDCallable(self):\n        rrstr = ('DTSTART;TZID=UTC+04:19970902T090000\\n' +\n                 'RRULE:FREQ=YEARLY;COUNT=3')\n\n        TZ = tz.tzstr('UTC+04')\n        def parse_tzstr(tzstr):\n            if tzstr is None:\n                raise ValueError('Invalid tzstr')\n\n            return tz.tzstr(tzstr)\n\n        rr = rrulestr(rrstr, tzids=parse_tzstr)\n\n        exp = [datetime(1997, 9, 2, 9, 0, tzinfo=TZ),\n               datetime(1998, 9, 2, 9, 0, tzinfo=TZ),\n               datetime(1999, 9, 2, 9, 0, tzinfo=TZ),]\n\n        self.assertEqual(list(rr), exp)\n\n    def testStrWithTZIDCallableFailure(self):\n        rrstr = ('DTSTART;TZID=America/New_York:19970902T090000\\n' +\n                 'RRULE:FREQ=YEARLY;COUNT=3')\n\n        class TzInfoError(Exception):\n            pass\n\n        def tzinfos(tzstr):\n            if tzstr == 'America/New_York':\n                raise TzInfoError('Invalid!')\n            return None\n\n        with self.assertRaises(TzInfoError):\n            rrulestr(rrstr, tzids=tzinfos)\n\n    def testStrWithConflictingTZID(self):\n        # RFC 5545 Section 3.3.5, FORM #2: DATE WITH UTC TIME\n        # https://tools.ietf.org/html/rfc5545#section-3.3.5\n        # The \"TZID\" property parameter MUST NOT be applied to DATE-TIME\n        with self.assertRaises(ValueError):\n            rrulestr(\"DTSTART;TZID=America/New_York:19970902T090000Z\\n\"+\n                     \"RRULE:FREQ=YEARLY;COUNT=3\\n\")\n\n    def testStrType(self):\n        self.assertEqual(isinstance(rrulestr(\n                              \"DTSTART:19970902T090000\\n\"\n                              \"RRULE:FREQ=YEARLY;COUNT=3\\n\"\n                              ), rrule), True)\n\n    def testStrForceSetType(self):\n        self.assertEqual(isinstance(rrulestr(\n                              \"DTSTART:19970902T090000\\n\"\n                              \"RRULE:FREQ=YEARLY;COUNT=3\\n\"\n                              , forceset=True), rruleset), True)\n\n    def testStrSetType(self):\n        self.assertEqual(isinstance(rrulestr(\n                              \"DTSTART:19970902T090000\\n\"\n                              \"RRULE:FREQ=YEARLY;COUNT=2;BYDAY=TU\\n\"\n                              \"RRULE:FREQ=YEARLY;COUNT=1;BYDAY=TH\\n\"\n                              ), rruleset), True)\n\n    def testStrCase(self):\n        self.assertEqual(list(rrulestr(\n                              \"dtstart:19970902T090000\\n\"\n                              \"rrule:freq=yearly;count=3\\n\"\n                              )),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1998, 9, 2, 9, 0),\n                          datetime(1999, 9, 2, 9, 0)])\n\n    def testStrSpaces(self):\n        self.assertEqual(list(rrulestr(\n                              \" DTSTART:19970902T090000 \"\n                              \" RRULE:FREQ=YEARLY;COUNT=3 \"\n                              )),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1998, 9, 2, 9, 0),\n                          datetime(1999, 9, 2, 9, 0)])\n\n    def testStrSpacesAndLines(self):\n        self.assertEqual(list(rrulestr(\n                              \" DTSTART:19970902T090000 \\n\"\n                              \" \\n\"\n                              \" RRULE:FREQ=YEARLY;COUNT=3 \\n\"\n                              )),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1998, 9, 2, 9, 0),\n                          datetime(1999, 9, 2, 9, 0)])\n\n    def testStrNoDTStart(self):\n        self.assertEqual(list(rrulestr(\n                              \"RRULE:FREQ=YEARLY;COUNT=3\\n\"\n                              , dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1998, 9, 2, 9, 0),\n                          datetime(1999, 9, 2, 9, 0)])\n\n    def testStrValueOnly(self):\n        self.assertEqual(list(rrulestr(\n                              \"FREQ=YEARLY;COUNT=3\\n\"\n                              , dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1998, 9, 2, 9, 0),\n                          datetime(1999, 9, 2, 9, 0)])\n\n    def testStrUnfold(self):\n        self.assertEqual(list(rrulestr(\n                              \"FREQ=YEA\\n RLY;COUNT=3\\n\", unfold=True,\n                              dtstart=datetime(1997, 9, 2, 9, 0))),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1998, 9, 2, 9, 0),\n                          datetime(1999, 9, 2, 9, 0)])\n\n    def testStrSet(self):\n        self.assertEqual(list(rrulestr(\n                              \"DTSTART:19970902T090000\\n\"\n                              \"RRULE:FREQ=YEARLY;COUNT=2;BYDAY=TU\\n\"\n                              \"RRULE:FREQ=YEARLY;COUNT=1;BYDAY=TH\\n\"\n                              )),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1997, 9, 4, 9, 0),\n                          datetime(1997, 9, 9, 9, 0)])\n\n    def testStrSetDate(self):\n        self.assertEqual(list(rrulestr(\n                              \"DTSTART:19970902T090000\\n\"\n                              \"RRULE:FREQ=YEARLY;COUNT=1;BYDAY=TU\\n\"\n                              \"RDATE:19970904T090000\\n\"\n                              \"RDATE:19970909T090000\\n\"\n                              )),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1997, 9, 4, 9, 0),\n                          datetime(1997, 9, 9, 9, 0)])\n\n    def testStrSetExRule(self):\n        self.assertEqual(list(rrulestr(\n                              \"DTSTART:19970902T090000\\n\"\n                              \"RRULE:FREQ=YEARLY;COUNT=6;BYDAY=TU,TH\\n\"\n                              \"EXRULE:FREQ=YEARLY;COUNT=3;BYDAY=TH\\n\"\n                              )),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1997, 9, 9, 9, 0),\n                          datetime(1997, 9, 16, 9, 0)])\n\n    def testStrSetExDate(self):\n        self.assertEqual(list(rrulestr(\n                              \"DTSTART:19970902T090000\\n\"\n                              \"RRULE:FREQ=YEARLY;COUNT=6;BYDAY=TU,TH\\n\"\n                              \"EXDATE:19970904T090000\\n\"\n                              \"EXDATE:19970911T090000\\n\"\n                              \"EXDATE:19970918T090000\\n\"\n                              )),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1997, 9, 9, 9, 0),\n                          datetime(1997, 9, 16, 9, 0)])\n\n    def testStrSetExDateMultiple(self):\n        rrstr = (\"DTSTART:19970902T090000\\n\"\n                 \"RRULE:FREQ=YEARLY;COUNT=6;BYDAY=TU,TH\\n\"\n                 \"EXDATE:19970904T090000,19970911T090000,19970918T090000\\n\")\n\n        rr = rrulestr(rrstr)\n        assert list(rr) == [datetime(1997, 9, 2, 9, 0),\n                            datetime(1997, 9, 9, 9, 0),\n                            datetime(1997, 9, 16, 9, 0)]\n\n    def testStrSetExDateWithTZID(self):\n        BXL = tz.gettz('Europe/Brussels')\n        rr = rrulestr(\"DTSTART;TZID=Europe/Brussels:19970902T090000\\n\"\n                      \"RRULE:FREQ=YEARLY;COUNT=6;BYDAY=TU,TH\\n\"\n                      \"EXDATE;TZID=Europe/Brussels:19970904T090000\\n\"\n                      \"EXDATE;TZID=Europe/Brussels:19970911T090000\\n\"\n                      \"EXDATE;TZID=Europe/Brussels:19970918T090000\\n\")\n\n        assert list(rr) == [datetime(1997, 9, 2, 9, 0, tzinfo=BXL),\n                            datetime(1997, 9, 9, 9, 0, tzinfo=BXL),\n                            datetime(1997, 9, 16, 9, 0, tzinfo=BXL)]\n\n    def testStrSetExDateValueDateTimeNoTZID(self):\n        rrstr = '\\n'.join([\n            \"DTSTART:19970902T090000\",\n            \"RRULE:FREQ=YEARLY;COUNT=4;BYDAY=TU,TH\",\n            \"EXDATE;VALUE=DATE-TIME:19970902T090000\",\n            \"EXDATE;VALUE=DATE-TIME:19970909T090000\",\n        ])\n\n        rr = rrulestr(rrstr)\n        assert list(rr) == [datetime(1997, 9, 4, 9), datetime(1997, 9, 11, 9)]\n\n    def testStrSetExDateValueMixDateTimeNoTZID(self):\n        rrstr = '\\n'.join([\n            \"DTSTART:19970902T090000\",\n            \"RRULE:FREQ=YEARLY;COUNT=4;BYDAY=TU,TH\",\n            \"EXDATE;VALUE=DATE-TIME:19970902T090000\",\n            \"EXDATE:19970909T090000\",\n        ])\n\n        rr = rrulestr(rrstr)\n        assert list(rr) == [datetime(1997, 9, 4, 9), datetime(1997, 9, 11, 9)]\n\n    def testStrSetExDateValueDateTimeWithTZID(self):\n        BXL = tz.gettz('Europe/Brussels')\n        rrstr = '\\n'.join([\n            \"DTSTART;VALUE=DATE-TIME;TZID=Europe/Brussels:19970902T090000\",\n            \"RRULE:FREQ=YEARLY;COUNT=4;BYDAY=TU,TH\",\n            \"EXDATE;VALUE=DATE-TIME;TZID=Europe/Brussels:19970902T090000\",\n            \"EXDATE;VALUE=DATE-TIME;TZID=Europe/Brussels:19970909T090000\",\n        ])\n\n        rr = rrulestr(rrstr)\n        assert list(rr) == [datetime(1997, 9, 4, 9, tzinfo=BXL),\n                            datetime(1997, 9, 11, 9, tzinfo=BXL)]\n\n    def testStrSetExDateValueDate(self):\n        rrstr = '\\n'.join([\n            \"DTSTART;VALUE=DATE:19970902\",\n            \"RRULE:FREQ=YEARLY;COUNT=4;BYDAY=TU,TH\",\n            \"EXDATE;VALUE=DATE:19970902\",\n            \"EXDATE;VALUE=DATE:19970909\",\n        ])\n\n        rr = rrulestr(rrstr)\n        assert list(rr) == [datetime(1997, 9, 4), datetime(1997, 9, 11)]\n\n    def testStrSetDateAndExDate(self):\n        self.assertEqual(list(rrulestr(\n                              \"DTSTART:19970902T090000\\n\"\n                              \"RDATE:19970902T090000\\n\"\n                              \"RDATE:19970904T090000\\n\"\n                              \"RDATE:19970909T090000\\n\"\n                              \"RDATE:19970911T090000\\n\"\n                              \"RDATE:19970916T090000\\n\"\n                              \"RDATE:19970918T090000\\n\"\n                              \"EXDATE:19970904T090000\\n\"\n                              \"EXDATE:19970911T090000\\n\"\n                              \"EXDATE:19970918T090000\\n\"\n                              )),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1997, 9, 9, 9, 0),\n                          datetime(1997, 9, 16, 9, 0)])\n\n    def testStrSetDateAndExRule(self):\n        self.assertEqual(list(rrulestr(\n                              \"DTSTART:19970902T090000\\n\"\n                              \"RDATE:19970902T090000\\n\"\n                              \"RDATE:19970904T090000\\n\"\n                              \"RDATE:19970909T090000\\n\"\n                              \"RDATE:19970911T090000\\n\"\n                              \"RDATE:19970916T090000\\n\"\n                              \"RDATE:19970918T090000\\n\"\n                              \"EXRULE:FREQ=YEARLY;COUNT=3;BYDAY=TH\\n\"\n                              )),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1997, 9, 9, 9, 0),\n                          datetime(1997, 9, 16, 9, 0)])\n\n    def testStrKeywords(self):\n        self.assertEqual(list(rrulestr(\n                              \"DTSTART:19970902T090000\\n\"\n                              \"RRULE:FREQ=YEARLY;COUNT=3;INTERVAL=3;\"\n                                    \"BYMONTH=3;BYWEEKDAY=TH;BYMONTHDAY=3;\"\n                                    \"BYHOUR=3;BYMINUTE=3;BYSECOND=3\\n\"\n                              )),\n                         [datetime(2033, 3, 3, 3, 3, 3),\n                          datetime(2039, 3, 3, 3, 3, 3),\n                          datetime(2072, 3, 3, 3, 3, 3)])\n\n    def testStrNWeekDay(self):\n        self.assertEqual(list(rrulestr(\n                              \"DTSTART:19970902T090000\\n\"\n                              \"RRULE:FREQ=YEARLY;COUNT=3;BYDAY=1TU,-1TH\\n\"\n                              )),\n                         [datetime(1997, 12, 25, 9, 0),\n                          datetime(1998, 1, 6, 9, 0),\n                          datetime(1998, 12, 31, 9, 0)])\n\n    def testStrUntil(self):\n        self.assertEqual(list(rrulestr(\n                              \"DTSTART:19970902T090000\\n\"\n                              \"RRULE:FREQ=YEARLY;\"\n                              \"UNTIL=19990101T000000;BYDAY=1TU,-1TH\\n\"\n                              )),\n                         [datetime(1997, 12, 25, 9, 0),\n                          datetime(1998, 1, 6, 9, 0),\n                          datetime(1998, 12, 31, 9, 0)])\n\n    def testStrValueDatetime(self):\n        rr = rrulestr(\"DTSTART;VALUE=DATE-TIME:19970902T090000\\n\"\n                       \"RRULE:FREQ=YEARLY;COUNT=2\")\n\n        self.assertEqual(list(rr), [datetime(1997, 9, 2, 9, 0, 0),\n                                    datetime(1998, 9, 2, 9, 0, 0)])\n\n    def testStrValueDate(self):\n        rr = rrulestr(\"DTSTART;VALUE=DATE:19970902\\n\"\n                       \"RRULE:FREQ=YEARLY;COUNT=2\")\n\n        self.assertEqual(list(rr), [datetime(1997, 9, 2, 0, 0, 0),\n                                    datetime(1998, 9, 2, 0, 0, 0)])\n\n    def testStrMultipleDTStartComma(self):\n        with pytest.raises(ValueError):\n            rr = rrulestr(\"DTSTART:19970101T000000,19970202T000000\\n\"\n                          \"RRULE:FREQ=YEARLY;COUNT=1\")\n\n    def testStrInvalidUntil(self):\n        with self.assertRaises(ValueError):\n            list(rrulestr(\"DTSTART:19970902T090000\\n\"\n                          \"RRULE:FREQ=YEARLY;\"\n                          \"UNTIL=TheCowsComeHome;BYDAY=1TU,-1TH\\n\"))\n\n    def testStrUntilMustBeUTC(self):\n        with self.assertRaises(ValueError):\n            list(rrulestr(\"DTSTART;TZID=America/New_York:19970902T090000\\n\"\n                          \"RRULE:FREQ=YEARLY;\"\n                          \"UNTIL=19990101T000000;BYDAY=1TU,-1TH\\n\"))\n\n    def testStrUntilWithTZ(self):\n        NYC = tz.gettz('America/New_York')\n        rr = list(rrulestr(\"DTSTART;TZID=America/New_York:19970101T000000\\n\"\n                          \"RRULE:FREQ=YEARLY;\"\n                          \"UNTIL=19990101T000000Z\\n\"))\n        self.assertEqual(list(rr), [datetime(1997, 1, 1, 0, 0, 0, tzinfo=NYC),\n                                    datetime(1998, 1, 1, 0, 0, 0, tzinfo=NYC)])\n\n    def testStrEmptyByDay(self):\n        with self.assertRaises(ValueError):\n            list(rrulestr(\"DTSTART:19970902T090000\\n\"\n                          \"FREQ=WEEKLY;\"\n                          \"BYDAY=;\"         # This part is invalid\n                          \"WKST=SU\"))\n\n    def testStrInvalidByDay(self):\n        with self.assertRaises(ValueError):\n            list(rrulestr(\"DTSTART:19970902T090000\\n\"\n                          \"FREQ=WEEKLY;\"\n                          \"BYDAY=-1OK;\"         # This part is invalid\n                          \"WKST=SU\"))\n\n    def testBadBySetPos(self):\n        self.assertRaises(ValueError,\n                          rrule, MONTHLY,\n                                 count=1,\n                                 bysetpos=0,\n                                 dtstart=datetime(1997, 9, 2, 9, 0))\n\n    def testBadBySetPosMany(self):\n        self.assertRaises(ValueError,\n                          rrule, MONTHLY,\n                                 count=1,\n                                 bysetpos=(-1, 0, 1),\n                                 dtstart=datetime(1997, 9, 2, 9, 0))\n\n    # Tests to ensure that str(rrule) works\n    def testToStrYearly(self):\n        rule = rrule(YEARLY, count=3, dtstart=datetime(1997, 9, 2, 9, 0))\n        self._rrulestr_reverse_test(rule)\n\n    def testToStrYearlyInterval(self):\n        rule = rrule(YEARLY, count=3, interval=2,\n                     dtstart=datetime(1997, 9, 2, 9, 0))\n        self._rrulestr_reverse_test(rule)\n\n    def testToStrYearlyByMonth(self):\n        self._rrulestr_reverse_test(rrule(YEARLY,\n                                          count=3,\n                                          bymonth=(1, 3),\n                                          dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrYearlyByMonthDay(self):\n        self._rrulestr_reverse_test(rrule(YEARLY,\n                                          count=3,\n                                          bymonthday=(1, 3),\n                                          dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrYearlyByMonthAndMonthDay(self):\n        self._rrulestr_reverse_test(rrule(YEARLY,\n                                          count=3,\n                                          bymonth=(1, 3),\n                                          bymonthday=(5, 7),\n                                          dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrYearlyByWeekDay(self):\n        self._rrulestr_reverse_test(rrule(YEARLY,\n                                          count=3,\n                                          byweekday=(TU, TH),\n                                          dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrYearlyByNWeekDay(self):\n        self._rrulestr_reverse_test(rrule(YEARLY,\n                                          count=3,\n                                          byweekday=(TU(1), TH(-1)),\n                                          dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrYearlyByNWeekDayLarge(self):\n        self._rrulestr_reverse_test(rrule(YEARLY,\n                              count=3,\n                              byweekday=(TU(3), TH(-3)),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrYearlyByMonthAndWeekDay(self):\n        self._rrulestr_reverse_test(rrule(YEARLY,\n                              count=3,\n                              bymonth=(1, 3),\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrYearlyByMonthAndNWeekDay(self):\n        self._rrulestr_reverse_test(rrule(YEARLY,\n                              count=3,\n                              bymonth=(1, 3),\n                              byweekday=(TU(1), TH(-1)),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrYearlyByMonthAndNWeekDayLarge(self):\n        # This is interesting because the TH(-3) ends up before\n        # the TU(3).\n        self._rrulestr_reverse_test(rrule(YEARLY,\n                              count=3,\n                              bymonth=(1, 3),\n                              byweekday=(TU(3), TH(-3)),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrYearlyByMonthDayAndWeekDay(self):\n        self._rrulestr_reverse_test(rrule(YEARLY,\n                              count=3,\n                              bymonthday=(1, 3),\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrYearlyByMonthAndMonthDayAndWeekDay(self):\n        self._rrulestr_reverse_test(rrule(YEARLY,\n                              count=3,\n                              bymonth=(1, 3),\n                              bymonthday=(1, 3),\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrYearlyByYearDay(self):\n        self._rrulestr_reverse_test(rrule(YEARLY,\n                              count=4,\n                              byyearday=(1, 100, 200, 365),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrYearlyByYearDayNeg(self):\n        self._rrulestr_reverse_test(rrule(YEARLY,\n                              count=4,\n                              byyearday=(-365, -266, -166, -1),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrYearlyByMonthAndYearDay(self):\n        self._rrulestr_reverse_test(rrule(YEARLY,\n                              count=4,\n                              bymonth=(4, 7),\n                              byyearday=(1, 100, 200, 365),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrYearlyByMonthAndYearDayNeg(self):\n        self._rrulestr_reverse_test(rrule(YEARLY,\n                              count=4,\n                              bymonth=(4, 7),\n                              byyearday=(-365, -266, -166, -1),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrYearlyByWeekNo(self):\n        self._rrulestr_reverse_test(rrule(YEARLY,\n                              count=3,\n                              byweekno=20,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrYearlyByWeekNoAndWeekDay(self):\n        # That's a nice one. The first days of week number one\n        # may be in the last year.\n        self._rrulestr_reverse_test(rrule(YEARLY,\n                              count=3,\n                              byweekno=1,\n                              byweekday=MO,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrYearlyByWeekNoAndWeekDayLarge(self):\n        # Another nice test. The last days of week number 52/53\n        # may be in the next year.\n        self._rrulestr_reverse_test(rrule(YEARLY,\n                              count=3,\n                              byweekno=52,\n                              byweekday=SU,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrYearlyByWeekNoAndWeekDayLast(self):\n        self._rrulestr_reverse_test(rrule(YEARLY,\n                              count=3,\n                              byweekno=-1,\n                              byweekday=SU,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrYearlyByEaster(self):\n        self._rrulestr_reverse_test(rrule(YEARLY,\n                              count=3,\n                              byeaster=0,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrYearlyByEasterPos(self):\n        self._rrulestr_reverse_test(rrule(YEARLY,\n                              count=3,\n                              byeaster=1,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrYearlyByEasterNeg(self):\n        self._rrulestr_reverse_test(rrule(YEARLY,\n                              count=3,\n                              byeaster=-1,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrYearlyByWeekNoAndWeekDay53(self):\n        self._rrulestr_reverse_test(rrule(YEARLY,\n                              count=3,\n                              byweekno=53,\n                              byweekday=MO,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrYearlyByHour(self):\n        self._rrulestr_reverse_test(rrule(YEARLY,\n                              count=3,\n                              byhour=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrYearlyByMinute(self):\n        self._rrulestr_reverse_test(rrule(YEARLY,\n                              count=3,\n                              byminute=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrYearlyBySecond(self):\n        self._rrulestr_reverse_test(rrule(YEARLY,\n                              count=3,\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrYearlyByHourAndMinute(self):\n        self._rrulestr_reverse_test(rrule(YEARLY,\n                              count=3,\n                              byhour=(6, 18),\n                              byminute=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrYearlyByHourAndSecond(self):\n        self._rrulestr_reverse_test(rrule(YEARLY,\n                              count=3,\n                              byhour=(6, 18),\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrYearlyByMinuteAndSecond(self):\n        self._rrulestr_reverse_test(rrule(YEARLY,\n                              count=3,\n                              byminute=(6, 18),\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrYearlyByHourAndMinuteAndSecond(self):\n        self._rrulestr_reverse_test(rrule(YEARLY,\n                              count=3,\n                              byhour=(6, 18),\n                              byminute=(6, 18),\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrYearlyBySetPos(self):\n        self._rrulestr_reverse_test(rrule(YEARLY,\n                              count=3,\n                              bymonthday=15,\n                              byhour=(6, 18),\n                              bysetpos=(3, -3),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMonthly(self):\n        self._rrulestr_reverse_test(rrule(MONTHLY,\n                              count=3,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMonthlyInterval(self):\n        self._rrulestr_reverse_test(rrule(MONTHLY,\n                              count=3,\n                              interval=2,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMonthlyIntervalLarge(self):\n        self._rrulestr_reverse_test(rrule(MONTHLY,\n                              count=3,\n                              interval=18,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMonthlyByMonth(self):\n        self._rrulestr_reverse_test(rrule(MONTHLY,\n                              count=3,\n                              bymonth=(1, 3),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMonthlyByMonthDay(self):\n        self._rrulestr_reverse_test(rrule(MONTHLY,\n                              count=3,\n                              bymonthday=(1, 3),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMonthlyByMonthAndMonthDay(self):\n        self._rrulestr_reverse_test(rrule(MONTHLY,\n                              count=3,\n                              bymonth=(1, 3),\n                              bymonthday=(5, 7),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMonthlyByWeekDay(self):\n        self._rrulestr_reverse_test(rrule(MONTHLY,\n                              count=3,\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n        # Third Monday of the month\n        self.assertEqual(rrule(MONTHLY,\n                         byweekday=(MO(+3)),\n                         dtstart=datetime(1997, 9, 1)).between(datetime(1997,\n                                                                        9,\n                                                                        1),\n                                                               datetime(1997,\n                                                                        12,\n                                                                        1)),\n                         [datetime(1997, 9, 15, 0, 0),\n                          datetime(1997, 10, 20, 0, 0),\n                          datetime(1997, 11, 17, 0, 0)])\n\n    def testToStrMonthlyByNWeekDay(self):\n        self._rrulestr_reverse_test(rrule(MONTHLY,\n                              count=3,\n                              byweekday=(TU(1), TH(-1)),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMonthlyByNWeekDayLarge(self):\n        self._rrulestr_reverse_test(rrule(MONTHLY,\n                              count=3,\n                              byweekday=(TU(3), TH(-3)),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMonthlyByMonthAndWeekDay(self):\n        self._rrulestr_reverse_test(rrule(MONTHLY,\n                              count=3,\n                              bymonth=(1, 3),\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMonthlyByMonthAndNWeekDay(self):\n        self._rrulestr_reverse_test(rrule(MONTHLY,\n                              count=3,\n                              bymonth=(1, 3),\n                              byweekday=(TU(1), TH(-1)),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMonthlyByMonthAndNWeekDayLarge(self):\n        self._rrulestr_reverse_test(rrule(MONTHLY,\n                              count=3,\n                              bymonth=(1, 3),\n                              byweekday=(TU(3), TH(-3)),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMonthlyByMonthDayAndWeekDay(self):\n        self._rrulestr_reverse_test(rrule(MONTHLY,\n                              count=3,\n                              bymonthday=(1, 3),\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMonthlyByMonthAndMonthDayAndWeekDay(self):\n        self._rrulestr_reverse_test(rrule(MONTHLY,\n                              count=3,\n                              bymonth=(1, 3),\n                              bymonthday=(1, 3),\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMonthlyByYearDay(self):\n        self._rrulestr_reverse_test(rrule(MONTHLY,\n                              count=4,\n                              byyearday=(1, 100, 200, 365),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMonthlyByYearDayNeg(self):\n        self._rrulestr_reverse_test(rrule(MONTHLY,\n                              count=4,\n                              byyearday=(-365, -266, -166, -1),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMonthlyByMonthAndYearDay(self):\n        self._rrulestr_reverse_test(rrule(MONTHLY,\n                              count=4,\n                              bymonth=(4, 7),\n                              byyearday=(1, 100, 200, 365),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMonthlyByMonthAndYearDayNeg(self):\n        self._rrulestr_reverse_test(rrule(MONTHLY,\n                              count=4,\n                              bymonth=(4, 7),\n                              byyearday=(-365, -266, -166, -1),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMonthlyByWeekNo(self):\n        self._rrulestr_reverse_test(rrule(MONTHLY,\n                              count=3,\n                              byweekno=20,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMonthlyByWeekNoAndWeekDay(self):\n        # That's a nice one. The first days of week number one\n        # may be in the last year.\n        self._rrulestr_reverse_test(rrule(MONTHLY,\n                              count=3,\n                              byweekno=1,\n                              byweekday=MO,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMonthlyByWeekNoAndWeekDayLarge(self):\n        # Another nice test. The last days of week number 52/53\n        # may be in the next year.\n        self._rrulestr_reverse_test(rrule(MONTHLY,\n                              count=3,\n                              byweekno=52,\n                              byweekday=SU,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMonthlyByWeekNoAndWeekDayLast(self):\n        self._rrulestr_reverse_test(rrule(MONTHLY,\n                              count=3,\n                              byweekno=-1,\n                              byweekday=SU,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMonthlyByWeekNoAndWeekDay53(self):\n        self._rrulestr_reverse_test(rrule(MONTHLY,\n                              count=3,\n                              byweekno=53,\n                              byweekday=MO,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMonthlyByEaster(self):\n        self._rrulestr_reverse_test(rrule(MONTHLY,\n                              count=3,\n                              byeaster=0,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMonthlyByEasterPos(self):\n        self._rrulestr_reverse_test(rrule(MONTHLY,\n                              count=3,\n                              byeaster=1,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMonthlyByEasterNeg(self):\n        self._rrulestr_reverse_test(rrule(MONTHLY,\n                              count=3,\n                              byeaster=-1,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMonthlyByHour(self):\n        self._rrulestr_reverse_test(rrule(MONTHLY,\n                              count=3,\n                              byhour=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMonthlyByMinute(self):\n        self._rrulestr_reverse_test(rrule(MONTHLY,\n                              count=3,\n                              byminute=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMonthlyBySecond(self):\n        self._rrulestr_reverse_test(rrule(MONTHLY,\n                              count=3,\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMonthlyByHourAndMinute(self):\n        self._rrulestr_reverse_test(rrule(MONTHLY,\n                              count=3,\n                              byhour=(6, 18),\n                              byminute=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMonthlyByHourAndSecond(self):\n        self._rrulestr_reverse_test(rrule(MONTHLY,\n                              count=3,\n                              byhour=(6, 18),\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMonthlyByMinuteAndSecond(self):\n        self._rrulestr_reverse_test(rrule(MONTHLY,\n                              count=3,\n                              byminute=(6, 18),\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMonthlyByHourAndMinuteAndSecond(self):\n        self._rrulestr_reverse_test(rrule(MONTHLY,\n                              count=3,\n                              byhour=(6, 18),\n                              byminute=(6, 18),\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMonthlyBySetPos(self):\n        self._rrulestr_reverse_test(rrule(MONTHLY,\n                              count=3,\n                              bymonthday=(13, 17),\n                              byhour=(6, 18),\n                              bysetpos=(3, -3),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrWeekly(self):\n        self._rrulestr_reverse_test(rrule(WEEKLY,\n                              count=3,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrWeeklyInterval(self):\n        self._rrulestr_reverse_test(rrule(WEEKLY,\n                              count=3,\n                              interval=2,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrWeeklyIntervalLarge(self):\n        self._rrulestr_reverse_test(rrule(WEEKLY,\n                              count=3,\n                              interval=20,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrWeeklyByMonth(self):\n        self._rrulestr_reverse_test(rrule(WEEKLY,\n                              count=3,\n                              bymonth=(1, 3),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrWeeklyByMonthDay(self):\n        self._rrulestr_reverse_test(rrule(WEEKLY,\n                              count=3,\n                              bymonthday=(1, 3),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrWeeklyByMonthAndMonthDay(self):\n        self._rrulestr_reverse_test(rrule(WEEKLY,\n                              count=3,\n                              bymonth=(1, 3),\n                              bymonthday=(5, 7),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrWeeklyByWeekDay(self):\n        self._rrulestr_reverse_test(rrule(WEEKLY,\n                              count=3,\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrWeeklyByNWeekDay(self):\n        self._rrulestr_reverse_test(rrule(WEEKLY,\n                              count=3,\n                              byweekday=(TU(1), TH(-1)),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrWeeklyByMonthAndWeekDay(self):\n        # This test is interesting, because it crosses the year\n        # boundary in a weekly period to find day '1' as a\n        # valid recurrence.\n        self._rrulestr_reverse_test(rrule(WEEKLY,\n                              count=3,\n                              bymonth=(1, 3),\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrWeeklyByMonthAndNWeekDay(self):\n        self._rrulestr_reverse_test(rrule(WEEKLY,\n                              count=3,\n                              bymonth=(1, 3),\n                              byweekday=(TU(1), TH(-1)),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrWeeklyByMonthDayAndWeekDay(self):\n        self._rrulestr_reverse_test(rrule(WEEKLY,\n                              count=3,\n                              bymonthday=(1, 3),\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrWeeklyByMonthAndMonthDayAndWeekDay(self):\n        self._rrulestr_reverse_test(rrule(WEEKLY,\n                              count=3,\n                              bymonth=(1, 3),\n                              bymonthday=(1, 3),\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrWeeklyByYearDay(self):\n        self._rrulestr_reverse_test(rrule(WEEKLY,\n                              count=4,\n                              byyearday=(1, 100, 200, 365),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrWeeklyByYearDayNeg(self):\n        self._rrulestr_reverse_test(rrule(WEEKLY,\n                              count=4,\n                              byyearday=(-365, -266, -166, -1),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrWeeklyByMonthAndYearDay(self):\n        self._rrulestr_reverse_test(rrule(WEEKLY,\n                              count=4,\n                              bymonth=(1, 7),\n                              byyearday=(1, 100, 200, 365),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrWeeklyByMonthAndYearDayNeg(self):\n        self._rrulestr_reverse_test(rrule(WEEKLY,\n                              count=4,\n                              bymonth=(1, 7),\n                              byyearday=(-365, -266, -166, -1),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrWeeklyByWeekNo(self):\n        self._rrulestr_reverse_test(rrule(WEEKLY,\n                              count=3,\n                              byweekno=20,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrWeeklyByWeekNoAndWeekDay(self):\n        # That's a nice one. The first days of week number one\n        # may be in the last year.\n        self._rrulestr_reverse_test(rrule(WEEKLY,\n                              count=3,\n                              byweekno=1,\n                              byweekday=MO,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrWeeklyByWeekNoAndWeekDayLarge(self):\n        # Another nice test. The last days of week number 52/53\n        # may be in the next year.\n        self._rrulestr_reverse_test(rrule(WEEKLY,\n                              count=3,\n                              byweekno=52,\n                              byweekday=SU,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrWeeklyByWeekNoAndWeekDayLast(self):\n        self._rrulestr_reverse_test(rrule(WEEKLY,\n                              count=3,\n                              byweekno=-1,\n                              byweekday=SU,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrWeeklyByWeekNoAndWeekDay53(self):\n        self._rrulestr_reverse_test(rrule(WEEKLY,\n                              count=3,\n                              byweekno=53,\n                              byweekday=MO,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrWeeklyByEaster(self):\n        self._rrulestr_reverse_test(rrule(WEEKLY,\n                              count=3,\n                              byeaster=0,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrWeeklyByEasterPos(self):\n        self._rrulestr_reverse_test(rrule(WEEKLY,\n                              count=3,\n                              byeaster=1,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrWeeklyByEasterNeg(self):\n        self._rrulestr_reverse_test(rrule(WEEKLY,\n                              count=3,\n                              byeaster=-1,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrWeeklyByHour(self):\n        self._rrulestr_reverse_test(rrule(WEEKLY,\n                              count=3,\n                              byhour=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrWeeklyByMinute(self):\n        self._rrulestr_reverse_test(rrule(WEEKLY,\n                              count=3,\n                              byminute=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrWeeklyBySecond(self):\n        self._rrulestr_reverse_test(rrule(WEEKLY,\n                              count=3,\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrWeeklyByHourAndMinute(self):\n        self._rrulestr_reverse_test(rrule(WEEKLY,\n                              count=3,\n                              byhour=(6, 18),\n                              byminute=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrWeeklyByHourAndSecond(self):\n        self._rrulestr_reverse_test(rrule(WEEKLY,\n                              count=3,\n                              byhour=(6, 18),\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrWeeklyByMinuteAndSecond(self):\n        self._rrulestr_reverse_test(rrule(WEEKLY,\n                              count=3,\n                              byminute=(6, 18),\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrWeeklyByHourAndMinuteAndSecond(self):\n        self._rrulestr_reverse_test(rrule(WEEKLY,\n                              count=3,\n                              byhour=(6, 18),\n                              byminute=(6, 18),\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrWeeklyBySetPos(self):\n        self._rrulestr_reverse_test(rrule(WEEKLY,\n                              count=3,\n                              byweekday=(TU, TH),\n                              byhour=(6, 18),\n                              bysetpos=(3, -3),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrDaily(self):\n        self._rrulestr_reverse_test(rrule(DAILY,\n                              count=3,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrDailyInterval(self):\n        self._rrulestr_reverse_test(rrule(DAILY,\n                              count=3,\n                              interval=2,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrDailyIntervalLarge(self):\n        self._rrulestr_reverse_test(rrule(DAILY,\n                              count=3,\n                              interval=92,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrDailyByMonth(self):\n        self._rrulestr_reverse_test(rrule(DAILY,\n                              count=3,\n                              bymonth=(1, 3),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrDailyByMonthDay(self):\n        self._rrulestr_reverse_test(rrule(DAILY,\n                              count=3,\n                              bymonthday=(1, 3),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrDailyByMonthAndMonthDay(self):\n        self._rrulestr_reverse_test(rrule(DAILY,\n                              count=3,\n                              bymonth=(1, 3),\n                              bymonthday=(5, 7),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrDailyByWeekDay(self):\n        self._rrulestr_reverse_test(rrule(DAILY,\n                              count=3,\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrDailyByNWeekDay(self):\n        self._rrulestr_reverse_test(rrule(DAILY,\n                              count=3,\n                              byweekday=(TU(1), TH(-1)),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrDailyByMonthAndWeekDay(self):\n        self._rrulestr_reverse_test(rrule(DAILY,\n                              count=3,\n                              bymonth=(1, 3),\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrDailyByMonthAndNWeekDay(self):\n        self._rrulestr_reverse_test(rrule(DAILY,\n                              count=3,\n                              bymonth=(1, 3),\n                              byweekday=(TU(1), TH(-1)),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrDailyByMonthDayAndWeekDay(self):\n        self._rrulestr_reverse_test(rrule(DAILY,\n                              count=3,\n                              bymonthday=(1, 3),\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrDailyByMonthAndMonthDayAndWeekDay(self):\n        self._rrulestr_reverse_test(rrule(DAILY,\n                              count=3,\n                              bymonth=(1, 3),\n                              bymonthday=(1, 3),\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrDailyByYearDay(self):\n        self._rrulestr_reverse_test(rrule(DAILY,\n                              count=4,\n                              byyearday=(1, 100, 200, 365),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrDailyByYearDayNeg(self):\n        self._rrulestr_reverse_test(rrule(DAILY,\n                              count=4,\n                              byyearday=(-365, -266, -166, -1),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrDailyByMonthAndYearDay(self):\n        self._rrulestr_reverse_test(rrule(DAILY,\n                              count=4,\n                              bymonth=(1, 7),\n                              byyearday=(1, 100, 200, 365),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrDailyByMonthAndYearDayNeg(self):\n        self._rrulestr_reverse_test(rrule(DAILY,\n                              count=4,\n                              bymonth=(1, 7),\n                              byyearday=(-365, -266, -166, -1),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrDailyByWeekNo(self):\n        self._rrulestr_reverse_test(rrule(DAILY,\n                              count=3,\n                              byweekno=20,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrDailyByWeekNoAndWeekDay(self):\n        # That's a nice one. The first days of week number one\n        # may be in the last year.\n        self._rrulestr_reverse_test(rrule(DAILY,\n                              count=3,\n                              byweekno=1,\n                              byweekday=MO,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrDailyByWeekNoAndWeekDayLarge(self):\n        # Another nice test. The last days of week number 52/53\n        # may be in the next year.\n        self._rrulestr_reverse_test(rrule(DAILY,\n                              count=3,\n                              byweekno=52,\n                              byweekday=SU,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrDailyByWeekNoAndWeekDayLast(self):\n        self._rrulestr_reverse_test(rrule(DAILY,\n                              count=3,\n                              byweekno=-1,\n                              byweekday=SU,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrDailyByWeekNoAndWeekDay53(self):\n        self._rrulestr_reverse_test(rrule(DAILY,\n                              count=3,\n                              byweekno=53,\n                              byweekday=MO,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrDailyByEaster(self):\n        self._rrulestr_reverse_test(rrule(DAILY,\n                              count=3,\n                              byeaster=0,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrDailyByEasterPos(self):\n        self._rrulestr_reverse_test(rrule(DAILY,\n                              count=3,\n                              byeaster=1,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrDailyByEasterNeg(self):\n        self._rrulestr_reverse_test(rrule(DAILY,\n                              count=3,\n                              byeaster=-1,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrDailyByHour(self):\n        self._rrulestr_reverse_test(rrule(DAILY,\n                              count=3,\n                              byhour=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrDailyByMinute(self):\n        self._rrulestr_reverse_test(rrule(DAILY,\n                              count=3,\n                              byminute=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrDailyBySecond(self):\n        self._rrulestr_reverse_test(rrule(DAILY,\n                              count=3,\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrDailyByHourAndMinute(self):\n        self._rrulestr_reverse_test(rrule(DAILY,\n                              count=3,\n                              byhour=(6, 18),\n                              byminute=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrDailyByHourAndSecond(self):\n        self._rrulestr_reverse_test(rrule(DAILY,\n                              count=3,\n                              byhour=(6, 18),\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrDailyByMinuteAndSecond(self):\n        self._rrulestr_reverse_test(rrule(DAILY,\n                              count=3,\n                              byminute=(6, 18),\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrDailyByHourAndMinuteAndSecond(self):\n        self._rrulestr_reverse_test(rrule(DAILY,\n                              count=3,\n                              byhour=(6, 18),\n                              byminute=(6, 18),\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrDailyBySetPos(self):\n        self._rrulestr_reverse_test(rrule(DAILY,\n                              count=3,\n                              byhour=(6, 18),\n                              byminute=(15, 45),\n                              bysetpos=(3, -3),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrHourly(self):\n        self._rrulestr_reverse_test(rrule(HOURLY,\n                              count=3,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrHourlyInterval(self):\n        self._rrulestr_reverse_test(rrule(HOURLY,\n                              count=3,\n                              interval=2,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrHourlyIntervalLarge(self):\n        self._rrulestr_reverse_test(rrule(HOURLY,\n                              count=3,\n                              interval=769,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrHourlyByMonth(self):\n        self._rrulestr_reverse_test(rrule(HOURLY,\n                              count=3,\n                              bymonth=(1, 3),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrHourlyByMonthDay(self):\n        self._rrulestr_reverse_test(rrule(HOURLY,\n                              count=3,\n                              bymonthday=(1, 3),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrHourlyByMonthAndMonthDay(self):\n        self._rrulestr_reverse_test(rrule(HOURLY,\n                              count=3,\n                              bymonth=(1, 3),\n                              bymonthday=(5, 7),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrHourlyByWeekDay(self):\n        self._rrulestr_reverse_test(rrule(HOURLY,\n                              count=3,\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrHourlyByNWeekDay(self):\n        self._rrulestr_reverse_test(rrule(HOURLY,\n                              count=3,\n                              byweekday=(TU(1), TH(-1)),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrHourlyByMonthAndWeekDay(self):\n        self._rrulestr_reverse_test(rrule(HOURLY,\n                              count=3,\n                              bymonth=(1, 3),\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrHourlyByMonthAndNWeekDay(self):\n        self._rrulestr_reverse_test(rrule(HOURLY,\n                              count=3,\n                              bymonth=(1, 3),\n                              byweekday=(TU(1), TH(-1)),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrHourlyByMonthDayAndWeekDay(self):\n        self._rrulestr_reverse_test(rrule(HOURLY,\n                              count=3,\n                              bymonthday=(1, 3),\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrHourlyByMonthAndMonthDayAndWeekDay(self):\n        self._rrulestr_reverse_test(rrule(HOURLY,\n                              count=3,\n                              bymonth=(1, 3),\n                              bymonthday=(1, 3),\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrHourlyByYearDay(self):\n        self._rrulestr_reverse_test(rrule(HOURLY,\n                              count=4,\n                              byyearday=(1, 100, 200, 365),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrHourlyByYearDayNeg(self):\n        self._rrulestr_reverse_test(rrule(HOURLY,\n                              count=4,\n                              byyearday=(-365, -266, -166, -1),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrHourlyByMonthAndYearDay(self):\n        self._rrulestr_reverse_test(rrule(HOURLY,\n                              count=4,\n                              bymonth=(4, 7),\n                              byyearday=(1, 100, 200, 365),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrHourlyByMonthAndYearDayNeg(self):\n        self._rrulestr_reverse_test(rrule(HOURLY,\n                              count=4,\n                              bymonth=(4, 7),\n                              byyearday=(-365, -266, -166, -1),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrHourlyByWeekNo(self):\n        self._rrulestr_reverse_test(rrule(HOURLY,\n                              count=3,\n                              byweekno=20,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrHourlyByWeekNoAndWeekDay(self):\n        self._rrulestr_reverse_test(rrule(HOURLY,\n                              count=3,\n                              byweekno=1,\n                              byweekday=MO,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrHourlyByWeekNoAndWeekDayLarge(self):\n        self._rrulestr_reverse_test(rrule(HOURLY,\n                              count=3,\n                              byweekno=52,\n                              byweekday=SU,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrHourlyByWeekNoAndWeekDayLast(self):\n        self._rrulestr_reverse_test(rrule(HOURLY,\n                              count=3,\n                              byweekno=-1,\n                              byweekday=SU,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrHourlyByWeekNoAndWeekDay53(self):\n        self._rrulestr_reverse_test(rrule(HOURLY,\n                              count=3,\n                              byweekno=53,\n                              byweekday=MO,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrHourlyByEaster(self):\n        self._rrulestr_reverse_test(rrule(HOURLY,\n                              count=3,\n                              byeaster=0,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrHourlyByEasterPos(self):\n        self._rrulestr_reverse_test(rrule(HOURLY,\n                              count=3,\n                              byeaster=1,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrHourlyByEasterNeg(self):\n        self._rrulestr_reverse_test(rrule(HOURLY,\n                              count=3,\n                              byeaster=-1,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrHourlyByHour(self):\n        self._rrulestr_reverse_test(rrule(HOURLY,\n                              count=3,\n                              byhour=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrHourlyByMinute(self):\n        self._rrulestr_reverse_test(rrule(HOURLY,\n                              count=3,\n                              byminute=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrHourlyBySecond(self):\n        self._rrulestr_reverse_test(rrule(HOURLY,\n                              count=3,\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrHourlyByHourAndMinute(self):\n        self._rrulestr_reverse_test(rrule(HOURLY,\n                              count=3,\n                              byhour=(6, 18),\n                              byminute=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrHourlyByHourAndSecond(self):\n        self._rrulestr_reverse_test(rrule(HOURLY,\n                              count=3,\n                              byhour=(6, 18),\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrHourlyByMinuteAndSecond(self):\n        self._rrulestr_reverse_test(rrule(HOURLY,\n                              count=3,\n                              byminute=(6, 18),\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrHourlyByHourAndMinuteAndSecond(self):\n        self._rrulestr_reverse_test(rrule(HOURLY,\n                              count=3,\n                              byhour=(6, 18),\n                              byminute=(6, 18),\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrHourlyBySetPos(self):\n        self._rrulestr_reverse_test(rrule(HOURLY,\n                              count=3,\n                              byminute=(15, 45),\n                              bysecond=(15, 45),\n                              bysetpos=(3, -3),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMinutely(self):\n        self._rrulestr_reverse_test(rrule(MINUTELY,\n                              count=3,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMinutelyInterval(self):\n        self._rrulestr_reverse_test(rrule(MINUTELY,\n                              count=3,\n                              interval=2,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMinutelyIntervalLarge(self):\n        self._rrulestr_reverse_test(rrule(MINUTELY,\n                              count=3,\n                              interval=1501,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMinutelyByMonth(self):\n        self._rrulestr_reverse_test(rrule(MINUTELY,\n                              count=3,\n                              bymonth=(1, 3),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMinutelyByMonthDay(self):\n        self._rrulestr_reverse_test(rrule(MINUTELY,\n                              count=3,\n                              bymonthday=(1, 3),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMinutelyByMonthAndMonthDay(self):\n        self._rrulestr_reverse_test(rrule(MINUTELY,\n                              count=3,\n                              bymonth=(1, 3),\n                              bymonthday=(5, 7),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMinutelyByWeekDay(self):\n        self._rrulestr_reverse_test(rrule(MINUTELY,\n                              count=3,\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMinutelyByNWeekDay(self):\n        self._rrulestr_reverse_test(rrule(MINUTELY,\n                              count=3,\n                              byweekday=(TU(1), TH(-1)),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMinutelyByMonthAndWeekDay(self):\n        self._rrulestr_reverse_test(rrule(MINUTELY,\n                              count=3,\n                              bymonth=(1, 3),\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMinutelyByMonthAndNWeekDay(self):\n        self._rrulestr_reverse_test(rrule(MINUTELY,\n                              count=3,\n                              bymonth=(1, 3),\n                              byweekday=(TU(1), TH(-1)),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMinutelyByMonthDayAndWeekDay(self):\n        self._rrulestr_reverse_test(rrule(MINUTELY,\n                              count=3,\n                              bymonthday=(1, 3),\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMinutelyByMonthAndMonthDayAndWeekDay(self):\n        self._rrulestr_reverse_test(rrule(MINUTELY,\n                              count=3,\n                              bymonth=(1, 3),\n                              bymonthday=(1, 3),\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMinutelyByYearDay(self):\n        self._rrulestr_reverse_test(rrule(MINUTELY,\n                              count=4,\n                              byyearday=(1, 100, 200, 365),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMinutelyByYearDayNeg(self):\n        self._rrulestr_reverse_test(rrule(MINUTELY,\n                              count=4,\n                              byyearday=(-365, -266, -166, -1),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMinutelyByMonthAndYearDay(self):\n        self._rrulestr_reverse_test(rrule(MINUTELY,\n                              count=4,\n                              bymonth=(4, 7),\n                              byyearday=(1, 100, 200, 365),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMinutelyByMonthAndYearDayNeg(self):\n        self._rrulestr_reverse_test(rrule(MINUTELY,\n                              count=4,\n                              bymonth=(4, 7),\n                              byyearday=(-365, -266, -166, -1),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMinutelyByWeekNo(self):\n        self._rrulestr_reverse_test(rrule(MINUTELY,\n                              count=3,\n                              byweekno=20,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMinutelyByWeekNoAndWeekDay(self):\n        self._rrulestr_reverse_test(rrule(MINUTELY,\n                              count=3,\n                              byweekno=1,\n                              byweekday=MO,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMinutelyByWeekNoAndWeekDayLarge(self):\n        self._rrulestr_reverse_test(rrule(MINUTELY,\n                              count=3,\n                              byweekno=52,\n                              byweekday=SU,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMinutelyByWeekNoAndWeekDayLast(self):\n        self._rrulestr_reverse_test(rrule(MINUTELY,\n                              count=3,\n                              byweekno=-1,\n                              byweekday=SU,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMinutelyByWeekNoAndWeekDay53(self):\n        self._rrulestr_reverse_test(rrule(MINUTELY,\n                              count=3,\n                              byweekno=53,\n                              byweekday=MO,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMinutelyByEaster(self):\n        self._rrulestr_reverse_test(rrule(MINUTELY,\n                              count=3,\n                              byeaster=0,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMinutelyByEasterPos(self):\n        self._rrulestr_reverse_test(rrule(MINUTELY,\n                              count=3,\n                              byeaster=1,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMinutelyByEasterNeg(self):\n        self._rrulestr_reverse_test(rrule(MINUTELY,\n                              count=3,\n                              byeaster=-1,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMinutelyByHour(self):\n        self._rrulestr_reverse_test(rrule(MINUTELY,\n                              count=3,\n                              byhour=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMinutelyByMinute(self):\n        self._rrulestr_reverse_test(rrule(MINUTELY,\n                              count=3,\n                              byminute=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMinutelyBySecond(self):\n        self._rrulestr_reverse_test(rrule(MINUTELY,\n                              count=3,\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMinutelyByHourAndMinute(self):\n        self._rrulestr_reverse_test(rrule(MINUTELY,\n                              count=3,\n                              byhour=(6, 18),\n                              byminute=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMinutelyByHourAndSecond(self):\n        self._rrulestr_reverse_test(rrule(MINUTELY,\n                              count=3,\n                              byhour=(6, 18),\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMinutelyByMinuteAndSecond(self):\n        self._rrulestr_reverse_test(rrule(MINUTELY,\n                              count=3,\n                              byminute=(6, 18),\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMinutelyByHourAndMinuteAndSecond(self):\n        self._rrulestr_reverse_test(rrule(MINUTELY,\n                              count=3,\n                              byhour=(6, 18),\n                              byminute=(6, 18),\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrMinutelyBySetPos(self):\n        self._rrulestr_reverse_test(rrule(MINUTELY,\n                              count=3,\n                              bysecond=(15, 30, 45),\n                              bysetpos=(3, -3),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrSecondly(self):\n        self._rrulestr_reverse_test(rrule(SECONDLY,\n                              count=3,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrSecondlyInterval(self):\n        self._rrulestr_reverse_test(rrule(SECONDLY,\n                              count=3,\n                              interval=2,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrSecondlyIntervalLarge(self):\n        self._rrulestr_reverse_test(rrule(SECONDLY,\n                              count=3,\n                              interval=90061,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrSecondlyByMonth(self):\n        self._rrulestr_reverse_test(rrule(SECONDLY,\n                              count=3,\n                              bymonth=(1, 3),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrSecondlyByMonthDay(self):\n        self._rrulestr_reverse_test(rrule(SECONDLY,\n                              count=3,\n                              bymonthday=(1, 3),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrSecondlyByMonthAndMonthDay(self):\n        self._rrulestr_reverse_test(rrule(SECONDLY,\n                              count=3,\n                              bymonth=(1, 3),\n                              bymonthday=(5, 7),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrSecondlyByWeekDay(self):\n        self._rrulestr_reverse_test(rrule(SECONDLY,\n                              count=3,\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrSecondlyByNWeekDay(self):\n        self._rrulestr_reverse_test(rrule(SECONDLY,\n                              count=3,\n                              byweekday=(TU(1), TH(-1)),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrSecondlyByMonthAndWeekDay(self):\n        self._rrulestr_reverse_test(rrule(SECONDLY,\n                              count=3,\n                              bymonth=(1, 3),\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrSecondlyByMonthAndNWeekDay(self):\n        self._rrulestr_reverse_test(rrule(SECONDLY,\n                              count=3,\n                              bymonth=(1, 3),\n                              byweekday=(TU(1), TH(-1)),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrSecondlyByMonthDayAndWeekDay(self):\n        self._rrulestr_reverse_test(rrule(SECONDLY,\n                              count=3,\n                              bymonthday=(1, 3),\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrSecondlyByMonthAndMonthDayAndWeekDay(self):\n        self._rrulestr_reverse_test(rrule(SECONDLY,\n                              count=3,\n                              bymonth=(1, 3),\n                              bymonthday=(1, 3),\n                              byweekday=(TU, TH),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrSecondlyByYearDay(self):\n        self._rrulestr_reverse_test(rrule(SECONDLY,\n                              count=4,\n                              byyearday=(1, 100, 200, 365),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrSecondlyByYearDayNeg(self):\n        self._rrulestr_reverse_test(rrule(SECONDLY,\n                              count=4,\n                              byyearday=(-365, -266, -166, -1),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrSecondlyByMonthAndYearDay(self):\n        self._rrulestr_reverse_test(rrule(SECONDLY,\n                              count=4,\n                              bymonth=(4, 7),\n                              byyearday=(1, 100, 200, 365),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrSecondlyByMonthAndYearDayNeg(self):\n        self._rrulestr_reverse_test(rrule(SECONDLY,\n                              count=4,\n                              bymonth=(4, 7),\n                              byyearday=(-365, -266, -166, -1),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrSecondlyByWeekNo(self):\n        self._rrulestr_reverse_test(rrule(SECONDLY,\n                              count=3,\n                              byweekno=20,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrSecondlyByWeekNoAndWeekDay(self):\n        self._rrulestr_reverse_test(rrule(SECONDLY,\n                              count=3,\n                              byweekno=1,\n                              byweekday=MO,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrSecondlyByWeekNoAndWeekDayLarge(self):\n        self._rrulestr_reverse_test(rrule(SECONDLY,\n                              count=3,\n                              byweekno=52,\n                              byweekday=SU,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrSecondlyByWeekNoAndWeekDayLast(self):\n        self._rrulestr_reverse_test(rrule(SECONDLY,\n                              count=3,\n                              byweekno=-1,\n                              byweekday=SU,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrSecondlyByWeekNoAndWeekDay53(self):\n        self._rrulestr_reverse_test(rrule(SECONDLY,\n                              count=3,\n                              byweekno=53,\n                              byweekday=MO,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrSecondlyByEaster(self):\n        self._rrulestr_reverse_test(rrule(SECONDLY,\n                              count=3,\n                              byeaster=0,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrSecondlyByEasterPos(self):\n        self._rrulestr_reverse_test(rrule(SECONDLY,\n                              count=3,\n                              byeaster=1,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrSecondlyByEasterNeg(self):\n        self._rrulestr_reverse_test(rrule(SECONDLY,\n                              count=3,\n                              byeaster=-1,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrSecondlyByHour(self):\n        self._rrulestr_reverse_test(rrule(SECONDLY,\n                              count=3,\n                              byhour=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrSecondlyByMinute(self):\n        self._rrulestr_reverse_test(rrule(SECONDLY,\n                              count=3,\n                              byminute=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrSecondlyBySecond(self):\n        self._rrulestr_reverse_test(rrule(SECONDLY,\n                              count=3,\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrSecondlyByHourAndMinute(self):\n        self._rrulestr_reverse_test(rrule(SECONDLY,\n                              count=3,\n                              byhour=(6, 18),\n                              byminute=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrSecondlyByHourAndSecond(self):\n        self._rrulestr_reverse_test(rrule(SECONDLY,\n                              count=3,\n                              byhour=(6, 18),\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrSecondlyByMinuteAndSecond(self):\n        self._rrulestr_reverse_test(rrule(SECONDLY,\n                              count=3,\n                              byminute=(6, 18),\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrSecondlyByHourAndMinuteAndSecond(self):\n        self._rrulestr_reverse_test(rrule(SECONDLY,\n                              count=3,\n                              byhour=(6, 18),\n                              byminute=(6, 18),\n                              bysecond=(6, 18),\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrSecondlyByHourAndMinuteAndSecondBug(self):\n        # This explores a bug found by Mathieu Bridon.\n        self._rrulestr_reverse_test(rrule(SECONDLY,\n                              count=3,\n                              bysecond=(0,),\n                              byminute=(1,),\n                              dtstart=datetime(2010, 3, 22, 12, 1)))\n\n    def testToStrWithWkSt(self):\n        self._rrulestr_reverse_test(rrule(WEEKLY,\n                              count=3,\n                              wkst=SU,\n                              dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testToStrLongIntegers(self):\n        if PY2:  # There are no longs in python3\n            self._rrulestr_reverse_test(rrule(MINUTELY,\n                                  count=long(2),\n                                  interval=long(2),\n                                  bymonth=long(2),\n                                  byweekday=long(3),\n                                  byhour=long(6),\n                                  byminute=long(6),\n                                  bysecond=long(6),\n                                  dtstart=datetime(1997, 9, 2, 9, 0)))\n\n            self._rrulestr_reverse_test(rrule(YEARLY,\n                                  count=long(2),\n                                  bymonthday=long(5),\n                                  byweekno=long(2),\n                                  dtstart=datetime(1997, 9, 2, 9, 0)))\n\n    def testReplaceIfSet(self):\n        rr = rrule(YEARLY,\n                   count=1,\n                   bymonthday=5,\n                   dtstart=datetime(1997, 1, 1))\n        newrr = rr.replace(bymonthday=6)\n        self.assertEqual(list(rr), [datetime(1997, 1, 5)])\n        self.assertEqual(list(newrr),\n                             [datetime(1997, 1, 6)])\n\n    def testReplaceIfNotSet(self):\n        rr = rrule(YEARLY,\n           count=1,\n           dtstart=datetime(1997, 1, 1))\n        newrr = rr.replace(bymonthday=6)\n        self.assertEqual(list(rr), [datetime(1997, 1, 1)])\n        self.assertEqual(list(newrr),\n                             [datetime(1997, 1, 6)])\n\n\n@pytest.mark.rrule\n@freeze_time(datetime(2018, 3, 6, 5, 36, tzinfo=tz.UTC))\ndef test_generated_aware_dtstart():\n    dtstart_exp = datetime(2018, 3, 6, 5, 36, tzinfo=tz.UTC)\n    UNTIL = datetime(2018, 3, 6, 8, 0, tzinfo=tz.UTC)\n\n    rule_without_dtstart = rrule(freq=HOURLY, until=UNTIL)\n    rule_with_dtstart = rrule(freq=HOURLY, dtstart=dtstart_exp, until=UNTIL)\n    assert list(rule_without_dtstart) == list(rule_with_dtstart)\n\n\n@pytest.mark.rrule\n@pytest.mark.rrulestr\n@pytest.mark.xfail(reason=\"rrulestr loses time zone, gh issue #637\")\n@freeze_time(datetime(2018, 3, 6, 5, 36, tzinfo=tz.UTC))\ndef test_generated_aware_dtstart_rrulestr():\n    rrule_without_dtstart = rrule(freq=HOURLY,\n                                  until=datetime(2018, 3, 6, 8, 0,\n                                                 tzinfo=tz.UTC))\n    rrule_r = rrulestr(str(rrule_without_dtstart))\n\n    assert list(rrule_r) == list(rrule_without_dtstart)\n\n\n@pytest.mark.rruleset\nclass RRuleSetTest(unittest.TestCase):\n    def testSet(self):\n        rrset = rruleset()\n        rrset.rrule(rrule(YEARLY, count=2, byweekday=TU,\n                          dtstart=datetime(1997, 9, 2, 9, 0)))\n        rrset.rrule(rrule(YEARLY, count=1, byweekday=TH,\n                          dtstart=datetime(1997, 9, 2, 9, 0)))\n        self.assertEqual(list(rrset),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1997, 9, 4, 9, 0),\n                          datetime(1997, 9, 9, 9, 0)])\n\n    def testSetDate(self):\n        rrset = rruleset()\n        rrset.rrule(rrule(YEARLY, count=1, byweekday=TU,\n                          dtstart=datetime(1997, 9, 2, 9, 0)))\n        rrset.rdate(datetime(1997, 9, 4, 9))\n        rrset.rdate(datetime(1997, 9, 9, 9))\n        self.assertEqual(list(rrset),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1997, 9, 4, 9, 0),\n                          datetime(1997, 9, 9, 9, 0)])\n\n    def testSetExRule(self):\n        rrset = rruleset()\n        rrset.rrule(rrule(YEARLY, count=6, byweekday=(TU, TH),\n                          dtstart=datetime(1997, 9, 2, 9, 0)))\n        rrset.exrule(rrule(YEARLY, count=3, byweekday=TH,\n                          dtstart=datetime(1997, 9, 2, 9, 0)))\n        self.assertEqual(list(rrset),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1997, 9, 9, 9, 0),\n                          datetime(1997, 9, 16, 9, 0)])\n\n    def testSetExDate(self):\n        rrset = rruleset()\n        rrset.rrule(rrule(YEARLY, count=6, byweekday=(TU, TH),\n                          dtstart=datetime(1997, 9, 2, 9, 0)))\n        rrset.exdate(datetime(1997, 9, 4, 9))\n        rrset.exdate(datetime(1997, 9, 11, 9))\n        rrset.exdate(datetime(1997, 9, 18, 9))\n        self.assertEqual(list(rrset),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1997, 9, 9, 9, 0),\n                          datetime(1997, 9, 16, 9, 0)])\n\n    def testSetExDateRevOrder(self):\n        rrset = rruleset()\n        rrset.rrule(rrule(MONTHLY, count=5, bymonthday=10,\n                          dtstart=datetime(2004, 1, 1, 9, 0)))\n        rrset.exdate(datetime(2004, 4, 10, 9, 0))\n        rrset.exdate(datetime(2004, 2, 10, 9, 0))\n        self.assertEqual(list(rrset),\n                         [datetime(2004, 1, 10, 9, 0),\n                          datetime(2004, 3, 10, 9, 0),\n                          datetime(2004, 5, 10, 9, 0)])\n\n    def testSetDateAndExDate(self):\n        rrset = rruleset()\n        rrset.rdate(datetime(1997, 9, 2, 9))\n        rrset.rdate(datetime(1997, 9, 4, 9))\n        rrset.rdate(datetime(1997, 9, 9, 9))\n        rrset.rdate(datetime(1997, 9, 11, 9))\n        rrset.rdate(datetime(1997, 9, 16, 9))\n        rrset.rdate(datetime(1997, 9, 18, 9))\n        rrset.exdate(datetime(1997, 9, 4, 9))\n        rrset.exdate(datetime(1997, 9, 11, 9))\n        rrset.exdate(datetime(1997, 9, 18, 9))\n        self.assertEqual(list(rrset),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1997, 9, 9, 9, 0),\n                          datetime(1997, 9, 16, 9, 0)])\n\n    def testSetDateAndExRule(self):\n        rrset = rruleset()\n        rrset.rdate(datetime(1997, 9, 2, 9))\n        rrset.rdate(datetime(1997, 9, 4, 9))\n        rrset.rdate(datetime(1997, 9, 9, 9))\n        rrset.rdate(datetime(1997, 9, 11, 9))\n        rrset.rdate(datetime(1997, 9, 16, 9))\n        rrset.rdate(datetime(1997, 9, 18, 9))\n        rrset.exrule(rrule(YEARLY, count=3, byweekday=TH,\n                           dtstart=datetime(1997, 9, 2, 9, 0)))\n        self.assertEqual(list(rrset),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1997, 9, 9, 9, 0),\n                          datetime(1997, 9, 16, 9, 0)])\n\n    def testSetCount(self):\n        rrset = rruleset()\n        rrset.rrule(rrule(YEARLY, count=6, byweekday=(TU, TH),\n                          dtstart=datetime(1997, 9, 2, 9, 0)))\n        rrset.exrule(rrule(YEARLY, count=3, byweekday=TH,\n                           dtstart=datetime(1997, 9, 2, 9, 0)))\n        self.assertEqual(rrset.count(), 3)\n\n    def testSetCachePre(self):\n        rrset = rruleset()\n        rrset.rrule(rrule(YEARLY, count=2, byweekday=TU,\n                          dtstart=datetime(1997, 9, 2, 9, 0)))\n        rrset.rrule(rrule(YEARLY, count=1, byweekday=TH,\n                          dtstart=datetime(1997, 9, 2, 9, 0)))\n        self.assertEqual(list(rrset),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1997, 9, 4, 9, 0),\n                          datetime(1997, 9, 9, 9, 0)])\n\n    def testSetCachePost(self):\n        rrset = rruleset(cache=True)\n        rrset.rrule(rrule(YEARLY, count=2, byweekday=TU,\n                          dtstart=datetime(1997, 9, 2, 9, 0)))\n        rrset.rrule(rrule(YEARLY, count=1, byweekday=TH,\n                          dtstart=datetime(1997, 9, 2, 9, 0)))\n        for x in rrset: pass\n        self.assertEqual(list(rrset),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1997, 9, 4, 9, 0),\n                          datetime(1997, 9, 9, 9, 0)])\n\n    def testSetCachePostInternal(self):\n        rrset = rruleset(cache=True)\n        rrset.rrule(rrule(YEARLY, count=2, byweekday=TU,\n                          dtstart=datetime(1997, 9, 2, 9, 0)))\n        rrset.rrule(rrule(YEARLY, count=1, byweekday=TH,\n                          dtstart=datetime(1997, 9, 2, 9, 0)))\n        for x in rrset: pass\n        self.assertEqual(list(rrset._cache),\n                         [datetime(1997, 9, 2, 9, 0),\n                          datetime(1997, 9, 4, 9, 0),\n                          datetime(1997, 9, 9, 9, 0)])\n\n    def testSetRRuleCount(self):\n        # Test that the count is updated when an rrule is added\n        rrset = rruleset(cache=False)\n        for cache in (True, False):\n            rrset = rruleset(cache=cache)\n            rrset.rrule(rrule(YEARLY, count=2, byweekday=TH,\n                              dtstart=datetime(1983, 4, 1)))\n            rrset.rrule(rrule(WEEKLY, count=4, byweekday=FR,\n                              dtstart=datetime(1991, 6, 3)))\n\n            # Check the length twice - first one sets a cache, second reads it\n            self.assertEqual(rrset.count(), 6)\n            self.assertEqual(rrset.count(), 6)\n\n            # This should invalidate the cache and force an update\n            rrset.rrule(rrule(MONTHLY, count=3, dtstart=datetime(1994, 1, 3)))\n\n            self.assertEqual(rrset.count(), 9)\n            self.assertEqual(rrset.count(), 9)\n\n    def testSetRDateCount(self):\n        # Test that the count is updated when an rdate is added\n        rrset = rruleset(cache=False)\n        for cache in (True, False):\n            rrset = rruleset(cache=cache)\n            rrset.rrule(rrule(YEARLY, count=2, byweekday=TH,\n                              dtstart=datetime(1983, 4, 1)))\n            rrset.rrule(rrule(WEEKLY, count=4, byweekday=FR,\n                              dtstart=datetime(1991, 6, 3)))\n\n            # Check the length twice - first one sets a cache, second reads it\n            self.assertEqual(rrset.count(), 6)\n            self.assertEqual(rrset.count(), 6)\n\n            # This should invalidate the cache and force an update\n            rrset.rdate(datetime(1993, 2, 14))\n\n            self.assertEqual(rrset.count(), 7)\n            self.assertEqual(rrset.count(), 7)\n\n    def testSetExRuleCount(self):\n        # Test that the count is updated when an exrule is added\n        rrset = rruleset(cache=False)\n        for cache in (True, False):\n            rrset = rruleset(cache=cache)\n            rrset.rrule(rrule(YEARLY, count=2, byweekday=TH,\n                              dtstart=datetime(1983, 4, 1)))\n            rrset.rrule(rrule(WEEKLY, count=4, byweekday=FR,\n                              dtstart=datetime(1991, 6, 3)))\n\n            # Check the length twice - first one sets a cache, second reads it\n            self.assertEqual(rrset.count(), 6)\n            self.assertEqual(rrset.count(), 6)\n\n            # This should invalidate the cache and force an update\n            rrset.exrule(rrule(WEEKLY, count=2, interval=2,\n                               dtstart=datetime(1991, 6, 14)))\n\n            self.assertEqual(rrset.count(), 4)\n            self.assertEqual(rrset.count(), 4)\n\n    def testSetExDateCount(self):\n        # Test that the count is updated when an rdate is added\n        for cache in (True, False):\n            rrset = rruleset(cache=cache)\n            rrset.rrule(rrule(YEARLY, count=2, byweekday=TH,\n                              dtstart=datetime(1983, 4, 1)))\n            rrset.rrule(rrule(WEEKLY, count=4, byweekday=FR,\n                              dtstart=datetime(1991, 6, 3)))\n\n            # Check the length twice - first one sets a cache, second reads it\n            self.assertEqual(rrset.count(), 6)\n            self.assertEqual(rrset.count(), 6)\n\n            # This should invalidate the cache and force an update\n            rrset.exdate(datetime(1991, 6, 28))\n\n            self.assertEqual(rrset.count(), 5)\n            self.assertEqual(rrset.count(), 5)\n\n\nclass WeekdayTest(unittest.TestCase):\n    def testInvalidNthWeekday(self):\n        with self.assertRaises(ValueError):\n            FR(0)\n\n    def testWeekdayCallable(self):\n        # Calling a weekday instance generates a new weekday instance with the\n        # value of n changed.\n        from dateutil.rrule import weekday\n        self.assertEqual(MO(1), weekday(0, 1))\n\n        # Calling a weekday instance with the identical n returns the original\n        # object\n        FR_3 = weekday(4, 3)\n        self.assertIs(FR_3(3), FR_3)\n\n    def testWeekdayEquality(self):\n        # Two weekday objects are not equal if they have different values for n\n        self.assertNotEqual(TH, TH(-1))\n        self.assertNotEqual(SA(3), SA(2))\n\n    def testWeekdayEqualitySubclass(self):\n        # Two weekday objects equal if their \"weekday\" and \"n\" attributes are\n        # available and the same\n        class BasicWeekday(object):\n            def __init__(self, weekday):\n                self.weekday = weekday\n\n        class BasicNWeekday(BasicWeekday):\n            def __init__(self, weekday, n=None):\n                super(BasicNWeekday, self).__init__(weekday)\n                self.n = n\n\n        MO_Basic = BasicWeekday(0)\n\n        self.assertNotEqual(MO, MO_Basic)\n        self.assertNotEqual(MO(1), MO_Basic)\n\n        TU_BasicN = BasicNWeekday(1)\n\n        self.assertEqual(TU, TU_BasicN)\n        self.assertNotEqual(TU(3), TU_BasicN)\n\n        WE_Basic3 = BasicNWeekday(2, 3)\n        self.assertEqual(WE(3), WE_Basic3)\n        self.assertNotEqual(WE(2), WE_Basic3)\n\n    def testWeekdayReprNoN(self):\n        no_n_reprs = ('MO', 'TU', 'WE', 'TH', 'FR', 'SA', 'SU')\n        no_n_wdays = (MO, TU, WE, TH, FR, SA, SU)\n\n        for repstr, wday in zip(no_n_reprs, no_n_wdays):\n            self.assertEqual(repr(wday), repstr)\n\n    def testWeekdayReprWithN(self):\n        with_n_reprs = ('WE(+1)', 'TH(-2)', 'SU(+3)')\n        with_n_wdays = (WE(1), TH(-2), SU(+3))\n\n        for repstr, wday in zip(with_n_reprs, with_n_wdays):\n            self.assertEqual(repr(wday), repstr)\n", "tests/test_utils.py": "# -*- coding: utf-8 -*-\nfrom __future__ import unicode_literals\nfrom datetime import timedelta, datetime\n\nfrom dateutil import tz\nfrom dateutil import utils\nfrom dateutil.tz import UTC\nfrom dateutil.utils import within_delta\n\nfrom freezegun import freeze_time\n\nNYC = tz.gettz(\"America/New_York\")\n\n\n@freeze_time(datetime(2014, 12, 15, 1, 21, 33, 4003))\ndef test_utils_today():\n    assert utils.today() == datetime(2014, 12, 15, 0, 0, 0)\n\n\n@freeze_time(datetime(2014, 12, 15, 12), tz_offset=5)\ndef test_utils_today_tz_info():\n    assert utils.today(NYC) == datetime(2014, 12, 15, 0, 0, 0, tzinfo=NYC)\n\n\n@freeze_time(datetime(2014, 12, 15, 23), tz_offset=5)\ndef test_utils_today_tz_info_different_day():\n    assert utils.today(UTC) == datetime(2014, 12, 16, 0, 0, 0, tzinfo=UTC)\n\n\ndef test_utils_default_tz_info_naive():\n    dt = datetime(2014, 9, 14, 9, 30)\n    assert utils.default_tzinfo(dt, NYC).tzinfo is NYC\n\n\ndef test_utils_default_tz_info_aware():\n    dt = datetime(2014, 9, 14, 9, 30, tzinfo=UTC)\n    assert utils.default_tzinfo(dt, NYC).tzinfo is UTC\n\n\ndef test_utils_within_delta():\n    d1 = datetime(2016, 1, 1, 12, 14, 1, 9)\n    d2 = d1.replace(microsecond=15)\n\n    assert within_delta(d1, d2, timedelta(seconds=1))\n    assert not within_delta(d1, d2, timedelta(microseconds=1))\n\n\ndef test_utils_within_delta_with_negative_delta():\n    d1 = datetime(2016, 1, 1)\n    d2 = datetime(2015, 12, 31)\n\n    assert within_delta(d2, d1, timedelta(days=-1))\n", "tests/property/test_parser_prop.py": "from hypothesis.strategies import integers\nfrom hypothesis import given\n\nimport pytest\n\nfrom dateutil.parser import parserinfo\n\n\n@pytest.mark.parserinfo\n@given(integers(min_value=100, max_value=9999))\ndef test_convertyear(n):\n    assert n == parserinfo().convertyear(n)\n\n\n@pytest.mark.parserinfo\n@given(integers(min_value=-50,\n                max_value=49))\ndef test_convertyear_no_specified_century(n):\n    p = parserinfo()\n    new_year = p._year + n\n    result = p.convertyear(new_year % 100, century_specified=False)\n    assert result == new_year\n", "tests/property/test_isoparse_prop.py": "from hypothesis import given, assume\nfrom hypothesis import strategies as st\n\nfrom dateutil import tz\nfrom dateutil.parser import isoparse\n\nimport pytest\n\n# Strategies\nTIME_ZONE_STRATEGY = st.sampled_from([None, tz.UTC] +\n    [tz.gettz(zname) for zname in ('US/Eastern', 'US/Pacific',\n                                   'Australia/Sydney', 'Europe/London')])\nASCII_STRATEGY = st.characters(max_codepoint=127)\n\n\n@pytest.mark.isoparser\n@given(dt=st.datetimes(timezones=TIME_ZONE_STRATEGY), sep=ASCII_STRATEGY)\ndef test_timespec_auto(dt, sep):\n    if dt.tzinfo is not None:\n        # Assume offset has no sub-second components\n        assume(dt.utcoffset().total_seconds() % 60 == 0)\n\n    sep = str(sep)          # Python 2.7 requires bytes\n    dtstr = dt.isoformat(sep=sep)\n    dt_rt = isoparse(dtstr)\n\n    assert dt_rt == dt\n", "tests/property/test_tz_prop.py": "from datetime import datetime, timedelta\n\nimport pytest\nimport six\nfrom hypothesis import assume, given\nfrom hypothesis import strategies as st\n\nfrom dateutil import tz as tz\n\nEPOCHALYPSE = datetime.fromtimestamp(2147483647)\nNEGATIVE_EPOCHALYPSE = datetime.fromtimestamp(0) - timedelta(seconds=2147483648)\n\n\n@pytest.mark.gettz\n@pytest.mark.parametrize(\"gettz_arg\", [None, \"\"])\n# TODO: Remove bounds when GH #590 is resolved\n@given(\n    dt=st.datetimes(\n        min_value=NEGATIVE_EPOCHALYPSE, max_value=EPOCHALYPSE, timezones=st.just(tz.UTC),\n    )\n)\ndef test_gettz_returns_local(gettz_arg, dt):\n    act_tz = tz.gettz(gettz_arg)\n    if isinstance(act_tz, tz.tzlocal):\n        return\n\n    dt_act = dt.astimezone(tz.gettz(gettz_arg))\n    if six.PY2:\n        dt_exp = dt.astimezone(tz.tzlocal())\n    else:\n        dt_exp = dt.astimezone()\n\n    assert dt_act == dt_exp\n    assert dt_act.tzname() == dt_exp.tzname()\n    assert dt_act.utcoffset() == dt_exp.utcoffset()\n", "ci_tools/make_zonefile_metadata.py": "#!/usr/bin/env python3\n\nimport hashlib\n\nZONEFILE_METADATA_TEMPLATE = \"\"\"{{\n    \"metadata_version\": 2.0,\n    \"releases_url\": [],\n    \"tzdata_file\": \"{tzdata_file}\",\n    \"tzdata_file_sha512\": \"{tzdata_sha512}\",\n    \"tzversion\": \"{tzdata_version}\",\n    \"zonegroups\": [\n        \"africa\",\n        \"antarctica\",\n        \"asia\",\n        \"australasia\",\n        \"europe\",\n        \"northamerica\",\n        \"southamerica\",\n        \"etcetera\",\n        \"factory\",\n        \"backzone\",\n        \"backward\"\n    ]\n}}\n\"\"\"\n\n\ndef calculate_sha512(fpath):\n    with open(fpath, 'rb') as f:\n        sha_hasher = hashlib.sha512()\n        sha_hasher.update(f.read())\n        return sha_hasher.hexdigest()\n\n\nif __name__ == \"__main__\":\n    import argparse\n    parser = argparse.ArgumentParser()\n\n    parser.add_argument('tzdata', metavar='TZDATA',\n                        help='The name tzdata tarball file')\n    parser.add_argument('version', metavar='VERSION',\n                        help='The version of the tzdata tarball')\n    parser.add_argument('out', metavar='OUT', nargs='?',\n                        default='zonefile_metadata.json',\n                        help='Where to write the file')\n\n    args = parser.parse_args()\n\n    tzdata = args.tzdata\n    version = args.version\n    sha512 = calculate_sha512(tzdata)\n\n    metadata_file_text = ZONEFILE_METADATA_TEMPLATE.format(\n        tzdata_file=tzdata,\n        tzdata_version=version,\n        tzdata_sha512=sha512,\n    )\n\n    with open(args.out, 'w') as f:\n        f.write(metadata_file_text)\n\n", "src/dateutil/relativedelta.py": "# -*- coding: utf-8 -*-\nimport datetime\nimport calendar\n\nimport operator\nfrom math import copysign\n\nfrom six import integer_types\nfrom warnings import warn\n\nfrom ._common import weekday\n\nMO, TU, WE, TH, FR, SA, SU = weekdays = tuple(weekday(x) for x in range(7))\n\n__all__ = [\"relativedelta\", \"MO\", \"TU\", \"WE\", \"TH\", \"FR\", \"SA\", \"SU\"]\n\n\nclass relativedelta(object):\n    \"\"\"\n    The relativedelta type is designed to be applied to an existing datetime and\n    can replace specific components of that datetime, or represents an interval\n    of time.\n\n    It is based on the specification of the excellent work done by M.-A. Lemburg\n    in his\n    `mx.DateTime <https://www.egenix.com/products/python/mxBase/mxDateTime/>`_ extension.\n    However, notice that this type does *NOT* implement the same algorithm as\n    his work. Do *NOT* expect it to behave like mx.DateTime's counterpart.\n\n    There are two different ways to build a relativedelta instance. The\n    first one is passing it two date/datetime classes::\n\n        relativedelta(datetime1, datetime2)\n\n    The second one is passing it any number of the following keyword arguments::\n\n        relativedelta(arg1=x,arg2=y,arg3=z...)\n\n        year, month, day, hour, minute, second, microsecond:\n            Absolute information (argument is singular); adding or subtracting a\n            relativedelta with absolute information does not perform an arithmetic\n            operation, but rather REPLACES the corresponding value in the\n            original datetime with the value(s) in relativedelta.\n\n        years, months, weeks, days, hours, minutes, seconds, microseconds:\n            Relative information, may be negative (argument is plural); adding\n            or subtracting a relativedelta with relative information performs\n            the corresponding arithmetic operation on the original datetime value\n            with the information in the relativedelta.\n\n        weekday:\n            One of the weekday instances (MO, TU, etc) available in the\n            relativedelta module. These instances may receive a parameter N,\n            specifying the Nth weekday, which could be positive or negative\n            (like MO(+1) or MO(-2)). Not specifying it is the same as specifying\n            +1. You can also use an integer, where 0=MO. This argument is always\n            relative e.g. if the calculated date is already Monday, using MO(1)\n            or MO(-1) won't change the day. To effectively make it absolute, use\n            it in combination with the day argument (e.g. day=1, MO(1) for first\n            Monday of the month).\n\n        leapdays:\n            Will add given days to the date found, if year is a leap\n            year, and the date found is post 28 of february.\n\n        yearday, nlyearday:\n            Set the yearday or the non-leap year day (jump leap days).\n            These are converted to day/month/leapdays information.\n\n    There are relative and absolute forms of the keyword\n    arguments. The plural is relative, and the singular is\n    absolute. For each argument in the order below, the absolute form\n    is applied first (by setting each attribute to that value) and\n    then the relative form (by adding the value to the attribute).\n\n    The order of attributes considered when this relativedelta is\n    added to a datetime is:\n\n    1. Year\n    2. Month\n    3. Day\n    4. Hours\n    5. Minutes\n    6. Seconds\n    7. Microseconds\n\n    Finally, weekday is applied, using the rule described above.\n\n    For example\n\n    >>> from datetime import datetime\n    >>> from dateutil.relativedelta import relativedelta, MO\n    >>> dt = datetime(2018, 4, 9, 13, 37, 0)\n    >>> delta = relativedelta(hours=25, day=1, weekday=MO(1))\n    >>> dt + delta\n    datetime.datetime(2018, 4, 2, 14, 37)\n\n    First, the day is set to 1 (the first of the month), then 25 hours\n    are added, to get to the 2nd day and 14th hour, finally the\n    weekday is applied, but since the 2nd is already a Monday there is\n    no effect.\n\n    \"\"\"\n\n    def __init__(self, dt1=None, dt2=None,\n                 years=0, months=0, days=0, leapdays=0, weeks=0,\n                 hours=0, minutes=0, seconds=0, microseconds=0,\n                 year=None, month=None, day=None, weekday=None,\n                 yearday=None, nlyearday=None,\n                 hour=None, minute=None, second=None, microsecond=None):\n\n        if dt1 and dt2:\n            # datetime is a subclass of date. So both must be date\n            if not (isinstance(dt1, datetime.date) and\n                    isinstance(dt2, datetime.date)):\n                raise TypeError(\"relativedelta only diffs datetime/date\")\n\n            # We allow two dates, or two datetimes, so we coerce them to be\n            # of the same type\n            if (isinstance(dt1, datetime.datetime) !=\n                    isinstance(dt2, datetime.datetime)):\n                if not isinstance(dt1, datetime.datetime):\n                    dt1 = datetime.datetime.fromordinal(dt1.toordinal())\n                elif not isinstance(dt2, datetime.datetime):\n                    dt2 = datetime.datetime.fromordinal(dt2.toordinal())\n\n            self.years = 0\n            self.months = 0\n            self.days = 0\n            self.leapdays = 0\n            self.hours = 0\n            self.minutes = 0\n            self.seconds = 0\n            self.microseconds = 0\n            self.year = None\n            self.month = None\n            self.day = None\n            self.weekday = None\n            self.hour = None\n            self.minute = None\n            self.second = None\n            self.microsecond = None\n            self._has_time = 0\n\n            # Get year / month delta between the two\n            months = (dt1.year - dt2.year) * 12 + (dt1.month - dt2.month)\n            self._set_months(months)\n\n            # Remove the year/month delta so the timedelta is just well-defined\n            # time units (seconds, days and microseconds)\n            dtm = self.__radd__(dt2)\n\n            # If we've overshot our target, make an adjustment\n            if dt1 < dt2:\n                compare = operator.gt\n                increment = 1\n            else:\n                compare = operator.lt\n                increment = -1\n\n            while compare(dt1, dtm):\n                months += increment\n                self._set_months(months)\n                dtm = self.__radd__(dt2)\n\n            # Get the timedelta between the \"months-adjusted\" date and dt1\n            delta = dt1 - dtm\n            self.seconds = delta.seconds + delta.days * 86400\n            self.microseconds = delta.microseconds\n        else:\n            # Check for non-integer values in integer-only quantities\n            if any(x is not None and x != int(x) for x in (years, months)):\n                raise ValueError(\"Non-integer years and months are \"\n                                 \"ambiguous and not currently supported.\")\n\n            # Relative information\n            self.years = int(years)\n            self.months = int(months)\n            self.days = days + weeks * 7\n            self.leapdays = leapdays\n            self.hours = hours\n            self.minutes = minutes\n            self.seconds = seconds\n            self.microseconds = microseconds\n\n            # Absolute information\n            self.year = year\n            self.month = month\n            self.day = day\n            self.hour = hour\n            self.minute = minute\n            self.second = second\n            self.microsecond = microsecond\n\n            if any(x is not None and int(x) != x\n                   for x in (year, month, day, hour,\n                             minute, second, microsecond)):\n                # For now we'll deprecate floats - later it'll be an error.\n                warn(\"Non-integer value passed as absolute information. \" +\n                     \"This is not a well-defined condition and will raise \" +\n                     \"errors in future versions.\", DeprecationWarning)\n\n            if isinstance(weekday, integer_types):\n                self.weekday = weekdays[weekday]\n            else:\n                self.weekday = weekday\n\n            yday = 0\n            if nlyearday:\n                yday = nlyearday\n            elif yearday:\n                yday = yearday\n                if yearday > 59:\n                    self.leapdays = -1\n            if yday:\n                ydayidx = [31, 59, 90, 120, 151, 181, 212,\n                           243, 273, 304, 334, 366]\n                for idx, ydays in enumerate(ydayidx):\n                    if yday <= ydays:\n                        self.month = idx+1\n                        if idx == 0:\n                            self.day = yday\n                        else:\n                            self.day = yday-ydayidx[idx-1]\n                        break\n                else:\n                    raise ValueError(\"invalid year day (%d)\" % yday)\n\n        self._fix()\n\n    def _fix(self):\n        if abs(self.microseconds) > 999999:\n            s = _sign(self.microseconds)\n            div, mod = divmod(self.microseconds * s, 1000000)\n            self.microseconds = mod * s\n            self.seconds += div * s\n        if abs(self.seconds) > 59:\n            s = _sign(self.seconds)\n            div, mod = divmod(self.seconds * s, 60)\n            self.seconds = mod * s\n            self.minutes += div * s\n        if abs(self.minutes) > 59:\n            s = _sign(self.minutes)\n            div, mod = divmod(self.minutes * s, 60)\n            self.minutes = mod * s\n            self.hours += div * s\n        if abs(self.hours) > 23:\n            s = _sign(self.hours)\n            div, mod = divmod(self.hours * s, 24)\n            self.hours = mod * s\n            self.days += div * s\n        if abs(self.months) > 11:\n            s = _sign(self.months)\n            div, mod = divmod(self.months * s, 12)\n            self.months = mod * s\n            self.years += div * s\n        if (self.hours or self.minutes or self.seconds or self.microseconds\n                or self.hour is not None or self.minute is not None or\n                self.second is not None or self.microsecond is not None):\n            self._has_time = 1\n        else:\n            self._has_time = 0\n\n    @property\n    def weeks(self):\n        return int(self.days / 7.0)\n\n    @weeks.setter\n    def weeks(self, value):\n        self.days = self.days - (self.weeks * 7) + value * 7\n\n    def _set_months(self, months):\n        self.months = months\n        if abs(self.months) > 11:\n            s = _sign(self.months)\n            div, mod = divmod(self.months * s, 12)\n            self.months = mod * s\n            self.years = div * s\n        else:\n            self.years = 0\n\n    def normalized(self):\n        \"\"\"\n        Return a version of this object represented entirely using integer\n        values for the relative attributes.\n\n        >>> relativedelta(days=1.5, hours=2).normalized()\n        relativedelta(days=+1, hours=+14)\n\n        :return:\n            Returns a :class:`dateutil.relativedelta.relativedelta` object.\n        \"\"\"\n        # Cascade remainders down (rounding each to roughly nearest microsecond)\n        days = int(self.days)\n\n        hours_f = round(self.hours + 24 * (self.days - days), 11)\n        hours = int(hours_f)\n\n        minutes_f = round(self.minutes + 60 * (hours_f - hours), 10)\n        minutes = int(minutes_f)\n\n        seconds_f = round(self.seconds + 60 * (minutes_f - minutes), 8)\n        seconds = int(seconds_f)\n\n        microseconds = round(self.microseconds + 1e6 * (seconds_f - seconds))\n\n        # Constructor carries overflow back up with call to _fix()\n        return self.__class__(years=self.years, months=self.months,\n                              days=days, hours=hours, minutes=minutes,\n                              seconds=seconds, microseconds=microseconds,\n                              leapdays=self.leapdays, year=self.year,\n                              month=self.month, day=self.day,\n                              weekday=self.weekday, hour=self.hour,\n                              minute=self.minute, second=self.second,\n                              microsecond=self.microsecond)\n\n    def __add__(self, other):\n        if isinstance(other, relativedelta):\n            return self.__class__(years=other.years + self.years,\n                                 months=other.months + self.months,\n                                 days=other.days + self.days,\n                                 hours=other.hours + self.hours,\n                                 minutes=other.minutes + self.minutes,\n                                 seconds=other.seconds + self.seconds,\n                                 microseconds=(other.microseconds +\n                                               self.microseconds),\n                                 leapdays=other.leapdays or self.leapdays,\n                                 year=(other.year if other.year is not None\n                                       else self.year),\n                                 month=(other.month if other.month is not None\n                                        else self.month),\n                                 day=(other.day if other.day is not None\n                                      else self.day),\n                                 weekday=(other.weekday if other.weekday is not None\n                                          else self.weekday),\n                                 hour=(other.hour if other.hour is not None\n                                       else self.hour),\n                                 minute=(other.minute if other.minute is not None\n                                         else self.minute),\n                                 second=(other.second if other.second is not None\n                                         else self.second),\n                                 microsecond=(other.microsecond if other.microsecond\n                                              is not None else\n                                              self.microsecond))\n        if isinstance(other, datetime.timedelta):\n            return self.__class__(years=self.years,\n                                  months=self.months,\n                                  days=self.days + other.days,\n                                  hours=self.hours,\n                                  minutes=self.minutes,\n                                  seconds=self.seconds + other.seconds,\n                                  microseconds=self.microseconds + other.microseconds,\n                                  leapdays=self.leapdays,\n                                  year=self.year,\n                                  month=self.month,\n                                  day=self.day,\n                                  weekday=self.weekday,\n                                  hour=self.hour,\n                                  minute=self.minute,\n                                  second=self.second,\n                                  microsecond=self.microsecond)\n        if not isinstance(other, datetime.date):\n            return NotImplemented\n        elif self._has_time and not isinstance(other, datetime.datetime):\n            other = datetime.datetime.fromordinal(other.toordinal())\n        year = (self.year or other.year)+self.years\n        month = self.month or other.month\n        if self.months:\n            assert 1 <= abs(self.months) <= 12\n            month += self.months\n            if month > 12:\n                year += 1\n                month -= 12\n            elif month < 1:\n                year -= 1\n                month += 12\n        day = min(calendar.monthrange(year, month)[1],\n                  self.day or other.day)\n        repl = {\"year\": year, \"month\": month, \"day\": day}\n        for attr in [\"hour\", \"minute\", \"second\", \"microsecond\"]:\n            value = getattr(self, attr)\n            if value is not None:\n                repl[attr] = value\n        days = self.days\n        if self.leapdays and month > 2 and calendar.isleap(year):\n            days += self.leapdays\n        ret = (other.replace(**repl)\n               + datetime.timedelta(days=days,\n                                    hours=self.hours,\n                                    minutes=self.minutes,\n                                    seconds=self.seconds,\n                                    microseconds=self.microseconds))\n        if self.weekday:\n            weekday, nth = self.weekday.weekday, self.weekday.n or 1\n            jumpdays = (abs(nth) - 1) * 7\n            if nth > 0:\n                jumpdays += (7 - ret.weekday() + weekday) % 7\n            else:\n                jumpdays += (ret.weekday() - weekday) % 7\n                jumpdays *= -1\n            ret += datetime.timedelta(days=jumpdays)\n        return ret\n\n    def __radd__(self, other):\n        return self.__add__(other)\n\n    def __rsub__(self, other):\n        return self.__neg__().__radd__(other)\n\n    def __sub__(self, other):\n        if not isinstance(other, relativedelta):\n            return NotImplemented   # In case the other object defines __rsub__\n        return self.__class__(years=self.years - other.years,\n                             months=self.months - other.months,\n                             days=self.days - other.days,\n                             hours=self.hours - other.hours,\n                             minutes=self.minutes - other.minutes,\n                             seconds=self.seconds - other.seconds,\n                             microseconds=self.microseconds - other.microseconds,\n                             leapdays=self.leapdays or other.leapdays,\n                             year=(self.year if self.year is not None\n                                   else other.year),\n                             month=(self.month if self.month is not None else\n                                    other.month),\n                             day=(self.day if self.day is not None else\n                                  other.day),\n                             weekday=(self.weekday if self.weekday is not None else\n                                      other.weekday),\n                             hour=(self.hour if self.hour is not None else\n                                   other.hour),\n                             minute=(self.minute if self.minute is not None else\n                                     other.minute),\n                             second=(self.second if self.second is not None else\n                                     other.second),\n                             microsecond=(self.microsecond if self.microsecond\n                                          is not None else\n                                          other.microsecond))\n\n    def __abs__(self):\n        return self.__class__(years=abs(self.years),\n                              months=abs(self.months),\n                              days=abs(self.days),\n                              hours=abs(self.hours),\n                              minutes=abs(self.minutes),\n                              seconds=abs(self.seconds),\n                              microseconds=abs(self.microseconds),\n                              leapdays=self.leapdays,\n                              year=self.year,\n                              month=self.month,\n                              day=self.day,\n                              weekday=self.weekday,\n                              hour=self.hour,\n                              minute=self.minute,\n                              second=self.second,\n                              microsecond=self.microsecond)\n\n    def __neg__(self):\n        return self.__class__(years=-self.years,\n                             months=-self.months,\n                             days=-self.days,\n                             hours=-self.hours,\n                             minutes=-self.minutes,\n                             seconds=-self.seconds,\n                             microseconds=-self.microseconds,\n                             leapdays=self.leapdays,\n                             year=self.year,\n                             month=self.month,\n                             day=self.day,\n                             weekday=self.weekday,\n                             hour=self.hour,\n                             minute=self.minute,\n                             second=self.second,\n                             microsecond=self.microsecond)\n\n    def __bool__(self):\n        return not (not self.years and\n                    not self.months and\n                    not self.days and\n                    not self.hours and\n                    not self.minutes and\n                    not self.seconds and\n                    not self.microseconds and\n                    not self.leapdays and\n                    self.year is None and\n                    self.month is None and\n                    self.day is None and\n                    self.weekday is None and\n                    self.hour is None and\n                    self.minute is None and\n                    self.second is None and\n                    self.microsecond is None)\n    # Compatibility with Python 2.x\n    __nonzero__ = __bool__\n\n    def __mul__(self, other):\n        try:\n            f = float(other)\n        except TypeError:\n            return NotImplemented\n\n        return self.__class__(years=int(self.years * f),\n                             months=int(self.months * f),\n                             days=int(self.days * f),\n                             hours=int(self.hours * f),\n                             minutes=int(self.minutes * f),\n                             seconds=int(self.seconds * f),\n                             microseconds=int(self.microseconds * f),\n                             leapdays=self.leapdays,\n                             year=self.year,\n                             month=self.month,\n                             day=self.day,\n                             weekday=self.weekday,\n                             hour=self.hour,\n                             minute=self.minute,\n                             second=self.second,\n                             microsecond=self.microsecond)\n\n    __rmul__ = __mul__\n\n    def __eq__(self, other):\n        if not isinstance(other, relativedelta):\n            return NotImplemented\n        if self.weekday or other.weekday:\n            if not self.weekday or not other.weekday:\n                return False\n            if self.weekday.weekday != other.weekday.weekday:\n                return False\n            n1, n2 = self.weekday.n, other.weekday.n\n            if n1 != n2 and not ((not n1 or n1 == 1) and (not n2 or n2 == 1)):\n                return False\n        return (self.years == other.years and\n                self.months == other.months and\n                self.days == other.days and\n                self.hours == other.hours and\n                self.minutes == other.minutes and\n                self.seconds == other.seconds and\n                self.microseconds == other.microseconds and\n                self.leapdays == other.leapdays and\n                self.year == other.year and\n                self.month == other.month and\n                self.day == other.day and\n                self.hour == other.hour and\n                self.minute == other.minute and\n                self.second == other.second and\n                self.microsecond == other.microsecond)\n\n    def __hash__(self):\n        return hash((\n            self.weekday,\n            self.years,\n            self.months,\n            self.days,\n            self.hours,\n            self.minutes,\n            self.seconds,\n            self.microseconds,\n            self.leapdays,\n            self.year,\n            self.month,\n            self.day,\n            self.hour,\n            self.minute,\n            self.second,\n            self.microsecond,\n        ))\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __div__(self, other):\n        try:\n            reciprocal = 1 / float(other)\n        except TypeError:\n            return NotImplemented\n\n        return self.__mul__(reciprocal)\n\n    __truediv__ = __div__\n\n    def __repr__(self):\n        l = []\n        for attr in [\"years\", \"months\", \"days\", \"leapdays\",\n                     \"hours\", \"minutes\", \"seconds\", \"microseconds\"]:\n            value = getattr(self, attr)\n            if value:\n                l.append(\"{attr}={value:+g}\".format(attr=attr, value=value))\n        for attr in [\"year\", \"month\", \"day\", \"weekday\",\n                     \"hour\", \"minute\", \"second\", \"microsecond\"]:\n            value = getattr(self, attr)\n            if value is not None:\n                l.append(\"{attr}={value}\".format(attr=attr, value=repr(value)))\n        return \"{classname}({attrs})\".format(classname=self.__class__.__name__,\n                                             attrs=\", \".join(l))\n\n\ndef _sign(x):\n    return int(copysign(1, x))\n\n# vim:ts=4:sw=4:et\n", "src/dateutil/_common.py": "\"\"\"\nCommon code used in multiple modules.\n\"\"\"\n\n\nclass weekday(object):\n    __slots__ = [\"weekday\", \"n\"]\n\n    def __init__(self, weekday, n=None):\n        self.weekday = weekday\n        self.n = n\n\n    def __call__(self, n):\n        if n == self.n:\n            return self\n        else:\n            return self.__class__(self.weekday, n)\n\n    def __eq__(self, other):\n        try:\n            if self.weekday != other.weekday or self.n != other.n:\n                return False\n        except AttributeError:\n            return False\n        return True\n\n    def __hash__(self):\n        return hash((\n          self.weekday,\n          self.n,\n        ))\n\n    def __ne__(self, other):\n        return not (self == other)\n\n    def __repr__(self):\n        s = (\"MO\", \"TU\", \"WE\", \"TH\", \"FR\", \"SA\", \"SU\")[self.weekday]\n        if not self.n:\n            return s\n        else:\n            return \"%s(%+d)\" % (s, self.n)\n\n# vim:ts=4:sw=4:et\n", "src/dateutil/utils.py": "# -*- coding: utf-8 -*-\n\"\"\"\nThis module offers general convenience and utility functions for dealing with\ndatetimes.\n\n.. versionadded:: 2.7.0\n\"\"\"\nfrom __future__ import unicode_literals\n\nfrom datetime import datetime, time\n\n\ndef today(tzinfo=None):\n    \"\"\"\n    Returns a :py:class:`datetime` representing the current day at midnight\n\n    :param tzinfo:\n        The time zone to attach (also used to determine the current day).\n\n    :return:\n        A :py:class:`datetime.datetime` object representing the current day\n        at midnight.\n    \"\"\"\n\n    dt = datetime.now(tzinfo)\n    return datetime.combine(dt.date(), time(0, tzinfo=tzinfo))\n\n\ndef default_tzinfo(dt, tzinfo):\n    \"\"\"\n    Sets the ``tzinfo`` parameter on naive datetimes only\n\n    This is useful for example when you are provided a datetime that may have\n    either an implicit or explicit time zone, such as when parsing a time zone\n    string.\n\n    .. doctest::\n\n        >>> from dateutil.tz import tzoffset\n        >>> from dateutil.parser import parse\n        >>> from dateutil.utils import default_tzinfo\n        >>> dflt_tz = tzoffset(\"EST\", -18000)\n        >>> print(default_tzinfo(parse('2014-01-01 12:30 UTC'), dflt_tz))\n        2014-01-01 12:30:00+00:00\n        >>> print(default_tzinfo(parse('2014-01-01 12:30'), dflt_tz))\n        2014-01-01 12:30:00-05:00\n\n    :param dt:\n        The datetime on which to replace the time zone\n\n    :param tzinfo:\n        The :py:class:`datetime.tzinfo` subclass instance to assign to\n        ``dt`` if (and only if) it is naive.\n\n    :return:\n        Returns an aware :py:class:`datetime.datetime`.\n    \"\"\"\n    if dt.tzinfo is not None:\n        return dt\n    else:\n        return dt.replace(tzinfo=tzinfo)\n\n\ndef within_delta(dt1, dt2, delta):\n    \"\"\"\n    Useful for comparing two datetimes that may have a negligible difference\n    to be considered equal.\n    \"\"\"\n    delta = abs(delta)\n    difference = dt1 - dt2\n    return -delta <= difference <= delta\n", "src/dateutil/tzwin.py": "# tzwin has moved to dateutil.tz.win\nfrom .tz.win import *\n", "src/dateutil/rrule.py": "# -*- coding: utf-8 -*-\n\"\"\"\nThe rrule module offers a small, complete, and very fast, implementation of\nthe recurrence rules documented in the\n`iCalendar RFC <https://tools.ietf.org/html/rfc5545>`_,\nincluding support for caching of results.\n\"\"\"\nimport calendar\nimport datetime\nimport heapq\nimport itertools\nimport re\nimport sys\nfrom functools import wraps\n# For warning about deprecation of until and count\nfrom warnings import warn\n\nfrom six import advance_iterator, integer_types\n\nfrom six.moves import _thread, range\n\nfrom ._common import weekday as weekdaybase\n\ntry:\n    from math import gcd\nexcept ImportError:\n    from fractions import gcd\n\n__all__ = [\"rrule\", \"rruleset\", \"rrulestr\",\n           \"YEARLY\", \"MONTHLY\", \"WEEKLY\", \"DAILY\",\n           \"HOURLY\", \"MINUTELY\", \"SECONDLY\",\n           \"MO\", \"TU\", \"WE\", \"TH\", \"FR\", \"SA\", \"SU\"]\n\n# Every mask is 7 days longer to handle cross-year weekly periods.\nM366MASK = tuple([1]*31+[2]*29+[3]*31+[4]*30+[5]*31+[6]*30 +\n                 [7]*31+[8]*31+[9]*30+[10]*31+[11]*30+[12]*31+[1]*7)\nM365MASK = list(M366MASK)\nM29, M30, M31 = list(range(1, 30)), list(range(1, 31)), list(range(1, 32))\nMDAY366MASK = tuple(M31+M29+M31+M30+M31+M30+M31+M31+M30+M31+M30+M31+M31[:7])\nMDAY365MASK = list(MDAY366MASK)\nM29, M30, M31 = list(range(-29, 0)), list(range(-30, 0)), list(range(-31, 0))\nNMDAY366MASK = tuple(M31+M29+M31+M30+M31+M30+M31+M31+M30+M31+M30+M31+M31[:7])\nNMDAY365MASK = list(NMDAY366MASK)\nM366RANGE = (0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366)\nM365RANGE = (0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365)\nWDAYMASK = [0, 1, 2, 3, 4, 5, 6]*55\ndel M29, M30, M31, M365MASK[59], MDAY365MASK[59], NMDAY365MASK[31]\nMDAY365MASK = tuple(MDAY365MASK)\nM365MASK = tuple(M365MASK)\n\nFREQNAMES = ['YEARLY', 'MONTHLY', 'WEEKLY', 'DAILY', 'HOURLY', 'MINUTELY', 'SECONDLY']\n\n(YEARLY,\n MONTHLY,\n WEEKLY,\n DAILY,\n HOURLY,\n MINUTELY,\n SECONDLY) = list(range(7))\n\n# Imported on demand.\neaster = None\nparser = None\n\n\nclass weekday(weekdaybase):\n    \"\"\"\n    This version of weekday does not allow n = 0.\n    \"\"\"\n    def __init__(self, wkday, n=None):\n        if n == 0:\n            raise ValueError(\"Can't create weekday with n==0\")\n\n        super(weekday, self).__init__(wkday, n)\n\n\nMO, TU, WE, TH, FR, SA, SU = weekdays = tuple(weekday(x) for x in range(7))\n\n\ndef _invalidates_cache(f):\n    \"\"\"\n    Decorator for rruleset methods which may invalidate the\n    cached length.\n    \"\"\"\n    @wraps(f)\n    def inner_func(self, *args, **kwargs):\n        rv = f(self, *args, **kwargs)\n        self._invalidate_cache()\n        return rv\n\n    return inner_func\n\n\nclass rrulebase(object):\n    def __init__(self, cache=False):\n        if cache:\n            self._cache = []\n            self._cache_lock = _thread.allocate_lock()\n            self._invalidate_cache()\n        else:\n            self._cache = None\n            self._cache_complete = False\n            self._len = None\n\n    def __iter__(self):\n        if self._cache_complete:\n            return iter(self._cache)\n        elif self._cache is None:\n            return self._iter()\n        else:\n            return self._iter_cached()\n\n    def _invalidate_cache(self):\n        if self._cache is not None:\n            self._cache = []\n            self._cache_complete = False\n            self._cache_gen = self._iter()\n\n            if self._cache_lock.locked():\n                self._cache_lock.release()\n\n        self._len = None\n\n    def _iter_cached(self):\n        i = 0\n        gen = self._cache_gen\n        cache = self._cache\n        acquire = self._cache_lock.acquire\n        release = self._cache_lock.release\n        while gen:\n            if i == len(cache):\n                acquire()\n                if self._cache_complete:\n                    break\n                try:\n                    for j in range(10):\n                        cache.append(advance_iterator(gen))\n                except StopIteration:\n                    self._cache_gen = gen = None\n                    self._cache_complete = True\n                    break\n                release()\n            yield cache[i]\n            i += 1\n        while i < self._len:\n            yield cache[i]\n            i += 1\n\n    def __getitem__(self, item):\n        if self._cache_complete:\n            return self._cache[item]\n        elif isinstance(item, slice):\n            if item.step and item.step < 0:\n                return list(iter(self))[item]\n            else:\n                return list(itertools.islice(self,\n                                             item.start or 0,\n                                             item.stop or sys.maxsize,\n                                             item.step or 1))\n        elif item >= 0:\n            gen = iter(self)\n            try:\n                for i in range(item+1):\n                    res = advance_iterator(gen)\n            except StopIteration:\n                raise IndexError\n            return res\n        else:\n            return list(iter(self))[item]\n\n    def __contains__(self, item):\n        if self._cache_complete:\n            return item in self._cache\n        else:\n            for i in self:\n                if i == item:\n                    return True\n                elif i > item:\n                    return False\n        return False\n\n    # __len__() introduces a large performance penalty.\n    def count(self):\n        \"\"\" Returns the number of recurrences in this set. It will have go\n            through the whole recurrence, if this hasn't been done before. \"\"\"\n        if self._len is None:\n            for x in self:\n                pass\n        return self._len\n\n    def before(self, dt, inc=False):\n        \"\"\" Returns the last recurrence before the given datetime instance. The\n            inc keyword defines what happens if dt is an occurrence. With\n            inc=True, if dt itself is an occurrence, it will be returned. \"\"\"\n        if self._cache_complete:\n            gen = self._cache\n        else:\n            gen = self\n        last = None\n        if inc:\n            for i in gen:\n                if i > dt:\n                    break\n                last = i\n        else:\n            for i in gen:\n                if i >= dt:\n                    break\n                last = i\n        return last\n\n    def after(self, dt, inc=False):\n        \"\"\" Returns the first recurrence after the given datetime instance. The\n            inc keyword defines what happens if dt is an occurrence. With\n            inc=True, if dt itself is an occurrence, it will be returned.  \"\"\"\n        if self._cache_complete:\n            gen = self._cache\n        else:\n            gen = self\n        if inc:\n            for i in gen:\n                if i >= dt:\n                    return i\n        else:\n            for i in gen:\n                if i > dt:\n                    return i\n        return None\n\n    def xafter(self, dt, count=None, inc=False):\n        \"\"\"\n        Generator which yields up to `count` recurrences after the given\n        datetime instance, equivalent to `after`.\n\n        :param dt:\n            The datetime at which to start generating recurrences.\n\n        :param count:\n            The maximum number of recurrences to generate. If `None` (default),\n            dates are generated until the recurrence rule is exhausted.\n\n        :param inc:\n            If `dt` is an instance of the rule and `inc` is `True`, it is\n            included in the output.\n\n        :yields: Yields a sequence of `datetime` objects.\n        \"\"\"\n\n        if self._cache_complete:\n            gen = self._cache\n        else:\n            gen = self\n\n        # Select the comparison function\n        if inc:\n            comp = lambda dc, dtc: dc >= dtc\n        else:\n            comp = lambda dc, dtc: dc > dtc\n\n        # Generate dates\n        n = 0\n        for d in gen:\n            if comp(d, dt):\n                if count is not None:\n                    n += 1\n                    if n > count:\n                        break\n\n                yield d\n\n    def between(self, after, before, inc=False, count=1):\n        \"\"\" Returns all the occurrences of the rrule between after and before.\n        The inc keyword defines what happens if after and/or before are\n        themselves occurrences. With inc=True, they will be included in the\n        list, if they are found in the recurrence set. \"\"\"\n        if self._cache_complete:\n            gen = self._cache\n        else:\n            gen = self\n        started = False\n        l = []\n        if inc:\n            for i in gen:\n                if i > before:\n                    break\n                elif not started:\n                    if i >= after:\n                        started = True\n                        l.append(i)\n                else:\n                    l.append(i)\n        else:\n            for i in gen:\n                if i >= before:\n                    break\n                elif not started:\n                    if i > after:\n                        started = True\n                        l.append(i)\n                else:\n                    l.append(i)\n        return l\n\n\nclass rrule(rrulebase):\n    \"\"\"\n    That's the base of the rrule operation. It accepts all the keywords\n    defined in the RFC as its constructor parameters (except byday,\n    which was renamed to byweekday) and more. The constructor prototype is::\n\n            rrule(freq)\n\n    Where freq must be one of YEARLY, MONTHLY, WEEKLY, DAILY, HOURLY, MINUTELY,\n    or SECONDLY.\n\n    .. note::\n        Per RFC section 3.3.10, recurrence instances falling on invalid dates\n        and times are ignored rather than coerced:\n\n            Recurrence rules may generate recurrence instances with an invalid\n            date (e.g., February 30) or nonexistent local time (e.g., 1:30 AM\n            on a day where the local time is moved forward by an hour at 1:00\n            AM).  Such recurrence instances MUST be ignored and MUST NOT be\n            counted as part of the recurrence set.\n\n        This can lead to possibly surprising behavior when, for example, the\n        start date occurs at the end of the month:\n\n        >>> from dateutil.rrule import rrule, MONTHLY\n        >>> from datetime import datetime\n        >>> start_date = datetime(2014, 12, 31)\n        >>> list(rrule(freq=MONTHLY, count=4, dtstart=start_date))\n        ... # doctest: +NORMALIZE_WHITESPACE\n        [datetime.datetime(2014, 12, 31, 0, 0),\n         datetime.datetime(2015, 1, 31, 0, 0),\n         datetime.datetime(2015, 3, 31, 0, 0),\n         datetime.datetime(2015, 5, 31, 0, 0)]\n\n    Additionally, it supports the following keyword arguments:\n\n    :param dtstart:\n        The recurrence start. Besides being the base for the recurrence,\n        missing parameters in the final recurrence instances will also be\n        extracted from this date. If not given, datetime.now() will be used\n        instead.\n    :param interval:\n        The interval between each freq iteration. For example, when using\n        YEARLY, an interval of 2 means once every two years, but with HOURLY,\n        it means once every two hours. The default interval is 1.\n    :param wkst:\n        The week start day. Must be one of the MO, TU, WE constants, or an\n        integer, specifying the first day of the week. This will affect\n        recurrences based on weekly periods. The default week start is got\n        from calendar.firstweekday(), and may be modified by\n        calendar.setfirstweekday().\n    :param count:\n        If given, this determines how many occurrences will be generated.\n\n        .. note::\n            As of version 2.5.0, the use of the keyword ``until`` in conjunction\n            with ``count`` is deprecated, to make sure ``dateutil`` is fully\n            compliant with `RFC-5545 Sec. 3.3.10 <https://tools.ietf.org/\n            html/rfc5545#section-3.3.10>`_. Therefore, ``until`` and ``count``\n            **must not** occur in the same call to ``rrule``.\n    :param until:\n        If given, this must be a datetime instance specifying the upper-bound\n        limit of the recurrence. The last recurrence in the rule is the greatest\n        datetime that is less than or equal to the value specified in the\n        ``until`` parameter.\n\n        .. note::\n            As of version 2.5.0, the use of the keyword ``until`` in conjunction\n            with ``count`` is deprecated, to make sure ``dateutil`` is fully\n            compliant with `RFC-5545 Sec. 3.3.10 <https://tools.ietf.org/\n            html/rfc5545#section-3.3.10>`_. Therefore, ``until`` and ``count``\n            **must not** occur in the same call to ``rrule``.\n    :param bysetpos:\n        If given, it must be either an integer, or a sequence of integers,\n        positive or negative. Each given integer will specify an occurrence\n        number, corresponding to the nth occurrence of the rule inside the\n        frequency period. For example, a bysetpos of -1 if combined with a\n        MONTHLY frequency, and a byweekday of (MO, TU, WE, TH, FR), will\n        result in the last work day of every month.\n    :param bymonth:\n        If given, it must be either an integer, or a sequence of integers,\n        meaning the months to apply the recurrence to.\n    :param bymonthday:\n        If given, it must be either an integer, or a sequence of integers,\n        meaning the month days to apply the recurrence to.\n    :param byyearday:\n        If given, it must be either an integer, or a sequence of integers,\n        meaning the year days to apply the recurrence to.\n    :param byeaster:\n        If given, it must be either an integer, or a sequence of integers,\n        positive or negative. Each integer will define an offset from the\n        Easter Sunday. Passing the offset 0 to byeaster will yield the Easter\n        Sunday itself. This is an extension to the RFC specification.\n    :param byweekno:\n        If given, it must be either an integer, or a sequence of integers,\n        meaning the week numbers to apply the recurrence to. Week numbers\n        have the meaning described in ISO8601, that is, the first week of\n        the year is that containing at least four days of the new year.\n    :param byweekday:\n        If given, it must be either an integer (0 == MO), a sequence of\n        integers, one of the weekday constants (MO, TU, etc), or a sequence\n        of these constants. When given, these variables will define the\n        weekdays where the recurrence will be applied. It's also possible to\n        use an argument n for the weekday instances, which will mean the nth\n        occurrence of this weekday in the period. For example, with MONTHLY,\n        or with YEARLY and BYMONTH, using FR(+1) in byweekday will specify the\n        first friday of the month where the recurrence happens. Notice that in\n        the RFC documentation, this is specified as BYDAY, but was renamed to\n        avoid the ambiguity of that keyword.\n    :param byhour:\n        If given, it must be either an integer, or a sequence of integers,\n        meaning the hours to apply the recurrence to.\n    :param byminute:\n        If given, it must be either an integer, or a sequence of integers,\n        meaning the minutes to apply the recurrence to.\n    :param bysecond:\n        If given, it must be either an integer, or a sequence of integers,\n        meaning the seconds to apply the recurrence to.\n    :param cache:\n        If given, it must be a boolean value specifying to enable or disable\n        caching of results. If you will use the same rrule instance multiple\n        times, enabling caching will improve the performance considerably.\n     \"\"\"\n    def __init__(self, freq, dtstart=None,\n                 interval=1, wkst=None, count=None, until=None, bysetpos=None,\n                 bymonth=None, bymonthday=None, byyearday=None, byeaster=None,\n                 byweekno=None, byweekday=None,\n                 byhour=None, byminute=None, bysecond=None,\n                 cache=False):\n        super(rrule, self).__init__(cache)\n        global easter\n        if not dtstart:\n            if until and until.tzinfo:\n                dtstart = datetime.datetime.now(tz=until.tzinfo).replace(microsecond=0)\n            else:\n                dtstart = datetime.datetime.now().replace(microsecond=0)\n        elif not isinstance(dtstart, datetime.datetime):\n            dtstart = datetime.datetime.fromordinal(dtstart.toordinal())\n        else:\n            dtstart = dtstart.replace(microsecond=0)\n        self._dtstart = dtstart\n        self._tzinfo = dtstart.tzinfo\n        self._freq = freq\n        self._interval = interval\n        self._count = count\n\n        # Cache the original byxxx rules, if they are provided, as the _byxxx\n        # attributes do not necessarily map to the inputs, and this can be\n        # a problem in generating the strings. Only store things if they've\n        # been supplied (the string retrieval will just use .get())\n        self._original_rule = {}\n\n        if until and not isinstance(until, datetime.datetime):\n            until = datetime.datetime.fromordinal(until.toordinal())\n        self._until = until\n\n        if self._dtstart and self._until:\n            if (self._dtstart.tzinfo is not None) != (self._until.tzinfo is not None):\n                # According to RFC5545 Section 3.3.10:\n                # https://tools.ietf.org/html/rfc5545#section-3.3.10\n                #\n                # > If the \"DTSTART\" property is specified as a date with UTC\n                # > time or a date with local time and time zone reference,\n                # > then the UNTIL rule part MUST be specified as a date with\n                # > UTC time.\n                raise ValueError(\n                    'RRULE UNTIL values must be specified in UTC when DTSTART '\n                    'is timezone-aware'\n                )\n\n        if count is not None and until:\n            warn(\"Using both 'count' and 'until' is inconsistent with RFC 5545\"\n                 \" and has been deprecated in dateutil. Future versions will \"\n                 \"raise an error.\", DeprecationWarning)\n\n        if wkst is None:\n            self._wkst = calendar.firstweekday()\n        elif isinstance(wkst, integer_types):\n            self._wkst = wkst\n        else:\n            self._wkst = wkst.weekday\n\n        if bysetpos is None:\n            self._bysetpos = None\n        elif isinstance(bysetpos, integer_types):\n            if bysetpos == 0 or not (-366 <= bysetpos <= 366):\n                raise ValueError(\"bysetpos must be between 1 and 366, \"\n                                 \"or between -366 and -1\")\n            self._bysetpos = (bysetpos,)\n        else:\n            self._bysetpos = tuple(bysetpos)\n            for pos in self._bysetpos:\n                if pos == 0 or not (-366 <= pos <= 366):\n                    raise ValueError(\"bysetpos must be between 1 and 366, \"\n                                     \"or between -366 and -1\")\n\n        if self._bysetpos:\n            self._original_rule['bysetpos'] = self._bysetpos\n\n        if (byweekno is None and byyearday is None and bymonthday is None and\n                byweekday is None and byeaster is None):\n            if freq == YEARLY:\n                if bymonth is None:\n                    bymonth = dtstart.month\n                    self._original_rule['bymonth'] = None\n                bymonthday = dtstart.day\n                self._original_rule['bymonthday'] = None\n            elif freq == MONTHLY:\n                bymonthday = dtstart.day\n                self._original_rule['bymonthday'] = None\n            elif freq == WEEKLY:\n                byweekday = dtstart.weekday()\n                self._original_rule['byweekday'] = None\n\n        # bymonth\n        if bymonth is None:\n            self._bymonth = None\n        else:\n            if isinstance(bymonth, integer_types):\n                bymonth = (bymonth,)\n\n            self._bymonth = tuple(sorted(set(bymonth)))\n\n            if 'bymonth' not in self._original_rule:\n                self._original_rule['bymonth'] = self._bymonth\n\n        # byyearday\n        if byyearday is None:\n            self._byyearday = None\n        else:\n            if isinstance(byyearday, integer_types):\n                byyearday = (byyearday,)\n\n            self._byyearday = tuple(sorted(set(byyearday)))\n            self._original_rule['byyearday'] = self._byyearday\n\n        # byeaster\n        if byeaster is not None:\n            if not easter:\n                from dateutil import easter\n            if isinstance(byeaster, integer_types):\n                self._byeaster = (byeaster,)\n            else:\n                self._byeaster = tuple(sorted(byeaster))\n\n            self._original_rule['byeaster'] = self._byeaster\n        else:\n            self._byeaster = None\n\n        # bymonthday\n        if bymonthday is None:\n            self._bymonthday = ()\n            self._bynmonthday = ()\n        else:\n            if isinstance(bymonthday, integer_types):\n                bymonthday = (bymonthday,)\n\n            bymonthday = set(bymonthday)            # Ensure it's unique\n\n            self._bymonthday = tuple(sorted(x for x in bymonthday if x > 0))\n            self._bynmonthday = tuple(sorted(x for x in bymonthday if x < 0))\n\n            # Storing positive numbers first, then negative numbers\n            if 'bymonthday' not in self._original_rule:\n                self._original_rule['bymonthday'] = tuple(\n                    itertools.chain(self._bymonthday, self._bynmonthday))\n\n        # byweekno\n        if byweekno is None:\n            self._byweekno = None\n        else:\n            if isinstance(byweekno, integer_types):\n                byweekno = (byweekno,)\n\n            self._byweekno = tuple(sorted(set(byweekno)))\n\n            self._original_rule['byweekno'] = self._byweekno\n\n        # byweekday / bynweekday\n        if byweekday is None:\n            self._byweekday = None\n            self._bynweekday = None\n        else:\n            # If it's one of the valid non-sequence types, convert to a\n            # single-element sequence before the iterator that builds the\n            # byweekday set.\n            if isinstance(byweekday, integer_types) or hasattr(byweekday, \"n\"):\n                byweekday = (byweekday,)\n\n            self._byweekday = set()\n            self._bynweekday = set()\n            for wday in byweekday:\n                if isinstance(wday, integer_types):\n                    self._byweekday.add(wday)\n                elif not wday.n or freq > MONTHLY:\n                    self._byweekday.add(wday.weekday)\n                else:\n                    self._bynweekday.add((wday.weekday, wday.n))\n\n            if not self._byweekday:\n                self._byweekday = None\n            elif not self._bynweekday:\n                self._bynweekday = None\n\n            if self._byweekday is not None:\n                self._byweekday = tuple(sorted(self._byweekday))\n                orig_byweekday = [weekday(x) for x in self._byweekday]\n            else:\n                orig_byweekday = ()\n\n            if self._bynweekday is not None:\n                self._bynweekday = tuple(sorted(self._bynweekday))\n                orig_bynweekday = [weekday(*x) for x in self._bynweekday]\n            else:\n                orig_bynweekday = ()\n\n            if 'byweekday' not in self._original_rule:\n                self._original_rule['byweekday'] = tuple(itertools.chain(\n                    orig_byweekday, orig_bynweekday))\n\n        # byhour\n        if byhour is None:\n            if freq < HOURLY:\n                self._byhour = {dtstart.hour}\n            else:\n                self._byhour = None\n        else:\n            if isinstance(byhour, integer_types):\n                byhour = (byhour,)\n\n            if freq == HOURLY:\n                self._byhour = self.__construct_byset(start=dtstart.hour,\n                                                      byxxx=byhour,\n                                                      base=24)\n            else:\n                self._byhour = set(byhour)\n\n            self._byhour = tuple(sorted(self._byhour))\n            self._original_rule['byhour'] = self._byhour\n\n        # byminute\n        if byminute is None:\n            if freq < MINUTELY:\n                self._byminute = {dtstart.minute}\n            else:\n                self._byminute = None\n        else:\n            if isinstance(byminute, integer_types):\n                byminute = (byminute,)\n\n            if freq == MINUTELY:\n                self._byminute = self.__construct_byset(start=dtstart.minute,\n                                                        byxxx=byminute,\n                                                        base=60)\n            else:\n                self._byminute = set(byminute)\n\n            self._byminute = tuple(sorted(self._byminute))\n            self._original_rule['byminute'] = self._byminute\n\n        # bysecond\n        if bysecond is None:\n            if freq < SECONDLY:\n                self._bysecond = ((dtstart.second,))\n            else:\n                self._bysecond = None\n        else:\n            if isinstance(bysecond, integer_types):\n                bysecond = (bysecond,)\n\n            self._bysecond = set(bysecond)\n\n            if freq == SECONDLY:\n                self._bysecond = self.__construct_byset(start=dtstart.second,\n                                                        byxxx=bysecond,\n                                                        base=60)\n            else:\n                self._bysecond = set(bysecond)\n\n            self._bysecond = tuple(sorted(self._bysecond))\n            self._original_rule['bysecond'] = self._bysecond\n\n        if self._freq >= HOURLY:\n            self._timeset = None\n        else:\n            self._timeset = []\n            for hour in self._byhour:\n                for minute in self._byminute:\n                    for second in self._bysecond:\n                        self._timeset.append(\n                            datetime.time(hour, minute, second,\n                                          tzinfo=self._tzinfo))\n            self._timeset.sort()\n            self._timeset = tuple(self._timeset)\n\n    def __str__(self):\n        \"\"\"\n        Output a string that would generate this RRULE if passed to rrulestr.\n        This is mostly compatible with RFC5545, except for the\n        dateutil-specific extension BYEASTER.\n        \"\"\"\n\n        output = []\n        h, m, s = [None] * 3\n        if self._dtstart:\n            output.append(self._dtstart.strftime('DTSTART:%Y%m%dT%H%M%S'))\n            h, m, s = self._dtstart.timetuple()[3:6]\n\n        parts = ['FREQ=' + FREQNAMES[self._freq]]\n        if self._interval != 1:\n            parts.append('INTERVAL=' + str(self._interval))\n\n        if self._wkst:\n            parts.append('WKST=' + repr(weekday(self._wkst))[0:2])\n\n        if self._count is not None:\n            parts.append('COUNT=' + str(self._count))\n\n        if self._until:\n            parts.append(self._until.strftime('UNTIL=%Y%m%dT%H%M%S'))\n\n        if self._original_rule.get('byweekday') is not None:\n            # The str() method on weekday objects doesn't generate\n            # RFC5545-compliant strings, so we should modify that.\n            original_rule = dict(self._original_rule)\n            wday_strings = []\n            for wday in original_rule['byweekday']:\n                if wday.n:\n                    wday_strings.append('{n:+d}{wday}'.format(\n                        n=wday.n,\n                        wday=repr(wday)[0:2]))\n                else:\n                    wday_strings.append(repr(wday))\n\n            original_rule['byweekday'] = wday_strings\n        else:\n            original_rule = self._original_rule\n\n        partfmt = '{name}={vals}'\n        for name, key in [('BYSETPOS', 'bysetpos'),\n                          ('BYMONTH', 'bymonth'),\n                          ('BYMONTHDAY', 'bymonthday'),\n                          ('BYYEARDAY', 'byyearday'),\n                          ('BYWEEKNO', 'byweekno'),\n                          ('BYDAY', 'byweekday'),\n                          ('BYHOUR', 'byhour'),\n                          ('BYMINUTE', 'byminute'),\n                          ('BYSECOND', 'bysecond'),\n                          ('BYEASTER', 'byeaster')]:\n            value = original_rule.get(key)\n            if value:\n                parts.append(partfmt.format(name=name, vals=(','.join(str(v)\n                                                             for v in value))))\n\n        output.append('RRULE:' + ';'.join(parts))\n        return '\\n'.join(output)\n\n    def replace(self, **kwargs):\n        \"\"\"Return new rrule with same attributes except for those attributes given new\n           values by whichever keyword arguments are specified.\"\"\"\n        new_kwargs = {\"interval\": self._interval,\n                      \"count\": self._count,\n                      \"dtstart\": self._dtstart,\n                      \"freq\": self._freq,\n                      \"until\": self._until,\n                      \"wkst\": self._wkst,\n                      \"cache\": False if self._cache is None else True }\n        new_kwargs.update(self._original_rule)\n        new_kwargs.update(kwargs)\n        return rrule(**new_kwargs)\n\n    def _iter(self):\n        year, month, day, hour, minute, second, weekday, yearday, _ = \\\n            self._dtstart.timetuple()\n\n        # Some local variables to speed things up a bit\n        freq = self._freq\n        interval = self._interval\n        wkst = self._wkst\n        until = self._until\n        bymonth = self._bymonth\n        byweekno = self._byweekno\n        byyearday = self._byyearday\n        byweekday = self._byweekday\n        byeaster = self._byeaster\n        bymonthday = self._bymonthday\n        bynmonthday = self._bynmonthday\n        bysetpos = self._bysetpos\n        byhour = self._byhour\n        byminute = self._byminute\n        bysecond = self._bysecond\n\n        ii = _iterinfo(self)\n        ii.rebuild(year, month)\n\n        getdayset = {YEARLY: ii.ydayset,\n                     MONTHLY: ii.mdayset,\n                     WEEKLY: ii.wdayset,\n                     DAILY: ii.ddayset,\n                     HOURLY: ii.ddayset,\n                     MINUTELY: ii.ddayset,\n                     SECONDLY: ii.ddayset}[freq]\n\n        if freq < HOURLY:\n            timeset = self._timeset\n        else:\n            gettimeset = {HOURLY: ii.htimeset,\n                          MINUTELY: ii.mtimeset,\n                          SECONDLY: ii.stimeset}[freq]\n            if ((freq >= HOURLY and\n                 self._byhour and hour not in self._byhour) or\n                (freq >= MINUTELY and\n                 self._byminute and minute not in self._byminute) or\n                (freq >= SECONDLY and\n                 self._bysecond and second not in self._bysecond)):\n                timeset = ()\n            else:\n                timeset = gettimeset(hour, minute, second)\n\n        total = 0\n        count = self._count\n        while True:\n            # Get dayset with the right frequency\n            dayset, start, end = getdayset(year, month, day)\n\n            # Do the \"hard\" work ;-)\n            filtered = False\n            for i in dayset[start:end]:\n                if ((bymonth and ii.mmask[i] not in bymonth) or\n                    (byweekno and not ii.wnomask[i]) or\n                    (byweekday and ii.wdaymask[i] not in byweekday) or\n                    (ii.nwdaymask and not ii.nwdaymask[i]) or\n                    (byeaster and not ii.eastermask[i]) or\n                    ((bymonthday or bynmonthday) and\n                     ii.mdaymask[i] not in bymonthday and\n                     ii.nmdaymask[i] not in bynmonthday) or\n                    (byyearday and\n                     ((i < ii.yearlen and i+1 not in byyearday and\n                       -ii.yearlen+i not in byyearday) or\n                      (i >= ii.yearlen and i+1-ii.yearlen not in byyearday and\n                       -ii.nextyearlen+i-ii.yearlen not in byyearday)))):\n                    dayset[i] = None\n                    filtered = True\n\n            # Output results\n            if bysetpos and timeset:\n                poslist = []\n                for pos in bysetpos:\n                    if pos < 0:\n                        daypos, timepos = divmod(pos, len(timeset))\n                    else:\n                        daypos, timepos = divmod(pos-1, len(timeset))\n                    try:\n                        i = [x for x in dayset[start:end]\n                             if x is not None][daypos]\n                        time = timeset[timepos]\n                    except IndexError:\n                        pass\n                    else:\n                        date = datetime.date.fromordinal(ii.yearordinal+i)\n                        res = datetime.datetime.combine(date, time)\n                        if res not in poslist:\n                            poslist.append(res)\n                poslist.sort()\n                for res in poslist:\n                    if until and res > until:\n                        self._len = total\n                        return\n                    elif res >= self._dtstart:\n                        if count is not None:\n                            count -= 1\n                            if count < 0:\n                                self._len = total\n                                return\n                        total += 1\n                        yield res\n            else:\n                for i in dayset[start:end]:\n                    if i is not None:\n                        date = datetime.date.fromordinal(ii.yearordinal + i)\n                        for time in timeset:\n                            res = datetime.datetime.combine(date, time)\n                            if until and res > until:\n                                self._len = total\n                                return\n                            elif res >= self._dtstart:\n                                if count is not None:\n                                    count -= 1\n                                    if count < 0:\n                                        self._len = total\n                                        return\n\n                                total += 1\n                                yield res\n\n            # Handle frequency and interval\n            fixday = False\n            if freq == YEARLY:\n                year += interval\n                if year > datetime.MAXYEAR:\n                    self._len = total\n                    return\n                ii.rebuild(year, month)\n            elif freq == MONTHLY:\n                month += interval\n                if month > 12:\n                    div, mod = divmod(month, 12)\n                    month = mod\n                    year += div\n                    if month == 0:\n                        month = 12\n                        year -= 1\n                    if year > datetime.MAXYEAR:\n                        self._len = total\n                        return\n                ii.rebuild(year, month)\n            elif freq == WEEKLY:\n                if wkst > weekday:\n                    day += -(weekday+1+(6-wkst))+self._interval*7\n                else:\n                    day += -(weekday-wkst)+self._interval*7\n                weekday = wkst\n                fixday = True\n            elif freq == DAILY:\n                day += interval\n                fixday = True\n            elif freq == HOURLY:\n                if filtered:\n                    # Jump to one iteration before next day\n                    hour += ((23-hour)//interval)*interval\n\n                if byhour:\n                    ndays, hour = self.__mod_distance(value=hour,\n                                                      byxxx=self._byhour,\n                                                      base=24)\n                else:\n                    ndays, hour = divmod(hour+interval, 24)\n\n                if ndays:\n                    day += ndays\n                    fixday = True\n\n                timeset = gettimeset(hour, minute, second)\n            elif freq == MINUTELY:\n                if filtered:\n                    # Jump to one iteration before next day\n                    minute += ((1439-(hour*60+minute))//interval)*interval\n\n                valid = False\n                rep_rate = (24*60)\n                for j in range(rep_rate // gcd(interval, rep_rate)):\n                    if byminute:\n                        nhours, minute = \\\n                            self.__mod_distance(value=minute,\n                                                byxxx=self._byminute,\n                                                base=60)\n                    else:\n                        nhours, minute = divmod(minute+interval, 60)\n\n                    div, hour = divmod(hour+nhours, 24)\n                    if div:\n                        day += div\n                        fixday = True\n                        filtered = False\n\n                    if not byhour or hour in byhour:\n                        valid = True\n                        break\n\n                if not valid:\n                    raise ValueError('Invalid combination of interval and ' +\n                                     'byhour resulting in empty rule.')\n\n                timeset = gettimeset(hour, minute, second)\n            elif freq == SECONDLY:\n                if filtered:\n                    # Jump to one iteration before next day\n                    second += (((86399 - (hour * 3600 + minute * 60 + second))\n                                // interval) * interval)\n\n                rep_rate = (24 * 3600)\n                valid = False\n                for j in range(0, rep_rate // gcd(interval, rep_rate)):\n                    if bysecond:\n                        nminutes, second = \\\n                            self.__mod_distance(value=second,\n                                                byxxx=self._bysecond,\n                                                base=60)\n                    else:\n                        nminutes, second = divmod(second+interval, 60)\n\n                    div, minute = divmod(minute+nminutes, 60)\n                    if div:\n                        hour += div\n                        div, hour = divmod(hour, 24)\n                        if div:\n                            day += div\n                            fixday = True\n\n                    if ((not byhour or hour in byhour) and\n                            (not byminute or minute in byminute) and\n                            (not bysecond or second in bysecond)):\n                        valid = True\n                        break\n\n                if not valid:\n                    raise ValueError('Invalid combination of interval, ' +\n                                     'byhour and byminute resulting in empty' +\n                                     ' rule.')\n\n                timeset = gettimeset(hour, minute, second)\n\n            if fixday and day > 28:\n                daysinmonth = calendar.monthrange(year, month)[1]\n                if day > daysinmonth:\n                    while day > daysinmonth:\n                        day -= daysinmonth\n                        month += 1\n                        if month == 13:\n                            month = 1\n                            year += 1\n                            if year > datetime.MAXYEAR:\n                                self._len = total\n                                return\n                        daysinmonth = calendar.monthrange(year, month)[1]\n                    ii.rebuild(year, month)\n\n    def __construct_byset(self, start, byxxx, base):\n        \"\"\"\n        If a `BYXXX` sequence is passed to the constructor at the same level as\n        `FREQ` (e.g. `FREQ=HOURLY,BYHOUR={2,4,7},INTERVAL=3`), there are some\n        specifications which cannot be reached given some starting conditions.\n\n        This occurs whenever the interval is not coprime with the base of a\n        given unit and the difference between the starting position and the\n        ending position is not coprime with the greatest common denominator\n        between the interval and the base. For example, with a FREQ of hourly\n        starting at 17:00 and an interval of 4, the only valid values for\n        BYHOUR would be {21, 1, 5, 9, 13, 17}, because 4 and 24 are not\n        coprime.\n\n        :param start:\n            Specifies the starting position.\n        :param byxxx:\n            An iterable containing the list of allowed values.\n        :param base:\n            The largest allowable value for the specified frequency (e.g.\n            24 hours, 60 minutes).\n\n        This does not preserve the type of the iterable, returning a set, since\n        the values should be unique and the order is irrelevant, this will\n        speed up later lookups.\n\n        In the event of an empty set, raises a :exception:`ValueError`, as this\n        results in an empty rrule.\n        \"\"\"\n\n        cset = set()\n\n        # Support a single byxxx value.\n        if isinstance(byxxx, integer_types):\n            byxxx = (byxxx, )\n\n        for num in byxxx:\n            i_gcd = gcd(self._interval, base)\n            # Use divmod rather than % because we need to wrap negative nums.\n            if i_gcd == 1 or divmod(num - start, i_gcd)[1] == 0:\n                cset.add(num)\n\n        if len(cset) == 0:\n            raise ValueError(\"Invalid rrule byxxx generates an empty set.\")\n\n        return cset\n\n    def __mod_distance(self, value, byxxx, base):\n        \"\"\"\n        Calculates the next value in a sequence where the `FREQ` parameter is\n        specified along with a `BYXXX` parameter at the same \"level\"\n        (e.g. `HOURLY` specified with `BYHOUR`).\n\n        :param value:\n            The old value of the component.\n        :param byxxx:\n            The `BYXXX` set, which should have been generated by\n            `rrule._construct_byset`, or something else which checks that a\n            valid rule is present.\n        :param base:\n            The largest allowable value for the specified frequency (e.g.\n            24 hours, 60 minutes).\n\n        If a valid value is not found after `base` iterations (the maximum\n        number before the sequence would start to repeat), this raises a\n        :exception:`ValueError`, as no valid values were found.\n\n        This returns a tuple of `divmod(n*interval, base)`, where `n` is the\n        smallest number of `interval` repetitions until the next specified\n        value in `byxxx` is found.\n        \"\"\"\n        accumulator = 0\n        for ii in range(1, base + 1):\n            # Using divmod() over % to account for negative intervals\n            div, value = divmod(value + self._interval, base)\n            accumulator += div\n            if value in byxxx:\n                return (accumulator, value)\n\n\nclass _iterinfo(object):\n    __slots__ = [\"rrule\", \"lastyear\", \"lastmonth\",\n                 \"yearlen\", \"nextyearlen\", \"yearordinal\", \"yearweekday\",\n                 \"mmask\", \"mrange\", \"mdaymask\", \"nmdaymask\",\n                 \"wdaymask\", \"wnomask\", \"nwdaymask\", \"eastermask\"]\n\n    def __init__(self, rrule):\n        for attr in self.__slots__:\n            setattr(self, attr, None)\n        self.rrule = rrule\n\n    def rebuild(self, year, month):\n        # Every mask is 7 days longer to handle cross-year weekly periods.\n        rr = self.rrule\n        if year != self.lastyear:\n            self.yearlen = 365 + calendar.isleap(year)\n            self.nextyearlen = 365 + calendar.isleap(year + 1)\n            firstyday = datetime.date(year, 1, 1)\n            self.yearordinal = firstyday.toordinal()\n            self.yearweekday = firstyday.weekday()\n\n            wday = datetime.date(year, 1, 1).weekday()\n            if self.yearlen == 365:\n                self.mmask = M365MASK\n                self.mdaymask = MDAY365MASK\n                self.nmdaymask = NMDAY365MASK\n                self.wdaymask = WDAYMASK[wday:]\n                self.mrange = M365RANGE\n            else:\n                self.mmask = M366MASK\n                self.mdaymask = MDAY366MASK\n                self.nmdaymask = NMDAY366MASK\n                self.wdaymask = WDAYMASK[wday:]\n                self.mrange = M366RANGE\n\n            if not rr._byweekno:\n                self.wnomask = None\n            else:\n                self.wnomask = [0]*(self.yearlen+7)\n                # no1wkst = firstwkst = self.wdaymask.index(rr._wkst)\n                no1wkst = firstwkst = (7-self.yearweekday+rr._wkst) % 7\n                if no1wkst >= 4:\n                    no1wkst = 0\n                    # Number of days in the year, plus the days we got\n                    # from last year.\n                    wyearlen = self.yearlen+(self.yearweekday-rr._wkst) % 7\n                else:\n                    # Number of days in the year, minus the days we\n                    # left in last year.\n                    wyearlen = self.yearlen-no1wkst\n                div, mod = divmod(wyearlen, 7)\n                numweeks = div+mod//4\n                for n in rr._byweekno:\n                    if n < 0:\n                        n += numweeks+1\n                    if not (0 < n <= numweeks):\n                        continue\n                    if n > 1:\n                        i = no1wkst+(n-1)*7\n                        if no1wkst != firstwkst:\n                            i -= 7-firstwkst\n                    else:\n                        i = no1wkst\n                    for j in range(7):\n                        self.wnomask[i] = 1\n                        i += 1\n                        if self.wdaymask[i] == rr._wkst:\n                            break\n                if 1 in rr._byweekno:\n                    # Check week number 1 of next year as well\n                    # TODO: Check -numweeks for next year.\n                    i = no1wkst+numweeks*7\n                    if no1wkst != firstwkst:\n                        i -= 7-firstwkst\n                    if i < self.yearlen:\n                        # If week starts in next year, we\n                        # don't care about it.\n                        for j in range(7):\n                            self.wnomask[i] = 1\n                            i += 1\n                            if self.wdaymask[i] == rr._wkst:\n                                break\n                if no1wkst:\n                    # Check last week number of last year as\n                    # well. If no1wkst is 0, either the year\n                    # started on week start, or week number 1\n                    # got days from last year, so there are no\n                    # days from last year's last week number in\n                    # this year.\n                    if -1 not in rr._byweekno:\n                        lyearweekday = datetime.date(year-1, 1, 1).weekday()\n                        lno1wkst = (7-lyearweekday+rr._wkst) % 7\n                        lyearlen = 365+calendar.isleap(year-1)\n                        if lno1wkst >= 4:\n                            lno1wkst = 0\n                            lnumweeks = 52+(lyearlen +\n                                            (lyearweekday-rr._wkst) % 7) % 7//4\n                        else:\n                            lnumweeks = 52+(self.yearlen-no1wkst) % 7//4\n                    else:\n                        lnumweeks = -1\n                    if lnumweeks in rr._byweekno:\n                        for i in range(no1wkst):\n                            self.wnomask[i] = 1\n\n        if (rr._bynweekday and (month != self.lastmonth or\n                                year != self.lastyear)):\n            ranges = []\n            if rr._freq == YEARLY:\n                if rr._bymonth:\n                    for month in rr._bymonth:\n                        ranges.append(self.mrange[month-1:month+1])\n                else:\n                    ranges = [(0, self.yearlen)]\n            elif rr._freq == MONTHLY:\n                ranges = [self.mrange[month-1:month+1]]\n            if ranges:\n                # Weekly frequency won't get here, so we may not\n                # care about cross-year weekly periods.\n                self.nwdaymask = [0]*self.yearlen\n                for first, last in ranges:\n                    last -= 1\n                    for wday, n in rr._bynweekday:\n                        if n < 0:\n                            i = last+(n+1)*7\n                            i -= (self.wdaymask[i]-wday) % 7\n                        else:\n                            i = first+(n-1)*7\n                            i += (7-self.wdaymask[i]+wday) % 7\n                        if first <= i <= last:\n                            self.nwdaymask[i] = 1\n\n        if rr._byeaster:\n            self.eastermask = [0]*(self.yearlen+7)\n            eyday = easter.easter(year).toordinal()-self.yearordinal\n            for offset in rr._byeaster:\n                self.eastermask[eyday+offset] = 1\n\n        self.lastyear = year\n        self.lastmonth = month\n\n    def ydayset(self, year, month, day):\n        return list(range(self.yearlen)), 0, self.yearlen\n\n    def mdayset(self, year, month, day):\n        dset = [None]*self.yearlen\n        start, end = self.mrange[month-1:month+1]\n        for i in range(start, end):\n            dset[i] = i\n        return dset, start, end\n\n    def wdayset(self, year, month, day):\n        # We need to handle cross-year weeks here.\n        dset = [None]*(self.yearlen+7)\n        i = datetime.date(year, month, day).toordinal()-self.yearordinal\n        start = i\n        for j in range(7):\n            dset[i] = i\n            i += 1\n            # if (not (0 <= i < self.yearlen) or\n            #    self.wdaymask[i] == self.rrule._wkst):\n            # This will cross the year boundary, if necessary.\n            if self.wdaymask[i] == self.rrule._wkst:\n                break\n        return dset, start, i\n\n    def ddayset(self, year, month, day):\n        dset = [None] * self.yearlen\n        i = datetime.date(year, month, day).toordinal() - self.yearordinal\n        dset[i] = i\n        return dset, i, i + 1\n\n    def htimeset(self, hour, minute, second):\n        tset = []\n        rr = self.rrule\n        for minute in rr._byminute:\n            for second in rr._bysecond:\n                tset.append(datetime.time(hour, minute, second,\n                                          tzinfo=rr._tzinfo))\n        tset.sort()\n        return tset\n\n    def mtimeset(self, hour, minute, second):\n        tset = []\n        rr = self.rrule\n        for second in rr._bysecond:\n            tset.append(datetime.time(hour, minute, second, tzinfo=rr._tzinfo))\n        tset.sort()\n        return tset\n\n    def stimeset(self, hour, minute, second):\n        return (datetime.time(hour, minute, second,\n                tzinfo=self.rrule._tzinfo),)\n\n\nclass rruleset(rrulebase):\n    \"\"\" The rruleset type allows more complex recurrence setups, mixing\n    multiple rules, dates, exclusion rules, and exclusion dates. The type\n    constructor takes the following keyword arguments:\n\n    :param cache: If True, caching of results will be enabled, improving\n                  performance of multiple queries considerably. \"\"\"\n\n    class _genitem(object):\n        def __init__(self, genlist, gen):\n            try:\n                self.dt = advance_iterator(gen)\n                genlist.append(self)\n            except StopIteration:\n                pass\n            self.genlist = genlist\n            self.gen = gen\n\n        def __next__(self):\n            try:\n                self.dt = advance_iterator(self.gen)\n            except StopIteration:\n                if self.genlist[0] is self:\n                    heapq.heappop(self.genlist)\n                else:\n                    self.genlist.remove(self)\n                    heapq.heapify(self.genlist)\n\n        next = __next__\n\n        def __lt__(self, other):\n            return self.dt < other.dt\n\n        def __gt__(self, other):\n            return self.dt > other.dt\n\n        def __eq__(self, other):\n            return self.dt == other.dt\n\n        def __ne__(self, other):\n            return self.dt != other.dt\n\n    def __init__(self, cache=False):\n        super(rruleset, self).__init__(cache)\n        self._rrule = []\n        self._rdate = []\n        self._exrule = []\n        self._exdate = []\n\n    @_invalidates_cache\n    def rrule(self, rrule):\n        \"\"\" Include the given :py:class:`rrule` instance in the recurrence set\n            generation. \"\"\"\n        self._rrule.append(rrule)\n\n    @_invalidates_cache\n    def rdate(self, rdate):\n        \"\"\" Include the given :py:class:`datetime` instance in the recurrence\n            set generation. \"\"\"\n        self._rdate.append(rdate)\n\n    @_invalidates_cache\n    def exrule(self, exrule):\n        \"\"\" Include the given rrule instance in the recurrence set exclusion\n            list. Dates which are part of the given recurrence rules will not\n            be generated, even if some inclusive rrule or rdate matches them.\n        \"\"\"\n        self._exrule.append(exrule)\n\n    @_invalidates_cache\n    def exdate(self, exdate):\n        \"\"\" Include the given datetime instance in the recurrence set\n            exclusion list. Dates included that way will not be generated,\n            even if some inclusive rrule or rdate matches them. \"\"\"\n        self._exdate.append(exdate)\n\n    def _iter(self):\n        rlist = []\n        self._rdate.sort()\n        self._genitem(rlist, iter(self._rdate))\n        for gen in [iter(x) for x in self._rrule]:\n            self._genitem(rlist, gen)\n        exlist = []\n        self._exdate.sort()\n        self._genitem(exlist, iter(self._exdate))\n        for gen in [iter(x) for x in self._exrule]:\n            self._genitem(exlist, gen)\n        lastdt = None\n        total = 0\n        heapq.heapify(rlist)\n        heapq.heapify(exlist)\n        while rlist:\n            ritem = rlist[0]\n            if not lastdt or lastdt != ritem.dt:\n                while exlist and exlist[0] < ritem:\n                    exitem = exlist[0]\n                    advance_iterator(exitem)\n                    if exlist and exlist[0] is exitem:\n                        heapq.heapreplace(exlist, exitem)\n                if not exlist or ritem != exlist[0]:\n                    total += 1\n                    yield ritem.dt\n                lastdt = ritem.dt\n            advance_iterator(ritem)\n            if rlist and rlist[0] is ritem:\n                heapq.heapreplace(rlist, ritem)\n        self._len = total\n\n\n\n\nclass _rrulestr(object):\n    \"\"\" Parses a string representation of a recurrence rule or set of\n    recurrence rules.\n\n    :param s:\n        Required, a string defining one or more recurrence rules.\n\n    :param dtstart:\n        If given, used as the default recurrence start if not specified in the\n        rule string.\n\n    :param cache:\n        If set ``True`` caching of results will be enabled, improving\n        performance of multiple queries considerably.\n\n    :param unfold:\n        If set ``True`` indicates that a rule string is split over more\n        than one line and should be joined before processing.\n\n    :param forceset:\n        If set ``True`` forces a :class:`dateutil.rrule.rruleset` to\n        be returned.\n\n    :param compatible:\n        If set ``True`` forces ``unfold`` and ``forceset`` to be ``True``.\n\n    :param ignoretz:\n        If set ``True``, time zones in parsed strings are ignored and a naive\n        :class:`datetime.datetime` object is returned.\n\n    :param tzids:\n        If given, a callable or mapping used to retrieve a\n        :class:`datetime.tzinfo` from a string representation.\n        Defaults to :func:`dateutil.tz.gettz`.\n\n    :param tzinfos:\n        Additional time zone names / aliases which may be present in a string\n        representation.  See :func:`dateutil.parser.parse` for more\n        information.\n\n    :return:\n        Returns a :class:`dateutil.rrule.rruleset` or\n        :class:`dateutil.rrule.rrule`\n    \"\"\"\n\n    _freq_map = {\"YEARLY\": YEARLY,\n                 \"MONTHLY\": MONTHLY,\n                 \"WEEKLY\": WEEKLY,\n                 \"DAILY\": DAILY,\n                 \"HOURLY\": HOURLY,\n                 \"MINUTELY\": MINUTELY,\n                 \"SECONDLY\": SECONDLY}\n\n    _weekday_map = {\"MO\": 0, \"TU\": 1, \"WE\": 2, \"TH\": 3,\n                    \"FR\": 4, \"SA\": 5, \"SU\": 6}\n\n    def _handle_int(self, rrkwargs, name, value, **kwargs):\n        rrkwargs[name.lower()] = int(value)\n\n    def _handle_int_list(self, rrkwargs, name, value, **kwargs):\n        rrkwargs[name.lower()] = [int(x) for x in value.split(',')]\n\n    _handle_INTERVAL = _handle_int\n    _handle_COUNT = _handle_int\n    _handle_BYSETPOS = _handle_int_list\n    _handle_BYMONTH = _handle_int_list\n    _handle_BYMONTHDAY = _handle_int_list\n    _handle_BYYEARDAY = _handle_int_list\n    _handle_BYEASTER = _handle_int_list\n    _handle_BYWEEKNO = _handle_int_list\n    _handle_BYHOUR = _handle_int_list\n    _handle_BYMINUTE = _handle_int_list\n    _handle_BYSECOND = _handle_int_list\n\n    def _handle_FREQ(self, rrkwargs, name, value, **kwargs):\n        rrkwargs[\"freq\"] = self._freq_map[value]\n\n    def _handle_UNTIL(self, rrkwargs, name, value, **kwargs):\n        global parser\n        if not parser:\n            from dateutil import parser\n        try:\n            rrkwargs[\"until\"] = parser.parse(value,\n                                             ignoretz=kwargs.get(\"ignoretz\"),\n                                             tzinfos=kwargs.get(\"tzinfos\"))\n        except ValueError:\n            raise ValueError(\"invalid until date\")\n\n    def _handle_WKST(self, rrkwargs, name, value, **kwargs):\n        rrkwargs[\"wkst\"] = self._weekday_map[value]\n\n    def _handle_BYWEEKDAY(self, rrkwargs, name, value, **kwargs):\n        \"\"\"\n        Two ways to specify this: +1MO or MO(+1)\n        \"\"\"\n        l = []\n        for wday in value.split(','):\n            if '(' in wday:\n                # If it's of the form TH(+1), etc.\n                splt = wday.split('(')\n                w = splt[0]\n                n = int(splt[1][:-1])\n            elif len(wday):\n                # If it's of the form +1MO\n                for i in range(len(wday)):\n                    if wday[i] not in '+-0123456789':\n                        break\n                n = wday[:i] or None\n                w = wday[i:]\n                if n:\n                    n = int(n)\n            else:\n                raise ValueError(\"Invalid (empty) BYDAY specification.\")\n\n            l.append(weekdays[self._weekday_map[w]](n))\n        rrkwargs[\"byweekday\"] = l\n\n    _handle_BYDAY = _handle_BYWEEKDAY\n\n    def _parse_rfc_rrule(self, line,\n                         dtstart=None,\n                         cache=False,\n                         ignoretz=False,\n                         tzinfos=None):\n        if line.find(':') != -1:\n            name, value = line.split(':')\n            if name != \"RRULE\":\n                raise ValueError(\"unknown parameter name\")\n        else:\n            value = line\n        rrkwargs = {}\n        for pair in value.split(';'):\n            name, value = pair.split('=')\n            name = name.upper()\n            value = value.upper()\n            try:\n                getattr(self, \"_handle_\"+name)(rrkwargs, name, value,\n                                               ignoretz=ignoretz,\n                                               tzinfos=tzinfos)\n            except AttributeError:\n                raise ValueError(\"unknown parameter '%s'\" % name)\n            except (KeyError, ValueError):\n                raise ValueError(\"invalid '%s': %s\" % (name, value))\n        return rrule(dtstart=dtstart, cache=cache, **rrkwargs)\n\n    def _parse_date_value(self, date_value, parms, rule_tzids,\n                          ignoretz, tzids, tzinfos):\n        global parser\n        if not parser:\n            from dateutil import parser\n\n        datevals = []\n        value_found = False\n        TZID = None\n\n        for parm in parms:\n            if parm.startswith(\"TZID=\"):\n                try:\n                    tzkey = rule_tzids[parm.split('TZID=')[-1]]\n                except KeyError:\n                    continue\n                if tzids is None:\n                    from . import tz\n                    tzlookup = tz.gettz\n                elif callable(tzids):\n                    tzlookup = tzids\n                else:\n                    tzlookup = getattr(tzids, 'get', None)\n                    if tzlookup is None:\n                        msg = ('tzids must be a callable, mapping, or None, '\n                               'not %s' % tzids)\n                        raise ValueError(msg)\n\n                TZID = tzlookup(tzkey)\n                continue\n\n            # RFC 5445 3.8.2.4: The VALUE parameter is optional, but may be found\n            # only once.\n            if parm not in {\"VALUE=DATE-TIME\", \"VALUE=DATE\"}:\n                raise ValueError(\"unsupported parm: \" + parm)\n            else:\n                if value_found:\n                    msg = (\"Duplicate value parameter found in: \" + parm)\n                    raise ValueError(msg)\n                value_found = True\n\n        for datestr in date_value.split(','):\n            date = parser.parse(datestr, ignoretz=ignoretz, tzinfos=tzinfos)\n            if TZID is not None:\n                if date.tzinfo is None:\n                    date = date.replace(tzinfo=TZID)\n                else:\n                    raise ValueError('DTSTART/EXDATE specifies multiple timezone')\n            datevals.append(date)\n\n        return datevals\n\n    def _parse_rfc(self, s,\n                   dtstart=None,\n                   cache=False,\n                   unfold=False,\n                   forceset=False,\n                   compatible=False,\n                   ignoretz=False,\n                   tzids=None,\n                   tzinfos=None):\n        global parser\n        if compatible:\n            forceset = True\n            unfold = True\n\n        TZID_NAMES = dict(map(\n            lambda x: (x.upper(), x),\n            re.findall('TZID=(?P<name>[^:]+):', s)\n        ))\n        s = s.upper()\n        if not s.strip():\n            raise ValueError(\"empty string\")\n        if unfold:\n            lines = s.splitlines()\n            i = 0\n            while i < len(lines):\n                line = lines[i].rstrip()\n                if not line:\n                    del lines[i]\n                elif i > 0 and line[0] == \" \":\n                    lines[i-1] += line[1:]\n                    del lines[i]\n                else:\n                    i += 1\n        else:\n            lines = s.split()\n        if (not forceset and len(lines) == 1 and (s.find(':') == -1 or\n                                                  s.startswith('RRULE:'))):\n            return self._parse_rfc_rrule(lines[0], cache=cache,\n                                         dtstart=dtstart, ignoretz=ignoretz,\n                                         tzinfos=tzinfos)\n        else:\n            rrulevals = []\n            rdatevals = []\n            exrulevals = []\n            exdatevals = []\n            for line in lines:\n                if not line:\n                    continue\n                if line.find(':') == -1:\n                    name = \"RRULE\"\n                    value = line\n                else:\n                    name, value = line.split(':', 1)\n                parms = name.split(';')\n                if not parms:\n                    raise ValueError(\"empty property name\")\n                name = parms[0]\n                parms = parms[1:]\n                if name == \"RRULE\":\n                    for parm in parms:\n                        raise ValueError(\"unsupported RRULE parm: \"+parm)\n                    rrulevals.append(value)\n                elif name == \"RDATE\":\n                    for parm in parms:\n                        if parm != \"VALUE=DATE-TIME\":\n                            raise ValueError(\"unsupported RDATE parm: \"+parm)\n                    rdatevals.append(value)\n                elif name == \"EXRULE\":\n                    for parm in parms:\n                        raise ValueError(\"unsupported EXRULE parm: \"+parm)\n                    exrulevals.append(value)\n                elif name == \"EXDATE\":\n                    exdatevals.extend(\n                        self._parse_date_value(value, parms,\n                                               TZID_NAMES, ignoretz,\n                                               tzids, tzinfos)\n                    )\n                elif name == \"DTSTART\":\n                    dtvals = self._parse_date_value(value, parms, TZID_NAMES,\n                                                    ignoretz, tzids, tzinfos)\n                    if len(dtvals) != 1:\n                        raise ValueError(\"Multiple DTSTART values specified:\" +\n                                         value)\n                    dtstart = dtvals[0]\n                else:\n                    raise ValueError(\"unsupported property: \"+name)\n            if (forceset or len(rrulevals) > 1 or rdatevals\n                    or exrulevals or exdatevals):\n                if not parser and (rdatevals or exdatevals):\n                    from dateutil import parser\n                rset = rruleset(cache=cache)\n                for value in rrulevals:\n                    rset.rrule(self._parse_rfc_rrule(value, dtstart=dtstart,\n                                                     ignoretz=ignoretz,\n                                                     tzinfos=tzinfos))\n                for value in rdatevals:\n                    for datestr in value.split(','):\n                        rset.rdate(parser.parse(datestr,\n                                                ignoretz=ignoretz,\n                                                tzinfos=tzinfos))\n                for value in exrulevals:\n                    rset.exrule(self._parse_rfc_rrule(value, dtstart=dtstart,\n                                                      ignoretz=ignoretz,\n                                                      tzinfos=tzinfos))\n                for value in exdatevals:\n                    rset.exdate(value)\n                if compatible and dtstart:\n                    rset.rdate(dtstart)\n                return rset\n            else:\n                return self._parse_rfc_rrule(rrulevals[0],\n                                             dtstart=dtstart,\n                                             cache=cache,\n                                             ignoretz=ignoretz,\n                                             tzinfos=tzinfos)\n\n    def __call__(self, s, **kwargs):\n        return self._parse_rfc(s, **kwargs)\n\n\nrrulestr = _rrulestr()\n\n# vim:ts=4:sw=4:et\n", "src/dateutil/__init__.py": "# -*- coding: utf-8 -*-\nimport sys\n\ntry:\n    from ._version import version as __version__\nexcept ImportError:\n    __version__ = 'unknown'\n\n__all__ = ['easter', 'parser', 'relativedelta', 'rrule', 'tz',\n           'utils', 'zoneinfo']\n\ndef __getattr__(name):\n    import importlib\n\n    if name in __all__:\n        return importlib.import_module(\".\" + name, __name__)\n    raise AttributeError(\n        \"module {!r} has not attribute {!r}\".format(__name__, name)\n    )\n\n\ndef __dir__():\n    # __dir__ should include all the lazy-importable modules as well.\n    return [x for x in globals() if x not in sys.modules] + __all__\n", "src/dateutil/easter.py": "# -*- coding: utf-8 -*-\n\"\"\"\nThis module offers a generic Easter computing method for any given year, using\nWestern, Orthodox or Julian algorithms.\n\"\"\"\n\nimport datetime\n\n__all__ = [\"easter\", \"EASTER_JULIAN\", \"EASTER_ORTHODOX\", \"EASTER_WESTERN\"]\n\nEASTER_JULIAN = 1\nEASTER_ORTHODOX = 2\nEASTER_WESTERN = 3\n\n\ndef easter(year, method=EASTER_WESTERN):\n    \"\"\"\n    This method was ported from the work done by GM Arts,\n    on top of the algorithm by Claus Tondering, which was\n    based in part on the algorithm of Ouding (1940), as\n    quoted in \"Explanatory Supplement to the Astronomical\n    Almanac\", P.  Kenneth Seidelmann, editor.\n\n    This algorithm implements three different Easter\n    calculation methods:\n\n    1. Original calculation in Julian calendar, valid in\n       dates after 326 AD\n    2. Original method, with date converted to Gregorian\n       calendar, valid in years 1583 to 4099\n    3. Revised method, in Gregorian calendar, valid in\n       years 1583 to 4099 as well\n\n    These methods are represented by the constants:\n\n    * ``EASTER_JULIAN   = 1``\n    * ``EASTER_ORTHODOX = 2``\n    * ``EASTER_WESTERN  = 3``\n\n    The default method is method 3.\n\n    More about the algorithm may be found at:\n\n    `GM Arts: Easter Algorithms <http://www.gmarts.org/index.php?go=415>`_\n\n    and\n\n    `The Calendar FAQ: Easter <https://www.tondering.dk/claus/cal/easter.php>`_\n\n    \"\"\"\n\n    if not (1 <= method <= 3):\n        raise ValueError(\"invalid method\")\n\n    # g - Golden year - 1\n    # c - Century\n    # h - (23 - Epact) mod 30\n    # i - Number of days from March 21 to Paschal Full Moon\n    # j - Weekday for PFM (0=Sunday, etc)\n    # p - Number of days from March 21 to Sunday on or before PFM\n    #     (-6 to 28 methods 1 & 3, to 56 for method 2)\n    # e - Extra days to add for method 2 (converting Julian\n    #     date to Gregorian date)\n\n    y = year\n    g = y % 19\n    e = 0\n    if method < 3:\n        # Old method\n        i = (19*g + 15) % 30\n        j = (y + y//4 + i) % 7\n        if method == 2:\n            # Extra dates to convert Julian to Gregorian date\n            e = 10\n            if y > 1600:\n                e = e + y//100 - 16 - (y//100 - 16)//4\n    else:\n        # New method\n        c = y//100\n        h = (c - c//4 - (8*c + 13)//25 + 19*g + 15) % 30\n        i = h - (h//28)*(1 - (h//28)*(29//(h + 1))*((21 - g)//11))\n        j = (y + y//4 + i + 2 - c + c//4) % 7\n\n    # p can be from -6 to 56 corresponding to dates 22 March to 23 May\n    # (later dates apply to method 2, although 23 May never actually occurs)\n    p = i - j + e\n    d = 1 + (p + 27 + (p + 6)//40) % 31\n    m = 3 + (p + 26)//30\n    return datetime.date(int(y), int(m), int(d))\n", "src/dateutil/parser/_parser.py": "# -*- coding: utf-8 -*-\n\"\"\"\nThis module offers a generic date/time string parser which is able to parse\nmost known formats to represent a date and/or time.\n\nThis module attempts to be forgiving with regards to unlikely input formats,\nreturning a datetime object even for dates which are ambiguous. If an element\nof a date/time stamp is omitted, the following rules are applied:\n\n- If AM or PM is left unspecified, a 24-hour clock is assumed, however, an hour\n  on a 12-hour clock (``0 <= hour <= 12``) *must* be specified if AM or PM is\n  specified.\n- If a time zone is omitted, a timezone-naive datetime is returned.\n\nIf any other elements are missing, they are taken from the\n:class:`datetime.datetime` object passed to the parameter ``default``. If this\nresults in a day number exceeding the valid number of days per month, the\nvalue falls back to the end of the month.\n\nAdditional resources about date/time string formats can be found below:\n\n- `A summary of the international standard date and time notation\n  <https://www.cl.cam.ac.uk/~mgk25/iso-time.html>`_\n- `W3C Date and Time Formats <https://www.w3.org/TR/NOTE-datetime>`_\n- `Time Formats (Planetary Rings Node) <https://pds-rings.seti.org:443/tools/time_formats.html>`_\n- `CPAN ParseDate module\n  <https://metacpan.org/pod/release/MUIR/Time-modules-2013.0912/lib/Time/ParseDate.pm>`_\n- `Java SimpleDateFormat Class\n  <https://docs.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.html>`_\n\"\"\"\nfrom __future__ import unicode_literals\n\nimport datetime\nimport re\nimport string\nimport time\nimport warnings\n\nfrom calendar import monthrange\nfrom io import StringIO\n\nimport six\nfrom six import integer_types, text_type\n\nfrom decimal import Decimal\n\nfrom warnings import warn\n\nfrom .. import relativedelta\nfrom .. import tz\n\n__all__ = [\"parse\", \"parserinfo\", \"ParserError\"]\n\n\n# TODO: pandas.core.tools.datetimes imports this explicitly.  Might be worth\n# making public and/or figuring out if there is something we can\n# take off their plate.\nclass _timelex(object):\n    # Fractional seconds are sometimes split by a comma\n    _split_decimal = re.compile(\"([.,])\")\n\n    def __init__(self, instream):\n        if isinstance(instream, (bytes, bytearray)):\n            instream = instream.decode()\n\n        if isinstance(instream, text_type):\n            instream = StringIO(instream)\n        elif getattr(instream, 'read', None) is None:\n            raise TypeError('Parser must be a string or character stream, not '\n                            '{itype}'.format(itype=instream.__class__.__name__))\n\n        self.instream = instream\n        self.charstack = []\n        self.tokenstack = []\n        self.eof = False\n\n    def get_token(self):\n        \"\"\"\n        This function breaks the time string into lexical units (tokens), which\n        can be parsed by the parser. Lexical units are demarcated by changes in\n        the character set, so any continuous string of letters is considered\n        one unit, any continuous string of numbers is considered one unit.\n\n        The main complication arises from the fact that dots ('.') can be used\n        both as separators (e.g. \"Sep.20.2009\") or decimal points (e.g.\n        \"4:30:21.447\"). As such, it is necessary to read the full context of\n        any dot-separated strings before breaking it into tokens; as such, this\n        function maintains a \"token stack\", for when the ambiguous context\n        demands that multiple tokens be parsed at once.\n        \"\"\"\n        if self.tokenstack:\n            return self.tokenstack.pop(0)\n\n        seenletters = False\n        token = None\n        state = None\n\n        while not self.eof:\n            # We only realize that we've reached the end of a token when we\n            # find a character that's not part of the current token - since\n            # that character may be part of the next token, it's stored in the\n            # charstack.\n            if self.charstack:\n                nextchar = self.charstack.pop(0)\n            else:\n                nextchar = self.instream.read(1)\n                while nextchar == '\\x00':\n                    nextchar = self.instream.read(1)\n\n            if not nextchar:\n                self.eof = True\n                break\n            elif not state:\n                # First character of the token - determines if we're starting\n                # to parse a word, a number or something else.\n                token = nextchar\n                if self.isword(nextchar):\n                    state = 'a'\n                elif self.isnum(nextchar):\n                    state = '0'\n                elif self.isspace(nextchar):\n                    token = ' '\n                    break  # emit token\n                else:\n                    break  # emit token\n            elif state == 'a':\n                # If we've already started reading a word, we keep reading\n                # letters until we find something that's not part of a word.\n                seenletters = True\n                if self.isword(nextchar):\n                    token += nextchar\n                elif nextchar == '.':\n                    token += nextchar\n                    state = 'a.'\n                else:\n                    self.charstack.append(nextchar)\n                    break  # emit token\n            elif state == '0':\n                # If we've already started reading a number, we keep reading\n                # numbers until we find something that doesn't fit.\n                if self.isnum(nextchar):\n                    token += nextchar\n                elif nextchar == '.' or (nextchar == ',' and len(token) >= 2):\n                    token += nextchar\n                    state = '0.'\n                else:\n                    self.charstack.append(nextchar)\n                    break  # emit token\n            elif state == 'a.':\n                # If we've seen some letters and a dot separator, continue\n                # parsing, and the tokens will be broken up later.\n                seenletters = True\n                if nextchar == '.' or self.isword(nextchar):\n                    token += nextchar\n                elif self.isnum(nextchar) and token[-1] == '.':\n                    token += nextchar\n                    state = '0.'\n                else:\n                    self.charstack.append(nextchar)\n                    break  # emit token\n            elif state == '0.':\n                # If we've seen at least one dot separator, keep going, we'll\n                # break up the tokens later.\n                if nextchar == '.' or self.isnum(nextchar):\n                    token += nextchar\n                elif self.isword(nextchar) and token[-1] == '.':\n                    token += nextchar\n                    state = 'a.'\n                else:\n                    self.charstack.append(nextchar)\n                    break  # emit token\n\n        if (state in ('a.', '0.') and (seenletters or token.count('.') > 1 or\n                                       token[-1] in '.,')):\n            l = self._split_decimal.split(token)\n            token = l[0]\n            for tok in l[1:]:\n                if tok:\n                    self.tokenstack.append(tok)\n\n        if state == '0.' and token.count('.') == 0:\n            token = token.replace(',', '.')\n\n        return token\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        token = self.get_token()\n        if token is None:\n            raise StopIteration\n\n        return token\n\n    def next(self):\n        return self.__next__()  # Python 2.x support\n\n    @classmethod\n    def split(cls, s):\n        return list(cls(s))\n\n    @classmethod\n    def isword(cls, nextchar):\n        \"\"\" Whether or not the next character is part of a word \"\"\"\n        return nextchar.isalpha()\n\n    @classmethod\n    def isnum(cls, nextchar):\n        \"\"\" Whether the next character is part of a number \"\"\"\n        return nextchar.isdigit()\n\n    @classmethod\n    def isspace(cls, nextchar):\n        \"\"\" Whether the next character is whitespace \"\"\"\n        return nextchar.isspace()\n\n\nclass _resultbase(object):\n\n    def __init__(self):\n        for attr in self.__slots__:\n            setattr(self, attr, None)\n\n    def _repr(self, classname):\n        l = []\n        for attr in self.__slots__:\n            value = getattr(self, attr)\n            if value is not None:\n                l.append(\"%s=%s\" % (attr, repr(value)))\n        return \"%s(%s)\" % (classname, \", \".join(l))\n\n    def __len__(self):\n        return (sum(getattr(self, attr) is not None\n                    for attr in self.__slots__))\n\n    def __repr__(self):\n        return self._repr(self.__class__.__name__)\n\n\nclass parserinfo(object):\n    \"\"\"\n    Class which handles what inputs are accepted. Subclass this to customize\n    the language and acceptable values for each parameter.\n\n    :param dayfirst:\n        Whether to interpret the first value in an ambiguous 3-integer date\n        (e.g. 01/05/09) as the day (``True``) or month (``False``). If\n        ``yearfirst`` is set to ``True``, this distinguishes between YDM\n        and YMD. Default is ``False``.\n\n    :param yearfirst:\n        Whether to interpret the first value in an ambiguous 3-integer date\n        (e.g. 01/05/09) as the year. If ``True``, the first number is taken\n        to be the year, otherwise the last number is taken to be the year.\n        Default is ``False``.\n    \"\"\"\n\n    # m from a.m/p.m, t from ISO T separator\n    JUMP = [\" \", \".\", \",\", \";\", \"-\", \"/\", \"'\",\n            \"at\", \"on\", \"and\", \"ad\", \"m\", \"t\", \"of\",\n            \"st\", \"nd\", \"rd\", \"th\"]\n\n    WEEKDAYS = [(\"Mon\", \"Monday\"),\n                (\"Tue\", \"Tuesday\"),     # TODO: \"Tues\"\n                (\"Wed\", \"Wednesday\"),\n                (\"Thu\", \"Thursday\"),    # TODO: \"Thurs\"\n                (\"Fri\", \"Friday\"),\n                (\"Sat\", \"Saturday\"),\n                (\"Sun\", \"Sunday\")]\n    MONTHS = [(\"Jan\", \"January\"),\n              (\"Feb\", \"February\"),      # TODO: \"Febr\"\n              (\"Mar\", \"March\"),\n              (\"Apr\", \"April\"),\n              (\"May\", \"May\"),\n              (\"Jun\", \"June\"),\n              (\"Jul\", \"July\"),\n              (\"Aug\", \"August\"),\n              (\"Sep\", \"Sept\", \"September\"),\n              (\"Oct\", \"October\"),\n              (\"Nov\", \"November\"),\n              (\"Dec\", \"December\")]\n    HMS = [(\"h\", \"hour\", \"hours\"),\n           (\"m\", \"minute\", \"minutes\"),\n           (\"s\", \"second\", \"seconds\")]\n    AMPM = [(\"am\", \"a\"),\n            (\"pm\", \"p\")]\n    UTCZONE = [\"UTC\", \"GMT\", \"Z\", \"z\"]\n    PERTAIN = [\"of\"]\n    TZOFFSET = {}\n    # TODO: ERA = [\"AD\", \"BC\", \"CE\", \"BCE\", \"Stardate\",\n    #              \"Anno Domini\", \"Year of Our Lord\"]\n\n    def __init__(self, dayfirst=False, yearfirst=False):\n        self._jump = self._convert(self.JUMP)\n        self._weekdays = self._convert(self.WEEKDAYS)\n        self._months = self._convert(self.MONTHS)\n        self._hms = self._convert(self.HMS)\n        self._ampm = self._convert(self.AMPM)\n        self._utczone = self._convert(self.UTCZONE)\n        self._pertain = self._convert(self.PERTAIN)\n\n        self.dayfirst = dayfirst\n        self.yearfirst = yearfirst\n\n        self._year = time.localtime().tm_year\n        self._century = self._year // 100 * 100\n\n    def _convert(self, lst):\n        dct = {}\n        for i, v in enumerate(lst):\n            if isinstance(v, tuple):\n                for v in v:\n                    dct[v.lower()] = i\n            else:\n                dct[v.lower()] = i\n        return dct\n\n    def jump(self, name):\n        return name.lower() in self._jump\n\n    def weekday(self, name):\n        try:\n            return self._weekdays[name.lower()]\n        except KeyError:\n            pass\n        return None\n\n    def month(self, name):\n        try:\n            return self._months[name.lower()] + 1\n        except KeyError:\n            pass\n        return None\n\n    def hms(self, name):\n        try:\n            return self._hms[name.lower()]\n        except KeyError:\n            return None\n\n    def ampm(self, name):\n        try:\n            return self._ampm[name.lower()]\n        except KeyError:\n            return None\n\n    def pertain(self, name):\n        return name.lower() in self._pertain\n\n    def utczone(self, name):\n        return name.lower() in self._utczone\n\n    def tzoffset(self, name):\n        if name in self._utczone:\n            return 0\n\n        return self.TZOFFSET.get(name)\n\n    def convertyear(self, year, century_specified=False):\n        \"\"\"\n        Converts two-digit years to year within [-50, 49]\n        range of self._year (current local time)\n        \"\"\"\n\n        # Function contract is that the year is always positive\n        assert year >= 0\n\n        if year < 100 and not century_specified:\n            # assume current century to start\n            year += self._century\n\n            if year >= self._year + 50:  # if too far in future\n                year -= 100\n            elif year < self._year - 50:  # if too far in past\n                year += 100\n\n        return year\n\n    def validate(self, res):\n        # move to info\n        if res.year is not None:\n            res.year = self.convertyear(res.year, res.century_specified)\n\n        if ((res.tzoffset == 0 and not res.tzname) or\n             (res.tzname == 'Z' or res.tzname == 'z')):\n            res.tzname = \"UTC\"\n            res.tzoffset = 0\n        elif res.tzoffset != 0 and res.tzname and self.utczone(res.tzname):\n            res.tzoffset = 0\n        return True\n\n\nclass _ymd(list):\n    def __init__(self, *args, **kwargs):\n        super(self.__class__, self).__init__(*args, **kwargs)\n        self.century_specified = False\n        self.dstridx = None\n        self.mstridx = None\n        self.ystridx = None\n\n    @property\n    def has_year(self):\n        return self.ystridx is not None\n\n    @property\n    def has_month(self):\n        return self.mstridx is not None\n\n    @property\n    def has_day(self):\n        return self.dstridx is not None\n\n    def could_be_day(self, value):\n        if self.has_day:\n            return False\n        elif not self.has_month:\n            return 1 <= value <= 31\n        elif not self.has_year:\n            # Be permissive, assume leap year\n            month = self[self.mstridx]\n            return 1 <= value <= monthrange(2000, month)[1]\n        else:\n            month = self[self.mstridx]\n            year = self[self.ystridx]\n            return 1 <= value <= monthrange(year, month)[1]\n\n    def append(self, val, label=None):\n        if hasattr(val, '__len__'):\n            if val.isdigit() and len(val) > 2:\n                self.century_specified = True\n                if label not in [None, 'Y']:  # pragma: no cover\n                    raise ValueError(label)\n                label = 'Y'\n        elif val > 100:\n            self.century_specified = True\n            if label not in [None, 'Y']:  # pragma: no cover\n                raise ValueError(label)\n            label = 'Y'\n\n        super(self.__class__, self).append(int(val))\n\n        if label == 'M':\n            if self.has_month:\n                raise ValueError('Month is already set')\n            self.mstridx = len(self) - 1\n        elif label == 'D':\n            if self.has_day:\n                raise ValueError('Day is already set')\n            self.dstridx = len(self) - 1\n        elif label == 'Y':\n            if self.has_year:\n                raise ValueError('Year is already set')\n            self.ystridx = len(self) - 1\n\n    def _resolve_from_stridxs(self, strids):\n        \"\"\"\n        Try to resolve the identities of year/month/day elements using\n        ystridx, mstridx, and dstridx, if enough of these are specified.\n        \"\"\"\n        if len(self) == 3 and len(strids) == 2:\n            # we can back out the remaining stridx value\n            missing = [x for x in range(3) if x not in strids.values()]\n            key = [x for x in ['y', 'm', 'd'] if x not in strids]\n            assert len(missing) == len(key) == 1\n            key = key[0]\n            val = missing[0]\n            strids[key] = val\n\n        assert len(self) == len(strids)  # otherwise this should not be called\n        out = {key: self[strids[key]] for key in strids}\n        return (out.get('y'), out.get('m'), out.get('d'))\n\n    def resolve_ymd(self, yearfirst, dayfirst):\n        len_ymd = len(self)\n        year, month, day = (None, None, None)\n\n        strids = (('y', self.ystridx),\n                  ('m', self.mstridx),\n                  ('d', self.dstridx))\n\n        strids = {key: val for key, val in strids if val is not None}\n        if (len(self) == len(strids) > 0 or\n                (len(self) == 3 and len(strids) == 2)):\n            return self._resolve_from_stridxs(strids)\n\n        mstridx = self.mstridx\n\n        if len_ymd > 3:\n            raise ValueError(\"More than three YMD values\")\n        elif len_ymd == 1 or (mstridx is not None and len_ymd == 2):\n            # One member, or two members with a month string\n            if mstridx is not None:\n                month = self[mstridx]\n                # since mstridx is 0 or 1, self[mstridx-1] always\n                # looks up the other element\n                other = self[mstridx - 1]\n            else:\n                other = self[0]\n\n            if len_ymd > 1 or mstridx is None:\n                if other > 31:\n                    year = other\n                else:\n                    day = other\n\n        elif len_ymd == 2:\n            # Two members with numbers\n            if self[0] > 31:\n                # 99-01\n                year, month = self\n            elif self[1] > 31:\n                # 01-99\n                month, year = self\n            elif dayfirst and self[1] <= 12:\n                # 13-01\n                day, month = self\n            else:\n                # 01-13\n                month, day = self\n\n        elif len_ymd == 3:\n            # Three members\n            if mstridx == 0:\n                if self[1] > 31:\n                    # Apr-2003-25\n                    month, year, day = self\n                else:\n                    month, day, year = self\n            elif mstridx == 1:\n                if self[0] > 31 or (yearfirst and self[2] <= 31):\n                    # 99-Jan-01\n                    year, month, day = self\n                else:\n                    # 01-Jan-01\n                    # Give precedence to day-first, since\n                    # two-digit years is usually hand-written.\n                    day, month, year = self\n\n            elif mstridx == 2:\n                # WTF!?\n                if self[1] > 31:\n                    # 01-99-Jan\n                    day, year, month = self\n                else:\n                    # 99-01-Jan\n                    year, day, month = self\n\n            else:\n                if (self[0] > 31 or\n                    self.ystridx == 0 or\n                        (yearfirst and self[1] <= 12 and self[2] <= 31)):\n                    # 99-01-01\n                    if dayfirst and self[2] <= 12:\n                        year, day, month = self\n                    else:\n                        year, month, day = self\n                elif self[0] > 12 or (dayfirst and self[1] <= 12):\n                    # 13-01-01\n                    day, month, year = self\n                else:\n                    # 01-13-01\n                    month, day, year = self\n\n        return year, month, day\n\n\nclass parser(object):\n    def __init__(self, info=None):\n        self.info = info or parserinfo()\n\n    def parse(self, timestr, default=None,\n              ignoretz=False, tzinfos=None, **kwargs):\n        \"\"\"\n        Parse the date/time string into a :class:`datetime.datetime` object.\n\n        :param timestr:\n            Any date/time string using the supported formats.\n\n        :param default:\n            The default datetime object, if this is a datetime object and not\n            ``None``, elements specified in ``timestr`` replace elements in the\n            default object.\n\n        :param ignoretz:\n            If set ``True``, time zones in parsed strings are ignored and a\n            naive :class:`datetime.datetime` object is returned.\n\n        :param tzinfos:\n            Additional time zone names / aliases which may be present in the\n            string. This argument maps time zone names (and optionally offsets\n            from those time zones) to time zones. This parameter can be a\n            dictionary with timezone aliases mapping time zone names to time\n            zones or a function taking two parameters (``tzname`` and\n            ``tzoffset``) and returning a time zone.\n\n            The timezones to which the names are mapped can be an integer\n            offset from UTC in seconds or a :class:`tzinfo` object.\n\n            .. doctest::\n               :options: +NORMALIZE_WHITESPACE\n\n                >>> from dateutil.parser import parse\n                >>> from dateutil.tz import gettz\n                >>> tzinfos = {\"BRST\": -7200, \"CST\": gettz(\"America/Chicago\")}\n                >>> parse(\"2012-01-19 17:21:00 BRST\", tzinfos=tzinfos)\n                datetime.datetime(2012, 1, 19, 17, 21, tzinfo=tzoffset(u'BRST', -7200))\n                >>> parse(\"2012-01-19 17:21:00 CST\", tzinfos=tzinfos)\n                datetime.datetime(2012, 1, 19, 17, 21,\n                                  tzinfo=tzfile('/usr/share/zoneinfo/America/Chicago'))\n\n            This parameter is ignored if ``ignoretz`` is set.\n\n        :param \\\\*\\\\*kwargs:\n            Keyword arguments as passed to ``_parse()``.\n\n        :return:\n            Returns a :class:`datetime.datetime` object or, if the\n            ``fuzzy_with_tokens`` option is ``True``, returns a tuple, the\n            first element being a :class:`datetime.datetime` object, the second\n            a tuple containing the fuzzy tokens.\n\n        :raises ParserError:\n            Raised for invalid or unknown string format, if the provided\n            :class:`tzinfo` is not in a valid format, or if an invalid date\n            would be created.\n\n        :raises TypeError:\n            Raised for non-string or character stream input.\n\n        :raises OverflowError:\n            Raised if the parsed date exceeds the largest valid C integer on\n            your system.\n        \"\"\"\n\n        if default is None:\n            default = datetime.datetime.now().replace(hour=0, minute=0,\n                                                      second=0, microsecond=0)\n\n        res, skipped_tokens = self._parse(timestr, **kwargs)\n\n        if res is None:\n            raise ParserError(\"Unknown string format: %s\", timestr)\n\n        if len(res) == 0:\n            raise ParserError(\"String does not contain a date: %s\", timestr)\n\n        try:\n            ret = self._build_naive(res, default)\n        except ValueError as e:\n            six.raise_from(ParserError(str(e) + \": %s\", timestr), e)\n\n        if not ignoretz:\n            ret = self._build_tzaware(ret, res, tzinfos)\n\n        if kwargs.get('fuzzy_with_tokens', False):\n            return ret, skipped_tokens\n        else:\n            return ret\n\n    class _result(_resultbase):\n        __slots__ = [\"year\", \"month\", \"day\", \"weekday\",\n                     \"hour\", \"minute\", \"second\", \"microsecond\",\n                     \"tzname\", \"tzoffset\", \"ampm\",\"any_unused_tokens\"]\n\n    def _parse(self, timestr, dayfirst=None, yearfirst=None, fuzzy=False,\n               fuzzy_with_tokens=False):\n        \"\"\"\n        Private method which performs the heavy lifting of parsing, called from\n        ``parse()``, which passes on its ``kwargs`` to this function.\n\n        :param timestr:\n            The string to parse.\n\n        :param dayfirst:\n            Whether to interpret the first value in an ambiguous 3-integer date\n            (e.g. 01/05/09) as the day (``True``) or month (``False``). If\n            ``yearfirst`` is set to ``True``, this distinguishes between YDM\n            and YMD. If set to ``None``, this value is retrieved from the\n            current :class:`parserinfo` object (which itself defaults to\n            ``False``).\n\n        :param yearfirst:\n            Whether to interpret the first value in an ambiguous 3-integer date\n            (e.g. 01/05/09) as the year. If ``True``, the first number is taken\n            to be the year, otherwise the last number is taken to be the year.\n            If this is set to ``None``, the value is retrieved from the current\n            :class:`parserinfo` object (which itself defaults to ``False``).\n\n        :param fuzzy:\n            Whether to allow fuzzy parsing, allowing for string like \"Today is\n            January 1, 2047 at 8:21:00AM\".\n\n        :param fuzzy_with_tokens:\n            If ``True``, ``fuzzy`` is automatically set to True, and the parser\n            will return a tuple where the first element is the parsed\n            :class:`datetime.datetime` datetimestamp and the second element is\n            a tuple containing the portions of the string which were ignored:\n\n            .. doctest::\n\n                >>> from dateutil.parser import parse\n                >>> parse(\"Today is January 1, 2047 at 8:21:00AM\", fuzzy_with_tokens=True)\n                (datetime.datetime(2047, 1, 1, 8, 21), (u'Today is ', u' ', u'at '))\n\n        \"\"\"\n        if fuzzy_with_tokens:\n            fuzzy = True\n\n        info = self.info\n\n        if dayfirst is None:\n            dayfirst = info.dayfirst\n\n        if yearfirst is None:\n            yearfirst = info.yearfirst\n\n        res = self._result()\n        l = _timelex.split(timestr)         # Splits the timestr into tokens\n\n        skipped_idxs = []\n\n        # year/month/day list\n        ymd = _ymd()\n\n        len_l = len(l)\n        i = 0\n        try:\n            while i < len_l:\n\n                # Check if it's a number\n                value_repr = l[i]\n                try:\n                    value = float(value_repr)\n                except ValueError:\n                    value = None\n\n                if value is not None:\n                    # Numeric token\n                    i = self._parse_numeric_token(l, i, info, ymd, res, fuzzy)\n\n                # Check weekday\n                elif info.weekday(l[i]) is not None:\n                    value = info.weekday(l[i])\n                    res.weekday = value\n\n                # Check month name\n                elif info.month(l[i]) is not None:\n                    value = info.month(l[i])\n                    ymd.append(value, 'M')\n\n                    if i + 1 < len_l:\n                        if l[i + 1] in ('-', '/'):\n                            # Jan-01[-99]\n                            sep = l[i + 1]\n                            ymd.append(l[i + 2])\n\n                            if i + 3 < len_l and l[i + 3] == sep:\n                                # Jan-01-99\n                                ymd.append(l[i + 4])\n                                i += 2\n\n                            i += 2\n\n                        elif (i + 4 < len_l and l[i + 1] == l[i + 3] == ' ' and\n                              info.pertain(l[i + 2])):\n                            # Jan of 01\n                            # In this case, 01 is clearly year\n                            if l[i + 4].isdigit():\n                                # Convert it here to become unambiguous\n                                value = int(l[i + 4])\n                                year = str(info.convertyear(value))\n                                ymd.append(year, 'Y')\n                            else:\n                                # Wrong guess\n                                pass\n                                # TODO: not hit in tests\n                            i += 4\n\n                # Check am/pm\n                elif info.ampm(l[i]) is not None:\n                    value = info.ampm(l[i])\n                    val_is_ampm = self._ampm_valid(res.hour, res.ampm, fuzzy)\n\n                    if val_is_ampm:\n                        res.hour = self._adjust_ampm(res.hour, value)\n                        res.ampm = value\n\n                    elif fuzzy:\n                        skipped_idxs.append(i)\n\n                # Check for a timezone name\n                elif self._could_be_tzname(res.hour, res.tzname, res.tzoffset, l[i]):\n                    res.tzname = l[i]\n                    res.tzoffset = info.tzoffset(res.tzname)\n\n                    # Check for something like GMT+3, or BRST+3. Notice\n                    # that it doesn't mean \"I am 3 hours after GMT\", but\n                    # \"my time +3 is GMT\". If found, we reverse the\n                    # logic so that timezone parsing code will get it\n                    # right.\n                    if i + 1 < len_l and l[i + 1] in ('+', '-'):\n                        l[i + 1] = ('+', '-')[l[i + 1] == '+']\n                        res.tzoffset = None\n                        if info.utczone(res.tzname):\n                            # With something like GMT+3, the timezone\n                            # is *not* GMT.\n                            res.tzname = None\n\n                # Check for a numbered timezone\n                elif res.hour is not None and l[i] in ('+', '-'):\n                    signal = (-1, 1)[l[i] == '+']\n                    len_li = len(l[i + 1])\n\n                    # TODO: check that l[i + 1] is integer?\n                    if len_li == 4:\n                        # -0300\n                        hour_offset = int(l[i + 1][:2])\n                        min_offset = int(l[i + 1][2:])\n                    elif i + 2 < len_l and l[i + 2] == ':':\n                        # -03:00\n                        hour_offset = int(l[i + 1])\n                        min_offset = int(l[i + 3])  # TODO: Check that l[i+3] is minute-like?\n                        i += 2\n                    elif len_li <= 2:\n                        # -[0]3\n                        hour_offset = int(l[i + 1][:2])\n                        min_offset = 0\n                    else:\n                        raise ValueError(timestr)\n\n                    res.tzoffset = signal * (hour_offset * 3600 + min_offset * 60)\n\n                    # Look for a timezone name between parenthesis\n                    if (i + 5 < len_l and\n                            info.jump(l[i + 2]) and l[i + 3] == '(' and\n                            l[i + 5] == ')' and\n                            3 <= len(l[i + 4]) and\n                            self._could_be_tzname(res.hour, res.tzname,\n                                                  None, l[i + 4])):\n                        # -0300 (BRST)\n                        res.tzname = l[i + 4]\n                        i += 4\n\n                    i += 1\n\n                # Check jumps\n                elif not (info.jump(l[i]) or fuzzy):\n                    raise ValueError(timestr)\n\n                else:\n                    skipped_idxs.append(i)\n                i += 1\n\n            # Process year/month/day\n            year, month, day = ymd.resolve_ymd(yearfirst, dayfirst)\n\n            res.century_specified = ymd.century_specified\n            res.year = year\n            res.month = month\n            res.day = day\n\n        except (IndexError, ValueError):\n            return None, None\n\n        if not info.validate(res):\n            return None, None\n\n        if fuzzy_with_tokens:\n            skipped_tokens = self._recombine_skipped(l, skipped_idxs)\n            return res, tuple(skipped_tokens)\n        else:\n            return res, None\n\n    def _parse_numeric_token(self, tokens, idx, info, ymd, res, fuzzy):\n        # Token is a number\n        value_repr = tokens[idx]\n        try:\n            value = self._to_decimal(value_repr)\n        except Exception as e:\n            six.raise_from(ValueError('Unknown numeric token'), e)\n\n        len_li = len(value_repr)\n\n        len_l = len(tokens)\n\n        if (len(ymd) == 3 and len_li in (2, 4) and\n            res.hour is None and\n            (idx + 1 >= len_l or\n             (tokens[idx + 1] != ':' and\n              info.hms(tokens[idx + 1]) is None))):\n            # 19990101T23[59]\n            s = tokens[idx]\n            res.hour = int(s[:2])\n\n            if len_li == 4:\n                res.minute = int(s[2:])\n\n        elif len_li == 6 or (len_li > 6 and tokens[idx].find('.') == 6):\n            # YYMMDD or HHMMSS[.ss]\n            s = tokens[idx]\n\n            if not ymd and '.' not in tokens[idx]:\n                ymd.append(s[:2])\n                ymd.append(s[2:4])\n                ymd.append(s[4:])\n            else:\n                # 19990101T235959[.59]\n\n                # TODO: Check if res attributes already set.\n                res.hour = int(s[:2])\n                res.minute = int(s[2:4])\n                res.second, res.microsecond = self._parsems(s[4:])\n\n        elif len_li in (8, 12, 14):\n            # YYYYMMDD\n            s = tokens[idx]\n            ymd.append(s[:4], 'Y')\n            ymd.append(s[4:6])\n            ymd.append(s[6:8])\n\n            if len_li > 8:\n                res.hour = int(s[8:10])\n                res.minute = int(s[10:12])\n\n                if len_li > 12:\n                    res.second = int(s[12:])\n\n        elif self._find_hms_idx(idx, tokens, info, allow_jump=True) is not None:\n            # HH[ ]h or MM[ ]m or SS[.ss][ ]s\n            hms_idx = self._find_hms_idx(idx, tokens, info, allow_jump=True)\n            (idx, hms) = self._parse_hms(idx, tokens, info, hms_idx)\n            if hms is not None:\n                # TODO: checking that hour/minute/second are not\n                # already set?\n                self._assign_hms(res, value_repr, hms)\n\n        elif idx + 2 < len_l and tokens[idx + 1] == ':':\n            # HH:MM[:SS[.ss]]\n            res.hour = int(value)\n            value = self._to_decimal(tokens[idx + 2])  # TODO: try/except for this?\n            (res.minute, res.second) = self._parse_min_sec(value)\n\n            if idx + 4 < len_l and tokens[idx + 3] == ':':\n                res.second, res.microsecond = self._parsems(tokens[idx + 4])\n\n                idx += 2\n\n            idx += 2\n\n        elif idx + 1 < len_l and tokens[idx + 1] in ('-', '/', '.'):\n            sep = tokens[idx + 1]\n            ymd.append(value_repr)\n\n            if idx + 2 < len_l and not info.jump(tokens[idx + 2]):\n                if tokens[idx + 2].isdigit():\n                    # 01-01[-01]\n                    ymd.append(tokens[idx + 2])\n                else:\n                    # 01-Jan[-01]\n                    value = info.month(tokens[idx + 2])\n\n                    if value is not None:\n                        ymd.append(value, 'M')\n                    else:\n                        raise ValueError()\n\n                if idx + 3 < len_l and tokens[idx + 3] == sep:\n                    # We have three members\n                    value = info.month(tokens[idx + 4])\n\n                    if value is not None:\n                        ymd.append(value, 'M')\n                    else:\n                        ymd.append(tokens[idx + 4])\n                    idx += 2\n\n                idx += 1\n            idx += 1\n\n        elif idx + 1 >= len_l or info.jump(tokens[idx + 1]):\n            if idx + 2 < len_l and info.ampm(tokens[idx + 2]) is not None:\n                # 12 am\n                hour = int(value)\n                res.hour = self._adjust_ampm(hour, info.ampm(tokens[idx + 2]))\n                idx += 1\n            else:\n                # Year, month or day\n                ymd.append(value)\n            idx += 1\n\n        elif info.ampm(tokens[idx + 1]) is not None and (0 <= value < 24):\n            # 12am\n            hour = int(value)\n            res.hour = self._adjust_ampm(hour, info.ampm(tokens[idx + 1]))\n            idx += 1\n\n        elif ymd.could_be_day(value):\n            ymd.append(value)\n\n        elif not fuzzy:\n            raise ValueError()\n\n        return idx\n\n    def _find_hms_idx(self, idx, tokens, info, allow_jump):\n        len_l = len(tokens)\n\n        if idx+1 < len_l and info.hms(tokens[idx+1]) is not None:\n            # There is an \"h\", \"m\", or \"s\" label following this token.  We take\n            # assign the upcoming label to the current token.\n            # e.g. the \"12\" in 12h\"\n            hms_idx = idx + 1\n\n        elif (allow_jump and idx+2 < len_l and tokens[idx+1] == ' ' and\n              info.hms(tokens[idx+2]) is not None):\n            # There is a space and then an \"h\", \"m\", or \"s\" label.\n            # e.g. the \"12\" in \"12 h\"\n            hms_idx = idx + 2\n\n        elif idx > 0 and info.hms(tokens[idx-1]) is not None:\n            # There is a \"h\", \"m\", or \"s\" preceding this token.  Since neither\n            # of the previous cases was hit, there is no label following this\n            # token, so we use the previous label.\n            # e.g. the \"04\" in \"12h04\"\n            hms_idx = idx-1\n\n        elif (1 < idx == len_l-1 and tokens[idx-1] == ' ' and\n              info.hms(tokens[idx-2]) is not None):\n            # If we are looking at the final token, we allow for a\n            # backward-looking check to skip over a space.\n            # TODO: Are we sure this is the right condition here?\n            hms_idx = idx - 2\n\n        else:\n            hms_idx = None\n\n        return hms_idx\n\n    def _assign_hms(self, res, value_repr, hms):\n        # See GH issue #427, fixing float rounding\n        value = self._to_decimal(value_repr)\n\n        if hms == 0:\n            # Hour\n            res.hour = int(value)\n            if value % 1:\n                res.minute = int(60*(value % 1))\n\n        elif hms == 1:\n            (res.minute, res.second) = self._parse_min_sec(value)\n\n        elif hms == 2:\n            (res.second, res.microsecond) = self._parsems(value_repr)\n\n    def _could_be_tzname(self, hour, tzname, tzoffset, token):\n        return (hour is not None and\n                tzname is None and\n                tzoffset is None and\n                len(token) <= 5 and\n                (all(x in string.ascii_uppercase for x in token)\n                 or token in self.info.UTCZONE))\n\n    def _ampm_valid(self, hour, ampm, fuzzy):\n        \"\"\"\n        For fuzzy parsing, 'a' or 'am' (both valid English words)\n        may erroneously trigger the AM/PM flag. Deal with that\n        here.\n        \"\"\"\n        val_is_ampm = True\n\n        # If there's already an AM/PM flag, this one isn't one.\n        if fuzzy and ampm is not None:\n            val_is_ampm = False\n\n        # If AM/PM is found and hour is not, raise a ValueError\n        if hour is None:\n            if fuzzy:\n                val_is_ampm = False\n            else:\n                raise ValueError('No hour specified with AM or PM flag.')\n        elif not 0 <= hour <= 12:\n            # If AM/PM is found, it's a 12 hour clock, so raise\n            # an error for invalid range\n            if fuzzy:\n                val_is_ampm = False\n            else:\n                raise ValueError('Invalid hour specified for 12-hour clock.')\n\n        return val_is_ampm\n\n    def _adjust_ampm(self, hour, ampm):\n        if hour < 12 and ampm == 1:\n            hour += 12\n        elif hour == 12 and ampm == 0:\n            hour = 0\n        return hour\n\n    def _parse_min_sec(self, value):\n        # TODO: Every usage of this function sets res.second to the return\n        # value. Are there any cases where second will be returned as None and\n        # we *don't* want to set res.second = None?\n        minute = int(value)\n        second = None\n\n        sec_remainder = value % 1\n        if sec_remainder:\n            second = int(60 * sec_remainder)\n        return (minute, second)\n\n    def _parse_hms(self, idx, tokens, info, hms_idx):\n        # TODO: Is this going to admit a lot of false-positives for when we\n        # just happen to have digits and \"h\", \"m\" or \"s\" characters in non-date\n        # text?  I guess hex hashes won't have that problem, but there's plenty\n        # of random junk out there.\n        if hms_idx is None:\n            hms = None\n            new_idx = idx\n        elif hms_idx > idx:\n            hms = info.hms(tokens[hms_idx])\n            new_idx = hms_idx\n        else:\n            # Looking backwards, increment one.\n            hms = info.hms(tokens[hms_idx]) + 1\n            new_idx = idx\n\n        return (new_idx, hms)\n\n    # ------------------------------------------------------------------\n    # Handling for individual tokens.  These are kept as methods instead\n    #  of functions for the sake of customizability via subclassing.\n\n    def _parsems(self, value):\n        \"\"\"Parse a I[.F] seconds value into (seconds, microseconds).\"\"\"\n        if \".\" not in value:\n            return int(value), 0\n        else:\n            i, f = value.split(\".\")\n            return int(i), int(f.ljust(6, \"0\")[:6])\n\n    def _to_decimal(self, val):\n        try:\n            decimal_value = Decimal(val)\n            # See GH 662, edge case, infinite value should not be converted\n            #  via `_to_decimal`\n            if not decimal_value.is_finite():\n                raise ValueError(\"Converted decimal value is infinite or NaN\")\n        except Exception as e:\n            msg = \"Could not convert %s to decimal\" % val\n            six.raise_from(ValueError(msg), e)\n        else:\n            return decimal_value\n\n    # ------------------------------------------------------------------\n    # Post-Parsing construction of datetime output.  These are kept as\n    #  methods instead of functions for the sake of customizability via\n    #  subclassing.\n\n    def _build_tzinfo(self, tzinfos, tzname, tzoffset):\n        if callable(tzinfos):\n            tzdata = tzinfos(tzname, tzoffset)\n        else:\n            tzdata = tzinfos.get(tzname)\n        # handle case where tzinfo is paased an options that returns None\n        # eg tzinfos = {'BRST' : None}\n        if isinstance(tzdata, datetime.tzinfo) or tzdata is None:\n            tzinfo = tzdata\n        elif isinstance(tzdata, text_type):\n            tzinfo = tz.tzstr(tzdata)\n        elif isinstance(tzdata, integer_types):\n            tzinfo = tz.tzoffset(tzname, tzdata)\n        else:\n            raise TypeError(\"Offset must be tzinfo subclass, tz string, \"\n                            \"or int offset.\")\n        return tzinfo\n\n    def _build_tzaware(self, naive, res, tzinfos):\n        if (callable(tzinfos) or (tzinfos and res.tzname in tzinfos)):\n            tzinfo = self._build_tzinfo(tzinfos, res.tzname, res.tzoffset)\n            aware = naive.replace(tzinfo=tzinfo)\n            aware = self._assign_tzname(aware, res.tzname)\n\n        elif res.tzname and res.tzname in time.tzname:\n            aware = naive.replace(tzinfo=tz.tzlocal())\n\n            # Handle ambiguous local datetime\n            aware = self._assign_tzname(aware, res.tzname)\n\n            # This is mostly relevant for winter GMT zones parsed in the UK\n            if (aware.tzname() != res.tzname and\n                    res.tzname in self.info.UTCZONE):\n                aware = aware.replace(tzinfo=tz.UTC)\n\n        elif res.tzoffset == 0:\n            aware = naive.replace(tzinfo=tz.UTC)\n\n        elif res.tzoffset:\n            aware = naive.replace(tzinfo=tz.tzoffset(res.tzname, res.tzoffset))\n\n        elif not res.tzname and not res.tzoffset:\n            # i.e. no timezone information was found.\n            aware = naive\n\n        elif res.tzname:\n            # tz-like string was parsed but we don't know what to do\n            # with it\n            warnings.warn(\"tzname {tzname} identified but not understood.  \"\n                          \"Pass `tzinfos` argument in order to correctly \"\n                          \"return a timezone-aware datetime.  In a future \"\n                          \"version, this will raise an \"\n                          \"exception.\".format(tzname=res.tzname),\n                          category=UnknownTimezoneWarning)\n            aware = naive\n\n        return aware\n\n    def _build_naive(self, res, default):\n        repl = {}\n        for attr in (\"year\", \"month\", \"day\", \"hour\",\n                     \"minute\", \"second\", \"microsecond\"):\n            value = getattr(res, attr)\n            if value is not None:\n                repl[attr] = value\n\n        if 'day' not in repl:\n            # If the default day exceeds the last day of the month, fall back\n            # to the end of the month.\n            cyear = default.year if res.year is None else res.year\n            cmonth = default.month if res.month is None else res.month\n            cday = default.day if res.day is None else res.day\n\n            if cday > monthrange(cyear, cmonth)[1]:\n                repl['day'] = monthrange(cyear, cmonth)[1]\n\n        naive = default.replace(**repl)\n\n        if res.weekday is not None and not res.day:\n            naive = naive + relativedelta.relativedelta(weekday=res.weekday)\n\n        return naive\n\n    def _assign_tzname(self, dt, tzname):\n        if dt.tzname() != tzname:\n            new_dt = tz.enfold(dt, fold=1)\n            if new_dt.tzname() == tzname:\n                return new_dt\n\n        return dt\n\n    def _recombine_skipped(self, tokens, skipped_idxs):\n        \"\"\"\n        >>> tokens = [\"foo\", \" \", \"bar\", \" \", \"19June2000\", \"baz\"]\n        >>> skipped_idxs = [0, 1, 2, 5]\n        >>> _recombine_skipped(tokens, skipped_idxs)\n        [\"foo bar\", \"baz\"]\n        \"\"\"\n        skipped_tokens = []\n        for i, idx in enumerate(sorted(skipped_idxs)):\n            if i > 0 and idx - 1 == skipped_idxs[i - 1]:\n                skipped_tokens[-1] = skipped_tokens[-1] + tokens[idx]\n            else:\n                skipped_tokens.append(tokens[idx])\n\n        return skipped_tokens\n\n\nDEFAULTPARSER = parser()\n\n\ndef parse(timestr, parserinfo=None, **kwargs):\n    \"\"\"\n\n    Parse a string in one of the supported formats, using the\n    ``parserinfo`` parameters.\n\n    :param timestr:\n        A string containing a date/time stamp.\n\n    :param parserinfo:\n        A :class:`parserinfo` object containing parameters for the parser.\n        If ``None``, the default arguments to the :class:`parserinfo`\n        constructor are used.\n\n    The ``**kwargs`` parameter takes the following keyword arguments:\n\n    :param default:\n        The default datetime object, if this is a datetime object and not\n        ``None``, elements specified in ``timestr`` replace elements in the\n        default object.\n\n    :param ignoretz:\n        If set ``True``, time zones in parsed strings are ignored and a naive\n        :class:`datetime` object is returned.\n\n    :param tzinfos:\n        Additional time zone names / aliases which may be present in the\n        string. This argument maps time zone names (and optionally offsets\n        from those time zones) to time zones. This parameter can be a\n        dictionary with timezone aliases mapping time zone names to time\n        zones or a function taking two parameters (``tzname`` and\n        ``tzoffset``) and returning a time zone.\n\n        The timezones to which the names are mapped can be an integer\n        offset from UTC in seconds or a :class:`tzinfo` object.\n\n        .. doctest::\n           :options: +NORMALIZE_WHITESPACE\n\n            >>> from dateutil.parser import parse\n            >>> from dateutil.tz import gettz\n            >>> tzinfos = {\"BRST\": -7200, \"CST\": gettz(\"America/Chicago\")}\n            >>> parse(\"2012-01-19 17:21:00 BRST\", tzinfos=tzinfos)\n            datetime.datetime(2012, 1, 19, 17, 21, tzinfo=tzoffset(u'BRST', -7200))\n            >>> parse(\"2012-01-19 17:21:00 CST\", tzinfos=tzinfos)\n            datetime.datetime(2012, 1, 19, 17, 21,\n                              tzinfo=tzfile('/usr/share/zoneinfo/America/Chicago'))\n\n        This parameter is ignored if ``ignoretz`` is set.\n\n    :param dayfirst:\n        Whether to interpret the first value in an ambiguous 3-integer date\n        (e.g. 01/05/09) as the day (``True``) or month (``False``). If\n        ``yearfirst`` is set to ``True``, this distinguishes between YDM and\n        YMD. If set to ``None``, this value is retrieved from the current\n        :class:`parserinfo` object (which itself defaults to ``False``).\n\n    :param yearfirst:\n        Whether to interpret the first value in an ambiguous 3-integer date\n        (e.g. 01/05/09) as the year. If ``True``, the first number is taken to\n        be the year, otherwise the last number is taken to be the year. If\n        this is set to ``None``, the value is retrieved from the current\n        :class:`parserinfo` object (which itself defaults to ``False``).\n\n    :param fuzzy:\n        Whether to allow fuzzy parsing, allowing for string like \"Today is\n        January 1, 2047 at 8:21:00AM\".\n\n    :param fuzzy_with_tokens:\n        If ``True``, ``fuzzy`` is automatically set to True, and the parser\n        will return a tuple where the first element is the parsed\n        :class:`datetime.datetime` datetimestamp and the second element is\n        a tuple containing the portions of the string which were ignored:\n\n        .. doctest::\n\n            >>> from dateutil.parser import parse\n            >>> parse(\"Today is January 1, 2047 at 8:21:00AM\", fuzzy_with_tokens=True)\n            (datetime.datetime(2047, 1, 1, 8, 21), (u'Today is ', u' ', u'at '))\n\n    :return:\n        Returns a :class:`datetime.datetime` object or, if the\n        ``fuzzy_with_tokens`` option is ``True``, returns a tuple, the\n        first element being a :class:`datetime.datetime` object, the second\n        a tuple containing the fuzzy tokens.\n\n    :raises ParserError:\n        Raised for invalid or unknown string formats, if the provided\n        :class:`tzinfo` is not in a valid format, or if an invalid date would\n        be created.\n\n    :raises OverflowError:\n        Raised if the parsed date exceeds the largest valid C integer on\n        your system.\n    \"\"\"\n    if parserinfo:\n        return parser(parserinfo).parse(timestr, **kwargs)\n    else:\n        return DEFAULTPARSER.parse(timestr, **kwargs)\n\n\nclass _tzparser(object):\n\n    class _result(_resultbase):\n\n        __slots__ = [\"stdabbr\", \"stdoffset\", \"dstabbr\", \"dstoffset\",\n                     \"start\", \"end\"]\n\n        class _attr(_resultbase):\n            __slots__ = [\"month\", \"week\", \"weekday\",\n                         \"yday\", \"jyday\", \"day\", \"time\"]\n\n        def __repr__(self):\n            return self._repr(\"\")\n\n        def __init__(self):\n            _resultbase.__init__(self)\n            self.start = self._attr()\n            self.end = self._attr()\n\n    def parse(self, tzstr):\n        res = self._result()\n        l = [x for x in re.split(r'([,:.]|[a-zA-Z]+|[0-9]+)',tzstr) if x]\n        used_idxs = list()\n        try:\n\n            len_l = len(l)\n\n            i = 0\n            while i < len_l:\n                # BRST+3[BRDT[+2]]\n                j = i\n                while j < len_l and not [x for x in l[j]\n                                         if x in \"0123456789:,-+\"]:\n                    j += 1\n                if j != i:\n                    if not res.stdabbr:\n                        offattr = \"stdoffset\"\n                        res.stdabbr = \"\".join(l[i:j])\n                    else:\n                        offattr = \"dstoffset\"\n                        res.dstabbr = \"\".join(l[i:j])\n\n                    for ii in range(j):\n                        used_idxs.append(ii)\n                    i = j\n                    if (i < len_l and (l[i] in ('+', '-') or l[i][0] in\n                                       \"0123456789\")):\n                        if l[i] in ('+', '-'):\n                            # Yes, that's right.  See the TZ variable\n                            # documentation.\n                            signal = (1, -1)[l[i] == '+']\n                            used_idxs.append(i)\n                            i += 1\n                        else:\n                            signal = -1\n                        len_li = len(l[i])\n                        if len_li == 4:\n                            # -0300\n                            setattr(res, offattr, (int(l[i][:2]) * 3600 +\n                                                   int(l[i][2:]) * 60) * signal)\n                        elif i + 1 < len_l and l[i + 1] == ':':\n                            # -03:00\n                            setattr(res, offattr,\n                                    (int(l[i]) * 3600 +\n                                     int(l[i + 2]) * 60) * signal)\n                            used_idxs.append(i)\n                            i += 2\n                        elif len_li <= 2:\n                            # -[0]3\n                            setattr(res, offattr,\n                                    int(l[i][:2]) * 3600 * signal)\n                        else:\n                            return None\n                        used_idxs.append(i)\n                        i += 1\n                    if res.dstabbr:\n                        break\n                else:\n                    break\n\n\n            if i < len_l:\n                for j in range(i, len_l):\n                    if l[j] == ';':\n                        l[j] = ','\n\n                assert l[i] == ','\n\n                i += 1\n\n            if i >= len_l:\n                pass\n            elif (8 <= l.count(',') <= 9 and\n                  not [y for x in l[i:] if x != ','\n                       for y in x if y not in \"0123456789+-\"]):\n                # GMT0BST,3,0,30,3600,10,0,26,7200[,3600]\n                for x in (res.start, res.end):\n                    x.month = int(l[i])\n                    used_idxs.append(i)\n                    i += 2\n                    if l[i] == '-':\n                        value = int(l[i + 1]) * -1\n                        used_idxs.append(i)\n                        i += 1\n                    else:\n                        value = int(l[i])\n                    used_idxs.append(i)\n                    i += 2\n                    if value:\n                        x.week = value\n                        x.weekday = (int(l[i]) - 1) % 7\n                    else:\n                        x.day = int(l[i])\n                    used_idxs.append(i)\n                    i += 2\n                    x.time = int(l[i])\n                    used_idxs.append(i)\n                    i += 2\n                if i < len_l:\n                    if l[i] in ('-', '+'):\n                        signal = (-1, 1)[l[i] == \"+\"]\n                        used_idxs.append(i)\n                        i += 1\n                    else:\n                        signal = 1\n                    used_idxs.append(i)\n                    res.dstoffset = (res.stdoffset + int(l[i]) * signal)\n\n                # This was a made-up format that is not in normal use\n                warn(('Parsed time zone \"%s\"' % tzstr) +\n                     'is in a non-standard dateutil-specific format, which ' +\n                     'is now deprecated; support for parsing this format ' +\n                     'will be removed in future versions. It is recommended ' +\n                     'that you switch to a standard format like the GNU ' +\n                     'TZ variable format.', tz.DeprecatedTzFormatWarning)\n            elif (l.count(',') == 2 and l[i:].count('/') <= 2 and\n                  not [y for x in l[i:] if x not in (',', '/', 'J', 'M',\n                                                     '.', '-', ':')\n                       for y in x if y not in \"0123456789\"]):\n                for x in (res.start, res.end):\n                    if l[i] == 'J':\n                        # non-leap year day (1 based)\n                        used_idxs.append(i)\n                        i += 1\n                        x.jyday = int(l[i])\n                    elif l[i] == 'M':\n                        # month[-.]week[-.]weekday\n                        used_idxs.append(i)\n                        i += 1\n                        x.month = int(l[i])\n                        used_idxs.append(i)\n                        i += 1\n                        assert l[i] in ('-', '.')\n                        used_idxs.append(i)\n                        i += 1\n                        x.week = int(l[i])\n                        if x.week == 5:\n                            x.week = -1\n                        used_idxs.append(i)\n                        i += 1\n                        assert l[i] in ('-', '.')\n                        used_idxs.append(i)\n                        i += 1\n                        x.weekday = (int(l[i]) - 1) % 7\n                    else:\n                        # year day (zero based)\n                        x.yday = int(l[i]) + 1\n\n                    used_idxs.append(i)\n                    i += 1\n\n                    if i < len_l and l[i] == '/':\n                        used_idxs.append(i)\n                        i += 1\n                        # start time\n                        len_li = len(l[i])\n                        if len_li == 4:\n                            # -0300\n                            x.time = (int(l[i][:2]) * 3600 +\n                                      int(l[i][2:]) * 60)\n                        elif i + 1 < len_l and l[i + 1] == ':':\n                            # -03:00\n                            x.time = int(l[i]) * 3600 + int(l[i + 2]) * 60\n                            used_idxs.append(i)\n                            i += 2\n                            if i + 1 < len_l and l[i + 1] == ':':\n                                used_idxs.append(i)\n                                i += 2\n                                x.time += int(l[i])\n                        elif len_li <= 2:\n                            # -[0]3\n                            x.time = (int(l[i][:2]) * 3600)\n                        else:\n                            return None\n                        used_idxs.append(i)\n                        i += 1\n\n                    assert i == len_l or l[i] == ','\n\n                    i += 1\n\n                assert i >= len_l\n\n        except (IndexError, ValueError, AssertionError):\n            return None\n\n        unused_idxs = set(range(len_l)).difference(used_idxs)\n        res.any_unused_tokens = not {l[n] for n in unused_idxs}.issubset({\",\",\":\"})\n        return res\n\n\nDEFAULTTZPARSER = _tzparser()\n\n\ndef _parsetz(tzstr):\n    return DEFAULTTZPARSER.parse(tzstr)\n\n\nclass ParserError(ValueError):\n    \"\"\"Exception subclass used for any failure to parse a datetime string.\n\n    This is a subclass of :py:exc:`ValueError`, and should be raised any time\n    earlier versions of ``dateutil`` would have raised ``ValueError``.\n\n    .. versionadded:: 2.8.1\n    \"\"\"\n    def __str__(self):\n        try:\n            return self.args[0] % self.args[1:]\n        except (TypeError, IndexError):\n            return super(ParserError, self).__str__()\n\n    def __repr__(self):\n        args = \", \".join(\"'%s'\" % arg for arg in self.args)\n        return \"%s(%s)\" % (self.__class__.__name__, args)\n\n\nclass UnknownTimezoneWarning(RuntimeWarning):\n    \"\"\"Raised when the parser finds a timezone it cannot parse into a tzinfo.\n\n    .. versionadded:: 2.7.0\n    \"\"\"\n# vim:ts=4:sw=4:et\n", "src/dateutil/parser/__init__.py": "# -*- coding: utf-8 -*-\nfrom ._parser import parse, parser, parserinfo, ParserError\nfrom ._parser import DEFAULTPARSER, DEFAULTTZPARSER\nfrom ._parser import UnknownTimezoneWarning\n\nfrom ._parser import __doc__\n\nfrom .isoparser import isoparser, isoparse\n\n__all__ = ['parse', 'parser', 'parserinfo',\n           'isoparse', 'isoparser',\n           'ParserError',\n           'UnknownTimezoneWarning']\n\n\n###\n# Deprecate portions of the private interface so that downstream code that\n# is improperly relying on it is given *some* notice.\n\n\ndef __deprecated_private_func(f):\n    from functools import wraps\n    import warnings\n\n    msg = ('{name} is a private function and may break without warning, '\n           'it will be moved and or renamed in future versions.')\n    msg = msg.format(name=f.__name__)\n\n    @wraps(f)\n    def deprecated_func(*args, **kwargs):\n        warnings.warn(msg, DeprecationWarning)\n        return f(*args, **kwargs)\n\n    return deprecated_func\n\ndef __deprecate_private_class(c):\n    import warnings\n\n    msg = ('{name} is a private class and may break without warning, '\n           'it will be moved and or renamed in future versions.')\n    msg = msg.format(name=c.__name__)\n\n    class private_class(c):\n        __doc__ = c.__doc__\n\n        def __init__(self, *args, **kwargs):\n            warnings.warn(msg, DeprecationWarning)\n            super(private_class, self).__init__(*args, **kwargs)\n\n    private_class.__name__ = c.__name__\n\n    return private_class\n\n\nfrom ._parser import _timelex, _resultbase\nfrom ._parser import _tzparser, _parsetz\n\n_timelex = __deprecate_private_class(_timelex)\n_tzparser = __deprecate_private_class(_tzparser)\n_resultbase = __deprecate_private_class(_resultbase)\n_parsetz = __deprecated_private_func(_parsetz)\n", "src/dateutil/parser/isoparser.py": "# -*- coding: utf-8 -*-\n\"\"\"\nThis module offers a parser for ISO-8601 strings\n\nIt is intended to support all valid date, time and datetime formats per the\nISO-8601 specification.\n\n..versionadded:: 2.7.0\n\"\"\"\nfrom datetime import datetime, timedelta, time, date\nimport calendar\nfrom dateutil import tz\n\nfrom functools import wraps\n\nimport re\nimport six\n\n__all__ = [\"isoparse\", \"isoparser\"]\n\n\ndef _takes_ascii(f):\n    @wraps(f)\n    def func(self, str_in, *args, **kwargs):\n        # If it's a stream, read the whole thing\n        str_in = getattr(str_in, 'read', lambda: str_in)()\n\n        # If it's unicode, turn it into bytes, since ISO-8601 only covers ASCII\n        if isinstance(str_in, six.text_type):\n            # ASCII is the same in UTF-8\n            try:\n                str_in = str_in.encode('ascii')\n            except UnicodeEncodeError as e:\n                msg = 'ISO-8601 strings should contain only ASCII characters'\n                six.raise_from(ValueError(msg), e)\n\n        return f(self, str_in, *args, **kwargs)\n\n    return func\n\n\nclass isoparser(object):\n    def __init__(self, sep=None):\n        \"\"\"\n        :param sep:\n            A single character that separates date and time portions. If\n            ``None``, the parser will accept any single character.\n            For strict ISO-8601 adherence, pass ``'T'``.\n        \"\"\"\n        if sep is not None:\n            if (len(sep) != 1 or ord(sep) >= 128 or sep in '0123456789'):\n                raise ValueError('Separator must be a single, non-numeric ' +\n                                 'ASCII character')\n\n            sep = sep.encode('ascii')\n\n        self._sep = sep\n\n    @_takes_ascii\n    def isoparse(self, dt_str):\n        \"\"\"\n        Parse an ISO-8601 datetime string into a :class:`datetime.datetime`.\n\n        An ISO-8601 datetime string consists of a date portion, followed\n        optionally by a time portion - the date and time portions are separated\n        by a single character separator, which is ``T`` in the official\n        standard. Incomplete date formats (such as ``YYYY-MM``) may *not* be\n        combined with a time portion.\n\n        Supported date formats are:\n\n        Common:\n\n        - ``YYYY``\n        - ``YYYY-MM``\n        - ``YYYY-MM-DD`` or ``YYYYMMDD``\n\n        Uncommon:\n\n        - ``YYYY-Www`` or ``YYYYWww`` - ISO week (day defaults to 0)\n        - ``YYYY-Www-D`` or ``YYYYWwwD`` - ISO week and day\n\n        The ISO week and day numbering follows the same logic as\n        :func:`datetime.date.isocalendar`.\n\n        Supported time formats are:\n\n        - ``hh``\n        - ``hh:mm`` or ``hhmm``\n        - ``hh:mm:ss`` or ``hhmmss``\n        - ``hh:mm:ss.ssssss`` (Up to 6 sub-second digits)\n\n        Midnight is a special case for `hh`, as the standard supports both\n        00:00 and 24:00 as a representation. The decimal separator can be\n        either a dot or a comma.\n\n\n        .. caution::\n\n            Support for fractional components other than seconds is part of the\n            ISO-8601 standard, but is not currently implemented in this parser.\n\n        Supported time zone offset formats are:\n\n        - `Z` (UTC)\n        - `\u00b1HH:MM`\n        - `\u00b1HHMM`\n        - `\u00b1HH`\n\n        Offsets will be represented as :class:`dateutil.tz.tzoffset` objects,\n        with the exception of UTC, which will be represented as\n        :class:`dateutil.tz.tzutc`. Time zone offsets equivalent to UTC (such\n        as `+00:00`) will also be represented as :class:`dateutil.tz.tzutc`.\n\n        :param dt_str:\n            A string or stream containing only an ISO-8601 datetime string\n\n        :return:\n            Returns a :class:`datetime.datetime` representing the string.\n            Unspecified components default to their lowest value.\n\n        .. warning::\n\n            As of version 2.7.0, the strictness of the parser should not be\n            considered a stable part of the contract. Any valid ISO-8601 string\n            that parses correctly with the default settings will continue to\n            parse correctly in future versions, but invalid strings that\n            currently fail (e.g. ``2017-01-01T00:00+00:00:00``) are not\n            guaranteed to continue failing in future versions if they encode\n            a valid date.\n\n        .. versionadded:: 2.7.0\n        \"\"\"\n        components, pos = self._parse_isodate(dt_str)\n\n        if len(dt_str) > pos:\n            if self._sep is None or dt_str[pos:pos + 1] == self._sep:\n                components += self._parse_isotime(dt_str[pos + 1:])\n            else:\n                raise ValueError('String contains unknown ISO components')\n\n        if len(components) > 3 and components[3] == 24:\n            components[3] = 0\n            return datetime(*components) + timedelta(days=1)\n\n        return datetime(*components)\n\n    @_takes_ascii\n    def parse_isodate(self, datestr):\n        \"\"\"\n        Parse the date portion of an ISO string.\n\n        :param datestr:\n            The string portion of an ISO string, without a separator\n\n        :return:\n            Returns a :class:`datetime.date` object\n        \"\"\"\n        components, pos = self._parse_isodate(datestr)\n        if pos < len(datestr):\n            raise ValueError('String contains unknown ISO ' +\n                             'components: {!r}'.format(datestr.decode('ascii')))\n        return date(*components)\n\n    @_takes_ascii\n    def parse_isotime(self, timestr):\n        \"\"\"\n        Parse the time portion of an ISO string.\n\n        :param timestr:\n            The time portion of an ISO string, without a separator\n\n        :return:\n            Returns a :class:`datetime.time` object\n        \"\"\"\n        components = self._parse_isotime(timestr)\n        if components[0] == 24:\n            components[0] = 0\n        return time(*components)\n\n    @_takes_ascii\n    def parse_tzstr(self, tzstr, zero_as_utc=True):\n        \"\"\"\n        Parse a valid ISO time zone string.\n\n        See :func:`isoparser.isoparse` for details on supported formats.\n\n        :param tzstr:\n            A string representing an ISO time zone offset\n\n        :param zero_as_utc:\n            Whether to return :class:`dateutil.tz.tzutc` for zero-offset zones\n\n        :return:\n            Returns :class:`dateutil.tz.tzoffset` for offsets and\n            :class:`dateutil.tz.tzutc` for ``Z`` and (if ``zero_as_utc`` is\n            specified) offsets equivalent to UTC.\n        \"\"\"\n        return self._parse_tzstr(tzstr, zero_as_utc=zero_as_utc)\n\n    # Constants\n    _DATE_SEP = b'-'\n    _TIME_SEP = b':'\n    _FRACTION_REGEX = re.compile(b'[\\\\.,]([0-9]+)')\n\n    def _parse_isodate(self, dt_str):\n        try:\n            return self._parse_isodate_common(dt_str)\n        except ValueError:\n            return self._parse_isodate_uncommon(dt_str)\n\n    def _parse_isodate_common(self, dt_str):\n        len_str = len(dt_str)\n        components = [1, 1, 1]\n\n        if len_str < 4:\n            raise ValueError('ISO string too short')\n\n        # Year\n        components[0] = int(dt_str[0:4])\n        pos = 4\n        if pos >= len_str:\n            return components, pos\n\n        has_sep = dt_str[pos:pos + 1] == self._DATE_SEP\n        if has_sep:\n            pos += 1\n\n        # Month\n        if len_str - pos < 2:\n            raise ValueError('Invalid common month')\n\n        components[1] = int(dt_str[pos:pos + 2])\n        pos += 2\n\n        if pos >= len_str:\n            if has_sep:\n                return components, pos\n            else:\n                raise ValueError('Invalid ISO format')\n\n        if has_sep:\n            if dt_str[pos:pos + 1] != self._DATE_SEP:\n                raise ValueError('Invalid separator in ISO string')\n            pos += 1\n\n        # Day\n        if len_str - pos < 2:\n            raise ValueError('Invalid common day')\n        components[2] = int(dt_str[pos:pos + 2])\n        return components, pos + 2\n\n    def _parse_isodate_uncommon(self, dt_str):\n        if len(dt_str) < 4:\n            raise ValueError('ISO string too short')\n\n        # All ISO formats start with the year\n        year = int(dt_str[0:4])\n\n        has_sep = dt_str[4:5] == self._DATE_SEP\n\n        pos = 4 + has_sep       # Skip '-' if it's there\n        if dt_str[pos:pos + 1] == b'W':\n            # YYYY-?Www-?D?\n            pos += 1\n            weekno = int(dt_str[pos:pos + 2])\n            pos += 2\n\n            dayno = 1\n            if len(dt_str) > pos:\n                if (dt_str[pos:pos + 1] == self._DATE_SEP) != has_sep:\n                    raise ValueError('Inconsistent use of dash separator')\n\n                pos += has_sep\n\n                dayno = int(dt_str[pos:pos + 1])\n                pos += 1\n\n            base_date = self._calculate_weekdate(year, weekno, dayno)\n        else:\n            # YYYYDDD or YYYY-DDD\n            if len(dt_str) - pos < 3:\n                raise ValueError('Invalid ordinal day')\n\n            ordinal_day = int(dt_str[pos:pos + 3])\n            pos += 3\n\n            if ordinal_day < 1 or ordinal_day > (365 + calendar.isleap(year)):\n                raise ValueError('Invalid ordinal day' +\n                                 ' {} for year {}'.format(ordinal_day, year))\n\n            base_date = date(year, 1, 1) + timedelta(days=ordinal_day - 1)\n\n        components = [base_date.year, base_date.month, base_date.day]\n        return components, pos\n\n    def _calculate_weekdate(self, year, week, day):\n        \"\"\"\n        Calculate the day of corresponding to the ISO year-week-day calendar.\n\n        This function is effectively the inverse of\n        :func:`datetime.date.isocalendar`.\n\n        :param year:\n            The year in the ISO calendar\n\n        :param week:\n            The week in the ISO calendar - range is [1, 53]\n\n        :param day:\n            The day in the ISO calendar - range is [1 (MON), 7 (SUN)]\n\n        :return:\n            Returns a :class:`datetime.date`\n        \"\"\"\n        if not 0 < week < 54:\n            raise ValueError('Invalid week: {}'.format(week))\n\n        if not 0 < day < 8:     # Range is 1-7\n            raise ValueError('Invalid weekday: {}'.format(day))\n\n        # Get week 1 for the specific year:\n        jan_4 = date(year, 1, 4)   # Week 1 always has January 4th in it\n        week_1 = jan_4 - timedelta(days=jan_4.isocalendar()[2] - 1)\n\n        # Now add the specific number of weeks and days to get what we want\n        week_offset = (week - 1) * 7 + (day - 1)\n        return week_1 + timedelta(days=week_offset)\n\n    def _parse_isotime(self, timestr):\n        len_str = len(timestr)\n        components = [0, 0, 0, 0, None]\n        pos = 0\n        comp = -1\n\n        if len_str < 2:\n            raise ValueError('ISO time too short')\n\n        has_sep = False\n\n        while pos < len_str and comp < 5:\n            comp += 1\n\n            if timestr[pos:pos + 1] in b'-+Zz':\n                # Detect time zone boundary\n                components[-1] = self._parse_tzstr(timestr[pos:])\n                pos = len_str\n                break\n\n            if comp == 1 and timestr[pos:pos+1] == self._TIME_SEP:\n                has_sep = True\n                pos += 1\n            elif comp == 2 and has_sep:\n                if timestr[pos:pos+1] != self._TIME_SEP:\n                    raise ValueError('Inconsistent use of colon separator')\n                pos += 1\n\n            if comp < 3:\n                # Hour, minute, second\n                components[comp] = int(timestr[pos:pos + 2])\n                pos += 2\n\n            if comp == 3:\n                # Fraction of a second\n                frac = self._FRACTION_REGEX.match(timestr[pos:])\n                if not frac:\n                    continue\n\n                us_str = frac.group(1)[:6]  # Truncate to microseconds\n                components[comp] = int(us_str) * 10**(6 - len(us_str))\n                pos += len(frac.group())\n\n        if pos < len_str:\n            raise ValueError('Unused components in ISO string')\n\n        if components[0] == 24:\n            # Standard supports 00:00 and 24:00 as representations of midnight\n            if any(component != 0 for component in components[1:4]):\n                raise ValueError('Hour may only be 24 at 24:00:00.000')\n\n        return components\n\n    def _parse_tzstr(self, tzstr, zero_as_utc=True):\n        if tzstr == b'Z' or tzstr == b'z':\n            return tz.UTC\n\n        if len(tzstr) not in {3, 5, 6}:\n            raise ValueError('Time zone offset must be 1, 3, 5 or 6 characters')\n\n        if tzstr[0:1] == b'-':\n            mult = -1\n        elif tzstr[0:1] == b'+':\n            mult = 1\n        else:\n            raise ValueError('Time zone offset requires sign')\n\n        hours = int(tzstr[1:3])\n        if len(tzstr) == 3:\n            minutes = 0\n        else:\n            minutes = int(tzstr[(4 if tzstr[3:4] == self._TIME_SEP else 3):])\n\n        if zero_as_utc and hours == 0 and minutes == 0:\n            return tz.UTC\n        else:\n            if minutes > 59:\n                raise ValueError('Invalid minutes in time zone offset')\n\n            if hours > 23:\n                raise ValueError('Invalid hours in time zone offset')\n\n            return tz.tzoffset(None, mult * (hours * 60 + minutes) * 60)\n\n\nDEFAULT_ISOPARSER = isoparser()\nisoparse = DEFAULT_ISOPARSER.isoparse\n", "src/dateutil/tz/_common.py": "from six import PY2\n\nfrom functools import wraps\n\nfrom datetime import datetime, timedelta, tzinfo\n\n\nZERO = timedelta(0)\n\n__all__ = ['tzname_in_python2', 'enfold']\n\n\ndef tzname_in_python2(namefunc):\n    \"\"\"Change unicode output into bytestrings in Python 2\n\n    tzname() API changed in Python 3. It used to return bytes, but was changed\n    to unicode strings\n    \"\"\"\n    if PY2:\n        @wraps(namefunc)\n        def adjust_encoding(*args, **kwargs):\n            name = namefunc(*args, **kwargs)\n            if name is not None:\n                name = name.encode()\n\n            return name\n\n        return adjust_encoding\n    else:\n        return namefunc\n\n\n# The following is adapted from Alexander Belopolsky's tz library\n# https://github.com/abalkin/tz\nif hasattr(datetime, 'fold'):\n    # This is the pre-python 3.6 fold situation\n    def enfold(dt, fold=1):\n        \"\"\"\n        Provides a unified interface for assigning the ``fold`` attribute to\n        datetimes both before and after the implementation of PEP-495.\n\n        :param fold:\n            The value for the ``fold`` attribute in the returned datetime. This\n            should be either 0 or 1.\n\n        :return:\n            Returns an object for which ``getattr(dt, 'fold', 0)`` returns\n            ``fold`` for all versions of Python. In versions prior to\n            Python 3.6, this is a ``_DatetimeWithFold`` object, which is a\n            subclass of :py:class:`datetime.datetime` with the ``fold``\n            attribute added, if ``fold`` is 1.\n\n        .. versionadded:: 2.6.0\n        \"\"\"\n        return dt.replace(fold=fold)\n\nelse:\n    class _DatetimeWithFold(datetime):\n        \"\"\"\n        This is a class designed to provide a PEP 495-compliant interface for\n        Python versions before 3.6. It is used only for dates in a fold, so\n        the ``fold`` attribute is fixed at ``1``.\n\n        .. versionadded:: 2.6.0\n        \"\"\"\n        __slots__ = ()\n\n        def replace(self, *args, **kwargs):\n            \"\"\"\n            Return a datetime with the same attributes, except for those\n            attributes given new values by whichever keyword arguments are\n            specified. Note that tzinfo=None can be specified to create a naive\n            datetime from an aware datetime with no conversion of date and time\n            data.\n\n            This is reimplemented in ``_DatetimeWithFold`` because pypy3 will\n            return a ``datetime.datetime`` even if ``fold`` is unchanged.\n            \"\"\"\n            argnames = (\n                'year', 'month', 'day', 'hour', 'minute', 'second',\n                'microsecond', 'tzinfo'\n            )\n\n            for arg, argname in zip(args, argnames):\n                if argname in kwargs:\n                    raise TypeError('Duplicate argument: {}'.format(argname))\n\n                kwargs[argname] = arg\n\n            for argname in argnames:\n                if argname not in kwargs:\n                    kwargs[argname] = getattr(self, argname)\n\n            dt_class = self.__class__ if kwargs.get('fold', 1) else datetime\n\n            return dt_class(**kwargs)\n\n        @property\n        def fold(self):\n            return 1\n\n    def enfold(dt, fold=1):\n        \"\"\"\n        Provides a unified interface for assigning the ``fold`` attribute to\n        datetimes both before and after the implementation of PEP-495.\n\n        :param fold:\n            The value for the ``fold`` attribute in the returned datetime. This\n            should be either 0 or 1.\n\n        :return:\n            Returns an object for which ``getattr(dt, 'fold', 0)`` returns\n            ``fold`` for all versions of Python. In versions prior to\n            Python 3.6, this is a ``_DatetimeWithFold`` object, which is a\n            subclass of :py:class:`datetime.datetime` with the ``fold``\n            attribute added, if ``fold`` is 1.\n\n        .. versionadded:: 2.6.0\n        \"\"\"\n        if getattr(dt, 'fold', 0) == fold:\n            return dt\n\n        args = dt.timetuple()[:6]\n        args += (dt.microsecond, dt.tzinfo)\n\n        if fold:\n            return _DatetimeWithFold(*args)\n        else:\n            return datetime(*args)\n\n\ndef _validate_fromutc_inputs(f):\n    \"\"\"\n    The CPython version of ``fromutc`` checks that the input is a ``datetime``\n    object and that ``self`` is attached as its ``tzinfo``.\n    \"\"\"\n    @wraps(f)\n    def fromutc(self, dt):\n        if not isinstance(dt, datetime):\n            raise TypeError(\"fromutc() requires a datetime argument\")\n        if dt.tzinfo is not self:\n            raise ValueError(\"dt.tzinfo is not self\")\n\n        return f(self, dt)\n\n    return fromutc\n\n\nclass _tzinfo(tzinfo):\n    \"\"\"\n    Base class for all ``dateutil`` ``tzinfo`` objects.\n    \"\"\"\n\n    def is_ambiguous(self, dt):\n        \"\"\"\n        Whether or not the \"wall time\" of a given datetime is ambiguous in this\n        zone.\n\n        :param dt:\n            A :py:class:`datetime.datetime`, naive or time zone aware.\n\n\n        :return:\n            Returns ``True`` if ambiguous, ``False`` otherwise.\n\n        .. versionadded:: 2.6.0\n        \"\"\"\n\n        dt = dt.replace(tzinfo=self)\n\n        wall_0 = enfold(dt, fold=0)\n        wall_1 = enfold(dt, fold=1)\n\n        same_offset = wall_0.utcoffset() == wall_1.utcoffset()\n        same_dt = wall_0.replace(tzinfo=None) == wall_1.replace(tzinfo=None)\n\n        return same_dt and not same_offset\n\n    def _fold_status(self, dt_utc, dt_wall):\n        \"\"\"\n        Determine the fold status of a \"wall\" datetime, given a representation\n        of the same datetime as a (naive) UTC datetime. This is calculated based\n        on the assumption that ``dt.utcoffset() - dt.dst()`` is constant for all\n        datetimes, and that this offset is the actual number of hours separating\n        ``dt_utc`` and ``dt_wall``.\n\n        :param dt_utc:\n            Representation of the datetime as UTC\n\n        :param dt_wall:\n            Representation of the datetime as \"wall time\". This parameter must\n            either have a `fold` attribute or have a fold-naive\n            :class:`datetime.tzinfo` attached, otherwise the calculation may\n            fail.\n        \"\"\"\n        if self.is_ambiguous(dt_wall):\n            delta_wall = dt_wall - dt_utc\n            _fold = int(delta_wall == (dt_utc.utcoffset() - dt_utc.dst()))\n        else:\n            _fold = 0\n\n        return _fold\n\n    def _fold(self, dt):\n        return getattr(dt, 'fold', 0)\n\n    def _fromutc(self, dt):\n        \"\"\"\n        Given a timezone-aware datetime in a given timezone, calculates a\n        timezone-aware datetime in a new timezone.\n\n        Since this is the one time that we *know* we have an unambiguous\n        datetime object, we take this opportunity to determine whether the\n        datetime is ambiguous and in a \"fold\" state (e.g. if it's the first\n        occurrence, chronologically, of the ambiguous datetime).\n\n        :param dt:\n            A timezone-aware :class:`datetime.datetime` object.\n        \"\"\"\n\n        # Re-implement the algorithm from Python's datetime.py\n        dtoff = dt.utcoffset()\n        if dtoff is None:\n            raise ValueError(\"fromutc() requires a non-None utcoffset() \"\n                             \"result\")\n\n        # The original datetime.py code assumes that `dst()` defaults to\n        # zero during ambiguous times. PEP 495 inverts this presumption, so\n        # for pre-PEP 495 versions of python, we need to tweak the algorithm.\n        dtdst = dt.dst()\n        if dtdst is None:\n            raise ValueError(\"fromutc() requires a non-None dst() result\")\n        delta = dtoff - dtdst\n\n        dt += delta\n        # Set fold=1 so we can default to being in the fold for\n        # ambiguous dates.\n        dtdst = enfold(dt, fold=1).dst()\n        if dtdst is None:\n            raise ValueError(\"fromutc(): dt.dst gave inconsistent \"\n                             \"results; cannot convert\")\n        return dt + dtdst\n\n    @_validate_fromutc_inputs\n    def fromutc(self, dt):\n        \"\"\"\n        Given a timezone-aware datetime in a given timezone, calculates a\n        timezone-aware datetime in a new timezone.\n\n        Since this is the one time that we *know* we have an unambiguous\n        datetime object, we take this opportunity to determine whether the\n        datetime is ambiguous and in a \"fold\" state (e.g. if it's the first\n        occurrence, chronologically, of the ambiguous datetime).\n\n        :param dt:\n            A timezone-aware :class:`datetime.datetime` object.\n        \"\"\"\n        dt_wall = self._fromutc(dt)\n\n        # Calculate the fold status given the two datetimes.\n        _fold = self._fold_status(dt, dt_wall)\n\n        # Set the default fold value for ambiguous dates\n        return enfold(dt_wall, fold=_fold)\n\n\nclass tzrangebase(_tzinfo):\n    \"\"\"\n    This is an abstract base class for time zones represented by an annual\n    transition into and out of DST. Child classes should implement the following\n    methods:\n\n        * ``__init__(self, *args, **kwargs)``\n        * ``transitions(self, year)`` - this is expected to return a tuple of\n          datetimes representing the DST on and off transitions in standard\n          time.\n\n    A fully initialized ``tzrangebase`` subclass should also provide the\n    following attributes:\n        * ``hasdst``: Boolean whether or not the zone uses DST.\n        * ``_dst_offset`` / ``_std_offset``: :class:`datetime.timedelta` objects\n          representing the respective UTC offsets.\n        * ``_dst_abbr`` / ``_std_abbr``: Strings representing the timezone short\n          abbreviations in DST and STD, respectively.\n        * ``_hasdst``: Whether or not the zone has DST.\n\n    .. versionadded:: 2.6.0\n    \"\"\"\n    def __init__(self):\n        raise NotImplementedError('tzrangebase is an abstract base class')\n\n    def utcoffset(self, dt):\n        isdst = self._isdst(dt)\n\n        if isdst is None:\n            return None\n        elif isdst:\n            return self._dst_offset\n        else:\n            return self._std_offset\n\n    def dst(self, dt):\n        isdst = self._isdst(dt)\n\n        if isdst is None:\n            return None\n        elif isdst:\n            return self._dst_base_offset\n        else:\n            return ZERO\n\n    @tzname_in_python2\n    def tzname(self, dt):\n        if self._isdst(dt):\n            return self._dst_abbr\n        else:\n            return self._std_abbr\n\n    def fromutc(self, dt):\n        \"\"\" Given a datetime in UTC, return local time \"\"\"\n        if not isinstance(dt, datetime):\n            raise TypeError(\"fromutc() requires a datetime argument\")\n\n        if dt.tzinfo is not self:\n            raise ValueError(\"dt.tzinfo is not self\")\n\n        # Get transitions - if there are none, fixed offset\n        transitions = self.transitions(dt.year)\n        if transitions is None:\n            return dt + self.utcoffset(dt)\n\n        # Get the transition times in UTC\n        dston, dstoff = transitions\n\n        dston -= self._std_offset\n        dstoff -= self._std_offset\n\n        utc_transitions = (dston, dstoff)\n        dt_utc = dt.replace(tzinfo=None)\n\n        isdst = self._naive_isdst(dt_utc, utc_transitions)\n\n        if isdst:\n            dt_wall = dt + self._dst_offset\n        else:\n            dt_wall = dt + self._std_offset\n\n        _fold = int(not isdst and self.is_ambiguous(dt_wall))\n\n        return enfold(dt_wall, fold=_fold)\n\n    def is_ambiguous(self, dt):\n        \"\"\"\n        Whether or not the \"wall time\" of a given datetime is ambiguous in this\n        zone.\n\n        :param dt:\n            A :py:class:`datetime.datetime`, naive or time zone aware.\n\n\n        :return:\n            Returns ``True`` if ambiguous, ``False`` otherwise.\n\n        .. versionadded:: 2.6.0\n        \"\"\"\n        if not self.hasdst:\n            return False\n\n        start, end = self.transitions(dt.year)\n\n        dt = dt.replace(tzinfo=None)\n        return (end <= dt < end + self._dst_base_offset)\n\n    def _isdst(self, dt):\n        if not self.hasdst:\n            return False\n        elif dt is None:\n            return None\n\n        transitions = self.transitions(dt.year)\n\n        if transitions is None:\n            return False\n\n        dt = dt.replace(tzinfo=None)\n\n        isdst = self._naive_isdst(dt, transitions)\n\n        # Handle ambiguous dates\n        if not isdst and self.is_ambiguous(dt):\n            return not self._fold(dt)\n        else:\n            return isdst\n\n    def _naive_isdst(self, dt, transitions):\n        dston, dstoff = transitions\n\n        dt = dt.replace(tzinfo=None)\n\n        if dston < dstoff:\n            isdst = dston <= dt < dstoff\n        else:\n            isdst = not dstoff <= dt < dston\n\n        return isdst\n\n    @property\n    def _dst_base_offset(self):\n        return self._dst_offset - self._std_offset\n\n    __hash__ = None\n\n    def __ne__(self, other):\n        return not (self == other)\n\n    def __repr__(self):\n        return \"%s(...)\" % self.__class__.__name__\n\n    __reduce__ = object.__reduce__\n", "src/dateutil/tz/tz.py": "# -*- coding: utf-8 -*-\n\"\"\"\nThis module offers timezone implementations subclassing the abstract\n:py:class:`datetime.tzinfo` type. There are classes to handle tzfile format\nfiles (usually are in :file:`/etc/localtime`, :file:`/usr/share/zoneinfo`,\netc), TZ environment string (in all known formats), given ranges (with help\nfrom relative deltas), local machine timezone, fixed offset timezone, and UTC\ntimezone.\n\"\"\"\nimport datetime\nimport struct\nimport time\nimport sys\nimport os\nimport bisect\nimport weakref\nfrom collections import OrderedDict\n\nimport six\nfrom six import string_types\nfrom six.moves import _thread\nfrom ._common import tzname_in_python2, _tzinfo\nfrom ._common import tzrangebase, enfold\nfrom ._common import _validate_fromutc_inputs\n\nfrom ._factories import _TzSingleton, _TzOffsetFactory\nfrom ._factories import _TzStrFactory\ntry:\n    from .win import tzwin, tzwinlocal\nexcept ImportError:\n    tzwin = tzwinlocal = None\n\n# For warning about rounding tzinfo\nfrom warnings import warn\n\nZERO = datetime.timedelta(0)\nEPOCH = datetime.datetime(1970, 1, 1, 0, 0)\nEPOCHORDINAL = EPOCH.toordinal()\n\n\n@six.add_metaclass(_TzSingleton)\nclass tzutc(datetime.tzinfo):\n    \"\"\"\n    This is a tzinfo object that represents the UTC time zone.\n\n    **Examples:**\n\n    .. doctest::\n\n        >>> from datetime import *\n        >>> from dateutil.tz import *\n\n        >>> datetime.now()\n        datetime.datetime(2003, 9, 27, 9, 40, 1, 521290)\n\n        >>> datetime.now(tzutc())\n        datetime.datetime(2003, 9, 27, 12, 40, 12, 156379, tzinfo=tzutc())\n\n        >>> datetime.now(tzutc()).tzname()\n        'UTC'\n\n    .. versionchanged:: 2.7.0\n        ``tzutc()`` is now a singleton, so the result of ``tzutc()`` will\n        always return the same object.\n\n        .. doctest::\n\n            >>> from dateutil.tz import tzutc, UTC\n            >>> tzutc() is tzutc()\n            True\n            >>> tzutc() is UTC\n            True\n    \"\"\"\n    def utcoffset(self, dt):\n        return ZERO\n\n    def dst(self, dt):\n        return ZERO\n\n    @tzname_in_python2\n    def tzname(self, dt):\n        return \"UTC\"\n\n    def is_ambiguous(self, dt):\n        \"\"\"\n        Whether or not the \"wall time\" of a given datetime is ambiguous in this\n        zone.\n\n        :param dt:\n            A :py:class:`datetime.datetime`, naive or time zone aware.\n\n\n        :return:\n            Returns ``True`` if ambiguous, ``False`` otherwise.\n\n        .. versionadded:: 2.6.0\n        \"\"\"\n        return False\n\n    @_validate_fromutc_inputs\n    def fromutc(self, dt):\n        \"\"\"\n        Fast track version of fromutc() returns the original ``dt`` object for\n        any valid :py:class:`datetime.datetime` object.\n        \"\"\"\n        return dt\n\n    def __eq__(self, other):\n        if not isinstance(other, (tzutc, tzoffset)):\n            return NotImplemented\n\n        return (isinstance(other, tzutc) or\n                (isinstance(other, tzoffset) and other._offset == ZERO))\n\n    __hash__ = None\n\n    def __ne__(self, other):\n        return not (self == other)\n\n    def __repr__(self):\n        return \"%s()\" % self.__class__.__name__\n\n    __reduce__ = object.__reduce__\n\n\n#: Convenience constant providing a :class:`tzutc()` instance\n#:\n#: .. versionadded:: 2.7.0\nUTC = tzutc()\n\n\n@six.add_metaclass(_TzOffsetFactory)\nclass tzoffset(datetime.tzinfo):\n    \"\"\"\n    A simple class for representing a fixed offset from UTC.\n\n    :param name:\n        The timezone name, to be returned when ``tzname()`` is called.\n    :param offset:\n        The time zone offset in seconds, or (since version 2.6.0, represented\n        as a :py:class:`datetime.timedelta` object).\n    \"\"\"\n    def __init__(self, name, offset):\n        self._name = name\n\n        try:\n            # Allow a timedelta\n            offset = offset.total_seconds()\n        except (TypeError, AttributeError):\n            pass\n\n        self._offset = datetime.timedelta(seconds=_get_supported_offset(offset))\n\n    def utcoffset(self, dt):\n        return self._offset\n\n    def dst(self, dt):\n        return ZERO\n\n    @tzname_in_python2\n    def tzname(self, dt):\n        return self._name\n\n    @_validate_fromutc_inputs\n    def fromutc(self, dt):\n        return dt + self._offset\n\n    def is_ambiguous(self, dt):\n        \"\"\"\n        Whether or not the \"wall time\" of a given datetime is ambiguous in this\n        zone.\n\n        :param dt:\n            A :py:class:`datetime.datetime`, naive or time zone aware.\n        :return:\n            Returns ``True`` if ambiguous, ``False`` otherwise.\n\n        .. versionadded:: 2.6.0\n        \"\"\"\n        return False\n\n    def __eq__(self, other):\n        if not isinstance(other, tzoffset):\n            return NotImplemented\n\n        return self._offset == other._offset\n\n    __hash__ = None\n\n    def __ne__(self, other):\n        return not (self == other)\n\n    def __repr__(self):\n        return \"%s(%s, %s)\" % (self.__class__.__name__,\n                               repr(self._name),\n                               int(self._offset.total_seconds()))\n\n    __reduce__ = object.__reduce__\n\n\nclass tzlocal(_tzinfo):\n    \"\"\"\n    A :class:`tzinfo` subclass built around the ``time`` timezone functions.\n    \"\"\"\n    def __init__(self):\n        super(tzlocal, self).__init__()\n\n        self._std_offset = datetime.timedelta(seconds=-time.timezone)\n        if time.daylight:\n            self._dst_offset = datetime.timedelta(seconds=-time.altzone)\n        else:\n            self._dst_offset = self._std_offset\n\n        self._dst_saved = self._dst_offset - self._std_offset\n        self._hasdst = bool(self._dst_saved)\n        self._tznames = tuple(time.tzname)\n\n    def utcoffset(self, dt):\n        if dt is None and self._hasdst:\n            return None\n\n        if self._isdst(dt):\n            return self._dst_offset\n        else:\n            return self._std_offset\n\n    def dst(self, dt):\n        if dt is None and self._hasdst:\n            return None\n\n        if self._isdst(dt):\n            return self._dst_offset - self._std_offset\n        else:\n            return ZERO\n\n    @tzname_in_python2\n    def tzname(self, dt):\n        return self._tznames[self._isdst(dt)]\n\n    def is_ambiguous(self, dt):\n        \"\"\"\n        Whether or not the \"wall time\" of a given datetime is ambiguous in this\n        zone.\n\n        :param dt:\n            A :py:class:`datetime.datetime`, naive or time zone aware.\n\n\n        :return:\n            Returns ``True`` if ambiguous, ``False`` otherwise.\n\n        .. versionadded:: 2.6.0\n        \"\"\"\n        naive_dst = self._naive_is_dst(dt)\n        return (not naive_dst and\n                (naive_dst != self._naive_is_dst(dt - self._dst_saved)))\n\n    def _naive_is_dst(self, dt):\n        timestamp = _datetime_to_timestamp(dt)\n        return time.localtime(timestamp + time.timezone).tm_isdst\n\n    def _isdst(self, dt, fold_naive=True):\n        # We can't use mktime here. It is unstable when deciding if\n        # the hour near to a change is DST or not.\n        #\n        # timestamp = time.mktime((dt.year, dt.month, dt.day, dt.hour,\n        #                         dt.minute, dt.second, dt.weekday(), 0, -1))\n        # return time.localtime(timestamp).tm_isdst\n        #\n        # The code above yields the following result:\n        #\n        # >>> import tz, datetime\n        # >>> t = tz.tzlocal()\n        # >>> datetime.datetime(2003,2,15,23,tzinfo=t).tzname()\n        # 'BRDT'\n        # >>> datetime.datetime(2003,2,16,0,tzinfo=t).tzname()\n        # 'BRST'\n        # >>> datetime.datetime(2003,2,15,23,tzinfo=t).tzname()\n        # 'BRST'\n        # >>> datetime.datetime(2003,2,15,22,tzinfo=t).tzname()\n        # 'BRDT'\n        # >>> datetime.datetime(2003,2,15,23,tzinfo=t).tzname()\n        # 'BRDT'\n        #\n        # Here is a more stable implementation:\n        #\n        if not self._hasdst:\n            return False\n\n        # Check for ambiguous times:\n        dstval = self._naive_is_dst(dt)\n        fold = getattr(dt, 'fold', None)\n\n        if self.is_ambiguous(dt):\n            if fold is not None:\n                return not self._fold(dt)\n            else:\n                return True\n\n        return dstval\n\n    def __eq__(self, other):\n        if isinstance(other, tzlocal):\n            return (self._std_offset == other._std_offset and\n                    self._dst_offset == other._dst_offset)\n        elif isinstance(other, tzutc):\n            return (not self._hasdst and\n                    self._tznames[0] in {'UTC', 'GMT'} and\n                    self._std_offset == ZERO)\n        elif isinstance(other, tzoffset):\n            return (not self._hasdst and\n                    self._tznames[0] == other._name and\n                    self._std_offset == other._offset)\n        else:\n            return NotImplemented\n\n    __hash__ = None\n\n    def __ne__(self, other):\n        return not (self == other)\n\n    def __repr__(self):\n        return \"%s()\" % self.__class__.__name__\n\n    __reduce__ = object.__reduce__\n\n\nclass _ttinfo(object):\n    __slots__ = [\"offset\", \"delta\", \"isdst\", \"abbr\",\n                 \"isstd\", \"isgmt\", \"dstoffset\"]\n\n    def __init__(self):\n        for attr in self.__slots__:\n            setattr(self, attr, None)\n\n    def __repr__(self):\n        l = []\n        for attr in self.__slots__:\n            value = getattr(self, attr)\n            if value is not None:\n                l.append(\"%s=%s\" % (attr, repr(value)))\n        return \"%s(%s)\" % (self.__class__.__name__, \", \".join(l))\n\n    def __eq__(self, other):\n        if not isinstance(other, _ttinfo):\n            return NotImplemented\n\n        return (self.offset == other.offset and\n                self.delta == other.delta and\n                self.isdst == other.isdst and\n                self.abbr == other.abbr and\n                self.isstd == other.isstd and\n                self.isgmt == other.isgmt and\n                self.dstoffset == other.dstoffset)\n\n    __hash__ = None\n\n    def __ne__(self, other):\n        return not (self == other)\n\n    def __getstate__(self):\n        state = {}\n        for name in self.__slots__:\n            state[name] = getattr(self, name, None)\n        return state\n\n    def __setstate__(self, state):\n        for name in self.__slots__:\n            if name in state:\n                setattr(self, name, state[name])\n\n\nclass _tzfile(object):\n    \"\"\"\n    Lightweight class for holding the relevant transition and time zone\n    information read from binary tzfiles.\n    \"\"\"\n    attrs = ['trans_list', 'trans_list_utc', 'trans_idx', 'ttinfo_list',\n             'ttinfo_std', 'ttinfo_dst', 'ttinfo_before', 'ttinfo_first']\n\n    def __init__(self, **kwargs):\n        for attr in self.attrs:\n            setattr(self, attr, kwargs.get(attr, None))\n\n\nclass tzfile(_tzinfo):\n    \"\"\"\n    This is a ``tzinfo`` subclass that allows one to use the ``tzfile(5)``\n    format timezone files to extract current and historical zone information.\n\n    :param fileobj:\n        This can be an opened file stream or a file name that the time zone\n        information can be read from.\n\n    :param filename:\n        This is an optional parameter specifying the source of the time zone\n        information in the event that ``fileobj`` is a file object. If omitted\n        and ``fileobj`` is a file stream, this parameter will be set either to\n        ``fileobj``'s ``name`` attribute or to ``repr(fileobj)``.\n\n    See `Sources for Time Zone and Daylight Saving Time Data\n    <https://data.iana.org/time-zones/tz-link.html>`_ for more information.\n    Time zone files can be compiled from the `IANA Time Zone database files\n    <https://www.iana.org/time-zones>`_ with the `zic time zone compiler\n    <https://www.freebsd.org/cgi/man.cgi?query=zic&sektion=8>`_\n\n    .. note::\n\n        Only construct a ``tzfile`` directly if you have a specific timezone\n        file on disk that you want to read into a Python ``tzinfo`` object.\n        If you want to get a ``tzfile`` representing a specific IANA zone,\n        (e.g. ``'America/New_York'``), you should call\n        :func:`dateutil.tz.gettz` with the zone identifier.\n\n\n    **Examples:**\n\n    Using the US Eastern time zone as an example, we can see that a ``tzfile``\n    provides time zone information for the standard Daylight Saving offsets:\n\n    .. testsetup:: tzfile\n\n        from dateutil.tz import gettz\n        from datetime import datetime\n\n    .. doctest:: tzfile\n\n        >>> NYC = gettz('America/New_York')\n        >>> NYC\n        tzfile('/usr/share/zoneinfo/America/New_York')\n\n        >>> print(datetime(2016, 1, 3, tzinfo=NYC))     # EST\n        2016-01-03 00:00:00-05:00\n\n        >>> print(datetime(2016, 7, 7, tzinfo=NYC))     # EDT\n        2016-07-07 00:00:00-04:00\n\n\n    The ``tzfile`` structure contains a fully history of the time zone,\n    so historical dates will also have the right offsets. For example, before\n    the adoption of the UTC standards, New York used local solar  mean time:\n\n    .. doctest:: tzfile\n\n       >>> print(datetime(1901, 4, 12, tzinfo=NYC))    # LMT\n       1901-04-12 00:00:00-04:56\n\n    And during World War II, New York was on \"Eastern War Time\", which was a\n    state of permanent daylight saving time:\n\n    .. doctest:: tzfile\n\n        >>> print(datetime(1944, 2, 7, tzinfo=NYC))    # EWT\n        1944-02-07 00:00:00-04:00\n\n    \"\"\"\n\n    def __init__(self, fileobj, filename=None):\n        super(tzfile, self).__init__()\n\n        file_opened_here = False\n        if isinstance(fileobj, string_types):\n            self._filename = fileobj\n            fileobj = open(fileobj, 'rb')\n            file_opened_here = True\n        elif filename is not None:\n            self._filename = filename\n        elif hasattr(fileobj, \"name\"):\n            self._filename = fileobj.name\n        else:\n            self._filename = repr(fileobj)\n\n        if fileobj is not None:\n            if not file_opened_here:\n                fileobj = _nullcontext(fileobj)\n\n            with fileobj as file_stream:\n                tzobj = self._read_tzfile(file_stream)\n\n            self._set_tzdata(tzobj)\n\n    def _set_tzdata(self, tzobj):\n        \"\"\" Set the time zone data of this object from a _tzfile object \"\"\"\n        # Copy the relevant attributes over as private attributes\n        for attr in _tzfile.attrs:\n            setattr(self, '_' + attr, getattr(tzobj, attr))\n\n    def _read_tzfile(self, fileobj):\n        out = _tzfile()\n\n        # From tzfile(5):\n        #\n        # The time zone information files used by tzset(3)\n        # begin with the magic characters \"TZif\" to identify\n        # them as time zone information files, followed by\n        # sixteen bytes reserved for future use, followed by\n        # six four-byte values of type long, written in a\n        # ``standard'' byte order (the high-order  byte\n        # of the value is written first).\n        if fileobj.read(4).decode() != \"TZif\":\n            raise ValueError(\"magic not found\")\n\n        fileobj.read(16)\n\n        (\n            # The number of UTC/local indicators stored in the file.\n            ttisgmtcnt,\n\n            # The number of standard/wall indicators stored in the file.\n            ttisstdcnt,\n\n            # The number of leap seconds for which data is\n            # stored in the file.\n            leapcnt,\n\n            # The number of \"transition times\" for which data\n            # is stored in the file.\n            timecnt,\n\n            # The number of \"local time types\" for which data\n            # is stored in the file (must not be zero).\n            typecnt,\n\n            # The  number  of  characters  of \"time zone\n            # abbreviation strings\" stored in the file.\n            charcnt,\n\n        ) = struct.unpack(\">6l\", fileobj.read(24))\n\n        # The above header is followed by tzh_timecnt four-byte\n        # values  of  type long,  sorted  in ascending order.\n        # These values are written in ``standard'' byte order.\n        # Each is used as a transition time (as  returned  by\n        # time(2)) at which the rules for computing local time\n        # change.\n\n        if timecnt:\n            out.trans_list_utc = list(struct.unpack(\">%dl\" % timecnt,\n                                                    fileobj.read(timecnt*4)))\n        else:\n            out.trans_list_utc = []\n\n        # Next come tzh_timecnt one-byte values of type unsigned\n        # char; each one tells which of the different types of\n        # ``local time'' types described in the file is associated\n        # with the same-indexed transition time. These values\n        # serve as indices into an array of ttinfo structures that\n        # appears next in the file.\n\n        if timecnt:\n            out.trans_idx = struct.unpack(\">%dB\" % timecnt,\n                                          fileobj.read(timecnt))\n        else:\n            out.trans_idx = []\n\n        # Each ttinfo structure is written as a four-byte value\n        # for tt_gmtoff  of  type long,  in  a  standard  byte\n        # order, followed  by a one-byte value for tt_isdst\n        # and a one-byte  value  for  tt_abbrind.   In  each\n        # structure, tt_gmtoff  gives  the  number  of\n        # seconds to be added to UTC, tt_isdst tells whether\n        # tm_isdst should be set by  localtime(3),  and\n        # tt_abbrind serves  as an index into the array of\n        # time zone abbreviation characters that follow the\n        # ttinfo structure(s) in the file.\n\n        ttinfo = []\n\n        for i in range(typecnt):\n            ttinfo.append(struct.unpack(\">lbb\", fileobj.read(6)))\n\n        abbr = fileobj.read(charcnt).decode()\n\n        # Then there are tzh_leapcnt pairs of four-byte\n        # values, written in  standard byte  order;  the\n        # first  value  of  each pair gives the time (as\n        # returned by time(2)) at which a leap second\n        # occurs;  the  second  gives the  total  number of\n        # leap seconds to be applied after the given time.\n        # The pairs of values are sorted in ascending order\n        # by time.\n\n        # Not used, for now (but seek for correct file position)\n        if leapcnt:\n            fileobj.seek(leapcnt * 8, os.SEEK_CUR)\n\n        # Then there are tzh_ttisstdcnt standard/wall\n        # indicators, each stored as a one-byte value;\n        # they tell whether the transition times associated\n        # with local time types were specified as standard\n        # time or wall clock time, and are used when\n        # a time zone file is used in handling POSIX-style\n        # time zone environment variables.\n\n        if ttisstdcnt:\n            isstd = struct.unpack(\">%db\" % ttisstdcnt,\n                                  fileobj.read(ttisstdcnt))\n\n        # Finally, there are tzh_ttisgmtcnt UTC/local\n        # indicators, each stored as a one-byte value;\n        # they tell whether the transition times associated\n        # with local time types were specified as UTC or\n        # local time, and are used when a time zone file\n        # is used in handling POSIX-style time zone envi-\n        # ronment variables.\n\n        if ttisgmtcnt:\n            isgmt = struct.unpack(\">%db\" % ttisgmtcnt,\n                                  fileobj.read(ttisgmtcnt))\n\n        # Build ttinfo list\n        out.ttinfo_list = []\n        for i in range(typecnt):\n            gmtoff, isdst, abbrind = ttinfo[i]\n            gmtoff = _get_supported_offset(gmtoff)\n            tti = _ttinfo()\n            tti.offset = gmtoff\n            tti.dstoffset = datetime.timedelta(0)\n            tti.delta = datetime.timedelta(seconds=gmtoff)\n            tti.isdst = isdst\n            tti.abbr = abbr[abbrind:abbr.find('\\x00', abbrind)]\n            tti.isstd = (ttisstdcnt > i and isstd[i] != 0)\n            tti.isgmt = (ttisgmtcnt > i and isgmt[i] != 0)\n            out.ttinfo_list.append(tti)\n\n        # Replace ttinfo indexes for ttinfo objects.\n        out.trans_idx = [out.ttinfo_list[idx] for idx in out.trans_idx]\n\n        # Set standard, dst, and before ttinfos. before will be\n        # used when a given time is before any transitions,\n        # and will be set to the first non-dst ttinfo, or to\n        # the first dst, if all of them are dst.\n        out.ttinfo_std = None\n        out.ttinfo_dst = None\n        out.ttinfo_before = None\n        if out.ttinfo_list:\n            if not out.trans_list_utc:\n                out.ttinfo_std = out.ttinfo_first = out.ttinfo_list[0]\n            else:\n                for i in range(timecnt-1, -1, -1):\n                    tti = out.trans_idx[i]\n                    if not out.ttinfo_std and not tti.isdst:\n                        out.ttinfo_std = tti\n                    elif not out.ttinfo_dst and tti.isdst:\n                        out.ttinfo_dst = tti\n\n                    if out.ttinfo_std and out.ttinfo_dst:\n                        break\n                else:\n                    if out.ttinfo_dst and not out.ttinfo_std:\n                        out.ttinfo_std = out.ttinfo_dst\n\n                for tti in out.ttinfo_list:\n                    if not tti.isdst:\n                        out.ttinfo_before = tti\n                        break\n                else:\n                    out.ttinfo_before = out.ttinfo_list[0]\n\n        # Now fix transition times to become relative to wall time.\n        #\n        # I'm not sure about this. In my tests, the tz source file\n        # is setup to wall time, and in the binary file isstd and\n        # isgmt are off, so it should be in wall time. OTOH, it's\n        # always in gmt time. Let me know if you have comments\n        # about this.\n        lastdst = None\n        lastoffset = None\n        lastdstoffset = None\n        lastbaseoffset = None\n        out.trans_list = []\n\n        for i, tti in enumerate(out.trans_idx):\n            offset = tti.offset\n            dstoffset = 0\n\n            if lastdst is not None:\n                if tti.isdst:\n                    if not lastdst:\n                        dstoffset = offset - lastoffset\n\n                    if not dstoffset and lastdstoffset:\n                        dstoffset = lastdstoffset\n\n                    tti.dstoffset = datetime.timedelta(seconds=dstoffset)\n                    lastdstoffset = dstoffset\n\n            # If a time zone changes its base offset during a DST transition,\n            # then you need to adjust by the previous base offset to get the\n            # transition time in local time. Otherwise you use the current\n            # base offset. Ideally, I would have some mathematical proof of\n            # why this is true, but I haven't really thought about it enough.\n            baseoffset = offset - dstoffset\n            adjustment = baseoffset\n            if (lastbaseoffset is not None and baseoffset != lastbaseoffset\n                    and tti.isdst != lastdst):\n                # The base DST has changed\n                adjustment = lastbaseoffset\n\n            lastdst = tti.isdst\n            lastoffset = offset\n            lastbaseoffset = baseoffset\n\n            out.trans_list.append(out.trans_list_utc[i] + adjustment)\n\n        out.trans_idx = tuple(out.trans_idx)\n        out.trans_list = tuple(out.trans_list)\n        out.trans_list_utc = tuple(out.trans_list_utc)\n\n        return out\n\n    def _find_last_transition(self, dt, in_utc=False):\n        # If there's no list, there are no transitions to find\n        if not self._trans_list:\n            return None\n\n        timestamp = _datetime_to_timestamp(dt)\n\n        # Find where the timestamp fits in the transition list - if the\n        # timestamp is a transition time, it's part of the \"after\" period.\n        trans_list = self._trans_list_utc if in_utc else self._trans_list\n        idx = bisect.bisect_right(trans_list, timestamp)\n\n        # We want to know when the previous transition was, so subtract off 1\n        return idx - 1\n\n    def _get_ttinfo(self, idx):\n        # For no list or after the last transition, default to _ttinfo_std\n        if idx is None or (idx + 1) >= len(self._trans_list):\n            return self._ttinfo_std\n\n        # If there is a list and the time is before it, return _ttinfo_before\n        if idx < 0:\n            return self._ttinfo_before\n\n        return self._trans_idx[idx]\n\n    def _find_ttinfo(self, dt):\n        idx = self._resolve_ambiguous_time(dt)\n\n        return self._get_ttinfo(idx)\n\n    def fromutc(self, dt):\n        \"\"\"\n        The ``tzfile`` implementation of :py:func:`datetime.tzinfo.fromutc`.\n\n        :param dt:\n            A :py:class:`datetime.datetime` object.\n\n        :raises TypeError:\n            Raised if ``dt`` is not a :py:class:`datetime.datetime` object.\n\n        :raises ValueError:\n            Raised if this is called with a ``dt`` which does not have this\n            ``tzinfo`` attached.\n\n        :return:\n            Returns a :py:class:`datetime.datetime` object representing the\n            wall time in ``self``'s time zone.\n        \"\"\"\n        # These isinstance checks are in datetime.tzinfo, so we'll preserve\n        # them, even if we don't care about duck typing.\n        if not isinstance(dt, datetime.datetime):\n            raise TypeError(\"fromutc() requires a datetime argument\")\n\n        if dt.tzinfo is not self:\n            raise ValueError(\"dt.tzinfo is not self\")\n\n        # First treat UTC as wall time and get the transition we're in.\n        idx = self._find_last_transition(dt, in_utc=True)\n        tti = self._get_ttinfo(idx)\n\n        dt_out = dt + datetime.timedelta(seconds=tti.offset)\n\n        fold = self.is_ambiguous(dt_out, idx=idx)\n\n        return enfold(dt_out, fold=int(fold))\n\n    def is_ambiguous(self, dt, idx=None):\n        \"\"\"\n        Whether or not the \"wall time\" of a given datetime is ambiguous in this\n        zone.\n\n        :param dt:\n            A :py:class:`datetime.datetime`, naive or time zone aware.\n\n\n        :return:\n            Returns ``True`` if ambiguous, ``False`` otherwise.\n\n        .. versionadded:: 2.6.0\n        \"\"\"\n        if idx is None:\n            idx = self._find_last_transition(dt)\n\n        # Calculate the difference in offsets from current to previous\n        timestamp = _datetime_to_timestamp(dt)\n        tti = self._get_ttinfo(idx)\n\n        if idx is None or idx <= 0:\n            return False\n\n        od = self._get_ttinfo(idx - 1).offset - tti.offset\n        tt = self._trans_list[idx]          # Transition time\n\n        return timestamp < tt + od\n\n    def _resolve_ambiguous_time(self, dt):\n        idx = self._find_last_transition(dt)\n\n        # If we have no transitions, return the index\n        _fold = self._fold(dt)\n        if idx is None or idx == 0:\n            return idx\n\n        # If it's ambiguous and we're in a fold, shift to a different index.\n        idx_offset = int(not _fold and self.is_ambiguous(dt, idx))\n\n        return idx - idx_offset\n\n    def utcoffset(self, dt):\n        if dt is None:\n            return None\n\n        if not self._ttinfo_std:\n            return ZERO\n\n        return self._find_ttinfo(dt).delta\n\n    def dst(self, dt):\n        if dt is None:\n            return None\n\n        if not self._ttinfo_dst:\n            return ZERO\n\n        tti = self._find_ttinfo(dt)\n\n        if not tti.isdst:\n            return ZERO\n\n        # The documentation says that utcoffset()-dst() must\n        # be constant for every dt.\n        return tti.dstoffset\n\n    @tzname_in_python2\n    def tzname(self, dt):\n        if not self._ttinfo_std or dt is None:\n            return None\n        return self._find_ttinfo(dt).abbr\n\n    def __eq__(self, other):\n        if not isinstance(other, tzfile):\n            return NotImplemented\n        return (self._trans_list == other._trans_list and\n                self._trans_idx == other._trans_idx and\n                self._ttinfo_list == other._ttinfo_list)\n\n    __hash__ = None\n\n    def __ne__(self, other):\n        return not (self == other)\n\n    def __repr__(self):\n        return \"%s(%s)\" % (self.__class__.__name__, repr(self._filename))\n\n    def __reduce__(self):\n        return self.__reduce_ex__(None)\n\n    def __reduce_ex__(self, protocol):\n        return (self.__class__, (None, self._filename), self.__dict__)\n\n\nclass tzrange(tzrangebase):\n    \"\"\"\n    The ``tzrange`` object is a time zone specified by a set of offsets and\n    abbreviations, equivalent to the way the ``TZ`` variable can be specified\n    in POSIX-like systems, but using Python delta objects to specify DST\n    start, end and offsets.\n\n    :param stdabbr:\n        The abbreviation for standard time (e.g. ``'EST'``).\n\n    :param stdoffset:\n        An integer or :class:`datetime.timedelta` object or equivalent\n        specifying the base offset from UTC.\n\n        If unspecified, +00:00 is used.\n\n    :param dstabbr:\n        The abbreviation for DST / \"Summer\" time (e.g. ``'EDT'``).\n\n        If specified, with no other DST information, DST is assumed to occur\n        and the default behavior or ``dstoffset``, ``start`` and ``end`` is\n        used. If unspecified and no other DST information is specified, it\n        is assumed that this zone has no DST.\n\n        If this is unspecified and other DST information is *is* specified,\n        DST occurs in the zone but the time zone abbreviation is left\n        unchanged.\n\n    :param dstoffset:\n        A an integer or :class:`datetime.timedelta` object or equivalent\n        specifying the UTC offset during DST. If unspecified and any other DST\n        information is specified, it is assumed to be the STD offset +1 hour.\n\n    :param start:\n        A :class:`relativedelta.relativedelta` object or equivalent specifying\n        the time and time of year that daylight savings time starts. To\n        specify, for example, that DST starts at 2AM on the 2nd Sunday in\n        March, pass:\n\n            ``relativedelta(hours=2, month=3, day=1, weekday=SU(+2))``\n\n        If unspecified and any other DST information is specified, the default\n        value is 2 AM on the first Sunday in April.\n\n    :param end:\n        A :class:`relativedelta.relativedelta` object or equivalent\n        representing the time and time of year that daylight savings time\n        ends, with the same specification method as in ``start``. One note is\n        that this should point to the first time in the *standard* zone, so if\n        a transition occurs at 2AM in the DST zone and the clocks are set back\n        1 hour to 1AM, set the ``hours`` parameter to +1.\n\n\n    **Examples:**\n\n    .. testsetup:: tzrange\n\n        from dateutil.tz import tzrange, tzstr\n\n    .. doctest:: tzrange\n\n        >>> tzstr('EST5EDT') == tzrange(\"EST\", -18000, \"EDT\")\n        True\n\n        >>> from dateutil.relativedelta import *\n        >>> range1 = tzrange(\"EST\", -18000, \"EDT\")\n        >>> range2 = tzrange(\"EST\", -18000, \"EDT\", -14400,\n        ...                  relativedelta(hours=+2, month=4, day=1,\n        ...                                weekday=SU(+1)),\n        ...                  relativedelta(hours=+1, month=10, day=31,\n        ...                                weekday=SU(-1)))\n        >>> tzstr('EST5EDT') == range1 == range2\n        True\n\n    \"\"\"\n    def __init__(self, stdabbr, stdoffset=None,\n                 dstabbr=None, dstoffset=None,\n                 start=None, end=None):\n\n        global relativedelta\n        from dateutil import relativedelta\n\n        self._std_abbr = stdabbr\n        self._dst_abbr = dstabbr\n\n        try:\n            stdoffset = stdoffset.total_seconds()\n        except (TypeError, AttributeError):\n            pass\n\n        try:\n            dstoffset = dstoffset.total_seconds()\n        except (TypeError, AttributeError):\n            pass\n\n        if stdoffset is not None:\n            self._std_offset = datetime.timedelta(seconds=stdoffset)\n        else:\n            self._std_offset = ZERO\n\n        if dstoffset is not None:\n            self._dst_offset = datetime.timedelta(seconds=dstoffset)\n        elif dstabbr and stdoffset is not None:\n            self._dst_offset = self._std_offset + datetime.timedelta(hours=+1)\n        else:\n            self._dst_offset = ZERO\n\n        if dstabbr and start is None:\n            self._start_delta = relativedelta.relativedelta(\n                hours=+2, month=4, day=1, weekday=relativedelta.SU(+1))\n        else:\n            self._start_delta = start\n\n        if dstabbr and end is None:\n            self._end_delta = relativedelta.relativedelta(\n                hours=+1, month=10, day=31, weekday=relativedelta.SU(-1))\n        else:\n            self._end_delta = end\n\n        self._dst_base_offset_ = self._dst_offset - self._std_offset\n        self.hasdst = bool(self._start_delta)\n\n    def transitions(self, year):\n        \"\"\"\n        For a given year, get the DST on and off transition times, expressed\n        always on the standard time side. For zones with no transitions, this\n        function returns ``None``.\n\n        :param year:\n            The year whose transitions you would like to query.\n\n        :return:\n            Returns a :class:`tuple` of :class:`datetime.datetime` objects,\n            ``(dston, dstoff)`` for zones with an annual DST transition, or\n            ``None`` for fixed offset zones.\n        \"\"\"\n        if not self.hasdst:\n            return None\n\n        base_year = datetime.datetime(year, 1, 1)\n\n        start = base_year + self._start_delta\n        end = base_year + self._end_delta\n\n        return (start, end)\n\n    def __eq__(self, other):\n        if not isinstance(other, tzrange):\n            return NotImplemented\n\n        return (self._std_abbr == other._std_abbr and\n                self._dst_abbr == other._dst_abbr and\n                self._std_offset == other._std_offset and\n                self._dst_offset == other._dst_offset and\n                self._start_delta == other._start_delta and\n                self._end_delta == other._end_delta)\n\n    @property\n    def _dst_base_offset(self):\n        return self._dst_base_offset_\n\n\n@six.add_metaclass(_TzStrFactory)\nclass tzstr(tzrange):\n    \"\"\"\n    ``tzstr`` objects are time zone objects specified by a time-zone string as\n    it would be passed to a ``TZ`` variable on POSIX-style systems (see\n    the `GNU C Library: TZ Variable`_ for more details).\n\n    There is one notable exception, which is that POSIX-style time zones use an\n    inverted offset format, so normally ``GMT+3`` would be parsed as an offset\n    3 hours *behind* GMT. The ``tzstr`` time zone object will parse this as an\n    offset 3 hours *ahead* of GMT. If you would like to maintain the POSIX\n    behavior, pass a ``True`` value to ``posix_offset``.\n\n    The :class:`tzrange` object provides the same functionality, but is\n    specified using :class:`relativedelta.relativedelta` objects. rather than\n    strings.\n\n    :param s:\n        A time zone string in ``TZ`` variable format. This can be a\n        :class:`bytes` (2.x: :class:`str`), :class:`str` (2.x:\n        :class:`unicode`) or a stream emitting unicode characters\n        (e.g. :class:`StringIO`).\n\n    :param posix_offset:\n        Optional. If set to ``True``, interpret strings such as ``GMT+3`` or\n        ``UTC+3`` as being 3 hours *behind* UTC rather than ahead, per the\n        POSIX standard.\n\n    .. caution::\n\n        Prior to version 2.7.0, this function also supported time zones\n        in the format:\n\n            * ``EST5EDT,4,0,6,7200,10,0,26,7200,3600``\n            * ``EST5EDT,4,1,0,7200,10,-1,0,7200,3600``\n\n        This format is non-standard and has been deprecated; this function\n        will raise a :class:`DeprecatedTZFormatWarning` until\n        support is removed in a future version.\n\n    .. _`GNU C Library: TZ Variable`:\n        https://www.gnu.org/software/libc/manual/html_node/TZ-Variable.html\n    \"\"\"\n    def __init__(self, s, posix_offset=False):\n        global parser\n        from dateutil.parser import _parser as parser\n\n        self._s = s\n\n        res = parser._parsetz(s)\n        if res is None or res.any_unused_tokens:\n            raise ValueError(\"unknown string format\")\n\n        # Here we break the compatibility with the TZ variable handling.\n        # GMT-3 actually *means* the timezone -3.\n        if res.stdabbr in (\"GMT\", \"UTC\") and not posix_offset:\n            res.stdoffset *= -1\n\n        # We must initialize it first, since _delta() needs\n        # _std_offset and _dst_offset set. Use False in start/end\n        # to avoid building it two times.\n        tzrange.__init__(self, res.stdabbr, res.stdoffset,\n                         res.dstabbr, res.dstoffset,\n                         start=False, end=False)\n\n        if not res.dstabbr:\n            self._start_delta = None\n            self._end_delta = None\n        else:\n            self._start_delta = self._delta(res.start)\n            if self._start_delta:\n                self._end_delta = self._delta(res.end, isend=1)\n\n        self.hasdst = bool(self._start_delta)\n\n    def _delta(self, x, isend=0):\n        from dateutil import relativedelta\n        kwargs = {}\n        if x.month is not None:\n            kwargs[\"month\"] = x.month\n            if x.weekday is not None:\n                kwargs[\"weekday\"] = relativedelta.weekday(x.weekday, x.week)\n                if x.week > 0:\n                    kwargs[\"day\"] = 1\n                else:\n                    kwargs[\"day\"] = 31\n            elif x.day:\n                kwargs[\"day\"] = x.day\n        elif x.yday is not None:\n            kwargs[\"yearday\"] = x.yday\n        elif x.jyday is not None:\n            kwargs[\"nlyearday\"] = x.jyday\n        if not kwargs:\n            # Default is to start on first sunday of april, and end\n            # on last sunday of october.\n            if not isend:\n                kwargs[\"month\"] = 4\n                kwargs[\"day\"] = 1\n                kwargs[\"weekday\"] = relativedelta.SU(+1)\n            else:\n                kwargs[\"month\"] = 10\n                kwargs[\"day\"] = 31\n                kwargs[\"weekday\"] = relativedelta.SU(-1)\n        if x.time is not None:\n            kwargs[\"seconds\"] = x.time\n        else:\n            # Default is 2AM.\n            kwargs[\"seconds\"] = 7200\n        if isend:\n            # Convert to standard time, to follow the documented way\n            # of working with the extra hour. See the documentation\n            # of the tzinfo class.\n            delta = self._dst_offset - self._std_offset\n            kwargs[\"seconds\"] -= delta.seconds + delta.days * 86400\n        return relativedelta.relativedelta(**kwargs)\n\n    def __repr__(self):\n        return \"%s(%s)\" % (self.__class__.__name__, repr(self._s))\n\n\nclass _tzicalvtzcomp(object):\n    def __init__(self, tzoffsetfrom, tzoffsetto, isdst,\n                 tzname=None, rrule=None):\n        self.tzoffsetfrom = datetime.timedelta(seconds=tzoffsetfrom)\n        self.tzoffsetto = datetime.timedelta(seconds=tzoffsetto)\n        self.tzoffsetdiff = self.tzoffsetto - self.tzoffsetfrom\n        self.isdst = isdst\n        self.tzname = tzname\n        self.rrule = rrule\n\n\nclass _tzicalvtz(_tzinfo):\n    def __init__(self, tzid, comps=[]):\n        super(_tzicalvtz, self).__init__()\n\n        self._tzid = tzid\n        self._comps = comps\n        self._cachedate = []\n        self._cachecomp = []\n        self._cache_lock = _thread.allocate_lock()\n\n    def _find_comp(self, dt):\n        if len(self._comps) == 1:\n            return self._comps[0]\n\n        dt = dt.replace(tzinfo=None)\n\n        try:\n            with self._cache_lock:\n                return self._cachecomp[self._cachedate.index(\n                    (dt, self._fold(dt)))]\n        except ValueError:\n            pass\n\n        lastcompdt = None\n        lastcomp = None\n\n        for comp in self._comps:\n            compdt = self._find_compdt(comp, dt)\n\n            if compdt and (not lastcompdt or lastcompdt < compdt):\n                lastcompdt = compdt\n                lastcomp = comp\n\n        if not lastcomp:\n            # RFC says nothing about what to do when a given\n            # time is before the first onset date. We'll look for the\n            # first standard component, or the first component, if\n            # none is found.\n            for comp in self._comps:\n                if not comp.isdst:\n                    lastcomp = comp\n                    break\n            else:\n                lastcomp = comp[0]\n\n        with self._cache_lock:\n            self._cachedate.insert(0, (dt, self._fold(dt)))\n            self._cachecomp.insert(0, lastcomp)\n\n            if len(self._cachedate) > 10:\n                self._cachedate.pop()\n                self._cachecomp.pop()\n\n        return lastcomp\n\n    def _find_compdt(self, comp, dt):\n        if comp.tzoffsetdiff < ZERO and self._fold(dt):\n            dt -= comp.tzoffsetdiff\n\n        compdt = comp.rrule.before(dt, inc=True)\n\n        return compdt\n\n    def utcoffset(self, dt):\n        if dt is None:\n            return None\n\n        return self._find_comp(dt).tzoffsetto\n\n    def dst(self, dt):\n        comp = self._find_comp(dt)\n        if comp.isdst:\n            return comp.tzoffsetdiff\n        else:\n            return ZERO\n\n    @tzname_in_python2\n    def tzname(self, dt):\n        return self._find_comp(dt).tzname\n\n    def __repr__(self):\n        return \"<tzicalvtz %s>\" % repr(self._tzid)\n\n    __reduce__ = object.__reduce__\n\n\nclass tzical(object):\n    \"\"\"\n    This object is designed to parse an iCalendar-style ``VTIMEZONE`` structure\n    as set out in `RFC 5545`_ Section 4.6.5 into one or more `tzinfo` objects.\n\n    :param `fileobj`:\n        A file or stream in iCalendar format, which should be UTF-8 encoded\n        with CRLF endings.\n\n    .. _`RFC 5545`: https://tools.ietf.org/html/rfc5545\n    \"\"\"\n    def __init__(self, fileobj):\n        global rrule\n        from dateutil import rrule\n\n        if isinstance(fileobj, string_types):\n            self._s = fileobj\n            # ical should be encoded in UTF-8 with CRLF\n            fileobj = open(fileobj, 'r')\n        else:\n            self._s = getattr(fileobj, 'name', repr(fileobj))\n            fileobj = _nullcontext(fileobj)\n\n        self._vtz = {}\n\n        with fileobj as fobj:\n            self._parse_rfc(fobj.read())\n\n    def keys(self):\n        \"\"\"\n        Retrieves the available time zones as a list.\n        \"\"\"\n        return list(self._vtz.keys())\n\n    def get(self, tzid=None):\n        \"\"\"\n        Retrieve a :py:class:`datetime.tzinfo` object by its ``tzid``.\n\n        :param tzid:\n            If there is exactly one time zone available, omitting ``tzid``\n            or passing :py:const:`None` value returns it. Otherwise a valid\n            key (which can be retrieved from :func:`keys`) is required.\n\n        :raises ValueError:\n            Raised if ``tzid`` is not specified but there are either more\n            or fewer than 1 zone defined.\n\n        :returns:\n            Returns either a :py:class:`datetime.tzinfo` object representing\n            the relevant time zone or :py:const:`None` if the ``tzid`` was\n            not found.\n        \"\"\"\n        if tzid is None:\n            if len(self._vtz) == 0:\n                raise ValueError(\"no timezones defined\")\n            elif len(self._vtz) > 1:\n                raise ValueError(\"more than one timezone available\")\n            tzid = next(iter(self._vtz))\n\n        return self._vtz.get(tzid)\n\n    def _parse_offset(self, s):\n        s = s.strip()\n        if not s:\n            raise ValueError(\"empty offset\")\n        if s[0] in ('+', '-'):\n            signal = (-1, +1)[s[0] == '+']\n            s = s[1:]\n        else:\n            signal = +1\n        if len(s) == 4:\n            return (int(s[:2]) * 3600 + int(s[2:]) * 60) * signal\n        elif len(s) == 6:\n            return (int(s[:2]) * 3600 + int(s[2:4]) * 60 + int(s[4:])) * signal\n        else:\n            raise ValueError(\"invalid offset: \" + s)\n\n    def _parse_rfc(self, s):\n        lines = s.splitlines()\n        if not lines:\n            raise ValueError(\"empty string\")\n\n        # Unfold\n        i = 0\n        while i < len(lines):\n            line = lines[i].rstrip()\n            if not line:\n                del lines[i]\n            elif i > 0 and line[0] == \" \":\n                lines[i-1] += line[1:]\n                del lines[i]\n            else:\n                i += 1\n\n        tzid = None\n        comps = []\n        invtz = False\n        comptype = None\n        for line in lines:\n            if not line:\n                continue\n            name, value = line.split(':', 1)\n            parms = name.split(';')\n            if not parms:\n                raise ValueError(\"empty property name\")\n            name = parms[0].upper()\n            parms = parms[1:]\n            if invtz:\n                if name == \"BEGIN\":\n                    if value in (\"STANDARD\", \"DAYLIGHT\"):\n                        # Process component\n                        pass\n                    else:\n                        raise ValueError(\"unknown component: \"+value)\n                    comptype = value\n                    founddtstart = False\n                    tzoffsetfrom = None\n                    tzoffsetto = None\n                    rrulelines = []\n                    tzname = None\n                elif name == \"END\":\n                    if value == \"VTIMEZONE\":\n                        if comptype:\n                            raise ValueError(\"component not closed: \"+comptype)\n                        if not tzid:\n                            raise ValueError(\"mandatory TZID not found\")\n                        if not comps:\n                            raise ValueError(\n                                \"at least one component is needed\")\n                        # Process vtimezone\n                        self._vtz[tzid] = _tzicalvtz(tzid, comps)\n                        invtz = False\n                    elif value == comptype:\n                        if not founddtstart:\n                            raise ValueError(\"mandatory DTSTART not found\")\n                        if tzoffsetfrom is None:\n                            raise ValueError(\n                                \"mandatory TZOFFSETFROM not found\")\n                        if tzoffsetto is None:\n                            raise ValueError(\n                                \"mandatory TZOFFSETFROM not found\")\n                        # Process component\n                        rr = None\n                        if rrulelines:\n                            rr = rrule.rrulestr(\"\\n\".join(rrulelines),\n                                                compatible=True,\n                                                ignoretz=True,\n                                                cache=True)\n                        comp = _tzicalvtzcomp(tzoffsetfrom, tzoffsetto,\n                                              (comptype == \"DAYLIGHT\"),\n                                              tzname, rr)\n                        comps.append(comp)\n                        comptype = None\n                    else:\n                        raise ValueError(\"invalid component end: \"+value)\n                elif comptype:\n                    if name == \"DTSTART\":\n                        # DTSTART in VTIMEZONE takes a subset of valid RRULE\n                        # values under RFC 5545.\n                        for parm in parms:\n                            if parm != 'VALUE=DATE-TIME':\n                                msg = ('Unsupported DTSTART param in ' +\n                                       'VTIMEZONE: ' + parm)\n                                raise ValueError(msg)\n                        rrulelines.append(line)\n                        founddtstart = True\n                    elif name in (\"RRULE\", \"RDATE\", \"EXRULE\", \"EXDATE\"):\n                        rrulelines.append(line)\n                    elif name == \"TZOFFSETFROM\":\n                        if parms:\n                            raise ValueError(\n                                \"unsupported %s parm: %s \" % (name, parms[0]))\n                        tzoffsetfrom = self._parse_offset(value)\n                    elif name == \"TZOFFSETTO\":\n                        if parms:\n                            raise ValueError(\n                                \"unsupported TZOFFSETTO parm: \"+parms[0])\n                        tzoffsetto = self._parse_offset(value)\n                    elif name == \"TZNAME\":\n                        if parms:\n                            raise ValueError(\n                                \"unsupported TZNAME parm: \"+parms[0])\n                        tzname = value\n                    elif name == \"COMMENT\":\n                        pass\n                    else:\n                        raise ValueError(\"unsupported property: \"+name)\n                else:\n                    if name == \"TZID\":\n                        if parms:\n                            raise ValueError(\n                                \"unsupported TZID parm: \"+parms[0])\n                        tzid = value\n                    elif name in (\"TZURL\", \"LAST-MODIFIED\", \"COMMENT\"):\n                        pass\n                    else:\n                        raise ValueError(\"unsupported property: \"+name)\n            elif name == \"BEGIN\" and value == \"VTIMEZONE\":\n                tzid = None\n                comps = []\n                invtz = True\n\n    def __repr__(self):\n        return \"%s(%s)\" % (self.__class__.__name__, repr(self._s))\n\n\nif sys.platform != \"win32\":\n    TZFILES = [\"/etc/localtime\", \"localtime\"]\n    TZPATHS = [\"/usr/share/zoneinfo\",\n               \"/usr/lib/zoneinfo\",\n               \"/usr/share/lib/zoneinfo\",\n               \"/etc/zoneinfo\"]\nelse:\n    TZFILES = []\n    TZPATHS = []\n\n\ndef __get_gettz():\n    tzlocal_classes = (tzlocal,)\n    if tzwinlocal is not None:\n        tzlocal_classes += (tzwinlocal,)\n\n    class GettzFunc(object):\n        \"\"\"\n        Retrieve a time zone object from a string representation\n\n        This function is intended to retrieve the :py:class:`tzinfo` subclass\n        that best represents the time zone that would be used if a POSIX\n        `TZ variable`_ were set to the same value.\n\n        If no argument or an empty string is passed to ``gettz``, local time\n        is returned:\n\n        .. code-block:: python3\n\n            >>> gettz()\n            tzfile('/etc/localtime')\n\n        This function is also the preferred way to map IANA tz database keys\n        to :class:`tzfile` objects:\n\n        .. code-block:: python3\n\n            >>> gettz('Pacific/Kiritimati')\n            tzfile('/usr/share/zoneinfo/Pacific/Kiritimati')\n\n        On Windows, the standard is extended to include the Windows-specific\n        zone names provided by the operating system:\n\n        .. code-block:: python3\n\n            >>> gettz('Egypt Standard Time')\n            tzwin('Egypt Standard Time')\n\n        Passing a GNU ``TZ`` style string time zone specification returns a\n        :class:`tzstr` object:\n\n        .. code-block:: python3\n\n            >>> gettz('AEST-10AEDT-11,M10.1.0/2,M4.1.0/3')\n            tzstr('AEST-10AEDT-11,M10.1.0/2,M4.1.0/3')\n\n        :param name:\n            A time zone name (IANA, or, on Windows, Windows keys), location of\n            a ``tzfile(5)`` zoneinfo file or ``TZ`` variable style time zone\n            specifier. An empty string, no argument or ``None`` is interpreted\n            as local time.\n\n        :return:\n            Returns an instance of one of ``dateutil``'s :py:class:`tzinfo`\n            subclasses.\n\n        .. versionchanged:: 2.7.0\n\n            After version 2.7.0, any two calls to ``gettz`` using the same\n            input strings will return the same object:\n\n            .. code-block:: python3\n\n                >>> tz.gettz('America/Chicago') is tz.gettz('America/Chicago')\n                True\n\n            In addition to improving performance, this ensures that\n            `\"same zone\" semantics`_ are used for datetimes in the same zone.\n\n\n        .. _`TZ variable`:\n            https://www.gnu.org/software/libc/manual/html_node/TZ-Variable.html\n\n        .. _`\"same zone\" semantics`:\n            https://blog.ganssle.io/articles/2018/02/aware-datetime-arithmetic.html\n        \"\"\"\n        def __init__(self):\n\n            self.__instances = weakref.WeakValueDictionary()\n            self.__strong_cache_size = 8\n            self.__strong_cache = OrderedDict()\n            self._cache_lock = _thread.allocate_lock()\n\n        def __call__(self, name=None):\n            with self._cache_lock:\n                rv = self.__instances.get(name, None)\n\n                if rv is None:\n                    rv = self.nocache(name=name)\n                    if not (name is None\n                            or isinstance(rv, tzlocal_classes)\n                            or rv is None):\n                        # tzlocal is slightly more complicated than the other\n                        # time zone providers because it depends on environment\n                        # at construction time, so don't cache that.\n                        #\n                        # We also cannot store weak references to None, so we\n                        # will also not store that.\n                        self.__instances[name] = rv\n                    else:\n                        # No need for strong caching, return immediately\n                        return rv\n\n                self.__strong_cache[name] = self.__strong_cache.pop(name, rv)\n\n                if len(self.__strong_cache) > self.__strong_cache_size:\n                    self.__strong_cache.popitem(last=False)\n\n            return rv\n\n        def set_cache_size(self, size):\n            with self._cache_lock:\n                self.__strong_cache_size = size\n                while len(self.__strong_cache) > size:\n                    self.__strong_cache.popitem(last=False)\n\n        def cache_clear(self):\n            with self._cache_lock:\n                self.__instances = weakref.WeakValueDictionary()\n                self.__strong_cache.clear()\n\n        @staticmethod\n        def nocache(name=None):\n            \"\"\"A non-cached version of gettz\"\"\"\n            tz = None\n            if not name:\n                try:\n                    name = os.environ[\"TZ\"]\n                except KeyError:\n                    pass\n            if name is None or name in (\"\", \":\"):\n                for filepath in TZFILES:\n                    if not os.path.isabs(filepath):\n                        filename = filepath\n                        for path in TZPATHS:\n                            filepath = os.path.join(path, filename)\n                            if os.path.isfile(filepath):\n                                break\n                        else:\n                            continue\n                    if os.path.isfile(filepath):\n                        try:\n                            tz = tzfile(filepath)\n                            break\n                        except (IOError, OSError, ValueError):\n                            pass\n                else:\n                    tz = tzlocal()\n            else:\n                try:\n                    if name.startswith(\":\"):\n                        name = name[1:]\n                except TypeError as e:\n                    if isinstance(name, bytes):\n                        new_msg = \"gettz argument should be str, not bytes\"\n                        six.raise_from(TypeError(new_msg), e)\n                    else:\n                        raise\n                if os.path.isabs(name):\n                    if os.path.isfile(name):\n                        tz = tzfile(name)\n                    else:\n                        tz = None\n                else:\n                    for path in TZPATHS:\n                        filepath = os.path.join(path, name)\n                        if not os.path.isfile(filepath):\n                            filepath = filepath.replace(' ', '_')\n                            if not os.path.isfile(filepath):\n                                continue\n                        try:\n                            tz = tzfile(filepath)\n                            break\n                        except (IOError, OSError, ValueError):\n                            pass\n                    else:\n                        tz = None\n                        if tzwin is not None:\n                            try:\n                                tz = tzwin(name)\n                            except (WindowsError, UnicodeEncodeError):\n                                # UnicodeEncodeError is for Python 2.7 compat\n                                tz = None\n\n                        if not tz:\n                            from dateutil.zoneinfo import get_zonefile_instance\n                            tz = get_zonefile_instance().get(name)\n\n                        if not tz:\n                            for c in name:\n                                # name is not a tzstr unless it has at least\n                                # one offset. For short values of \"name\", an\n                                # explicit for loop seems to be the fastest way\n                                # To determine if a string contains a digit\n                                if c in \"0123456789\":\n                                    try:\n                                        tz = tzstr(name)\n                                    except ValueError:\n                                        pass\n                                    break\n                            else:\n                                if name in (\"GMT\", \"UTC\"):\n                                    tz = UTC\n                                elif name in time.tzname:\n                                    tz = tzlocal()\n            return tz\n\n    return GettzFunc()\n\n\ngettz = __get_gettz()\ndel __get_gettz\n\n\ndef datetime_exists(dt, tz=None):\n    \"\"\"\n    Given a datetime and a time zone, determine whether or not a given datetime\n    would fall in a gap.\n\n    :param dt:\n        A :class:`datetime.datetime` (whose time zone will be ignored if ``tz``\n        is provided.)\n\n    :param tz:\n        A :class:`datetime.tzinfo` with support for the ``fold`` attribute. If\n        ``None`` or not provided, the datetime's own time zone will be used.\n\n    :return:\n        Returns a boolean value whether or not the \"wall time\" exists in\n        ``tz``.\n\n    .. versionadded:: 2.7.0\n    \"\"\"\n    if tz is None:\n        if dt.tzinfo is None:\n            raise ValueError('Datetime is naive and no time zone provided.')\n        tz = dt.tzinfo\n\n    dt = dt.replace(tzinfo=None)\n\n    # This is essentially a test of whether or not the datetime can survive\n    # a round trip to UTC.\n    dt_rt = dt.replace(tzinfo=tz).astimezone(UTC).astimezone(tz)\n    dt_rt = dt_rt.replace(tzinfo=None)\n\n    return dt == dt_rt\n\n\ndef datetime_ambiguous(dt, tz=None):\n    \"\"\"\n    Given a datetime and a time zone, determine whether or not a given datetime\n    is ambiguous (i.e if there are two times differentiated only by their DST\n    status).\n\n    :param dt:\n        A :class:`datetime.datetime` (whose time zone will be ignored if ``tz``\n        is provided.)\n\n    :param tz:\n        A :class:`datetime.tzinfo` with support for the ``fold`` attribute. If\n        ``None`` or not provided, the datetime's own time zone will be used.\n\n    :return:\n        Returns a boolean value whether or not the \"wall time\" is ambiguous in\n        ``tz``.\n\n    .. versionadded:: 2.6.0\n    \"\"\"\n    if tz is None:\n        if dt.tzinfo is None:\n            raise ValueError('Datetime is naive and no time zone provided.')\n\n        tz = dt.tzinfo\n\n    # If a time zone defines its own \"is_ambiguous\" function, we'll use that.\n    is_ambiguous_fn = getattr(tz, 'is_ambiguous', None)\n    if is_ambiguous_fn is not None:\n        try:\n            return tz.is_ambiguous(dt)\n        except Exception:\n            pass\n\n    # If it doesn't come out and tell us it's ambiguous, we'll just check if\n    # the fold attribute has any effect on this particular date and time.\n    dt = dt.replace(tzinfo=tz)\n    wall_0 = enfold(dt, fold=0)\n    wall_1 = enfold(dt, fold=1)\n\n    same_offset = wall_0.utcoffset() == wall_1.utcoffset()\n    same_dst = wall_0.dst() == wall_1.dst()\n\n    return not (same_offset and same_dst)\n\n\ndef resolve_imaginary(dt):\n    \"\"\"\n    Given a datetime that may be imaginary, return an existing datetime.\n\n    This function assumes that an imaginary datetime represents what the\n    wall time would be in a zone had the offset transition not occurred, so\n    it will always fall forward by the transition's change in offset.\n\n    .. doctest::\n\n        >>> from dateutil import tz\n        >>> from datetime import datetime\n        >>> NYC = tz.gettz('America/New_York')\n        >>> print(tz.resolve_imaginary(datetime(2017, 3, 12, 2, 30, tzinfo=NYC)))\n        2017-03-12 03:30:00-04:00\n\n        >>> KIR = tz.gettz('Pacific/Kiritimati')\n        >>> print(tz.resolve_imaginary(datetime(1995, 1, 1, 12, 30, tzinfo=KIR)))\n        1995-01-02 12:30:00+14:00\n\n    As a note, :func:`datetime.astimezone` is guaranteed to produce a valid,\n    existing datetime, so a round-trip to and from UTC is sufficient to get\n    an extant datetime, however, this generally \"falls back\" to an earlier time\n    rather than falling forward to the STD side (though no guarantees are made\n    about this behavior).\n\n    :param dt:\n        A :class:`datetime.datetime` which may or may not exist.\n\n    :return:\n        Returns an existing :class:`datetime.datetime`. If ``dt`` was not\n        imaginary, the datetime returned is guaranteed to be the same object\n        passed to the function.\n\n    .. versionadded:: 2.7.0\n    \"\"\"\n    if dt.tzinfo is not None and not datetime_exists(dt):\n\n        curr_offset = (dt + datetime.timedelta(hours=24)).utcoffset()\n        old_offset = (dt - datetime.timedelta(hours=24)).utcoffset()\n\n        dt += curr_offset - old_offset\n\n    return dt\n\n\ndef _datetime_to_timestamp(dt):\n    \"\"\"\n    Convert a :class:`datetime.datetime` object to an epoch timestamp in\n    seconds since January 1, 1970, ignoring the time zone.\n    \"\"\"\n    return (dt.replace(tzinfo=None) - EPOCH).total_seconds()\n\n\nif sys.version_info >= (3, 6):\n    def _get_supported_offset(second_offset):\n        return second_offset\nelse:\n    def _get_supported_offset(second_offset):\n        # For python pre-3.6, round to full-minutes if that's not the case.\n        # Python's datetime doesn't accept sub-minute timezones. Check\n        # http://python.org/sf/1447945 or https://bugs.python.org/issue5288\n        # for some information.\n        old_offset = second_offset\n        calculated_offset = 60 * ((second_offset + 30) // 60)\n        return calculated_offset\n\n\ntry:\n    # Python 3.7 feature\n    from contextlib import nullcontext as _nullcontext\nexcept ImportError:\n    class _nullcontext(object):\n        \"\"\"\n        Class for wrapping contexts so that they are passed through in a\n        with statement.\n        \"\"\"\n        def __init__(self, context):\n            self.context = context\n\n        def __enter__(self):\n            return self.context\n\n        def __exit__(*args, **kwargs):\n            pass\n\n# vim:ts=4:sw=4:et\n", "src/dateutil/tz/win.py": "# -*- coding: utf-8 -*-\n\"\"\"\nThis module provides an interface to the native time zone data on Windows,\nincluding :py:class:`datetime.tzinfo` implementations.\n\nAttempting to import this module on a non-Windows platform will raise an\n:py:obj:`ImportError`.\n\"\"\"\n# This code was originally contributed by Jeffrey Harris.\nimport datetime\nimport struct\n\nfrom six.moves import winreg\nfrom six import text_type\n\ntry:\n    import ctypes\n    from ctypes import wintypes\nexcept ValueError:\n    # ValueError is raised on non-Windows systems for some horrible reason.\n    raise ImportError(\"Running tzwin on non-Windows system\")\n\nfrom ._common import tzrangebase\n\n__all__ = [\"tzwin\", \"tzwinlocal\", \"tzres\"]\n\nONEWEEK = datetime.timedelta(7)\n\nTZKEYNAMENT = r\"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones\"\nTZKEYNAME9X = r\"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Time Zones\"\nTZLOCALKEYNAME = r\"SYSTEM\\CurrentControlSet\\Control\\TimeZoneInformation\"\n\n\ndef _settzkeyname():\n    handle = winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE)\n    try:\n        winreg.OpenKey(handle, TZKEYNAMENT).Close()\n        TZKEYNAME = TZKEYNAMENT\n    except WindowsError:\n        TZKEYNAME = TZKEYNAME9X\n    handle.Close()\n    return TZKEYNAME\n\n\nTZKEYNAME = _settzkeyname()\n\n\nclass tzres(object):\n    \"\"\"\n    Class for accessing ``tzres.dll``, which contains timezone name related\n    resources.\n\n    .. versionadded:: 2.5.0\n    \"\"\"\n    p_wchar = ctypes.POINTER(wintypes.WCHAR)        # Pointer to a wide char\n\n    def __init__(self, tzres_loc='tzres.dll'):\n        # Load the user32 DLL so we can load strings from tzres\n        user32 = ctypes.WinDLL('user32')\n\n        # Specify the LoadStringW function\n        user32.LoadStringW.argtypes = (wintypes.HINSTANCE,\n                                       wintypes.UINT,\n                                       wintypes.LPWSTR,\n                                       ctypes.c_int)\n\n        self.LoadStringW = user32.LoadStringW\n        self._tzres = ctypes.WinDLL(tzres_loc)\n        self.tzres_loc = tzres_loc\n\n    def load_name(self, offset):\n        \"\"\"\n        Load a timezone name from a DLL offset (integer).\n\n        >>> from dateutil.tzwin import tzres\n        >>> tzr = tzres()\n        >>> print(tzr.load_name(112))\n        'Eastern Standard Time'\n\n        :param offset:\n            A positive integer value referring to a string from the tzres dll.\n\n        .. note::\n\n            Offsets found in the registry are generally of the form\n            ``@tzres.dll,-114``. The offset in this case is 114, not -114.\n\n        \"\"\"\n        resource = self.p_wchar()\n        lpBuffer = ctypes.cast(ctypes.byref(resource), wintypes.LPWSTR)\n        nchar = self.LoadStringW(self._tzres._handle, offset, lpBuffer, 0)\n        return resource[:nchar]\n\n    def name_from_string(self, tzname_str):\n        \"\"\"\n        Parse strings as returned from the Windows registry into the time zone\n        name as defined in the registry.\n\n        >>> from dateutil.tzwin import tzres\n        >>> tzr = tzres()\n        >>> print(tzr.name_from_string('@tzres.dll,-251'))\n        'Dateline Daylight Time'\n        >>> print(tzr.name_from_string('Eastern Standard Time'))\n        'Eastern Standard Time'\n\n        :param tzname_str:\n            A timezone name string as returned from a Windows registry key.\n\n        :return:\n            Returns the localized timezone string from tzres.dll if the string\n            is of the form `@tzres.dll,-offset`, else returns the input string.\n        \"\"\"\n        if not tzname_str.startswith('@'):\n            return tzname_str\n\n        name_splt = tzname_str.split(',-')\n        try:\n            offset = int(name_splt[1])\n        except:\n            raise ValueError(\"Malformed timezone string.\")\n\n        return self.load_name(offset)\n\n\nclass tzwinbase(tzrangebase):\n    \"\"\"tzinfo class based on win32's timezones available in the registry.\"\"\"\n    def __init__(self):\n        raise NotImplementedError('tzwinbase is an abstract base class')\n\n    def __eq__(self, other):\n        # Compare on all relevant dimensions, including name.\n        if not isinstance(other, tzwinbase):\n            return NotImplemented\n\n        return  (self._std_offset == other._std_offset and\n                 self._dst_offset == other._dst_offset and\n                 self._stddayofweek == other._stddayofweek and\n                 self._dstdayofweek == other._dstdayofweek and\n                 self._stdweeknumber == other._stdweeknumber and\n                 self._dstweeknumber == other._dstweeknumber and\n                 self._stdhour == other._stdhour and\n                 self._dsthour == other._dsthour and\n                 self._stdminute == other._stdminute and\n                 self._dstminute == other._dstminute and\n                 self._std_abbr == other._std_abbr and\n                 self._dst_abbr == other._dst_abbr)\n\n    @staticmethod\n    def list():\n        \"\"\"Return a list of all time zones known to the system.\"\"\"\n        with winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE) as handle:\n            with winreg.OpenKey(handle, TZKEYNAME) as tzkey:\n                result = [winreg.EnumKey(tzkey, i)\n                          for i in range(winreg.QueryInfoKey(tzkey)[0])]\n        return result\n\n    def display(self):\n        \"\"\"\n        Return the display name of the time zone.\n        \"\"\"\n        return self._display\n\n    def transitions(self, year):\n        \"\"\"\n        For a given year, get the DST on and off transition times, expressed\n        always on the standard time side. For zones with no transitions, this\n        function returns ``None``.\n\n        :param year:\n            The year whose transitions you would like to query.\n\n        :return:\n            Returns a :class:`tuple` of :class:`datetime.datetime` objects,\n            ``(dston, dstoff)`` for zones with an annual DST transition, or\n            ``None`` for fixed offset zones.\n        \"\"\"\n\n        if not self.hasdst:\n            return None\n\n        dston = picknthweekday(year, self._dstmonth, self._dstdayofweek,\n                               self._dsthour, self._dstminute,\n                               self._dstweeknumber)\n\n        dstoff = picknthweekday(year, self._stdmonth, self._stddayofweek,\n                                self._stdhour, self._stdminute,\n                                self._stdweeknumber)\n\n        # Ambiguous dates default to the STD side\n        dstoff -= self._dst_base_offset\n\n        return dston, dstoff\n\n    def _get_hasdst(self):\n        return self._dstmonth != 0\n\n    @property\n    def _dst_base_offset(self):\n        return self._dst_base_offset_\n\n\nclass tzwin(tzwinbase):\n    \"\"\"\n    Time zone object created from the zone info in the Windows registry\n\n    These are similar to :py:class:`dateutil.tz.tzrange` objects in that\n    the time zone data is provided in the format of a single offset rule\n    for either 0 or 2 time zone transitions per year.\n\n    :param: name\n        The name of a Windows time zone key, e.g. \"Eastern Standard Time\".\n        The full list of keys can be retrieved with :func:`tzwin.list`.\n    \"\"\"\n\n    def __init__(self, name):\n        self._name = name\n\n        with winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE) as handle:\n            tzkeyname = text_type(\"{kn}\\\\{name}\").format(kn=TZKEYNAME, name=name)\n            with winreg.OpenKey(handle, tzkeyname) as tzkey:\n                keydict = valuestodict(tzkey)\n\n        self._std_abbr = keydict[\"Std\"]\n        self._dst_abbr = keydict[\"Dlt\"]\n\n        self._display = keydict[\"Display\"]\n\n        # See http://ww_winreg.jsiinc.com/SUBA/tip0300/rh0398.htm\n        tup = struct.unpack(\"=3l16h\", keydict[\"TZI\"])\n        stdoffset = -tup[0]-tup[1]          # Bias + StandardBias * -1\n        dstoffset = stdoffset-tup[2]        # + DaylightBias * -1\n        self._std_offset = datetime.timedelta(minutes=stdoffset)\n        self._dst_offset = datetime.timedelta(minutes=dstoffset)\n\n        # for the meaning see the win32 TIME_ZONE_INFORMATION structure docs\n        # http://msdn.microsoft.com/en-us/library/windows/desktop/ms725481(v=vs.85).aspx\n        (self._stdmonth,\n         self._stddayofweek,   # Sunday = 0\n         self._stdweeknumber,  # Last = 5\n         self._stdhour,\n         self._stdminute) = tup[4:9]\n\n        (self._dstmonth,\n         self._dstdayofweek,   # Sunday = 0\n         self._dstweeknumber,  # Last = 5\n         self._dsthour,\n         self._dstminute) = tup[12:17]\n\n        self._dst_base_offset_ = self._dst_offset - self._std_offset\n        self.hasdst = self._get_hasdst()\n\n    def __repr__(self):\n        return \"tzwin(%s)\" % repr(self._name)\n\n    def __reduce__(self):\n        return (self.__class__, (self._name,))\n\n\nclass tzwinlocal(tzwinbase):\n    \"\"\"\n    Class representing the local time zone information in the Windows registry\n\n    While :class:`dateutil.tz.tzlocal` makes system calls (via the :mod:`time`\n    module) to retrieve time zone information, ``tzwinlocal`` retrieves the\n    rules directly from the Windows registry and creates an object like\n    :class:`dateutil.tz.tzwin`.\n\n    Because Windows does not have an equivalent of :func:`time.tzset`, on\n    Windows, :class:`dateutil.tz.tzlocal` instances will always reflect the\n    time zone settings *at the time that the process was started*, meaning\n    changes to the machine's time zone settings during the run of a program\n    on Windows will **not** be reflected by :class:`dateutil.tz.tzlocal`.\n    Because ``tzwinlocal`` reads the registry directly, it is unaffected by\n    this issue.\n    \"\"\"\n    def __init__(self):\n        with winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE) as handle:\n            with winreg.OpenKey(handle, TZLOCALKEYNAME) as tzlocalkey:\n                keydict = valuestodict(tzlocalkey)\n\n            self._std_abbr = keydict[\"StandardName\"]\n            self._dst_abbr = keydict[\"DaylightName\"]\n\n            try:\n                tzkeyname = text_type('{kn}\\\\{sn}').format(kn=TZKEYNAME,\n                                                          sn=self._std_abbr)\n                with winreg.OpenKey(handle, tzkeyname) as tzkey:\n                    _keydict = valuestodict(tzkey)\n                    self._display = _keydict[\"Display\"]\n            except OSError:\n                self._display = None\n\n        stdoffset = -keydict[\"Bias\"]-keydict[\"StandardBias\"]\n        dstoffset = stdoffset-keydict[\"DaylightBias\"]\n\n        self._std_offset = datetime.timedelta(minutes=stdoffset)\n        self._dst_offset = datetime.timedelta(minutes=dstoffset)\n\n        # For reasons unclear, in this particular key, the day of week has been\n        # moved to the END of the SYSTEMTIME structure.\n        tup = struct.unpack(\"=8h\", keydict[\"StandardStart\"])\n\n        (self._stdmonth,\n         self._stdweeknumber,  # Last = 5\n         self._stdhour,\n         self._stdminute) = tup[1:5]\n\n        self._stddayofweek = tup[7]\n\n        tup = struct.unpack(\"=8h\", keydict[\"DaylightStart\"])\n\n        (self._dstmonth,\n         self._dstweeknumber,  # Last = 5\n         self._dsthour,\n         self._dstminute) = tup[1:5]\n\n        self._dstdayofweek = tup[7]\n\n        self._dst_base_offset_ = self._dst_offset - self._std_offset\n        self.hasdst = self._get_hasdst()\n\n    def __repr__(self):\n        return \"tzwinlocal()\"\n\n    def __str__(self):\n        # str will return the standard name, not the daylight name.\n        return \"tzwinlocal(%s)\" % repr(self._std_abbr)\n\n    def __reduce__(self):\n        return (self.__class__, ())\n\n\ndef picknthweekday(year, month, dayofweek, hour, minute, whichweek):\n    \"\"\" dayofweek == 0 means Sunday, whichweek 5 means last instance \"\"\"\n    first = datetime.datetime(year, month, 1, hour, minute)\n\n    # This will work if dayofweek is ISO weekday (1-7) or Microsoft-style (0-6),\n    # Because 7 % 7 = 0\n    weekdayone = first.replace(day=((dayofweek - first.isoweekday()) % 7) + 1)\n    wd = weekdayone + ((whichweek - 1) * ONEWEEK)\n    if (wd.month != month):\n        wd -= ONEWEEK\n\n    return wd\n\n\ndef valuestodict(key):\n    \"\"\"Convert a registry key's values to a dictionary.\"\"\"\n    dout = {}\n    size = winreg.QueryInfoKey(key)[1]\n    tz_res = None\n\n    for i in range(size):\n        key_name, value, dtype = winreg.EnumValue(key, i)\n        if dtype == winreg.REG_DWORD or dtype == winreg.REG_DWORD_LITTLE_ENDIAN:\n            # If it's a DWORD (32-bit integer), it's stored as unsigned - convert\n            # that to a proper signed integer\n            if value & (1 << 31):\n                value = value - (1 << 32)\n        elif dtype == winreg.REG_SZ:\n            # If it's a reference to the tzres DLL, load the actual string\n            if value.startswith('@tzres'):\n                tz_res = tz_res or tzres()\n                value = tz_res.name_from_string(value)\n\n            value = value.rstrip('\\x00')    # Remove trailing nulls\n\n        dout[key_name] = value\n\n    return dout\n", "src/dateutil/tz/_factories.py": "from datetime import timedelta\nimport weakref\nfrom collections import OrderedDict\n\nfrom six.moves import _thread\n\n\nclass _TzSingleton(type):\n    def __init__(cls, *args, **kwargs):\n        cls.__instance = None\n        super(_TzSingleton, cls).__init__(*args, **kwargs)\n\n    def __call__(cls):\n        if cls.__instance is None:\n            cls.__instance = super(_TzSingleton, cls).__call__()\n        return cls.__instance\n\n\nclass _TzFactory(type):\n    def instance(cls, *args, **kwargs):\n        \"\"\"Alternate constructor that returns a fresh instance\"\"\"\n        return type.__call__(cls, *args, **kwargs)\n\n\nclass _TzOffsetFactory(_TzFactory):\n    def __init__(cls, *args, **kwargs):\n        cls.__instances = weakref.WeakValueDictionary()\n        cls.__strong_cache = OrderedDict()\n        cls.__strong_cache_size = 8\n\n        cls._cache_lock = _thread.allocate_lock()\n\n    def __call__(cls, name, offset):\n        if isinstance(offset, timedelta):\n            key = (name, offset.total_seconds())\n        else:\n            key = (name, offset)\n\n        instance = cls.__instances.get(key, None)\n        if instance is None:\n            instance = cls.__instances.setdefault(key,\n                                                  cls.instance(name, offset))\n\n        # This lock may not be necessary in Python 3. See GH issue #901\n        with cls._cache_lock:\n            cls.__strong_cache[key] = cls.__strong_cache.pop(key, instance)\n\n            # Remove an item if the strong cache is overpopulated\n            if len(cls.__strong_cache) > cls.__strong_cache_size:\n                cls.__strong_cache.popitem(last=False)\n\n        return instance\n\n\nclass _TzStrFactory(_TzFactory):\n    def __init__(cls, *args, **kwargs):\n        cls.__instances = weakref.WeakValueDictionary()\n        cls.__strong_cache = OrderedDict()\n        cls.__strong_cache_size = 8\n\n        cls.__cache_lock = _thread.allocate_lock()\n\n    def __call__(cls, s, posix_offset=False):\n        key = (s, posix_offset)\n        instance = cls.__instances.get(key, None)\n\n        if instance is None:\n            instance = cls.__instances.setdefault(key,\n                cls.instance(s, posix_offset))\n\n        # This lock may not be necessary in Python 3. See GH issue #901\n        with cls.__cache_lock:\n            cls.__strong_cache[key] = cls.__strong_cache.pop(key, instance)\n\n            # Remove an item if the strong cache is overpopulated\n            if len(cls.__strong_cache) > cls.__strong_cache_size:\n                cls.__strong_cache.popitem(last=False)\n\n        return instance\n\n", "src/dateutil/tz/__init__.py": "# -*- coding: utf-8 -*-\nfrom .tz import *\nfrom .tz import __doc__\n\n__all__ = [\"tzutc\", \"tzoffset\", \"tzlocal\", \"tzfile\", \"tzrange\",\n           \"tzstr\", \"tzical\", \"tzwin\", \"tzwinlocal\", \"gettz\",\n           \"enfold\", \"datetime_ambiguous\", \"datetime_exists\",\n           \"resolve_imaginary\", \"UTC\", \"DeprecatedTzFormatWarning\"]\n\n\nclass DeprecatedTzFormatWarning(Warning):\n    \"\"\"Warning raised when time zones are parsed from deprecated formats.\"\"\"\n", "src/dateutil/zoneinfo/rebuild.py": "import logging\nimport os\nimport tempfile\nimport shutil\nimport json\nfrom subprocess import check_call, check_output\nfrom tarfile import TarFile\n\nfrom dateutil.zoneinfo import METADATA_FN, ZONEFILENAME\n\n\ndef rebuild(filename, tag=None, format=\"gz\", zonegroups=[], metadata=None):\n    \"\"\"Rebuild the internal timezone info in dateutil/zoneinfo/zoneinfo*tar*\n\n    filename is the timezone tarball from ``ftp.iana.org/tz``.\n\n    \"\"\"\n    tmpdir = tempfile.mkdtemp()\n    zonedir = os.path.join(tmpdir, \"zoneinfo\")\n    moduledir = os.path.dirname(__file__)\n    try:\n        with TarFile.open(filename) as tf:\n            for name in zonegroups:\n                tf.extract(name, tmpdir)\n            filepaths = [os.path.join(tmpdir, n) for n in zonegroups]\n\n            _run_zic(zonedir, filepaths)\n\n        # write metadata file\n        with open(os.path.join(zonedir, METADATA_FN), 'w') as f:\n            json.dump(metadata, f, indent=4, sort_keys=True)\n        target = os.path.join(moduledir, ZONEFILENAME)\n        with TarFile.open(target, \"w:%s\" % format) as tf:\n            for entry in os.listdir(zonedir):\n                entrypath = os.path.join(zonedir, entry)\n                tf.add(entrypath, entry)\n    finally:\n        shutil.rmtree(tmpdir)\n\n\ndef _run_zic(zonedir, filepaths):\n    \"\"\"Calls the ``zic`` compiler in a compatible way to get a \"fat\" binary.\n\n    Recent versions of ``zic`` default to ``-b slim``, while older versions\n    don't even have the ``-b`` option (but default to \"fat\" binaries). The\n    current version of dateutil does not support Version 2+ TZif files, which\n    causes problems when used in conjunction with \"slim\" binaries, so this\n    function is used to ensure that we always get a \"fat\" binary.\n    \"\"\"\n\n    try:\n        help_text = check_output([\"zic\", \"--help\"])\n    except OSError as e:\n        _print_on_nosuchfile(e)\n        raise\n\n    if b\"-b \" in help_text:\n        bloat_args = [\"-b\", \"fat\"]\n    else:\n        bloat_args = []\n\n    check_call([\"zic\"] + bloat_args + [\"-d\", zonedir] + filepaths)\n\n\ndef _print_on_nosuchfile(e):\n    \"\"\"Print helpful troubleshooting message\n\n    e is an exception raised by subprocess.check_call()\n\n    \"\"\"\n    if e.errno == 2:\n        logging.error(\n            \"Could not find zic. Perhaps you need to install \"\n            \"libc-bin or some other package that provides it, \"\n            \"or it's not in your PATH?\")\n", "src/dateutil/zoneinfo/__init__.py": "# -*- coding: utf-8 -*-\nimport warnings\nimport json\n\nfrom tarfile import TarFile\nfrom pkgutil import get_data\nfrom io import BytesIO\n\nfrom dateutil.tz import tzfile as _tzfile\n\n__all__ = [\"get_zonefile_instance\", \"gettz\", \"gettz_db_metadata\"]\n\nZONEFILENAME = \"dateutil-zoneinfo.tar.gz\"\nMETADATA_FN = 'METADATA'\n\n\nclass tzfile(_tzfile):\n    def __reduce__(self):\n        return (gettz, (self._filename,))\n\n\ndef getzoneinfofile_stream():\n    try:\n        return BytesIO(get_data(__name__, ZONEFILENAME))\n    except IOError as e:  # TODO  switch to FileNotFoundError?\n        warnings.warn(\"I/O error({0}): {1}\".format(e.errno, e.strerror))\n        return None\n\n\nclass ZoneInfoFile(object):\n    def __init__(self, zonefile_stream=None):\n        if zonefile_stream is not None:\n            with TarFile.open(fileobj=zonefile_stream) as tf:\n                self.zones = {zf.name: tzfile(tf.extractfile(zf), filename=zf.name)\n                              for zf in tf.getmembers()\n                              if zf.isfile() and zf.name != METADATA_FN}\n                # deal with links: They'll point to their parent object. Less\n                # waste of memory\n                links = {zl.name: self.zones[zl.linkname]\n                         for zl in tf.getmembers() if\n                         zl.islnk() or zl.issym()}\n                self.zones.update(links)\n                try:\n                    metadata_json = tf.extractfile(tf.getmember(METADATA_FN))\n                    metadata_str = metadata_json.read().decode('UTF-8')\n                    self.metadata = json.loads(metadata_str)\n                except KeyError:\n                    # no metadata in tar file\n                    self.metadata = None\n        else:\n            self.zones = {}\n            self.metadata = None\n\n    def get(self, name, default=None):\n        \"\"\"\n        Wrapper for :func:`ZoneInfoFile.zones.get`. This is a convenience method\n        for retrieving zones from the zone dictionary.\n\n        :param name:\n            The name of the zone to retrieve. (Generally IANA zone names)\n\n        :param default:\n            The value to return in the event of a missing key.\n\n        .. versionadded:: 2.6.0\n\n        \"\"\"\n        return self.zones.get(name, default)\n\n\n# The current API has gettz as a module function, although in fact it taps into\n# a stateful class. So as a workaround for now, without changing the API, we\n# will create a new \"global\" class instance the first time a user requests a\n# timezone. Ugly, but adheres to the api.\n#\n# TODO: Remove after deprecation period.\n_CLASS_ZONE_INSTANCE = []\n\n\ndef get_zonefile_instance(new_instance=False):\n    \"\"\"\n    This is a convenience function which provides a :class:`ZoneInfoFile`\n    instance using the data provided by the ``dateutil`` package. By default, it\n    caches a single instance of the ZoneInfoFile object and returns that.\n\n    :param new_instance:\n        If ``True``, a new instance of :class:`ZoneInfoFile` is instantiated and\n        used as the cached instance for the next call. Otherwise, new instances\n        are created only as necessary.\n\n    :return:\n        Returns a :class:`ZoneInfoFile` object.\n\n    .. versionadded:: 2.6\n    \"\"\"\n    if new_instance:\n        zif = None\n    else:\n        zif = getattr(get_zonefile_instance, '_cached_instance', None)\n\n    if zif is None:\n        zif = ZoneInfoFile(getzoneinfofile_stream())\n\n        get_zonefile_instance._cached_instance = zif\n\n    return zif\n\n\ndef gettz(name):\n    \"\"\"\n    This retrieves a time zone from the local zoneinfo tarball that is packaged\n    with dateutil.\n\n    :param name:\n        An IANA-style time zone name, as found in the zoneinfo file.\n\n    :return:\n        Returns a :class:`dateutil.tz.tzfile` time zone object.\n\n    .. warning::\n        It is generally inadvisable to use this function, and it is only\n        provided for API compatibility with earlier versions. This is *not*\n        equivalent to ``dateutil.tz.gettz()``, which selects an appropriate\n        time zone based on the inputs, favoring system zoneinfo. This is ONLY\n        for accessing the dateutil-specific zoneinfo (which may be out of\n        date compared to the system zoneinfo).\n\n    .. deprecated:: 2.6\n        If you need to use a specific zoneinfofile over the system zoneinfo,\n        instantiate a :class:`dateutil.zoneinfo.ZoneInfoFile` object and call\n        :func:`dateutil.zoneinfo.ZoneInfoFile.get(name)` instead.\n\n        Use :func:`get_zonefile_instance` to retrieve an instance of the\n        dateutil-provided zoneinfo.\n    \"\"\"\n    warnings.warn(\"zoneinfo.gettz() will be removed in future versions, \"\n                  \"to use the dateutil-provided zoneinfo files, instantiate a \"\n                  \"ZoneInfoFile object and use ZoneInfoFile.zones.get() \"\n                  \"instead. See the documentation for details.\",\n                  DeprecationWarning)\n\n    if len(_CLASS_ZONE_INSTANCE) == 0:\n        _CLASS_ZONE_INSTANCE.append(ZoneInfoFile(getzoneinfofile_stream()))\n    return _CLASS_ZONE_INSTANCE[0].zones.get(name)\n\n\ndef gettz_db_metadata():\n    \"\"\" Get the zonefile metadata\n\n    See `zonefile_metadata`_\n\n    :returns:\n        A dictionary with the database metadata\n\n    .. deprecated:: 2.6\n        See deprecation warning in :func:`zoneinfo.gettz`. To get metadata,\n        query the attribute ``zoneinfo.ZoneInfoFile.metadata``.\n    \"\"\"\n    warnings.warn(\"zoneinfo.gettz_db_metadata() will be removed in future \"\n                  \"versions, to use the dateutil-provided zoneinfo files, \"\n                  \"ZoneInfoFile object and query the 'metadata' attribute \"\n                  \"instead. See the documentation for details.\",\n                  DeprecationWarning)\n\n    if len(_CLASS_ZONE_INSTANCE) == 0:\n        _CLASS_ZONE_INSTANCE.append(ZoneInfoFile(getzoneinfofile_stream()))\n    return _CLASS_ZONE_INSTANCE[0].metadata\n"}