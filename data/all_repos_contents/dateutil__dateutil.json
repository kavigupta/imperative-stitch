{"updatezinfo.py": "#!/usr/bin/env python\nimport os\nimport hashlib\nimport json\nimport io\n\nfrom six.moves.urllib import request\nfrom six.moves.urllib import error as urllib_error\n\ntry:\n    import dateutil\nexcept ImportError:\n    print(\"dateutil not installed locally, adding src to Python path\")\n    import sys\n    here = os.path.dirname(__file__)\n    sys.path.append(os.path.join(here, \"src\"))\n    print(sys.path)\n\nfrom dateutil.zoneinfo import rebuild\n\nMETADATA_FILE = \"zonefile_metadata.json\"\n\n\ndef main(metadata_file):\n    with io.open(metadata_file, 'r') as f:\n        metadata = json.load(f)\n\n    releases_urls = metadata['releases_url']\n    if metadata['metadata_version'] < 2.0:\n        # In later versions the releases URL is a mirror URL\n        releases_urls = [releases_urls]\n\n    if not os.path.isfile(metadata['tzdata_file']):\n\n        for ii, releases_url in enumerate(releases_urls):\n            print(\"Downloading tz file from mirror {ii}\".format(ii=ii))\n            try:\n                request.urlretrieve(os.path.join(releases_url,\n                                                 metadata['tzdata_file']),\n                                    metadata['tzdata_file'])\n            except urllib_error.URLError as e:\n                print(\"Download failed, trying next mirror.\")\n                last_error = e\n                continue\n\n            last_error = None\n            break\n\n        if last_error is not None:\n            raise last_error\n\n    with open(metadata['tzdata_file'], 'rb') as tzfile:\n        sha_hasher = hashlib.sha512()\n        sha_hasher.update(tzfile.read())\n        sha_512_file = sha_hasher.hexdigest()\n        assert metadata['tzdata_file_sha512'] == sha_512_file, \"SHA failed for\"\n    print(\"Updating timezone information...\")\n    rebuild.rebuild(metadata['tzdata_file'], zonegroups=metadata['zonegroups'],\n            metadata=metadata)\n    print(\"Done.\")\n\n\nif __name__ == \"__main__\":\n    import argparse\n    parser = argparse.ArgumentParser()\n    parser.add_argument('metadata', metavar='METADATA_FILE',\n                        default=METADATA_FILE,\n                        nargs='?')\n\n    args = parser.parse_args()\n    main(args.metadata)\n", "setup.py": "#!/usr/bin/python\nfrom os.path import isfile\nimport os\n\nimport setuptools\nfrom setuptools import setup, find_packages\nfrom setuptools.command.test import test as TestCommand\n\nfrom distutils.version import LooseVersion\nimport warnings\n\nimport io\nimport sys\n\nif isfile(\"MANIFEST\"):\n    os.unlink(\"MANIFEST\")\n\nif LooseVersion(setuptools.__version__) <= LooseVersion(\"24.3\"):\n    warnings.warn(\"python_requires requires setuptools version > 24.3\",\n                  UserWarning)\n\n\nclass Unsupported(TestCommand):\n    def run(self):\n        sys.stderr.write(\"Running 'test' with setup.py is not supported. \"\n                         \"Use 'pytest' or 'tox' to run the tests.\\n\")\n        sys.exit(1)\n\n\n###\n# Load metadata\n\ndef README():\n    with io.open('README.rst', encoding='utf-8') as f:\n        readme_lines = f.readlines()\n\n    # The .. doctest directive is not supported by PyPA\n    lines_out = []\n    for line in readme_lines:\n        if line.startswith('.. doctest'):\n            lines_out.append('.. code-block:: python3\\n')\n        else:\n            lines_out.append(line)\n\n    return ''.join(lines_out)\nREADME = README()  # NOQA\n\n\nsetup(\n      use_scm_version={\n          'write_to': 'src/dateutil/_version.py',\n      },\n      ## Needed since doctest not supported by PyPA.\n      long_description = README,\n      cmdclass={\n          \"test\": Unsupported\n      }\n      )\n", "src/dateutil/relativedelta.py": "# -*- coding: utf-8 -*-\nimport datetime\nimport calendar\n\nimport operator\nfrom math import copysign\n\nfrom six import integer_types\nfrom warnings import warn\n\nfrom ._common import weekday\n\nMO, TU, WE, TH, FR, SA, SU = weekdays = tuple(weekday(x) for x in range(7))\n\n__all__ = [\"relativedelta\", \"MO\", \"TU\", \"WE\", \"TH\", \"FR\", \"SA\", \"SU\"]\n\n\nclass relativedelta(object):\n    \"\"\"\n    The relativedelta type is designed to be applied to an existing datetime and\n    can replace specific components of that datetime, or represents an interval\n    of time.\n\n    It is based on the specification of the excellent work done by M.-A. Lemburg\n    in his\n    `mx.DateTime <https://www.egenix.com/products/python/mxBase/mxDateTime/>`_ extension.\n    However, notice that this type does *NOT* implement the same algorithm as\n    his work. Do *NOT* expect it to behave like mx.DateTime's counterpart.\n\n    There are two different ways to build a relativedelta instance. The\n    first one is passing it two date/datetime classes::\n\n        relativedelta(datetime1, datetime2)\n\n    The second one is passing it any number of the following keyword arguments::\n\n        relativedelta(arg1=x,arg2=y,arg3=z...)\n\n        year, month, day, hour, minute, second, microsecond:\n            Absolute information (argument is singular); adding or subtracting a\n            relativedelta with absolute information does not perform an arithmetic\n            operation, but rather REPLACES the corresponding value in the\n            original datetime with the value(s) in relativedelta.\n\n        years, months, weeks, days, hours, minutes, seconds, microseconds:\n            Relative information, may be negative (argument is plural); adding\n            or subtracting a relativedelta with relative information performs\n            the corresponding arithmetic operation on the original datetime value\n            with the information in the relativedelta.\n\n        weekday:\n            One of the weekday instances (MO, TU, etc) available in the\n            relativedelta module. These instances may receive a parameter N,\n            specifying the Nth weekday, which could be positive or negative\n            (like MO(+1) or MO(-2)). Not specifying it is the same as specifying\n            +1. You can also use an integer, where 0=MO. This argument is always\n            relative e.g. if the calculated date is already Monday, using MO(1)\n            or MO(-1) won't change the day. To effectively make it absolute, use\n            it in combination with the day argument (e.g. day=1, MO(1) for first\n            Monday of the month).\n\n        leapdays:\n            Will add given days to the date found, if year is a leap\n            year, and the date found is post 28 of february.\n\n        yearday, nlyearday:\n            Set the yearday or the non-leap year day (jump leap days).\n            These are converted to day/month/leapdays information.\n\n    There are relative and absolute forms of the keyword\n    arguments. The plural is relative, and the singular is\n    absolute. For each argument in the order below, the absolute form\n    is applied first (by setting each attribute to that value) and\n    then the relative form (by adding the value to the attribute).\n\n    The order of attributes considered when this relativedelta is\n    added to a datetime is:\n\n    1. Year\n    2. Month\n    3. Day\n    4. Hours\n    5. Minutes\n    6. Seconds\n    7. Microseconds\n\n    Finally, weekday is applied, using the rule described above.\n\n    For example\n\n    >>> from datetime import datetime\n    >>> from dateutil.relativedelta import relativedelta, MO\n    >>> dt = datetime(2018, 4, 9, 13, 37, 0)\n    >>> delta = relativedelta(hours=25, day=1, weekday=MO(1))\n    >>> dt + delta\n    datetime.datetime(2018, 4, 2, 14, 37)\n\n    First, the day is set to 1 (the first of the month), then 25 hours\n    are added, to get to the 2nd day and 14th hour, finally the\n    weekday is applied, but since the 2nd is already a Monday there is\n    no effect.\n\n    \"\"\"\n\n    def __init__(self, dt1=None, dt2=None,\n                 years=0, months=0, days=0, leapdays=0, weeks=0,\n                 hours=0, minutes=0, seconds=0, microseconds=0,\n                 year=None, month=None, day=None, weekday=None,\n                 yearday=None, nlyearday=None,\n                 hour=None, minute=None, second=None, microsecond=None):\n\n        if dt1 and dt2:\n            # datetime is a subclass of date. So both must be date\n            if not (isinstance(dt1, datetime.date) and\n                    isinstance(dt2, datetime.date)):\n                raise TypeError(\"relativedelta only diffs datetime/date\")\n\n            # We allow two dates, or two datetimes, so we coerce them to be\n            # of the same type\n            if (isinstance(dt1, datetime.datetime) !=\n                    isinstance(dt2, datetime.datetime)):\n                if not isinstance(dt1, datetime.datetime):\n                    dt1 = datetime.datetime.fromordinal(dt1.toordinal())\n                elif not isinstance(dt2, datetime.datetime):\n                    dt2 = datetime.datetime.fromordinal(dt2.toordinal())\n\n            self.years = 0\n            self.months = 0\n            self.days = 0\n            self.leapdays = 0\n            self.hours = 0\n            self.minutes = 0\n            self.seconds = 0\n            self.microseconds = 0\n            self.year = None\n            self.month = None\n            self.day = None\n            self.weekday = None\n            self.hour = None\n            self.minute = None\n            self.second = None\n            self.microsecond = None\n            self._has_time = 0\n\n            # Get year / month delta between the two\n            months = (dt1.year - dt2.year) * 12 + (dt1.month - dt2.month)\n            self._set_months(months)\n\n            # Remove the year/month delta so the timedelta is just well-defined\n            # time units (seconds, days and microseconds)\n            dtm = self.__radd__(dt2)\n\n            # If we've overshot our target, make an adjustment\n            if dt1 < dt2:\n                compare = operator.gt\n                increment = 1\n            else:\n                compare = operator.lt\n                increment = -1\n\n            while compare(dt1, dtm):\n                months += increment\n                self._set_months(months)\n                dtm = self.__radd__(dt2)\n\n            # Get the timedelta between the \"months-adjusted\" date and dt1\n            delta = dt1 - dtm\n            self.seconds = delta.seconds + delta.days * 86400\n            self.microseconds = delta.microseconds\n        else:\n            # Check for non-integer values in integer-only quantities\n            if any(x is not None and x != int(x) for x in (years, months)):\n                raise ValueError(\"Non-integer years and months are \"\n                                 \"ambiguous and not currently supported.\")\n\n            # Relative information\n            self.years = int(years)\n            self.months = int(months)\n            self.days = days + weeks * 7\n            self.leapdays = leapdays\n            self.hours = hours\n            self.minutes = minutes\n            self.seconds = seconds\n            self.microseconds = microseconds\n\n            # Absolute information\n            self.year = year\n            self.month = month\n            self.day = day\n            self.hour = hour\n            self.minute = minute\n            self.second = second\n            self.microsecond = microsecond\n\n            if any(x is not None and int(x) != x\n                   for x in (year, month, day, hour,\n                             minute, second, microsecond)):\n                # For now we'll deprecate floats - later it'll be an error.\n                warn(\"Non-integer value passed as absolute information. \" +\n                     \"This is not a well-defined condition and will raise \" +\n                     \"errors in future versions.\", DeprecationWarning)\n\n            if isinstance(weekday, integer_types):\n                self.weekday = weekdays[weekday]\n            else:\n                self.weekday = weekday\n\n            yday = 0\n            if nlyearday:\n                yday = nlyearday\n            elif yearday:\n                yday = yearday\n                if yearday > 59:\n                    self.leapdays = -1\n            if yday:\n                ydayidx = [31, 59, 90, 120, 151, 181, 212,\n                           243, 273, 304, 334, 366]\n                for idx, ydays in enumerate(ydayidx):\n                    if yday <= ydays:\n                        self.month = idx+1\n                        if idx == 0:\n                            self.day = yday\n                        else:\n                            self.day = yday-ydayidx[idx-1]\n                        break\n                else:\n                    raise ValueError(\"invalid year day (%d)\" % yday)\n\n        self._fix()\n\n    def _fix(self):\n        if abs(self.microseconds) > 999999:\n            s = _sign(self.microseconds)\n            div, mod = divmod(self.microseconds * s, 1000000)\n            self.microseconds = mod * s\n            self.seconds += div * s\n        if abs(self.seconds) > 59:\n            s = _sign(self.seconds)\n            div, mod = divmod(self.seconds * s, 60)\n            self.seconds = mod * s\n            self.minutes += div * s\n        if abs(self.minutes) > 59:\n            s = _sign(self.minutes)\n            div, mod = divmod(self.minutes * s, 60)\n            self.minutes = mod * s\n            self.hours += div * s\n        if abs(self.hours) > 23:\n            s = _sign(self.hours)\n            div, mod = divmod(self.hours * s, 24)\n            self.hours = mod * s\n            self.days += div * s\n        if abs(self.months) > 11:\n            s = _sign(self.months)\n            div, mod = divmod(self.months * s, 12)\n            self.months = mod * s\n            self.years += div * s\n        if (self.hours or self.minutes or self.seconds or self.microseconds\n                or self.hour is not None or self.minute is not None or\n                self.second is not None or self.microsecond is not None):\n            self._has_time = 1\n        else:\n            self._has_time = 0\n\n    @property\n    def weeks(self):\n        return int(self.days / 7.0)\n\n    @weeks.setter\n    def weeks(self, value):\n        self.days = self.days - (self.weeks * 7) + value * 7\n\n    def _set_months(self, months):\n        self.months = months\n        if abs(self.months) > 11:\n            s = _sign(self.months)\n            div, mod = divmod(self.months * s, 12)\n            self.months = mod * s\n            self.years = div * s\n        else:\n            self.years = 0\n\n    def normalized(self):\n        \"\"\"\n        Return a version of this object represented entirely using integer\n        values for the relative attributes.\n\n        >>> relativedelta(days=1.5, hours=2).normalized()\n        relativedelta(days=+1, hours=+14)\n\n        :return:\n            Returns a :class:`dateutil.relativedelta.relativedelta` object.\n        \"\"\"\n        # Cascade remainders down (rounding each to roughly nearest microsecond)\n        days = int(self.days)\n\n        hours_f = round(self.hours + 24 * (self.days - days), 11)\n        hours = int(hours_f)\n\n        minutes_f = round(self.minutes + 60 * (hours_f - hours), 10)\n        minutes = int(minutes_f)\n\n        seconds_f = round(self.seconds + 60 * (minutes_f - minutes), 8)\n        seconds = int(seconds_f)\n\n        microseconds = round(self.microseconds + 1e6 * (seconds_f - seconds))\n\n        # Constructor carries overflow back up with call to _fix()\n        return self.__class__(years=self.years, months=self.months,\n                              days=days, hours=hours, minutes=minutes,\n                              seconds=seconds, microseconds=microseconds,\n                              leapdays=self.leapdays, year=self.year,\n                              month=self.month, day=self.day,\n                              weekday=self.weekday, hour=self.hour,\n                              minute=self.minute, second=self.second,\n                              microsecond=self.microsecond)\n\n    def __add__(self, other):\n        if isinstance(other, relativedelta):\n            return self.__class__(years=other.years + self.years,\n                                 months=other.months + self.months,\n                                 days=other.days + self.days,\n                                 hours=other.hours + self.hours,\n                                 minutes=other.minutes + self.minutes,\n                                 seconds=other.seconds + self.seconds,\n                                 microseconds=(other.microseconds +\n                                               self.microseconds),\n                                 leapdays=other.leapdays or self.leapdays,\n                                 year=(other.year if other.year is not None\n                                       else self.year),\n                                 month=(other.month if other.month is not None\n                                        else self.month),\n                                 day=(other.day if other.day is not None\n                                      else self.day),\n                                 weekday=(other.weekday if other.weekday is not None\n                                          else self.weekday),\n                                 hour=(other.hour if other.hour is not None\n                                       else self.hour),\n                                 minute=(other.minute if other.minute is not None\n                                         else self.minute),\n                                 second=(other.second if other.second is not None\n                                         else self.second),\n                                 microsecond=(other.microsecond if other.microsecond\n                                              is not None else\n                                              self.microsecond))\n        if isinstance(other, datetime.timedelta):\n            return self.__class__(years=self.years,\n                                  months=self.months,\n                                  days=self.days + other.days,\n                                  hours=self.hours,\n                                  minutes=self.minutes,\n                                  seconds=self.seconds + other.seconds,\n                                  microseconds=self.microseconds + other.microseconds,\n                                  leapdays=self.leapdays,\n                                  year=self.year,\n                                  month=self.month,\n                                  day=self.day,\n                                  weekday=self.weekday,\n                                  hour=self.hour,\n                                  minute=self.minute,\n                                  second=self.second,\n                                  microsecond=self.microsecond)\n        if not isinstance(other, datetime.date):\n            return NotImplemented\n        elif self._has_time and not isinstance(other, datetime.datetime):\n            other = datetime.datetime.fromordinal(other.toordinal())\n        year = (self.year or other.year)+self.years\n        month = self.month or other.month\n        if self.months:\n            assert 1 <= abs(self.months) <= 12\n            month += self.months\n            if month > 12:\n                year += 1\n                month -= 12\n            elif month < 1:\n                year -= 1\n                month += 12\n        day = min(calendar.monthrange(year, month)[1],\n                  self.day or other.day)\n        repl = {\"year\": year, \"month\": month, \"day\": day}\n        for attr in [\"hour\", \"minute\", \"second\", \"microsecond\"]:\n            value = getattr(self, attr)\n            if value is not None:\n                repl[attr] = value\n        days = self.days\n        if self.leapdays and month > 2 and calendar.isleap(year):\n            days += self.leapdays\n        ret = (other.replace(**repl)\n               + datetime.timedelta(days=days,\n                                    hours=self.hours,\n                                    minutes=self.minutes,\n                                    seconds=self.seconds,\n                                    microseconds=self.microseconds))\n        if self.weekday:\n            weekday, nth = self.weekday.weekday, self.weekday.n or 1\n            jumpdays = (abs(nth) - 1) * 7\n            if nth > 0:\n                jumpdays += (7 - ret.weekday() + weekday) % 7\n            else:\n                jumpdays += (ret.weekday() - weekday) % 7\n                jumpdays *= -1\n            ret += datetime.timedelta(days=jumpdays)\n        return ret\n\n    def __radd__(self, other):\n        return self.__add__(other)\n\n    def __rsub__(self, other):\n        return self.__neg__().__radd__(other)\n\n    def __sub__(self, other):\n        if not isinstance(other, relativedelta):\n            return NotImplemented   # In case the other object defines __rsub__\n        return self.__class__(years=self.years - other.years,\n                             months=self.months - other.months,\n                             days=self.days - other.days,\n                             hours=self.hours - other.hours,\n                             minutes=self.minutes - other.minutes,\n                             seconds=self.seconds - other.seconds,\n                             microseconds=self.microseconds - other.microseconds,\n                             leapdays=self.leapdays or other.leapdays,\n                             year=(self.year if self.year is not None\n                                   else other.year),\n                             month=(self.month if self.month is not None else\n                                    other.month),\n                             day=(self.day if self.day is not None else\n                                  other.day),\n                             weekday=(self.weekday if self.weekday is not None else\n                                      other.weekday),\n                             hour=(self.hour if self.hour is not None else\n                                   other.hour),\n                             minute=(self.minute if self.minute is not None else\n                                     other.minute),\n                             second=(self.second if self.second is not None else\n                                     other.second),\n                             microsecond=(self.microsecond if self.microsecond\n                                          is not None else\n                                          other.microsecond))\n\n    def __abs__(self):\n        return self.__class__(years=abs(self.years),\n                              months=abs(self.months),\n                              days=abs(self.days),\n                              hours=abs(self.hours),\n                              minutes=abs(self.minutes),\n                              seconds=abs(self.seconds),\n                              microseconds=abs(self.microseconds),\n                              leapdays=self.leapdays,\n                              year=self.year,\n                              month=self.month,\n                              day=self.day,\n                              weekday=self.weekday,\n                              hour=self.hour,\n                              minute=self.minute,\n                              second=self.second,\n                              microsecond=self.microsecond)\n\n    def __neg__(self):\n        return self.__class__(years=-self.years,\n                             months=-self.months,\n                             days=-self.days,\n                             hours=-self.hours,\n                             minutes=-self.minutes,\n                             seconds=-self.seconds,\n                             microseconds=-self.microseconds,\n                             leapdays=self.leapdays,\n                             year=self.year,\n                             month=self.month,\n                             day=self.day,\n                             weekday=self.weekday,\n                             hour=self.hour,\n                             minute=self.minute,\n                             second=self.second,\n                             microsecond=self.microsecond)\n\n    def __bool__(self):\n        return not (not self.years and\n                    not self.months and\n                    not self.days and\n                    not self.hours and\n                    not self.minutes and\n                    not self.seconds and\n                    not self.microseconds and\n                    not self.leapdays and\n                    self.year is None and\n                    self.month is None and\n                    self.day is None and\n                    self.weekday is None and\n                    self.hour is None and\n                    self.minute is None and\n                    self.second is None and\n                    self.microsecond is None)\n    # Compatibility with Python 2.x\n    __nonzero__ = __bool__\n\n    def __mul__(self, other):\n        try:\n            f = float(other)\n        except TypeError:\n            return NotImplemented\n\n        return self.__class__(years=int(self.years * f),\n                             months=int(self.months * f),\n                             days=int(self.days * f),\n                             hours=int(self.hours * f),\n                             minutes=int(self.minutes * f),\n                             seconds=int(self.seconds * f),\n                             microseconds=int(self.microseconds * f),\n                             leapdays=self.leapdays,\n                             year=self.year,\n                             month=self.month,\n                             day=self.day,\n                             weekday=self.weekday,\n                             hour=self.hour,\n                             minute=self.minute,\n                             second=self.second,\n                             microsecond=self.microsecond)\n\n    __rmul__ = __mul__\n\n    def __eq__(self, other):\n        if not isinstance(other, relativedelta):\n            return NotImplemented\n        if self.weekday or other.weekday:\n            if not self.weekday or not other.weekday:\n                return False\n            if self.weekday.weekday != other.weekday.weekday:\n                return False\n            n1, n2 = self.weekday.n, other.weekday.n\n            if n1 != n2 and not ((not n1 or n1 == 1) and (not n2 or n2 == 1)):\n                return False\n        return (self.years == other.years and\n                self.months == other.months and\n                self.days == other.days and\n                self.hours == other.hours and\n                self.minutes == other.minutes and\n                self.seconds == other.seconds and\n                self.microseconds == other.microseconds and\n                self.leapdays == other.leapdays and\n                self.year == other.year and\n                self.month == other.month and\n                self.day == other.day and\n                self.hour == other.hour and\n                self.minute == other.minute and\n                self.second == other.second and\n                self.microsecond == other.microsecond)\n\n    def __hash__(self):\n        return hash((\n            self.weekday,\n            self.years,\n            self.months,\n            self.days,\n            self.hours,\n            self.minutes,\n            self.seconds,\n            self.microseconds,\n            self.leapdays,\n            self.year,\n            self.month,\n            self.day,\n            self.hour,\n            self.minute,\n            self.second,\n            self.microsecond,\n        ))\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __div__(self, other):\n        try:\n            reciprocal = 1 / float(other)\n        except TypeError:\n            return NotImplemented\n\n        return self.__mul__(reciprocal)\n\n    __truediv__ = __div__\n\n    def __repr__(self):\n        l = []\n        for attr in [\"years\", \"months\", \"days\", \"leapdays\",\n                     \"hours\", \"minutes\", \"seconds\", \"microseconds\"]:\n            value = getattr(self, attr)\n            if value:\n                l.append(\"{attr}={value:+g}\".format(attr=attr, value=value))\n        for attr in [\"year\", \"month\", \"day\", \"weekday\",\n                     \"hour\", \"minute\", \"second\", \"microsecond\"]:\n            value = getattr(self, attr)\n            if value is not None:\n                l.append(\"{attr}={value}\".format(attr=attr, value=repr(value)))\n        return \"{classname}({attrs})\".format(classname=self.__class__.__name__,\n                                             attrs=\", \".join(l))\n\n\ndef _sign(x):\n    return int(copysign(1, x))\n\n# vim:ts=4:sw=4:et\n", "src/dateutil/_common.py": "\"\"\"\nCommon code used in multiple modules.\n\"\"\"\n\n\nclass weekday(object):\n    __slots__ = [\"weekday\", \"n\"]\n\n    def __init__(self, weekday, n=None):\n        self.weekday = weekday\n        self.n = n\n\n    def __call__(self, n):\n        if n == self.n:\n            return self\n        else:\n            return self.__class__(self.weekday, n)\n\n    def __eq__(self, other):\n        try:\n            if self.weekday != other.weekday or self.n != other.n:\n                return False\n        except AttributeError:\n            return False\n        return True\n\n    def __hash__(self):\n        return hash((\n          self.weekday,\n          self.n,\n        ))\n\n    def __ne__(self, other):\n        return not (self == other)\n\n    def __repr__(self):\n        s = (\"MO\", \"TU\", \"WE\", \"TH\", \"FR\", \"SA\", \"SU\")[self.weekday]\n        if not self.n:\n            return s\n        else:\n            return \"%s(%+d)\" % (s, self.n)\n\n# vim:ts=4:sw=4:et\n", "src/dateutil/utils.py": "# -*- coding: utf-8 -*-\n\"\"\"\nThis module offers general convenience and utility functions for dealing with\ndatetimes.\n\n.. versionadded:: 2.7.0\n\"\"\"\nfrom __future__ import unicode_literals\n\nfrom datetime import datetime, time\n\n\ndef today(tzinfo=None):\n    \"\"\"\n    Returns a :py:class:`datetime` representing the current day at midnight\n\n    :param tzinfo:\n        The time zone to attach (also used to determine the current day).\n\n    :return:\n        A :py:class:`datetime.datetime` object representing the current day\n        at midnight.\n    \"\"\"\n\n    dt = datetime.now(tzinfo)\n    return datetime.combine(dt.date(), time(0, tzinfo=tzinfo))\n\n\ndef default_tzinfo(dt, tzinfo):\n    \"\"\"\n    Sets the ``tzinfo`` parameter on naive datetimes only\n\n    This is useful for example when you are provided a datetime that may have\n    either an implicit or explicit time zone, such as when parsing a time zone\n    string.\n\n    .. doctest::\n\n        >>> from dateutil.tz import tzoffset\n        >>> from dateutil.parser import parse\n        >>> from dateutil.utils import default_tzinfo\n        >>> dflt_tz = tzoffset(\"EST\", -18000)\n        >>> print(default_tzinfo(parse('2014-01-01 12:30 UTC'), dflt_tz))\n        2014-01-01 12:30:00+00:00\n        >>> print(default_tzinfo(parse('2014-01-01 12:30'), dflt_tz))\n        2014-01-01 12:30:00-05:00\n\n    :param dt:\n        The datetime on which to replace the time zone\n\n    :param tzinfo:\n        The :py:class:`datetime.tzinfo` subclass instance to assign to\n        ``dt`` if (and only if) it is naive.\n\n    :return:\n        Returns an aware :py:class:`datetime.datetime`.\n    \"\"\"\n    if dt.tzinfo is not None:\n        return dt\n    else:\n        return dt.replace(tzinfo=tzinfo)\n\n\ndef within_delta(dt1, dt2, delta):\n    \"\"\"\n    Useful for comparing two datetimes that may have a negligible difference\n    to be considered equal.\n    \"\"\"\n    delta = abs(delta)\n    difference = dt1 - dt2\n    return -delta <= difference <= delta\n", "src/dateutil/tzwin.py": "# tzwin has moved to dateutil.tz.win\nfrom .tz.win import *\n", "src/dateutil/rrule.py": "# -*- coding: utf-8 -*-\n\"\"\"\nThe rrule module offers a small, complete, and very fast, implementation of\nthe recurrence rules documented in the\n`iCalendar RFC <https://tools.ietf.org/html/rfc5545>`_,\nincluding support for caching of results.\n\"\"\"\nimport calendar\nimport datetime\nimport heapq\nimport itertools\nimport re\nimport sys\nfrom functools import wraps\n# For warning about deprecation of until and count\nfrom warnings import warn\n\nfrom six import advance_iterator, integer_types\n\nfrom six.moves import _thread, range\n\nfrom ._common import weekday as weekdaybase\n\ntry:\n    from math import gcd\nexcept ImportError:\n    from fractions import gcd\n\n__all__ = [\"rrule\", \"rruleset\", \"rrulestr\",\n           \"YEARLY\", \"MONTHLY\", \"WEEKLY\", \"DAILY\",\n           \"HOURLY\", \"MINUTELY\", \"SECONDLY\",\n           \"MO\", \"TU\", \"WE\", \"TH\", \"FR\", \"SA\", \"SU\"]\n\n# Every mask is 7 days longer to handle cross-year weekly periods.\nM366MASK = tuple([1]*31+[2]*29+[3]*31+[4]*30+[5]*31+[6]*30 +\n                 [7]*31+[8]*31+[9]*30+[10]*31+[11]*30+[12]*31+[1]*7)\nM365MASK = list(M366MASK)\nM29, M30, M31 = list(range(1, 30)), list(range(1, 31)), list(range(1, 32))\nMDAY366MASK = tuple(M31+M29+M31+M30+M31+M30+M31+M31+M30+M31+M30+M31+M31[:7])\nMDAY365MASK = list(MDAY366MASK)\nM29, M30, M31 = list(range(-29, 0)), list(range(-30, 0)), list(range(-31, 0))\nNMDAY366MASK = tuple(M31+M29+M31+M30+M31+M30+M31+M31+M30+M31+M30+M31+M31[:7])\nNMDAY365MASK = list(NMDAY366MASK)\nM366RANGE = (0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366)\nM365RANGE = (0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365)\nWDAYMASK = [0, 1, 2, 3, 4, 5, 6]*55\ndel M29, M30, M31, M365MASK[59], MDAY365MASK[59], NMDAY365MASK[31]\nMDAY365MASK = tuple(MDAY365MASK)\nM365MASK = tuple(M365MASK)\n\nFREQNAMES = ['YEARLY', 'MONTHLY', 'WEEKLY', 'DAILY', 'HOURLY', 'MINUTELY', 'SECONDLY']\n\n(YEARLY,\n MONTHLY,\n WEEKLY,\n DAILY,\n HOURLY,\n MINUTELY,\n SECONDLY) = list(range(7))\n\n# Imported on demand.\neaster = None\nparser = None\n\n\nclass weekday(weekdaybase):\n    \"\"\"\n    This version of weekday does not allow n = 0.\n    \"\"\"\n    def __init__(self, wkday, n=None):\n        if n == 0:\n            raise ValueError(\"Can't create weekday with n==0\")\n\n        super(weekday, self).__init__(wkday, n)\n\n\nMO, TU, WE, TH, FR, SA, SU = weekdays = tuple(weekday(x) for x in range(7))\n\n\ndef _invalidates_cache(f):\n    \"\"\"\n    Decorator for rruleset methods which may invalidate the\n    cached length.\n    \"\"\"\n    @wraps(f)\n    def inner_func(self, *args, **kwargs):\n        rv = f(self, *args, **kwargs)\n        self._invalidate_cache()\n        return rv\n\n    return inner_func\n\n\nclass rrulebase(object):\n    def __init__(self, cache=False):\n        if cache:\n            self._cache = []\n            self._cache_lock = _thread.allocate_lock()\n            self._invalidate_cache()\n        else:\n            self._cache = None\n            self._cache_complete = False\n            self._len = None\n\n    def __iter__(self):\n        if self._cache_complete:\n            return iter(self._cache)\n        elif self._cache is None:\n            return self._iter()\n        else:\n            return self._iter_cached()\n\n    def _invalidate_cache(self):\n        if self._cache is not None:\n            self._cache = []\n            self._cache_complete = False\n            self._cache_gen = self._iter()\n\n            if self._cache_lock.locked():\n                self._cache_lock.release()\n\n        self._len = None\n\n    def _iter_cached(self):\n        i = 0\n        gen = self._cache_gen\n        cache = self._cache\n        acquire = self._cache_lock.acquire\n        release = self._cache_lock.release\n        while gen:\n            if i == len(cache):\n                acquire()\n                if self._cache_complete:\n                    break\n                try:\n                    for j in range(10):\n                        cache.append(advance_iterator(gen))\n                except StopIteration:\n                    self._cache_gen = gen = None\n                    self._cache_complete = True\n                    break\n                release()\n            yield cache[i]\n            i += 1\n        while i < self._len:\n            yield cache[i]\n            i += 1\n\n    def __getitem__(self, item):\n        if self._cache_complete:\n            return self._cache[item]\n        elif isinstance(item, slice):\n            if item.step and item.step < 0:\n                return list(iter(self))[item]\n            else:\n                return list(itertools.islice(self,\n                                             item.start or 0,\n                                             item.stop or sys.maxsize,\n                                             item.step or 1))\n        elif item >= 0:\n            gen = iter(self)\n            try:\n                for i in range(item+1):\n                    res = advance_iterator(gen)\n            except StopIteration:\n                raise IndexError\n            return res\n        else:\n            return list(iter(self))[item]\n\n    def __contains__(self, item):\n        if self._cache_complete:\n            return item in self._cache\n        else:\n            for i in self:\n                if i == item:\n                    return True\n                elif i > item:\n                    return False\n        return False\n\n    # __len__() introduces a large performance penalty.\n    def count(self):\n        \"\"\" Returns the number of recurrences in this set. It will have go\n            through the whole recurrence, if this hasn't been done before. \"\"\"\n        if self._len is None:\n            for x in self:\n                pass\n        return self._len\n\n    def before(self, dt, inc=False):\n        \"\"\" Returns the last recurrence before the given datetime instance. The\n            inc keyword defines what happens if dt is an occurrence. With\n            inc=True, if dt itself is an occurrence, it will be returned. \"\"\"\n        if self._cache_complete:\n            gen = self._cache\n        else:\n            gen = self\n        last = None\n        if inc:\n            for i in gen:\n                if i > dt:\n                    break\n                last = i\n        else:\n            for i in gen:\n                if i >= dt:\n                    break\n                last = i\n        return last\n\n    def after(self, dt, inc=False):\n        \"\"\" Returns the first recurrence after the given datetime instance. The\n            inc keyword defines what happens if dt is an occurrence. With\n            inc=True, if dt itself is an occurrence, it will be returned.  \"\"\"\n        if self._cache_complete:\n            gen = self._cache\n        else:\n            gen = self\n        if inc:\n            for i in gen:\n                if i >= dt:\n                    return i\n        else:\n            for i in gen:\n                if i > dt:\n                    return i\n        return None\n\n    def xafter(self, dt, count=None, inc=False):\n        \"\"\"\n        Generator which yields up to `count` recurrences after the given\n        datetime instance, equivalent to `after`.\n\n        :param dt:\n            The datetime at which to start generating recurrences.\n\n        :param count:\n            The maximum number of recurrences to generate. If `None` (default),\n            dates are generated until the recurrence rule is exhausted.\n\n        :param inc:\n            If `dt` is an instance of the rule and `inc` is `True`, it is\n            included in the output.\n\n        :yields: Yields a sequence of `datetime` objects.\n        \"\"\"\n\n        if self._cache_complete:\n            gen = self._cache\n        else:\n            gen = self\n\n        # Select the comparison function\n        if inc:\n            comp = lambda dc, dtc: dc >= dtc\n        else:\n            comp = lambda dc, dtc: dc > dtc\n\n        # Generate dates\n        n = 0\n        for d in gen:\n            if comp(d, dt):\n                if count is not None:\n                    n += 1\n                    if n > count:\n                        break\n\n                yield d\n\n    def between(self, after, before, inc=False, count=1):\n        \"\"\" Returns all the occurrences of the rrule between after and before.\n        The inc keyword defines what happens if after and/or before are\n        themselves occurrences. With inc=True, they will be included in the\n        list, if they are found in the recurrence set. \"\"\"\n        if self._cache_complete:\n            gen = self._cache\n        else:\n            gen = self\n        started = False\n        l = []\n        if inc:\n            for i in gen:\n                if i > before:\n                    break\n                elif not started:\n                    if i >= after:\n                        started = True\n                        l.append(i)\n                else:\n                    l.append(i)\n        else:\n            for i in gen:\n                if i >= before:\n                    break\n                elif not started:\n                    if i > after:\n                        started = True\n                        l.append(i)\n                else:\n                    l.append(i)\n        return l\n\n\nclass rrule(rrulebase):\n    \"\"\"\n    That's the base of the rrule operation. It accepts all the keywords\n    defined in the RFC as its constructor parameters (except byday,\n    which was renamed to byweekday) and more. The constructor prototype is::\n\n            rrule(freq)\n\n    Where freq must be one of YEARLY, MONTHLY, WEEKLY, DAILY, HOURLY, MINUTELY,\n    or SECONDLY.\n\n    .. note::\n        Per RFC section 3.3.10, recurrence instances falling on invalid dates\n        and times are ignored rather than coerced:\n\n            Recurrence rules may generate recurrence instances with an invalid\n            date (e.g., February 30) or nonexistent local time (e.g., 1:30 AM\n            on a day where the local time is moved forward by an hour at 1:00\n            AM).  Such recurrence instances MUST be ignored and MUST NOT be\n            counted as part of the recurrence set.\n\n        This can lead to possibly surprising behavior when, for example, the\n        start date occurs at the end of the month:\n\n        >>> from dateutil.rrule import rrule, MONTHLY\n        >>> from datetime import datetime\n        >>> start_date = datetime(2014, 12, 31)\n        >>> list(rrule(freq=MONTHLY, count=4, dtstart=start_date))\n        ... # doctest: +NORMALIZE_WHITESPACE\n        [datetime.datetime(2014, 12, 31, 0, 0),\n         datetime.datetime(2015, 1, 31, 0, 0),\n         datetime.datetime(2015, 3, 31, 0, 0),\n         datetime.datetime(2015, 5, 31, 0, 0)]\n\n    Additionally, it supports the following keyword arguments:\n\n    :param dtstart:\n        The recurrence start. Besides being the base for the recurrence,\n        missing parameters in the final recurrence instances will also be\n        extracted from this date. If not given, datetime.now() will be used\n        instead.\n    :param interval:\n        The interval between each freq iteration. For example, when using\n        YEARLY, an interval of 2 means once every two years, but with HOURLY,\n        it means once every two hours. The default interval is 1.\n    :param wkst:\n        The week start day. Must be one of the MO, TU, WE constants, or an\n        integer, specifying the first day of the week. This will affect\n        recurrences based on weekly periods. The default week start is got\n        from calendar.firstweekday(), and may be modified by\n        calendar.setfirstweekday().\n    :param count:\n        If given, this determines how many occurrences will be generated.\n\n        .. note::\n            As of version 2.5.0, the use of the keyword ``until`` in conjunction\n            with ``count`` is deprecated, to make sure ``dateutil`` is fully\n            compliant with `RFC-5545 Sec. 3.3.10 <https://tools.ietf.org/\n            html/rfc5545#section-3.3.10>`_. Therefore, ``until`` and ``count``\n            **must not** occur in the same call to ``rrule``.\n    :param until:\n        If given, this must be a datetime instance specifying the upper-bound\n        limit of the recurrence. The last recurrence in the rule is the greatest\n        datetime that is less than or equal to the value specified in the\n        ``until`` parameter.\n\n        .. note::\n            As of version 2.5.0, the use of the keyword ``until`` in conjunction\n            with ``count`` is deprecated, to make sure ``dateutil`` is fully\n            compliant with `RFC-5545 Sec. 3.3.10 <https://tools.ietf.org/\n            html/rfc5545#section-3.3.10>`_. Therefore, ``until`` and ``count``\n            **must not** occur in the same call to ``rrule``.\n    :param bysetpos:\n        If given, it must be either an integer, or a sequence of integers,\n        positive or negative. Each given integer will specify an occurrence\n        number, corresponding to the nth occurrence of the rule inside the\n        frequency period. For example, a bysetpos of -1 if combined with a\n        MONTHLY frequency, and a byweekday of (MO, TU, WE, TH, FR), will\n        result in the last work day of every month.\n    :param bymonth:\n        If given, it must be either an integer, or a sequence of integers,\n        meaning the months to apply the recurrence to.\n    :param bymonthday:\n        If given, it must be either an integer, or a sequence of integers,\n        meaning the month days to apply the recurrence to.\n    :param byyearday:\n        If given, it must be either an integer, or a sequence of integers,\n        meaning the year days to apply the recurrence to.\n    :param byeaster:\n        If given, it must be either an integer, or a sequence of integers,\n        positive or negative. Each integer will define an offset from the\n        Easter Sunday. Passing the offset 0 to byeaster will yield the Easter\n        Sunday itself. This is an extension to the RFC specification.\n    :param byweekno:\n        If given, it must be either an integer, or a sequence of integers,\n        meaning the week numbers to apply the recurrence to. Week numbers\n        have the meaning described in ISO8601, that is, the first week of\n        the year is that containing at least four days of the new year.\n    :param byweekday:\n        If given, it must be either an integer (0 == MO), a sequence of\n        integers, one of the weekday constants (MO, TU, etc), or a sequence\n        of these constants. When given, these variables will define the\n        weekdays where the recurrence will be applied. It's also possible to\n        use an argument n for the weekday instances, which will mean the nth\n        occurrence of this weekday in the period. For example, with MONTHLY,\n        or with YEARLY and BYMONTH, using FR(+1) in byweekday will specify the\n        first friday of the month where the recurrence happens. Notice that in\n        the RFC documentation, this is specified as BYDAY, but was renamed to\n        avoid the ambiguity of that keyword.\n    :param byhour:\n        If given, it must be either an integer, or a sequence of integers,\n        meaning the hours to apply the recurrence to.\n    :param byminute:\n        If given, it must be either an integer, or a sequence of integers,\n        meaning the minutes to apply the recurrence to.\n    :param bysecond:\n        If given, it must be either an integer, or a sequence of integers,\n        meaning the seconds to apply the recurrence to.\n    :param cache:\n        If given, it must be a boolean value specifying to enable or disable\n        caching of results. If you will use the same rrule instance multiple\n        times, enabling caching will improve the performance considerably.\n     \"\"\"\n    def __init__(self, freq, dtstart=None,\n                 interval=1, wkst=None, count=None, until=None, bysetpos=None,\n                 bymonth=None, bymonthday=None, byyearday=None, byeaster=None,\n                 byweekno=None, byweekday=None,\n                 byhour=None, byminute=None, bysecond=None,\n                 cache=False):\n        super(rrule, self).__init__(cache)\n        global easter\n        if not dtstart:\n            if until and until.tzinfo:\n                dtstart = datetime.datetime.now(tz=until.tzinfo).replace(microsecond=0)\n            else:\n                dtstart = datetime.datetime.now().replace(microsecond=0)\n        elif not isinstance(dtstart, datetime.datetime):\n            dtstart = datetime.datetime.fromordinal(dtstart.toordinal())\n        else:\n            dtstart = dtstart.replace(microsecond=0)\n        self._dtstart = dtstart\n        self._tzinfo = dtstart.tzinfo\n        self._freq = freq\n        self._interval = interval\n        self._count = count\n\n        # Cache the original byxxx rules, if they are provided, as the _byxxx\n        # attributes do not necessarily map to the inputs, and this can be\n        # a problem in generating the strings. Only store things if they've\n        # been supplied (the string retrieval will just use .get())\n        self._original_rule = {}\n\n        if until and not isinstance(until, datetime.datetime):\n            until = datetime.datetime.fromordinal(until.toordinal())\n        self._until = until\n\n        if self._dtstart and self._until:\n            if (self._dtstart.tzinfo is not None) != (self._until.tzinfo is not None):\n                # According to RFC5545 Section 3.3.10:\n                # https://tools.ietf.org/html/rfc5545#section-3.3.10\n                #\n                # > If the \"DTSTART\" property is specified as a date with UTC\n                # > time or a date with local time and time zone reference,\n                # > then the UNTIL rule part MUST be specified as a date with\n                # > UTC time.\n                raise ValueError(\n                    'RRULE UNTIL values must be specified in UTC when DTSTART '\n                    'is timezone-aware'\n                )\n\n        if count is not None and until:\n            warn(\"Using both 'count' and 'until' is inconsistent with RFC 5545\"\n                 \" and has been deprecated in dateutil. Future versions will \"\n                 \"raise an error.\", DeprecationWarning)\n\n        if wkst is None:\n            self._wkst = calendar.firstweekday()\n        elif isinstance(wkst, integer_types):\n            self._wkst = wkst\n        else:\n            self._wkst = wkst.weekday\n\n        if bysetpos is None:\n            self._bysetpos = None\n        elif isinstance(bysetpos, integer_types):\n            if bysetpos == 0 or not (-366 <= bysetpos <= 366):\n                raise ValueError(\"bysetpos must be between 1 and 366, \"\n                                 \"or between -366 and -1\")\n            self._bysetpos = (bysetpos,)\n        else:\n            self._bysetpos = tuple(bysetpos)\n            for pos in self._bysetpos:\n                if pos == 0 or not (-366 <= pos <= 366):\n                    raise ValueError(\"bysetpos must be between 1 and 366, \"\n                                     \"or between -366 and -1\")\n\n        if self._bysetpos:\n            self._original_rule['bysetpos'] = self._bysetpos\n\n        if (byweekno is None and byyearday is None and bymonthday is None and\n                byweekday is None and byeaster is None):\n            if freq == YEARLY:\n                if bymonth is None:\n                    bymonth = dtstart.month\n                    self._original_rule['bymonth'] = None\n                bymonthday = dtstart.day\n                self._original_rule['bymonthday'] = None\n            elif freq == MONTHLY:\n                bymonthday = dtstart.day\n                self._original_rule['bymonthday'] = None\n            elif freq == WEEKLY:\n                byweekday = dtstart.weekday()\n                self._original_rule['byweekday'] = None\n\n        # bymonth\n        if bymonth is None:\n            self._bymonth = None\n        else:\n            if isinstance(bymonth, integer_types):\n                bymonth = (bymonth,)\n\n            self._bymonth = tuple(sorted(set(bymonth)))\n\n            if 'bymonth' not in self._original_rule:\n                self._original_rule['bymonth'] = self._bymonth\n\n        # byyearday\n        if byyearday is None:\n            self._byyearday = None\n        else:\n            if isinstance(byyearday, integer_types):\n                byyearday = (byyearday,)\n\n            self._byyearday = tuple(sorted(set(byyearday)))\n            self._original_rule['byyearday'] = self._byyearday\n\n        # byeaster\n        if byeaster is not None:\n            if not easter:\n                from dateutil import easter\n            if isinstance(byeaster, integer_types):\n                self._byeaster = (byeaster,)\n            else:\n                self._byeaster = tuple(sorted(byeaster))\n\n            self._original_rule['byeaster'] = self._byeaster\n        else:\n            self._byeaster = None\n\n        # bymonthday\n        if bymonthday is None:\n            self._bymonthday = ()\n            self._bynmonthday = ()\n        else:\n            if isinstance(bymonthday, integer_types):\n                bymonthday = (bymonthday,)\n\n            bymonthday = set(bymonthday)            # Ensure it's unique\n\n            self._bymonthday = tuple(sorted(x for x in bymonthday if x > 0))\n            self._bynmonthday = tuple(sorted(x for x in bymonthday if x < 0))\n\n            # Storing positive numbers first, then negative numbers\n            if 'bymonthday' not in self._original_rule:\n                self._original_rule['bymonthday'] = tuple(\n                    itertools.chain(self._bymonthday, self._bynmonthday))\n\n        # byweekno\n        if byweekno is None:\n            self._byweekno = None\n        else:\n            if isinstance(byweekno, integer_types):\n                byweekno = (byweekno,)\n\n            self._byweekno = tuple(sorted(set(byweekno)))\n\n            self._original_rule['byweekno'] = self._byweekno\n\n        # byweekday / bynweekday\n        if byweekday is None:\n            self._byweekday = None\n            self._bynweekday = None\n        else:\n            # If it's one of the valid non-sequence types, convert to a\n            # single-element sequence before the iterator that builds the\n            # byweekday set.\n            if isinstance(byweekday, integer_types) or hasattr(byweekday, \"n\"):\n                byweekday = (byweekday,)\n\n            self._byweekday = set()\n            self._bynweekday = set()\n            for wday in byweekday:\n                if isinstance(wday, integer_types):\n                    self._byweekday.add(wday)\n                elif not wday.n or freq > MONTHLY:\n                    self._byweekday.add(wday.weekday)\n                else:\n                    self._bynweekday.add((wday.weekday, wday.n))\n\n            if not self._byweekday:\n                self._byweekday = None\n            elif not self._bynweekday:\n                self._bynweekday = None\n\n            if self._byweekday is not None:\n                self._byweekday = tuple(sorted(self._byweekday))\n                orig_byweekday = [weekday(x) for x in self._byweekday]\n            else:\n                orig_byweekday = ()\n\n            if self._bynweekday is not None:\n                self._bynweekday = tuple(sorted(self._bynweekday))\n                orig_bynweekday = [weekday(*x) for x in self._bynweekday]\n            else:\n                orig_bynweekday = ()\n\n            if 'byweekday' not in self._original_rule:\n                self._original_rule['byweekday'] = tuple(itertools.chain(\n                    orig_byweekday, orig_bynweekday))\n\n        # byhour\n        if byhour is None:\n            if freq < HOURLY:\n                self._byhour = {dtstart.hour}\n            else:\n                self._byhour = None\n        else:\n            if isinstance(byhour, integer_types):\n                byhour = (byhour,)\n\n            if freq == HOURLY:\n                self._byhour = self.__construct_byset(start=dtstart.hour,\n                                                      byxxx=byhour,\n                                                      base=24)\n            else:\n                self._byhour = set(byhour)\n\n            self._byhour = tuple(sorted(self._byhour))\n            self._original_rule['byhour'] = self._byhour\n\n        # byminute\n        if byminute is None:\n            if freq < MINUTELY:\n                self._byminute = {dtstart.minute}\n            else:\n                self._byminute = None\n        else:\n            if isinstance(byminute, integer_types):\n                byminute = (byminute,)\n\n            if freq == MINUTELY:\n                self._byminute = self.__construct_byset(start=dtstart.minute,\n                                                        byxxx=byminute,\n                                                        base=60)\n            else:\n                self._byminute = set(byminute)\n\n            self._byminute = tuple(sorted(self._byminute))\n            self._original_rule['byminute'] = self._byminute\n\n        # bysecond\n        if bysecond is None:\n            if freq < SECONDLY:\n                self._bysecond = ((dtstart.second,))\n            else:\n                self._bysecond = None\n        else:\n            if isinstance(bysecond, integer_types):\n                bysecond = (bysecond,)\n\n            self._bysecond = set(bysecond)\n\n            if freq == SECONDLY:\n                self._bysecond = self.__construct_byset(start=dtstart.second,\n                                                        byxxx=bysecond,\n                                                        base=60)\n            else:\n                self._bysecond = set(bysecond)\n\n            self._bysecond = tuple(sorted(self._bysecond))\n            self._original_rule['bysecond'] = self._bysecond\n\n        if self._freq >= HOURLY:\n            self._timeset = None\n        else:\n            self._timeset = []\n            for hour in self._byhour:\n                for minute in self._byminute:\n                    for second in self._bysecond:\n                        self._timeset.append(\n                            datetime.time(hour, minute, second,\n                                          tzinfo=self._tzinfo))\n            self._timeset.sort()\n            self._timeset = tuple(self._timeset)\n\n    def __str__(self):\n        \"\"\"\n        Output a string that would generate this RRULE if passed to rrulestr.\n        This is mostly compatible with RFC5545, except for the\n        dateutil-specific extension BYEASTER.\n        \"\"\"\n\n        output = []\n        h, m, s = [None] * 3\n        if self._dtstart:\n            output.append(self._dtstart.strftime('DTSTART:%Y%m%dT%H%M%S'))\n            h, m, s = self._dtstart.timetuple()[3:6]\n\n        parts = ['FREQ=' + FREQNAMES[self._freq]]\n        if self._interval != 1:\n            parts.append('INTERVAL=' + str(self._interval))\n\n        if self._wkst:\n            parts.append('WKST=' + repr(weekday(self._wkst))[0:2])\n\n        if self._count is not None:\n            parts.append('COUNT=' + str(self._count))\n\n        if self._until:\n            parts.append(self._until.strftime('UNTIL=%Y%m%dT%H%M%S'))\n\n        if self._original_rule.get('byweekday') is not None:\n            # The str() method on weekday objects doesn't generate\n            # RFC5545-compliant strings, so we should modify that.\n            original_rule = dict(self._original_rule)\n            wday_strings = []\n            for wday in original_rule['byweekday']:\n                if wday.n:\n                    wday_strings.append('{n:+d}{wday}'.format(\n                        n=wday.n,\n                        wday=repr(wday)[0:2]))\n                else:\n                    wday_strings.append(repr(wday))\n\n            original_rule['byweekday'] = wday_strings\n        else:\n            original_rule = self._original_rule\n\n        partfmt = '{name}={vals}'\n        for name, key in [('BYSETPOS', 'bysetpos'),\n                          ('BYMONTH', 'bymonth'),\n                          ('BYMONTHDAY', 'bymonthday'),\n                          ('BYYEARDAY', 'byyearday'),\n                          ('BYWEEKNO', 'byweekno'),\n                          ('BYDAY', 'byweekday'),\n                          ('BYHOUR', 'byhour'),\n                          ('BYMINUTE', 'byminute'),\n                          ('BYSECOND', 'bysecond'),\n                          ('BYEASTER', 'byeaster')]:\n            value = original_rule.get(key)\n            if value:\n                parts.append(partfmt.format(name=name, vals=(','.join(str(v)\n                                                             for v in value))))\n\n        output.append('RRULE:' + ';'.join(parts))\n        return '\\n'.join(output)\n\n    def replace(self, **kwargs):\n        \"\"\"Return new rrule with same attributes except for those attributes given new\n           values by whichever keyword arguments are specified.\"\"\"\n        new_kwargs = {\"interval\": self._interval,\n                      \"count\": self._count,\n                      \"dtstart\": self._dtstart,\n                      \"freq\": self._freq,\n                      \"until\": self._until,\n                      \"wkst\": self._wkst,\n                      \"cache\": False if self._cache is None else True }\n        new_kwargs.update(self._original_rule)\n        new_kwargs.update(kwargs)\n        return rrule(**new_kwargs)\n\n    def _iter(self):\n        year, month, day, hour, minute, second, weekday, yearday, _ = \\\n            self._dtstart.timetuple()\n\n        # Some local variables to speed things up a bit\n        freq = self._freq\n        interval = self._interval\n        wkst = self._wkst\n        until = self._until\n        bymonth = self._bymonth\n        byweekno = self._byweekno\n        byyearday = self._byyearday\n        byweekday = self._byweekday\n        byeaster = self._byeaster\n        bymonthday = self._bymonthday\n        bynmonthday = self._bynmonthday\n        bysetpos = self._bysetpos\n        byhour = self._byhour\n        byminute = self._byminute\n        bysecond = self._bysecond\n\n        ii = _iterinfo(self)\n        ii.rebuild(year, month)\n\n        getdayset = {YEARLY: ii.ydayset,\n                     MONTHLY: ii.mdayset,\n                     WEEKLY: ii.wdayset,\n                     DAILY: ii.ddayset,\n                     HOURLY: ii.ddayset,\n                     MINUTELY: ii.ddayset,\n                     SECONDLY: ii.ddayset}[freq]\n\n        if freq < HOURLY:\n            timeset = self._timeset\n        else:\n            gettimeset = {HOURLY: ii.htimeset,\n                          MINUTELY: ii.mtimeset,\n                          SECONDLY: ii.stimeset}[freq]\n            if ((freq >= HOURLY and\n                 self._byhour and hour not in self._byhour) or\n                (freq >= MINUTELY and\n                 self._byminute and minute not in self._byminute) or\n                (freq >= SECONDLY and\n                 self._bysecond and second not in self._bysecond)):\n                timeset = ()\n            else:\n                timeset = gettimeset(hour, minute, second)\n\n        total = 0\n        count = self._count\n        while True:\n            # Get dayset with the right frequency\n            dayset, start, end = getdayset(year, month, day)\n\n            # Do the \"hard\" work ;-)\n            filtered = False\n            for i in dayset[start:end]:\n                if ((bymonth and ii.mmask[i] not in bymonth) or\n                    (byweekno and not ii.wnomask[i]) or\n                    (byweekday and ii.wdaymask[i] not in byweekday) or\n                    (ii.nwdaymask and not ii.nwdaymask[i]) or\n                    (byeaster and not ii.eastermask[i]) or\n                    ((bymonthday or bynmonthday) and\n                     ii.mdaymask[i] not in bymonthday and\n                     ii.nmdaymask[i] not in bynmonthday) or\n                    (byyearday and\n                     ((i < ii.yearlen and i+1 not in byyearday and\n                       -ii.yearlen+i not in byyearday) or\n                      (i >= ii.yearlen and i+1-ii.yearlen not in byyearday and\n                       -ii.nextyearlen+i-ii.yearlen not in byyearday)))):\n                    dayset[i] = None\n                    filtered = True\n\n            # Output results\n            if bysetpos and timeset:\n                poslist = []\n                for pos in bysetpos:\n                    if pos < 0:\n                        daypos, timepos = divmod(pos, len(timeset))\n                    else:\n                        daypos, timepos = divmod(pos-1, len(timeset))\n                    try:\n                        i = [x for x in dayset[start:end]\n                             if x is not None][daypos]\n                        time = timeset[timepos]\n                    except IndexError:\n                        pass\n                    else:\n                        date = datetime.date.fromordinal(ii.yearordinal+i)\n                        res = datetime.datetime.combine(date, time)\n                        if res not in poslist:\n                            poslist.append(res)\n                poslist.sort()\n                for res in poslist:\n                    if until and res > until:\n                        self._len = total\n                        return\n                    elif res >= self._dtstart:\n                        if count is not None:\n                            count -= 1\n                            if count < 0:\n                                self._len = total\n                                return\n                        total += 1\n                        yield res\n            else:\n                for i in dayset[start:end]:\n                    if i is not None:\n                        date = datetime.date.fromordinal(ii.yearordinal + i)\n                        for time in timeset:\n                            res = datetime.datetime.combine(date, time)\n                            if until and res > until:\n                                self._len = total\n                                return\n                            elif res >= self._dtstart:\n                                if count is not None:\n                                    count -= 1\n                                    if count < 0:\n                                        self._len = total\n                                        return\n\n                                total += 1\n                                yield res\n\n            # Handle frequency and interval\n            fixday = False\n            if freq == YEARLY:\n                year += interval\n                if year > datetime.MAXYEAR:\n                    self._len = total\n                    return\n                ii.rebuild(year, month)\n            elif freq == MONTHLY:\n                month += interval\n                if month > 12:\n                    div, mod = divmod(month, 12)\n                    month = mod\n                    year += div\n                    if month == 0:\n                        month = 12\n                        year -= 1\n                    if year > datetime.MAXYEAR:\n                        self._len = total\n                        return\n                ii.rebuild(year, month)\n            elif freq == WEEKLY:\n                if wkst > weekday:\n                    day += -(weekday+1+(6-wkst))+self._interval*7\n                else:\n                    day += -(weekday-wkst)+self._interval*7\n                weekday = wkst\n                fixday = True\n            elif freq == DAILY:\n                day += interval\n                fixday = True\n            elif freq == HOURLY:\n                if filtered:\n                    # Jump to one iteration before next day\n                    hour += ((23-hour)//interval)*interval\n\n                if byhour:\n                    ndays, hour = self.__mod_distance(value=hour,\n                                                      byxxx=self._byhour,\n                                                      base=24)\n                else:\n                    ndays, hour = divmod(hour+interval, 24)\n\n                if ndays:\n                    day += ndays\n                    fixday = True\n\n                timeset = gettimeset(hour, minute, second)\n            elif freq == MINUTELY:\n                if filtered:\n                    # Jump to one iteration before next day\n                    minute += ((1439-(hour*60+minute))//interval)*interval\n\n                valid = False\n                rep_rate = (24*60)\n                for j in range(rep_rate // gcd(interval, rep_rate)):\n                    if byminute:\n                        nhours, minute = \\\n                            self.__mod_distance(value=minute,\n                                                byxxx=self._byminute,\n                                                base=60)\n                    else:\n                        nhours, minute = divmod(minute+interval, 60)\n\n                    div, hour = divmod(hour+nhours, 24)\n                    if div:\n                        day += div\n                        fixday = True\n                        filtered = False\n\n                    if not byhour or hour in byhour:\n                        valid = True\n                        break\n\n                if not valid:\n                    raise ValueError('Invalid combination of interval and ' +\n                                     'byhour resulting in empty rule.')\n\n                timeset = gettimeset(hour, minute, second)\n            elif freq == SECONDLY:\n                if filtered:\n                    # Jump to one iteration before next day\n                    second += (((86399 - (hour * 3600 + minute * 60 + second))\n                                // interval) * interval)\n\n                rep_rate = (24 * 3600)\n                valid = False\n                for j in range(0, rep_rate // gcd(interval, rep_rate)):\n                    if bysecond:\n                        nminutes, second = \\\n                            self.__mod_distance(value=second,\n                                                byxxx=self._bysecond,\n                                                base=60)\n                    else:\n                        nminutes, second = divmod(second+interval, 60)\n\n                    div, minute = divmod(minute+nminutes, 60)\n                    if div:\n                        hour += div\n                        div, hour = divmod(hour, 24)\n                        if div:\n                            day += div\n                            fixday = True\n\n                    if ((not byhour or hour in byhour) and\n                            (not byminute or minute in byminute) and\n                            (not bysecond or second in bysecond)):\n                        valid = True\n                        break\n\n                if not valid:\n                    raise ValueError('Invalid combination of interval, ' +\n                                     'byhour and byminute resulting in empty' +\n                                     ' rule.')\n\n                timeset = gettimeset(hour, minute, second)\n\n            if fixday and day > 28:\n                daysinmonth = calendar.monthrange(year, month)[1]\n                if day > daysinmonth:\n                    while day > daysinmonth:\n                        day -= daysinmonth\n                        month += 1\n                        if month == 13:\n                            month = 1\n                            year += 1\n                            if year > datetime.MAXYEAR:\n                                self._len = total\n                                return\n                        daysinmonth = calendar.monthrange(year, month)[1]\n                    ii.rebuild(year, month)\n\n    def __construct_byset(self, start, byxxx, base):\n        \"\"\"\n        If a `BYXXX` sequence is passed to the constructor at the same level as\n        `FREQ` (e.g. `FREQ=HOURLY,BYHOUR={2,4,7},INTERVAL=3`), there are some\n        specifications which cannot be reached given some starting conditions.\n\n        This occurs whenever the interval is not coprime with the base of a\n        given unit and the difference between the starting position and the\n        ending position is not coprime with the greatest common denominator\n        between the interval and the base. For example, with a FREQ of hourly\n        starting at 17:00 and an interval of 4, the only valid values for\n        BYHOUR would be {21, 1, 5, 9, 13, 17}, because 4 and 24 are not\n        coprime.\n\n        :param start:\n            Specifies the starting position.\n        :param byxxx:\n            An iterable containing the list of allowed values.\n        :param base:\n            The largest allowable value for the specified frequency (e.g.\n            24 hours, 60 minutes).\n\n        This does not preserve the type of the iterable, returning a set, since\n        the values should be unique and the order is irrelevant, this will\n        speed up later lookups.\n\n        In the event of an empty set, raises a :exception:`ValueError`, as this\n        results in an empty rrule.\n        \"\"\"\n\n        cset = set()\n\n        # Support a single byxxx value.\n        if isinstance(byxxx, integer_types):\n            byxxx = (byxxx, )\n\n        for num in byxxx:\n            i_gcd = gcd(self._interval, base)\n            # Use divmod rather than % because we need to wrap negative nums.\n            if i_gcd == 1 or divmod(num - start, i_gcd)[1] == 0:\n                cset.add(num)\n\n        if len(cset) == 0:\n            raise ValueError(\"Invalid rrule byxxx generates an empty set.\")\n\n        return cset\n\n    def __mod_distance(self, value, byxxx, base):\n        \"\"\"\n        Calculates the next value in a sequence where the `FREQ` parameter is\n        specified along with a `BYXXX` parameter at the same \"level\"\n        (e.g. `HOURLY` specified with `BYHOUR`).\n\n        :param value:\n            The old value of the component.\n        :param byxxx:\n            The `BYXXX` set, which should have been generated by\n            `rrule._construct_byset`, or something else which checks that a\n            valid rule is present.\n        :param base:\n            The largest allowable value for the specified frequency (e.g.\n            24 hours, 60 minutes).\n\n        If a valid value is not found after `base` iterations (the maximum\n        number before the sequence would start to repeat), this raises a\n        :exception:`ValueError`, as no valid values were found.\n\n        This returns a tuple of `divmod(n*interval, base)`, where `n` is the\n        smallest number of `interval` repetitions until the next specified\n        value in `byxxx` is found.\n        \"\"\"\n        accumulator = 0\n        for ii in range(1, base + 1):\n            # Using divmod() over % to account for negative intervals\n            div, value = divmod(value + self._interval, base)\n            accumulator += div\n            if value in byxxx:\n                return (accumulator, value)\n\n\nclass _iterinfo(object):\n    __slots__ = [\"rrule\", \"lastyear\", \"lastmonth\",\n                 \"yearlen\", \"nextyearlen\", \"yearordinal\", \"yearweekday\",\n                 \"mmask\", \"mrange\", \"mdaymask\", \"nmdaymask\",\n                 \"wdaymask\", \"wnomask\", \"nwdaymask\", \"eastermask\"]\n\n    def __init__(self, rrule):\n        for attr in self.__slots__:\n            setattr(self, attr, None)\n        self.rrule = rrule\n\n    def rebuild(self, year, month):\n        # Every mask is 7 days longer to handle cross-year weekly periods.\n        rr = self.rrule\n        if year != self.lastyear:\n            self.yearlen = 365 + calendar.isleap(year)\n            self.nextyearlen = 365 + calendar.isleap(year + 1)\n            firstyday = datetime.date(year, 1, 1)\n            self.yearordinal = firstyday.toordinal()\n            self.yearweekday = firstyday.weekday()\n\n            wday = datetime.date(year, 1, 1).weekday()\n            if self.yearlen == 365:\n                self.mmask = M365MASK\n                self.mdaymask = MDAY365MASK\n                self.nmdaymask = NMDAY365MASK\n                self.wdaymask = WDAYMASK[wday:]\n                self.mrange = M365RANGE\n            else:\n                self.mmask = M366MASK\n                self.mdaymask = MDAY366MASK\n                self.nmdaymask = NMDAY366MASK\n                self.wdaymask = WDAYMASK[wday:]\n                self.mrange = M366RANGE\n\n            if not rr._byweekno:\n                self.wnomask = None\n            else:\n                self.wnomask = [0]*(self.yearlen+7)\n                # no1wkst = firstwkst = self.wdaymask.index(rr._wkst)\n                no1wkst = firstwkst = (7-self.yearweekday+rr._wkst) % 7\n                if no1wkst >= 4:\n                    no1wkst = 0\n                    # Number of days in the year, plus the days we got\n                    # from last year.\n                    wyearlen = self.yearlen+(self.yearweekday-rr._wkst) % 7\n                else:\n                    # Number of days in the year, minus the days we\n                    # left in last year.\n                    wyearlen = self.yearlen-no1wkst\n                div, mod = divmod(wyearlen, 7)\n                numweeks = div+mod//4\n                for n in rr._byweekno:\n                    if n < 0:\n                        n += numweeks+1\n                    if not (0 < n <= numweeks):\n                        continue\n                    if n > 1:\n                        i = no1wkst+(n-1)*7\n                        if no1wkst != firstwkst:\n                            i -= 7-firstwkst\n                    else:\n                        i = no1wkst\n                    for j in range(7):\n                        self.wnomask[i] = 1\n                        i += 1\n                        if self.wdaymask[i] == rr._wkst:\n                            break\n                if 1 in rr._byweekno:\n                    # Check week number 1 of next year as well\n                    # TODO: Check -numweeks for next year.\n                    i = no1wkst+numweeks*7\n                    if no1wkst != firstwkst:\n                        i -= 7-firstwkst\n                    if i < self.yearlen:\n                        # If week starts in next year, we\n                        # don't care about it.\n                        for j in range(7):\n                            self.wnomask[i] = 1\n                            i += 1\n                            if self.wdaymask[i] == rr._wkst:\n                                break\n                if no1wkst:\n                    # Check last week number of last year as\n                    # well. If no1wkst is 0, either the year\n                    # started on week start, or week number 1\n                    # got days from last year, so there are no\n                    # days from last year's last week number in\n                    # this year.\n                    if -1 not in rr._byweekno:\n                        lyearweekday = datetime.date(year-1, 1, 1).weekday()\n                        lno1wkst = (7-lyearweekday+rr._wkst) % 7\n                        lyearlen = 365+calendar.isleap(year-1)\n                        if lno1wkst >= 4:\n                            lno1wkst = 0\n                            lnumweeks = 52+(lyearlen +\n                                            (lyearweekday-rr._wkst) % 7) % 7//4\n                        else:\n                            lnumweeks = 52+(self.yearlen-no1wkst) % 7//4\n                    else:\n                        lnumweeks = -1\n                    if lnumweeks in rr._byweekno:\n                        for i in range(no1wkst):\n                            self.wnomask[i] = 1\n\n        if (rr._bynweekday and (month != self.lastmonth or\n                                year != self.lastyear)):\n            ranges = []\n            if rr._freq == YEARLY:\n                if rr._bymonth:\n                    for month in rr._bymonth:\n                        ranges.append(self.mrange[month-1:month+1])\n                else:\n                    ranges = [(0, self.yearlen)]\n            elif rr._freq == MONTHLY:\n                ranges = [self.mrange[month-1:month+1]]\n            if ranges:\n                # Weekly frequency won't get here, so we may not\n                # care about cross-year weekly periods.\n                self.nwdaymask = [0]*self.yearlen\n                for first, last in ranges:\n                    last -= 1\n                    for wday, n in rr._bynweekday:\n                        if n < 0:\n                            i = last+(n+1)*7\n                            i -= (self.wdaymask[i]-wday) % 7\n                        else:\n                            i = first+(n-1)*7\n                            i += (7-self.wdaymask[i]+wday) % 7\n                        if first <= i <= last:\n                            self.nwdaymask[i] = 1\n\n        if rr._byeaster:\n            self.eastermask = [0]*(self.yearlen+7)\n            eyday = easter.easter(year).toordinal()-self.yearordinal\n            for offset in rr._byeaster:\n                self.eastermask[eyday+offset] = 1\n\n        self.lastyear = year\n        self.lastmonth = month\n\n    def ydayset(self, year, month, day):\n        return list(range(self.yearlen)), 0, self.yearlen\n\n    def mdayset(self, year, month, day):\n        dset = [None]*self.yearlen\n        start, end = self.mrange[month-1:month+1]\n        for i in range(start, end):\n            dset[i] = i\n        return dset, start, end\n\n    def wdayset(self, year, month, day):\n        # We need to handle cross-year weeks here.\n        dset = [None]*(self.yearlen+7)\n        i = datetime.date(year, month, day).toordinal()-self.yearordinal\n        start = i\n        for j in range(7):\n            dset[i] = i\n            i += 1\n            # if (not (0 <= i < self.yearlen) or\n            #    self.wdaymask[i] == self.rrule._wkst):\n            # This will cross the year boundary, if necessary.\n            if self.wdaymask[i] == self.rrule._wkst:\n                break\n        return dset, start, i\n\n    def ddayset(self, year, month, day):\n        dset = [None] * self.yearlen\n        i = datetime.date(year, month, day).toordinal() - self.yearordinal\n        dset[i] = i\n        return dset, i, i + 1\n\n    def htimeset(self, hour, minute, second):\n        tset = []\n        rr = self.rrule\n        for minute in rr._byminute:\n            for second in rr._bysecond:\n                tset.append(datetime.time(hour, minute, second,\n                                          tzinfo=rr._tzinfo))\n        tset.sort()\n        return tset\n\n    def mtimeset(self, hour, minute, second):\n        tset = []\n        rr = self.rrule\n        for second in rr._bysecond:\n            tset.append(datetime.time(hour, minute, second, tzinfo=rr._tzinfo))\n        tset.sort()\n        return tset\n\n    def stimeset(self, hour, minute, second):\n        return (datetime.time(hour, minute, second,\n                tzinfo=self.rrule._tzinfo),)\n\n\nclass rruleset(rrulebase):\n    \"\"\" The rruleset type allows more complex recurrence setups, mixing\n    multiple rules, dates, exclusion rules, and exclusion dates. The type\n    constructor takes the following keyword arguments:\n\n    :param cache: If True, caching of results will be enabled, improving\n                  performance of multiple queries considerably. \"\"\"\n\n    class _genitem(object):\n        def __init__(self, genlist, gen):\n            try:\n                self.dt = advance_iterator(gen)\n                genlist.append(self)\n            except StopIteration:\n                pass\n            self.genlist = genlist\n            self.gen = gen\n\n        def __next__(self):\n            try:\n                self.dt = advance_iterator(self.gen)\n            except StopIteration:\n                if self.genlist[0] is self:\n                    heapq.heappop(self.genlist)\n                else:\n                    self.genlist.remove(self)\n                    heapq.heapify(self.genlist)\n\n        next = __next__\n\n        def __lt__(self, other):\n            return self.dt < other.dt\n\n        def __gt__(self, other):\n            return self.dt > other.dt\n\n        def __eq__(self, other):\n            return self.dt == other.dt\n\n        def __ne__(self, other):\n            return self.dt != other.dt\n\n    def __init__(self, cache=False):\n        super(rruleset, self).__init__(cache)\n        self._rrule = []\n        self._rdate = []\n        self._exrule = []\n        self._exdate = []\n\n    @_invalidates_cache\n    def rrule(self, rrule):\n        \"\"\" Include the given :py:class:`rrule` instance in the recurrence set\n            generation. \"\"\"\n        self._rrule.append(rrule)\n\n    @_invalidates_cache\n    def rdate(self, rdate):\n        \"\"\" Include the given :py:class:`datetime` instance in the recurrence\n            set generation. \"\"\"\n        self._rdate.append(rdate)\n\n    @_invalidates_cache\n    def exrule(self, exrule):\n        \"\"\" Include the given rrule instance in the recurrence set exclusion\n            list. Dates which are part of the given recurrence rules will not\n            be generated, even if some inclusive rrule or rdate matches them.\n        \"\"\"\n        self._exrule.append(exrule)\n\n    @_invalidates_cache\n    def exdate(self, exdate):\n        \"\"\" Include the given datetime instance in the recurrence set\n            exclusion list. Dates included that way will not be generated,\n            even if some inclusive rrule or rdate matches them. \"\"\"\n        self._exdate.append(exdate)\n\n    def _iter(self):\n        rlist = []\n        self._rdate.sort()\n        self._genitem(rlist, iter(self._rdate))\n        for gen in [iter(x) for x in self._rrule]:\n            self._genitem(rlist, gen)\n        exlist = []\n        self._exdate.sort()\n        self._genitem(exlist, iter(self._exdate))\n        for gen in [iter(x) for x in self._exrule]:\n            self._genitem(exlist, gen)\n        lastdt = None\n        total = 0\n        heapq.heapify(rlist)\n        heapq.heapify(exlist)\n        while rlist:\n            ritem = rlist[0]\n            if not lastdt or lastdt != ritem.dt:\n                while exlist and exlist[0] < ritem:\n                    exitem = exlist[0]\n                    advance_iterator(exitem)\n                    if exlist and exlist[0] is exitem:\n                        heapq.heapreplace(exlist, exitem)\n                if not exlist or ritem != exlist[0]:\n                    total += 1\n                    yield ritem.dt\n                lastdt = ritem.dt\n            advance_iterator(ritem)\n            if rlist and rlist[0] is ritem:\n                heapq.heapreplace(rlist, ritem)\n        self._len = total\n\n\n\n\nclass _rrulestr(object):\n    \"\"\" Parses a string representation of a recurrence rule or set of\n    recurrence rules.\n\n    :param s:\n        Required, a string defining one or more recurrence rules.\n\n    :param dtstart:\n        If given, used as the default recurrence start if not specified in the\n        rule string.\n\n    :param cache:\n        If set ``True`` caching of results will be enabled, improving\n        performance of multiple queries considerably.\n\n    :param unfold:\n        If set ``True`` indicates that a rule string is split over more\n        than one line and should be joined before processing.\n\n    :param forceset:\n        If set ``True`` forces a :class:`dateutil.rrule.rruleset` to\n        be returned.\n\n    :param compatible:\n        If set ``True`` forces ``unfold`` and ``forceset`` to be ``True``.\n\n    :param ignoretz:\n        If set ``True``, time zones in parsed strings are ignored and a naive\n        :class:`datetime.datetime` object is returned.\n\n    :param tzids:\n        If given, a callable or mapping used to retrieve a\n        :class:`datetime.tzinfo` from a string representation.\n        Defaults to :func:`dateutil.tz.gettz`.\n\n    :param tzinfos:\n        Additional time zone names / aliases which may be present in a string\n        representation.  See :func:`dateutil.parser.parse` for more\n        information.\n\n    :return:\n        Returns a :class:`dateutil.rrule.rruleset` or\n        :class:`dateutil.rrule.rrule`\n    \"\"\"\n\n    _freq_map = {\"YEARLY\": YEARLY,\n                 \"MONTHLY\": MONTHLY,\n                 \"WEEKLY\": WEEKLY,\n                 \"DAILY\": DAILY,\n                 \"HOURLY\": HOURLY,\n                 \"MINUTELY\": MINUTELY,\n                 \"SECONDLY\": SECONDLY}\n\n    _weekday_map = {\"MO\": 0, \"TU\": 1, \"WE\": 2, \"TH\": 3,\n                    \"FR\": 4, \"SA\": 5, \"SU\": 6}\n\n    def _handle_int(self, rrkwargs, name, value, **kwargs):\n        rrkwargs[name.lower()] = int(value)\n\n    def _handle_int_list(self, rrkwargs, name, value, **kwargs):\n        rrkwargs[name.lower()] = [int(x) for x in value.split(',')]\n\n    _handle_INTERVAL = _handle_int\n    _handle_COUNT = _handle_int\n    _handle_BYSETPOS = _handle_int_list\n    _handle_BYMONTH = _handle_int_list\n    _handle_BYMONTHDAY = _handle_int_list\n    _handle_BYYEARDAY = _handle_int_list\n    _handle_BYEASTER = _handle_int_list\n    _handle_BYWEEKNO = _handle_int_list\n    _handle_BYHOUR = _handle_int_list\n    _handle_BYMINUTE = _handle_int_list\n    _handle_BYSECOND = _handle_int_list\n\n    def _handle_FREQ(self, rrkwargs, name, value, **kwargs):\n        rrkwargs[\"freq\"] = self._freq_map[value]\n\n    def _handle_UNTIL(self, rrkwargs, name, value, **kwargs):\n        global parser\n        if not parser:\n            from dateutil import parser\n        try:\n            rrkwargs[\"until\"] = parser.parse(value,\n                                             ignoretz=kwargs.get(\"ignoretz\"),\n                                             tzinfos=kwargs.get(\"tzinfos\"))\n        except ValueError:\n            raise ValueError(\"invalid until date\")\n\n    def _handle_WKST(self, rrkwargs, name, value, **kwargs):\n        rrkwargs[\"wkst\"] = self._weekday_map[value]\n\n    def _handle_BYWEEKDAY(self, rrkwargs, name, value, **kwargs):\n        \"\"\"\n        Two ways to specify this: +1MO or MO(+1)\n        \"\"\"\n        l = []\n        for wday in value.split(','):\n            if '(' in wday:\n                # If it's of the form TH(+1), etc.\n                splt = wday.split('(')\n                w = splt[0]\n                n = int(splt[1][:-1])\n            elif len(wday):\n                # If it's of the form +1MO\n                for i in range(len(wday)):\n                    if wday[i] not in '+-0123456789':\n                        break\n                n = wday[:i] or None\n                w = wday[i:]\n                if n:\n                    n = int(n)\n            else:\n                raise ValueError(\"Invalid (empty) BYDAY specification.\")\n\n            l.append(weekdays[self._weekday_map[w]](n))\n        rrkwargs[\"byweekday\"] = l\n\n    _handle_BYDAY = _handle_BYWEEKDAY\n\n    def _parse_rfc_rrule(self, line,\n                         dtstart=None,\n                         cache=False,\n                         ignoretz=False,\n                         tzinfos=None):\n        if line.find(':') != -1:\n            name, value = line.split(':')\n            if name != \"RRULE\":\n                raise ValueError(\"unknown parameter name\")\n        else:\n            value = line\n        rrkwargs = {}\n        for pair in value.split(';'):\n            name, value = pair.split('=')\n            name = name.upper()\n            value = value.upper()\n            try:\n                getattr(self, \"_handle_\"+name)(rrkwargs, name, value,\n                                               ignoretz=ignoretz,\n                                               tzinfos=tzinfos)\n            except AttributeError:\n                raise ValueError(\"unknown parameter '%s'\" % name)\n            except (KeyError, ValueError):\n                raise ValueError(\"invalid '%s': %s\" % (name, value))\n        return rrule(dtstart=dtstart, cache=cache, **rrkwargs)\n\n    def _parse_date_value(self, date_value, parms, rule_tzids,\n                          ignoretz, tzids, tzinfos):\n        global parser\n        if not parser:\n            from dateutil import parser\n\n        datevals = []\n        value_found = False\n        TZID = None\n\n        for parm in parms:\n            if parm.startswith(\"TZID=\"):\n                try:\n                    tzkey = rule_tzids[parm.split('TZID=')[-1]]\n                except KeyError:\n                    continue\n                if tzids is None:\n                    from . import tz\n                    tzlookup = tz.gettz\n                elif callable(tzids):\n                    tzlookup = tzids\n                else:\n                    tzlookup = getattr(tzids, 'get', None)\n                    if tzlookup is None:\n                        msg = ('tzids must be a callable, mapping, or None, '\n                               'not %s' % tzids)\n                        raise ValueError(msg)\n\n                TZID = tzlookup(tzkey)\n                continue\n\n            # RFC 5445 3.8.2.4: The VALUE parameter is optional, but may be found\n            # only once.\n            if parm not in {\"VALUE=DATE-TIME\", \"VALUE=DATE\"}:\n                raise ValueError(\"unsupported parm: \" + parm)\n            else:\n                if value_found:\n                    msg = (\"Duplicate value parameter found in: \" + parm)\n                    raise ValueError(msg)\n                value_found = True\n\n        for datestr in date_value.split(','):\n            date = parser.parse(datestr, ignoretz=ignoretz, tzinfos=tzinfos)\n            if TZID is not None:\n                if date.tzinfo is None:\n                    date = date.replace(tzinfo=TZID)\n                else:\n                    raise ValueError('DTSTART/EXDATE specifies multiple timezone')\n            datevals.append(date)\n\n        return datevals\n\n    def _parse_rfc(self, s,\n                   dtstart=None,\n                   cache=False,\n                   unfold=False,\n                   forceset=False,\n                   compatible=False,\n                   ignoretz=False,\n                   tzids=None,\n                   tzinfos=None):\n        global parser\n        if compatible:\n            forceset = True\n            unfold = True\n\n        TZID_NAMES = dict(map(\n            lambda x: (x.upper(), x),\n            re.findall('TZID=(?P<name>[^:]+):', s)\n        ))\n        s = s.upper()\n        if not s.strip():\n            raise ValueError(\"empty string\")\n        if unfold:\n            lines = s.splitlines()\n            i = 0\n            while i < len(lines):\n                line = lines[i].rstrip()\n                if not line:\n                    del lines[i]\n                elif i > 0 and line[0] == \" \":\n                    lines[i-1] += line[1:]\n                    del lines[i]\n                else:\n                    i += 1\n        else:\n            lines = s.split()\n        if (not forceset and len(lines) == 1 and (s.find(':') == -1 or\n                                                  s.startswith('RRULE:'))):\n            return self._parse_rfc_rrule(lines[0], cache=cache,\n                                         dtstart=dtstart, ignoretz=ignoretz,\n                                         tzinfos=tzinfos)\n        else:\n            rrulevals = []\n            rdatevals = []\n            exrulevals = []\n            exdatevals = []\n            for line in lines:\n                if not line:\n                    continue\n                if line.find(':') == -1:\n                    name = \"RRULE\"\n                    value = line\n                else:\n                    name, value = line.split(':', 1)\n                parms = name.split(';')\n                if not parms:\n                    raise ValueError(\"empty property name\")\n                name = parms[0]\n                parms = parms[1:]\n                if name == \"RRULE\":\n                    for parm in parms:\n                        raise ValueError(\"unsupported RRULE parm: \"+parm)\n                    rrulevals.append(value)\n                elif name == \"RDATE\":\n                    for parm in parms:\n                        if parm != \"VALUE=DATE-TIME\":\n                            raise ValueError(\"unsupported RDATE parm: \"+parm)\n                    rdatevals.append(value)\n                elif name == \"EXRULE\":\n                    for parm in parms:\n                        raise ValueError(\"unsupported EXRULE parm: \"+parm)\n                    exrulevals.append(value)\n                elif name == \"EXDATE\":\n                    exdatevals.extend(\n                        self._parse_date_value(value, parms,\n                                               TZID_NAMES, ignoretz,\n                                               tzids, tzinfos)\n                    )\n                elif name == \"DTSTART\":\n                    dtvals = self._parse_date_value(value, parms, TZID_NAMES,\n                                                    ignoretz, tzids, tzinfos)\n                    if len(dtvals) != 1:\n                        raise ValueError(\"Multiple DTSTART values specified:\" +\n                                         value)\n                    dtstart = dtvals[0]\n                else:\n                    raise ValueError(\"unsupported property: \"+name)\n            if (forceset or len(rrulevals) > 1 or rdatevals\n                    or exrulevals or exdatevals):\n                if not parser and (rdatevals or exdatevals):\n                    from dateutil import parser\n                rset = rruleset(cache=cache)\n                for value in rrulevals:\n                    rset.rrule(self._parse_rfc_rrule(value, dtstart=dtstart,\n                                                     ignoretz=ignoretz,\n                                                     tzinfos=tzinfos))\n                for value in rdatevals:\n                    for datestr in value.split(','):\n                        rset.rdate(parser.parse(datestr,\n                                                ignoretz=ignoretz,\n                                                tzinfos=tzinfos))\n                for value in exrulevals:\n                    rset.exrule(self._parse_rfc_rrule(value, dtstart=dtstart,\n                                                      ignoretz=ignoretz,\n                                                      tzinfos=tzinfos))\n                for value in exdatevals:\n                    rset.exdate(value)\n                if compatible and dtstart:\n                    rset.rdate(dtstart)\n                return rset\n            else:\n                return self._parse_rfc_rrule(rrulevals[0],\n                                             dtstart=dtstart,\n                                             cache=cache,\n                                             ignoretz=ignoretz,\n                                             tzinfos=tzinfos)\n\n    def __call__(self, s, **kwargs):\n        return self._parse_rfc(s, **kwargs)\n\n\nrrulestr = _rrulestr()\n\n# vim:ts=4:sw=4:et\n", "src/dateutil/__init__.py": "# -*- coding: utf-8 -*-\nimport sys\n\ntry:\n    from ._version import version as __version__\nexcept ImportError:\n    __version__ = 'unknown'\n\n__all__ = ['easter', 'parser', 'relativedelta', 'rrule', 'tz',\n           'utils', 'zoneinfo']\n\ndef __getattr__(name):\n    import importlib\n\n    if name in __all__:\n        return importlib.import_module(\".\" + name, __name__)\n    raise AttributeError(\n        \"module {!r} has not attribute {!r}\".format(__name__, name)\n    )\n\n\ndef __dir__():\n    # __dir__ should include all the lazy-importable modules as well.\n    return [x for x in globals() if x not in sys.modules] + __all__\n", "src/dateutil/easter.py": "# -*- coding: utf-8 -*-\n\"\"\"\nThis module offers a generic Easter computing method for any given year, using\nWestern, Orthodox or Julian algorithms.\n\"\"\"\n\nimport datetime\n\n__all__ = [\"easter\", \"EASTER_JULIAN\", \"EASTER_ORTHODOX\", \"EASTER_WESTERN\"]\n\nEASTER_JULIAN = 1\nEASTER_ORTHODOX = 2\nEASTER_WESTERN = 3\n\n\ndef easter(year, method=EASTER_WESTERN):\n    \"\"\"\n    This method was ported from the work done by GM Arts,\n    on top of the algorithm by Claus Tondering, which was\n    based in part on the algorithm of Ouding (1940), as\n    quoted in \"Explanatory Supplement to the Astronomical\n    Almanac\", P.  Kenneth Seidelmann, editor.\n\n    This algorithm implements three different Easter\n    calculation methods:\n\n    1. Original calculation in Julian calendar, valid in\n       dates after 326 AD\n    2. Original method, with date converted to Gregorian\n       calendar, valid in years 1583 to 4099\n    3. Revised method, in Gregorian calendar, valid in\n       years 1583 to 4099 as well\n\n    These methods are represented by the constants:\n\n    * ``EASTER_JULIAN   = 1``\n    * ``EASTER_ORTHODOX = 2``\n    * ``EASTER_WESTERN  = 3``\n\n    The default method is method 3.\n\n    More about the algorithm may be found at:\n\n    `GM Arts: Easter Algorithms <http://www.gmarts.org/index.php?go=415>`_\n\n    and\n\n    `The Calendar FAQ: Easter <https://www.tondering.dk/claus/cal/easter.php>`_\n\n    \"\"\"\n\n    if not (1 <= method <= 3):\n        raise ValueError(\"invalid method\")\n\n    # g - Golden year - 1\n    # c - Century\n    # h - (23 - Epact) mod 30\n    # i - Number of days from March 21 to Paschal Full Moon\n    # j - Weekday for PFM (0=Sunday, etc)\n    # p - Number of days from March 21 to Sunday on or before PFM\n    #     (-6 to 28 methods 1 & 3, to 56 for method 2)\n    # e - Extra days to add for method 2 (converting Julian\n    #     date to Gregorian date)\n\n    y = year\n    g = y % 19\n    e = 0\n    if method < 3:\n        # Old method\n        i = (19*g + 15) % 30\n        j = (y + y//4 + i) % 7\n        if method == 2:\n            # Extra dates to convert Julian to Gregorian date\n            e = 10\n            if y > 1600:\n                e = e + y//100 - 16 - (y//100 - 16)//4\n    else:\n        # New method\n        c = y//100\n        h = (c - c//4 - (8*c + 13)//25 + 19*g + 15) % 30\n        i = h - (h//28)*(1 - (h//28)*(29//(h + 1))*((21 - g)//11))\n        j = (y + y//4 + i + 2 - c + c//4) % 7\n\n    # p can be from -6 to 56 corresponding to dates 22 March to 23 May\n    # (later dates apply to method 2, although 23 May never actually occurs)\n    p = i - j + e\n    d = 1 + (p + 27 + (p + 6)//40) % 31\n    m = 3 + (p + 26)//30\n    return datetime.date(int(y), int(m), int(d))\n", "src/dateutil/parser/_parser.py": "# -*- coding: utf-8 -*-\n\"\"\"\nThis module offers a generic date/time string parser which is able to parse\nmost known formats to represent a date and/or time.\n\nThis module attempts to be forgiving with regards to unlikely input formats,\nreturning a datetime object even for dates which are ambiguous. If an element\nof a date/time stamp is omitted, the following rules are applied:\n\n- If AM or PM is left unspecified, a 24-hour clock is assumed, however, an hour\n  on a 12-hour clock (``0 <= hour <= 12``) *must* be specified if AM or PM is\n  specified.\n- If a time zone is omitted, a timezone-naive datetime is returned.\n\nIf any other elements are missing, they are taken from the\n:class:`datetime.datetime` object passed to the parameter ``default``. If this\nresults in a day number exceeding the valid number of days per month, the\nvalue falls back to the end of the month.\n\nAdditional resources about date/time string formats can be found below:\n\n- `A summary of the international standard date and time notation\n  <https://www.cl.cam.ac.uk/~mgk25/iso-time.html>`_\n- `W3C Date and Time Formats <https://www.w3.org/TR/NOTE-datetime>`_\n- `Time Formats (Planetary Rings Node) <https://pds-rings.seti.org:443/tools/time_formats.html>`_\n- `CPAN ParseDate module\n  <https://metacpan.org/pod/release/MUIR/Time-modules-2013.0912/lib/Time/ParseDate.pm>`_\n- `Java SimpleDateFormat Class\n  <https://docs.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.html>`_\n\"\"\"\nfrom __future__ import unicode_literals\n\nimport datetime\nimport re\nimport string\nimport time\nimport warnings\n\nfrom calendar import monthrange\nfrom io import StringIO\n\nimport six\nfrom six import integer_types, text_type\n\nfrom decimal import Decimal\n\nfrom warnings import warn\n\nfrom .. import relativedelta\nfrom .. import tz\n\n__all__ = [\"parse\", \"parserinfo\", \"ParserError\"]\n\n\n# TODO: pandas.core.tools.datetimes imports this explicitly.  Might be worth\n# making public and/or figuring out if there is something we can\n# take off their plate.\nclass _timelex(object):\n    # Fractional seconds are sometimes split by a comma\n    _split_decimal = re.compile(\"([.,])\")\n\n    def __init__(self, instream):\n        if isinstance(instream, (bytes, bytearray)):\n            instream = instream.decode()\n\n        if isinstance(instream, text_type):\n            instream = StringIO(instream)\n        elif getattr(instream, 'read', None) is None:\n            raise TypeError('Parser must be a string or character stream, not '\n                            '{itype}'.format(itype=instream.__class__.__name__))\n\n        self.instream = instream\n        self.charstack = []\n        self.tokenstack = []\n        self.eof = False\n\n    def get_token(self):\n        \"\"\"\n        This function breaks the time string into lexical units (tokens), which\n        can be parsed by the parser. Lexical units are demarcated by changes in\n        the character set, so any continuous string of letters is considered\n        one unit, any continuous string of numbers is considered one unit.\n\n        The main complication arises from the fact that dots ('.') can be used\n        both as separators (e.g. \"Sep.20.2009\") or decimal points (e.g.\n        \"4:30:21.447\"). As such, it is necessary to read the full context of\n        any dot-separated strings before breaking it into tokens; as such, this\n        function maintains a \"token stack\", for when the ambiguous context\n        demands that multiple tokens be parsed at once.\n        \"\"\"\n        if self.tokenstack:\n            return self.tokenstack.pop(0)\n\n        seenletters = False\n        token = None\n        state = None\n\n        while not self.eof:\n            # We only realize that we've reached the end of a token when we\n            # find a character that's not part of the current token - since\n            # that character may be part of the next token, it's stored in the\n            # charstack.\n            if self.charstack:\n                nextchar = self.charstack.pop(0)\n            else:\n                nextchar = self.instream.read(1)\n                while nextchar == '\\x00':\n                    nextchar = self.instream.read(1)\n\n            if not nextchar:\n                self.eof = True\n                break\n            elif not state:\n                # First character of the token - determines if we're starting\n                # to parse a word, a number or something else.\n                token = nextchar\n                if self.isword(nextchar):\n                    state = 'a'\n                elif self.isnum(nextchar):\n                    state = '0'\n                elif self.isspace(nextchar):\n                    token = ' '\n                    break  # emit token\n                else:\n                    break  # emit token\n            elif state == 'a':\n                # If we've already started reading a word, we keep reading\n                # letters until we find something that's not part of a word.\n                seenletters = True\n                if self.isword(nextchar):\n                    token += nextchar\n                elif nextchar == '.':\n                    token += nextchar\n                    state = 'a.'\n                else:\n                    self.charstack.append(nextchar)\n                    break  # emit token\n            elif state == '0':\n                # If we've already started reading a number, we keep reading\n                # numbers until we find something that doesn't fit.\n                if self.isnum(nextchar):\n                    token += nextchar\n                elif nextchar == '.' or (nextchar == ',' and len(token) >= 2):\n                    token += nextchar\n                    state = '0.'\n                else:\n                    self.charstack.append(nextchar)\n                    break  # emit token\n            elif state == 'a.':\n                # If we've seen some letters and a dot separator, continue\n                # parsing, and the tokens will be broken up later.\n                seenletters = True\n                if nextchar == '.' or self.isword(nextchar):\n                    token += nextchar\n                elif self.isnum(nextchar) and token[-1] == '.':\n                    token += nextchar\n                    state = '0.'\n                else:\n                    self.charstack.append(nextchar)\n                    break  # emit token\n            elif state == '0.':\n                # If we've seen at least one dot separator, keep going, we'll\n                # break up the tokens later.\n                if nextchar == '.' or self.isnum(nextchar):\n                    token += nextchar\n                elif self.isword(nextchar) and token[-1] == '.':\n                    token += nextchar\n                    state = 'a.'\n                else:\n                    self.charstack.append(nextchar)\n                    break  # emit token\n\n        if (state in ('a.', '0.') and (seenletters or token.count('.') > 1 or\n                                       token[-1] in '.,')):\n            l = self._split_decimal.split(token)\n            token = l[0]\n            for tok in l[1:]:\n                if tok:\n                    self.tokenstack.append(tok)\n\n        if state == '0.' and token.count('.') == 0:\n            token = token.replace(',', '.')\n\n        return token\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        token = self.get_token()\n        if token is None:\n            raise StopIteration\n\n        return token\n\n    def next(self):\n        return self.__next__()  # Python 2.x support\n\n    @classmethod\n    def split(cls, s):\n        return list(cls(s))\n\n    @classmethod\n    def isword(cls, nextchar):\n        \"\"\" Whether or not the next character is part of a word \"\"\"\n        return nextchar.isalpha()\n\n    @classmethod\n    def isnum(cls, nextchar):\n        \"\"\" Whether the next character is part of a number \"\"\"\n        return nextchar.isdigit()\n\n    @classmethod\n    def isspace(cls, nextchar):\n        \"\"\" Whether the next character is whitespace \"\"\"\n        return nextchar.isspace()\n\n\nclass _resultbase(object):\n\n    def __init__(self):\n        for attr in self.__slots__:\n            setattr(self, attr, None)\n\n    def _repr(self, classname):\n        l = []\n        for attr in self.__slots__:\n            value = getattr(self, attr)\n            if value is not None:\n                l.append(\"%s=%s\" % (attr, repr(value)))\n        return \"%s(%s)\" % (classname, \", \".join(l))\n\n    def __len__(self):\n        return (sum(getattr(self, attr) is not None\n                    for attr in self.__slots__))\n\n    def __repr__(self):\n        return self._repr(self.__class__.__name__)\n\n\nclass parserinfo(object):\n    \"\"\"\n    Class which handles what inputs are accepted. Subclass this to customize\n    the language and acceptable values for each parameter.\n\n    :param dayfirst:\n        Whether to interpret the first value in an ambiguous 3-integer date\n        (e.g. 01/05/09) as the day (``True``) or month (``False``). If\n        ``yearfirst`` is set to ``True``, this distinguishes between YDM\n        and YMD. Default is ``False``.\n\n    :param yearfirst:\n        Whether to interpret the first value in an ambiguous 3-integer date\n        (e.g. 01/05/09) as the year. If ``True``, the first number is taken\n        to be the year, otherwise the last number is taken to be the year.\n        Default is ``False``.\n    \"\"\"\n\n    # m from a.m/p.m, t from ISO T separator\n    JUMP = [\" \", \".\", \",\", \";\", \"-\", \"/\", \"'\",\n            \"at\", \"on\", \"and\", \"ad\", \"m\", \"t\", \"of\",\n            \"st\", \"nd\", \"rd\", \"th\"]\n\n    WEEKDAYS = [(\"Mon\", \"Monday\"),\n                (\"Tue\", \"Tuesday\"),     # TODO: \"Tues\"\n                (\"Wed\", \"Wednesday\"),\n                (\"Thu\", \"Thursday\"),    # TODO: \"Thurs\"\n                (\"Fri\", \"Friday\"),\n                (\"Sat\", \"Saturday\"),\n                (\"Sun\", \"Sunday\")]\n    MONTHS = [(\"Jan\", \"January\"),\n              (\"Feb\", \"February\"),      # TODO: \"Febr\"\n              (\"Mar\", \"March\"),\n              (\"Apr\", \"April\"),\n              (\"May\", \"May\"),\n              (\"Jun\", \"June\"),\n              (\"Jul\", \"July\"),\n              (\"Aug\", \"August\"),\n              (\"Sep\", \"Sept\", \"September\"),\n              (\"Oct\", \"October\"),\n              (\"Nov\", \"November\"),\n              (\"Dec\", \"December\")]\n    HMS = [(\"h\", \"hour\", \"hours\"),\n           (\"m\", \"minute\", \"minutes\"),\n           (\"s\", \"second\", \"seconds\")]\n    AMPM = [(\"am\", \"a\"),\n            (\"pm\", \"p\")]\n    UTCZONE = [\"UTC\", \"GMT\", \"Z\", \"z\"]\n    PERTAIN = [\"of\"]\n    TZOFFSET = {}\n    # TODO: ERA = [\"AD\", \"BC\", \"CE\", \"BCE\", \"Stardate\",\n    #              \"Anno Domini\", \"Year of Our Lord\"]\n\n    def __init__(self, dayfirst=False, yearfirst=False):\n        self._jump = self._convert(self.JUMP)\n        self._weekdays = self._convert(self.WEEKDAYS)\n        self._months = self._convert(self.MONTHS)\n        self._hms = self._convert(self.HMS)\n        self._ampm = self._convert(self.AMPM)\n        self._utczone = self._convert(self.UTCZONE)\n        self._pertain = self._convert(self.PERTAIN)\n\n        self.dayfirst = dayfirst\n        self.yearfirst = yearfirst\n\n        self._year = time.localtime().tm_year\n        self._century = self._year // 100 * 100\n\n    def _convert(self, lst):\n        dct = {}\n        for i, v in enumerate(lst):\n            if isinstance(v, tuple):\n                for v in v:\n                    dct[v.lower()] = i\n            else:\n                dct[v.lower()] = i\n        return dct\n\n    def jump(self, name):\n        return name.lower() in self._jump\n\n    def weekday(self, name):\n        try:\n            return self._weekdays[name.lower()]\n        except KeyError:\n            pass\n        return None\n\n    def month(self, name):\n        try:\n            return self._months[name.lower()] + 1\n        except KeyError:\n            pass\n        return None\n\n    def hms(self, name):\n        try:\n            return self._hms[name.lower()]\n        except KeyError:\n            return None\n\n    def ampm(self, name):\n        try:\n            return self._ampm[name.lower()]\n        except KeyError:\n            return None\n\n    def pertain(self, name):\n        return name.lower() in self._pertain\n\n    def utczone(self, name):\n        return name.lower() in self._utczone\n\n    def tzoffset(self, name):\n        if name in self._utczone:\n            return 0\n\n        return self.TZOFFSET.get(name)\n\n    def convertyear(self, year, century_specified=False):\n        \"\"\"\n        Converts two-digit years to year within [-50, 49]\n        range of self._year (current local time)\n        \"\"\"\n\n        # Function contract is that the year is always positive\n        assert year >= 0\n\n        if year < 100 and not century_specified:\n            # assume current century to start\n            year += self._century\n\n            if year >= self._year + 50:  # if too far in future\n                year -= 100\n            elif year < self._year - 50:  # if too far in past\n                year += 100\n\n        return year\n\n    def validate(self, res):\n        # move to info\n        if res.year is not None:\n            res.year = self.convertyear(res.year, res.century_specified)\n\n        if ((res.tzoffset == 0 and not res.tzname) or\n             (res.tzname == 'Z' or res.tzname == 'z')):\n            res.tzname = \"UTC\"\n            res.tzoffset = 0\n        elif res.tzoffset != 0 and res.tzname and self.utczone(res.tzname):\n            res.tzoffset = 0\n        return True\n\n\nclass _ymd(list):\n    def __init__(self, *args, **kwargs):\n        super(self.__class__, self).__init__(*args, **kwargs)\n        self.century_specified = False\n        self.dstridx = None\n        self.mstridx = None\n        self.ystridx = None\n\n    @property\n    def has_year(self):\n        return self.ystridx is not None\n\n    @property\n    def has_month(self):\n        return self.mstridx is not None\n\n    @property\n    def has_day(self):\n        return self.dstridx is not None\n\n    def could_be_day(self, value):\n        if self.has_day:\n            return False\n        elif not self.has_month:\n            return 1 <= value <= 31\n        elif not self.has_year:\n            # Be permissive, assume leap year\n            month = self[self.mstridx]\n            return 1 <= value <= monthrange(2000, month)[1]\n        else:\n            month = self[self.mstridx]\n            year = self[self.ystridx]\n            return 1 <= value <= monthrange(year, month)[1]\n\n    def append(self, val, label=None):\n        if hasattr(val, '__len__'):\n            if val.isdigit() and len(val) > 2:\n                self.century_specified = True\n                if label not in [None, 'Y']:  # pragma: no cover\n                    raise ValueError(label)\n                label = 'Y'\n        elif val > 100:\n            self.century_specified = True\n            if label not in [None, 'Y']:  # pragma: no cover\n                raise ValueError(label)\n            label = 'Y'\n\n        super(self.__class__, self).append(int(val))\n\n        if label == 'M':\n            if self.has_month:\n                raise ValueError('Month is already set')\n            self.mstridx = len(self) - 1\n        elif label == 'D':\n            if self.has_day:\n                raise ValueError('Day is already set')\n            self.dstridx = len(self) - 1\n        elif label == 'Y':\n            if self.has_year:\n                raise ValueError('Year is already set')\n            self.ystridx = len(self) - 1\n\n    def _resolve_from_stridxs(self, strids):\n        \"\"\"\n        Try to resolve the identities of year/month/day elements using\n        ystridx, mstridx, and dstridx, if enough of these are specified.\n        \"\"\"\n        if len(self) == 3 and len(strids) == 2:\n            # we can back out the remaining stridx value\n            missing = [x for x in range(3) if x not in strids.values()]\n            key = [x for x in ['y', 'm', 'd'] if x not in strids]\n            assert len(missing) == len(key) == 1\n            key = key[0]\n            val = missing[0]\n            strids[key] = val\n\n        assert len(self) == len(strids)  # otherwise this should not be called\n        out = {key: self[strids[key]] for key in strids}\n        return (out.get('y'), out.get('m'), out.get('d'))\n\n    def resolve_ymd(self, yearfirst, dayfirst):\n        len_ymd = len(self)\n        year, month, day = (None, None, None)\n\n        strids = (('y', self.ystridx),\n                  ('m', self.mstridx),\n                  ('d', self.dstridx))\n\n        strids = {key: val for key, val in strids if val is not None}\n        if (len(self) == len(strids) > 0 or\n                (len(self) == 3 and len(strids) == 2)):\n            return self._resolve_from_stridxs(strids)\n\n        mstridx = self.mstridx\n\n        if len_ymd > 3:\n            raise ValueError(\"More than three YMD values\")\n        elif len_ymd == 1 or (mstridx is not None and len_ymd == 2):\n            # One member, or two members with a month string\n            if mstridx is not None:\n                month = self[mstridx]\n                # since mstridx is 0 or 1, self[mstridx-1] always\n                # looks up the other element\n                other = self[mstridx - 1]\n            else:\n                other = self[0]\n\n            if len_ymd > 1 or mstridx is None:\n                if other > 31:\n                    year = other\n                else:\n                    day = other\n\n        elif len_ymd == 2:\n            # Two members with numbers\n            if self[0] > 31:\n                # 99-01\n                year, month = self\n            elif self[1] > 31:\n                # 01-99\n                month, year = self\n            elif dayfirst and self[1] <= 12:\n                # 13-01\n                day, month = self\n            else:\n                # 01-13\n                month, day = self\n\n        elif len_ymd == 3:\n            # Three members\n            if mstridx == 0:\n                if self[1] > 31:\n                    # Apr-2003-25\n                    month, year, day = self\n                else:\n                    month, day, year = self\n            elif mstridx == 1:\n                if self[0] > 31 or (yearfirst and self[2] <= 31):\n                    # 99-Jan-01\n                    year, month, day = self\n                else:\n                    # 01-Jan-01\n                    # Give precedence to day-first, since\n                    # two-digit years is usually hand-written.\n                    day, month, year = self\n\n            elif mstridx == 2:\n                # WTF!?\n                if self[1] > 31:\n                    # 01-99-Jan\n                    day, year, month = self\n                else:\n                    # 99-01-Jan\n                    year, day, month = self\n\n            else:\n                if (self[0] > 31 or\n                    self.ystridx == 0 or\n                        (yearfirst and self[1] <= 12 and self[2] <= 31)):\n                    # 99-01-01\n                    if dayfirst and self[2] <= 12:\n                        year, day, month = self\n                    else:\n                        year, month, day = self\n                elif self[0] > 12 or (dayfirst and self[1] <= 12):\n                    # 13-01-01\n                    day, month, year = self\n                else:\n                    # 01-13-01\n                    month, day, year = self\n\n        return year, month, day\n\n\nclass parser(object):\n    def __init__(self, info=None):\n        self.info = info or parserinfo()\n\n    def parse(self, timestr, default=None,\n              ignoretz=False, tzinfos=None, **kwargs):\n        \"\"\"\n        Parse the date/time string into a :class:`datetime.datetime` object.\n\n        :param timestr:\n            Any date/time string using the supported formats.\n\n        :param default:\n            The default datetime object, if this is a datetime object and not\n            ``None``, elements specified in ``timestr`` replace elements in the\n            default object.\n\n        :param ignoretz:\n            If set ``True``, time zones in parsed strings are ignored and a\n            naive :class:`datetime.datetime` object is returned.\n\n        :param tzinfos:\n            Additional time zone names / aliases which may be present in the\n            string. This argument maps time zone names (and optionally offsets\n            from those time zones) to time zones. This parameter can be a\n            dictionary with timezone aliases mapping time zone names to time\n            zones or a function taking two parameters (``tzname`` and\n            ``tzoffset``) and returning a time zone.\n\n            The timezones to which the names are mapped can be an integer\n            offset from UTC in seconds or a :class:`tzinfo` object.\n\n            .. doctest::\n               :options: +NORMALIZE_WHITESPACE\n\n                >>> from dateutil.parser import parse\n                >>> from dateutil.tz import gettz\n                >>> tzinfos = {\"BRST\": -7200, \"CST\": gettz(\"America/Chicago\")}\n                >>> parse(\"2012-01-19 17:21:00 BRST\", tzinfos=tzinfos)\n                datetime.datetime(2012, 1, 19, 17, 21, tzinfo=tzoffset(u'BRST', -7200))\n                >>> parse(\"2012-01-19 17:21:00 CST\", tzinfos=tzinfos)\n                datetime.datetime(2012, 1, 19, 17, 21,\n                                  tzinfo=tzfile('/usr/share/zoneinfo/America/Chicago'))\n\n            This parameter is ignored if ``ignoretz`` is set.\n\n        :param \\\\*\\\\*kwargs:\n            Keyword arguments as passed to ``_parse()``.\n\n        :return:\n            Returns a :class:`datetime.datetime` object or, if the\n            ``fuzzy_with_tokens`` option is ``True``, returns a tuple, the\n            first element being a :class:`datetime.datetime` object, the second\n            a tuple containing the fuzzy tokens.\n\n        :raises ParserError:\n            Raised for invalid or unknown string format, if the provided\n            :class:`tzinfo` is not in a valid format, or if an invalid date\n            would be created.\n\n        :raises TypeError:\n            Raised for non-string or character stream input.\n\n        :raises OverflowError:\n            Raised if the parsed date exceeds the largest valid C integer on\n            your system.\n        \"\"\"\n\n        if default is None:\n            default = datetime.datetime.now().replace(hour=0, minute=0,\n                                                      second=0, microsecond=0)\n\n        res, skipped_tokens = self._parse(timestr, **kwargs)\n\n        if res is None:\n            raise ParserError(\"Unknown string format: %s\", timestr)\n\n        if len(res) == 0:\n            raise ParserError(\"String does not contain a date: %s\", timestr)\n\n        try:\n            ret = self._build_naive(res, default)\n        except ValueError as e:\n            six.raise_from(ParserError(str(e) + \": %s\", timestr), e)\n\n        if not ignoretz:\n            ret = self._build_tzaware(ret, res, tzinfos)\n\n        if kwargs.get('fuzzy_with_tokens', False):\n            return ret, skipped_tokens\n        else:\n            return ret\n\n    class _result(_resultbase):\n        __slots__ = [\"year\", \"month\", \"day\", \"weekday\",\n                     \"hour\", \"minute\", \"second\", \"microsecond\",\n                     \"tzname\", \"tzoffset\", \"ampm\",\"any_unused_tokens\"]\n\n    def _parse(self, timestr, dayfirst=None, yearfirst=None, fuzzy=False,\n               fuzzy_with_tokens=False):\n        \"\"\"\n        Private method which performs the heavy lifting of parsing, called from\n        ``parse()``, which passes on its ``kwargs`` to this function.\n\n        :param timestr:\n            The string to parse.\n\n        :param dayfirst:\n            Whether to interpret the first value in an ambiguous 3-integer date\n            (e.g. 01/05/09) as the day (``True``) or month (``False``). If\n            ``yearfirst`` is set to ``True``, this distinguishes between YDM\n            and YMD. If set to ``None``, this value is retrieved from the\n            current :class:`parserinfo` object (which itself defaults to\n            ``False``).\n\n        :param yearfirst:\n            Whether to interpret the first value in an ambiguous 3-integer date\n            (e.g. 01/05/09) as the year. If ``True``, the first number is taken\n            to be the year, otherwise the last number is taken to be the year.\n            If this is set to ``None``, the value is retrieved from the current\n            :class:`parserinfo` object (which itself defaults to ``False``).\n\n        :param fuzzy:\n            Whether to allow fuzzy parsing, allowing for string like \"Today is\n            January 1, 2047 at 8:21:00AM\".\n\n        :param fuzzy_with_tokens:\n            If ``True``, ``fuzzy`` is automatically set to True, and the parser\n            will return a tuple where the first element is the parsed\n            :class:`datetime.datetime` datetimestamp and the second element is\n            a tuple containing the portions of the string which were ignored:\n\n            .. doctest::\n\n                >>> from dateutil.parser import parse\n                >>> parse(\"Today is January 1, 2047 at 8:21:00AM\", fuzzy_with_tokens=True)\n                (datetime.datetime(2047, 1, 1, 8, 21), (u'Today is ', u' ', u'at '))\n\n        \"\"\"\n        if fuzzy_with_tokens:\n            fuzzy = True\n\n        info = self.info\n\n        if dayfirst is None:\n            dayfirst = info.dayfirst\n\n        if yearfirst is None:\n            yearfirst = info.yearfirst\n\n        res = self._result()\n        l = _timelex.split(timestr)         # Splits the timestr into tokens\n\n        skipped_idxs = []\n\n        # year/month/day list\n        ymd = _ymd()\n\n        len_l = len(l)\n        i = 0\n        try:\n            while i < len_l:\n\n                # Check if it's a number\n                value_repr = l[i]\n                try:\n                    value = float(value_repr)\n                except ValueError:\n                    value = None\n\n                if value is not None:\n                    # Numeric token\n                    i = self._parse_numeric_token(l, i, info, ymd, res, fuzzy)\n\n                # Check weekday\n                elif info.weekday(l[i]) is not None:\n                    value = info.weekday(l[i])\n                    res.weekday = value\n\n                # Check month name\n                elif info.month(l[i]) is not None:\n                    value = info.month(l[i])\n                    ymd.append(value, 'M')\n\n                    if i + 1 < len_l:\n                        if l[i + 1] in ('-', '/'):\n                            # Jan-01[-99]\n                            sep = l[i + 1]\n                            ymd.append(l[i + 2])\n\n                            if i + 3 < len_l and l[i + 3] == sep:\n                                # Jan-01-99\n                                ymd.append(l[i + 4])\n                                i += 2\n\n                            i += 2\n\n                        elif (i + 4 < len_l and l[i + 1] == l[i + 3] == ' ' and\n                              info.pertain(l[i + 2])):\n                            # Jan of 01\n                            # In this case, 01 is clearly year\n                            if l[i + 4].isdigit():\n                                # Convert it here to become unambiguous\n                                value = int(l[i + 4])\n                                year = str(info.convertyear(value))\n                                ymd.append(year, 'Y')\n                            else:\n                                # Wrong guess\n                                pass\n                                # TODO: not hit in tests\n                            i += 4\n\n                # Check am/pm\n                elif info.ampm(l[i]) is not None:\n                    value = info.ampm(l[i])\n                    val_is_ampm = self._ampm_valid(res.hour, res.ampm, fuzzy)\n\n                    if val_is_ampm:\n                        res.hour = self._adjust_ampm(res.hour, value)\n                        res.ampm = value\n\n                    elif fuzzy:\n                        skipped_idxs.append(i)\n\n                # Check for a timezone name\n                elif self._could_be_tzname(res.hour, res.tzname, res.tzoffset, l[i]):\n                    res.tzname = l[i]\n                    res.tzoffset = info.tzoffset(res.tzname)\n\n                    # Check for something like GMT+3, or BRST+3. Notice\n                    # that it doesn't mean \"I am 3 hours after GMT\", but\n                    # \"my time +3 is GMT\". If found, we reverse the\n                    # logic so that timezone parsing code will get it\n                    # right.\n                    if i + 1 < len_l and l[i + 1] in ('+', '-'):\n                        l[i + 1] = ('+', '-')[l[i + 1] == '+']\n                        res.tzoffset = None\n                        if info.utczone(res.tzname):\n                            # With something like GMT+3, the timezone\n                            # is *not* GMT.\n                            res.tzname = None\n\n                # Check for a numbered timezone\n                elif res.hour is not None and l[i] in ('+', '-'):\n                    signal = (-1, 1)[l[i] == '+']\n                    len_li = len(l[i + 1])\n\n                    # TODO: check that l[i + 1] is integer?\n                    if len_li == 4:\n                        # -0300\n                        hour_offset = int(l[i + 1][:2])\n                        min_offset = int(l[i + 1][2:])\n                    elif i + 2 < len_l and l[i + 2] == ':':\n                        # -03:00\n                        hour_offset = int(l[i + 1])\n                        min_offset = int(l[i + 3])  # TODO: Check that l[i+3] is minute-like?\n                        i += 2\n                    elif len_li <= 2:\n                        # -[0]3\n                        hour_offset = int(l[i + 1][:2])\n                        min_offset = 0\n                    else:\n                        raise ValueError(timestr)\n\n                    res.tzoffset = signal * (hour_offset * 3600 + min_offset * 60)\n\n                    # Look for a timezone name between parenthesis\n                    if (i + 5 < len_l and\n                            info.jump(l[i + 2]) and l[i + 3] == '(' and\n                            l[i + 5] == ')' and\n                            3 <= len(l[i + 4]) and\n                            self._could_be_tzname(res.hour, res.tzname,\n                                                  None, l[i + 4])):\n                        # -0300 (BRST)\n                        res.tzname = l[i + 4]\n                        i += 4\n\n                    i += 1\n\n                # Check jumps\n                elif not (info.jump(l[i]) or fuzzy):\n                    raise ValueError(timestr)\n\n                else:\n                    skipped_idxs.append(i)\n                i += 1\n\n            # Process year/month/day\n            year, month, day = ymd.resolve_ymd(yearfirst, dayfirst)\n\n            res.century_specified = ymd.century_specified\n            res.year = year\n            res.month = month\n            res.day = day\n\n        except (IndexError, ValueError):\n            return None, None\n\n        if not info.validate(res):\n            return None, None\n\n        if fuzzy_with_tokens:\n            skipped_tokens = self._recombine_skipped(l, skipped_idxs)\n            return res, tuple(skipped_tokens)\n        else:\n            return res, None\n\n    def _parse_numeric_token(self, tokens, idx, info, ymd, res, fuzzy):\n        # Token is a number\n        value_repr = tokens[idx]\n        try:\n            value = self._to_decimal(value_repr)\n        except Exception as e:\n            six.raise_from(ValueError('Unknown numeric token'), e)\n\n        len_li = len(value_repr)\n\n        len_l = len(tokens)\n\n        if (len(ymd) == 3 and len_li in (2, 4) and\n            res.hour is None and\n            (idx + 1 >= len_l or\n             (tokens[idx + 1] != ':' and\n              info.hms(tokens[idx + 1]) is None))):\n            # 19990101T23[59]\n            s = tokens[idx]\n            res.hour = int(s[:2])\n\n            if len_li == 4:\n                res.minute = int(s[2:])\n\n        elif len_li == 6 or (len_li > 6 and tokens[idx].find('.') == 6):\n            # YYMMDD or HHMMSS[.ss]\n            s = tokens[idx]\n\n            if not ymd and '.' not in tokens[idx]:\n                ymd.append(s[:2])\n                ymd.append(s[2:4])\n                ymd.append(s[4:])\n            else:\n                # 19990101T235959[.59]\n\n                # TODO: Check if res attributes already set.\n                res.hour = int(s[:2])\n                res.minute = int(s[2:4])\n                res.second, res.microsecond = self._parsems(s[4:])\n\n        elif len_li in (8, 12, 14):\n            # YYYYMMDD\n            s = tokens[idx]\n            ymd.append(s[:4], 'Y')\n            ymd.append(s[4:6])\n            ymd.append(s[6:8])\n\n            if len_li > 8:\n                res.hour = int(s[8:10])\n                res.minute = int(s[10:12])\n\n                if len_li > 12:\n                    res.second = int(s[12:])\n\n        elif self._find_hms_idx(idx, tokens, info, allow_jump=True) is not None:\n            # HH[ ]h or MM[ ]m or SS[.ss][ ]s\n            hms_idx = self._find_hms_idx(idx, tokens, info, allow_jump=True)\n            (idx, hms) = self._parse_hms(idx, tokens, info, hms_idx)\n            if hms is not None:\n                # TODO: checking that hour/minute/second are not\n                # already set?\n                self._assign_hms(res, value_repr, hms)\n\n        elif idx + 2 < len_l and tokens[idx + 1] == ':':\n            # HH:MM[:SS[.ss]]\n            res.hour = int(value)\n            value = self._to_decimal(tokens[idx + 2])  # TODO: try/except for this?\n            (res.minute, res.second) = self._parse_min_sec(value)\n\n            if idx + 4 < len_l and tokens[idx + 3] == ':':\n                res.second, res.microsecond = self._parsems(tokens[idx + 4])\n\n                idx += 2\n\n            idx += 2\n\n        elif idx + 1 < len_l and tokens[idx + 1] in ('-', '/', '.'):\n            sep = tokens[idx + 1]\n            ymd.append(value_repr)\n\n            if idx + 2 < len_l and not info.jump(tokens[idx + 2]):\n                if tokens[idx + 2].isdigit():\n                    # 01-01[-01]\n                    ymd.append(tokens[idx + 2])\n                else:\n                    # 01-Jan[-01]\n                    value = info.month(tokens[idx + 2])\n\n                    if value is not None:\n                        ymd.append(value, 'M')\n                    else:\n                        raise ValueError()\n\n                if idx + 3 < len_l and tokens[idx + 3] == sep:\n                    # We have three members\n                    value = info.month(tokens[idx + 4])\n\n                    if value is not None:\n                        ymd.append(value, 'M')\n                    else:\n                        ymd.append(tokens[idx + 4])\n                    idx += 2\n\n                idx += 1\n            idx += 1\n\n        elif idx + 1 >= len_l or info.jump(tokens[idx + 1]):\n            if idx + 2 < len_l and info.ampm(tokens[idx + 2]) is not None:\n                # 12 am\n                hour = int(value)\n                res.hour = self._adjust_ampm(hour, info.ampm(tokens[idx + 2]))\n                idx += 1\n            else:\n                # Year, month or day\n                ymd.append(value)\n            idx += 1\n\n        elif info.ampm(tokens[idx + 1]) is not None and (0 <= value < 24):\n            # 12am\n            hour = int(value)\n            res.hour = self._adjust_ampm(hour, info.ampm(tokens[idx + 1]))\n            idx += 1\n\n        elif ymd.could_be_day(value):\n            ymd.append(value)\n\n        elif not fuzzy:\n            raise ValueError()\n\n        return idx\n\n    def _find_hms_idx(self, idx, tokens, info, allow_jump):\n        len_l = len(tokens)\n\n        if idx+1 < len_l and info.hms(tokens[idx+1]) is not None:\n            # There is an \"h\", \"m\", or \"s\" label following this token.  We take\n            # assign the upcoming label to the current token.\n            # e.g. the \"12\" in 12h\"\n            hms_idx = idx + 1\n\n        elif (allow_jump and idx+2 < len_l and tokens[idx+1] == ' ' and\n              info.hms(tokens[idx+2]) is not None):\n            # There is a space and then an \"h\", \"m\", or \"s\" label.\n            # e.g. the \"12\" in \"12 h\"\n            hms_idx = idx + 2\n\n        elif idx > 0 and info.hms(tokens[idx-1]) is not None:\n            # There is a \"h\", \"m\", or \"s\" preceding this token.  Since neither\n            # of the previous cases was hit, there is no label following this\n            # token, so we use the previous label.\n            # e.g. the \"04\" in \"12h04\"\n            hms_idx = idx-1\n\n        elif (1 < idx == len_l-1 and tokens[idx-1] == ' ' and\n              info.hms(tokens[idx-2]) is not None):\n            # If we are looking at the final token, we allow for a\n            # backward-looking check to skip over a space.\n            # TODO: Are we sure this is the right condition here?\n            hms_idx = idx - 2\n\n        else:\n            hms_idx = None\n\n        return hms_idx\n\n    def _assign_hms(self, res, value_repr, hms):\n        # See GH issue #427, fixing float rounding\n        value = self._to_decimal(value_repr)\n\n        if hms == 0:\n            # Hour\n            res.hour = int(value)\n            if value % 1:\n                res.minute = int(60*(value % 1))\n\n        elif hms == 1:\n            (res.minute, res.second) = self._parse_min_sec(value)\n\n        elif hms == 2:\n            (res.second, res.microsecond) = self._parsems(value_repr)\n\n    def _could_be_tzname(self, hour, tzname, tzoffset, token):\n        return (hour is not None and\n                tzname is None and\n                tzoffset is None and\n                len(token) <= 5 and\n                (all(x in string.ascii_uppercase for x in token)\n                 or token in self.info.UTCZONE))\n\n    def _ampm_valid(self, hour, ampm, fuzzy):\n        \"\"\"\n        For fuzzy parsing, 'a' or 'am' (both valid English words)\n        may erroneously trigger the AM/PM flag. Deal with that\n        here.\n        \"\"\"\n        val_is_ampm = True\n\n        # If there's already an AM/PM flag, this one isn't one.\n        if fuzzy and ampm is not None:\n            val_is_ampm = False\n\n        # If AM/PM is found and hour is not, raise a ValueError\n        if hour is None:\n            if fuzzy:\n                val_is_ampm = False\n            else:\n                raise ValueError('No hour specified with AM or PM flag.')\n        elif not 0 <= hour <= 12:\n            # If AM/PM is found, it's a 12 hour clock, so raise\n            # an error for invalid range\n            if fuzzy:\n                val_is_ampm = False\n            else:\n                raise ValueError('Invalid hour specified for 12-hour clock.')\n\n        return val_is_ampm\n\n    def _adjust_ampm(self, hour, ampm):\n        if hour < 12 and ampm == 1:\n            hour += 12\n        elif hour == 12 and ampm == 0:\n            hour = 0\n        return hour\n\n    def _parse_min_sec(self, value):\n        # TODO: Every usage of this function sets res.second to the return\n        # value. Are there any cases where second will be returned as None and\n        # we *don't* want to set res.second = None?\n        minute = int(value)\n        second = None\n\n        sec_remainder = value % 1\n        if sec_remainder:\n            second = int(60 * sec_remainder)\n        return (minute, second)\n\n    def _parse_hms(self, idx, tokens, info, hms_idx):\n        # TODO: Is this going to admit a lot of false-positives for when we\n        # just happen to have digits and \"h\", \"m\" or \"s\" characters in non-date\n        # text?  I guess hex hashes won't have that problem, but there's plenty\n        # of random junk out there.\n        if hms_idx is None:\n            hms = None\n            new_idx = idx\n        elif hms_idx > idx:\n            hms = info.hms(tokens[hms_idx])\n            new_idx = hms_idx\n        else:\n            # Looking backwards, increment one.\n            hms = info.hms(tokens[hms_idx]) + 1\n            new_idx = idx\n\n        return (new_idx, hms)\n\n    # ------------------------------------------------------------------\n    # Handling for individual tokens.  These are kept as methods instead\n    #  of functions for the sake of customizability via subclassing.\n\n    def _parsems(self, value):\n        \"\"\"Parse a I[.F] seconds value into (seconds, microseconds).\"\"\"\n        if \".\" not in value:\n            return int(value), 0\n        else:\n            i, f = value.split(\".\")\n            return int(i), int(f.ljust(6, \"0\")[:6])\n\n    def _to_decimal(self, val):\n        try:\n            decimal_value = Decimal(val)\n            # See GH 662, edge case, infinite value should not be converted\n            #  via `_to_decimal`\n            if not decimal_value.is_finite():\n                raise ValueError(\"Converted decimal value is infinite or NaN\")\n        except Exception as e:\n            msg = \"Could not convert %s to decimal\" % val\n            six.raise_from(ValueError(msg), e)\n        else:\n            return decimal_value\n\n    # ------------------------------------------------------------------\n    # Post-Parsing construction of datetime output.  These are kept as\n    #  methods instead of functions for the sake of customizability via\n    #  subclassing.\n\n    def _build_tzinfo(self, tzinfos, tzname, tzoffset):\n        if callable(tzinfos):\n            tzdata = tzinfos(tzname, tzoffset)\n        else:\n            tzdata = tzinfos.get(tzname)\n        # handle case where tzinfo is paased an options that returns None\n        # eg tzinfos = {'BRST' : None}\n        if isinstance(tzdata, datetime.tzinfo) or tzdata is None:\n            tzinfo = tzdata\n        elif isinstance(tzdata, text_type):\n            tzinfo = tz.tzstr(tzdata)\n        elif isinstance(tzdata, integer_types):\n            tzinfo = tz.tzoffset(tzname, tzdata)\n        else:\n            raise TypeError(\"Offset must be tzinfo subclass, tz string, \"\n                            \"or int offset.\")\n        return tzinfo\n\n    def _build_tzaware(self, naive, res, tzinfos):\n        if (callable(tzinfos) or (tzinfos and res.tzname in tzinfos)):\n            tzinfo = self._build_tzinfo(tzinfos, res.tzname, res.tzoffset)\n            aware = naive.replace(tzinfo=tzinfo)\n            aware = self._assign_tzname(aware, res.tzname)\n\n        elif res.tzname and res.tzname in time.tzname:\n            aware = naive.replace(tzinfo=tz.tzlocal())\n\n            # Handle ambiguous local datetime\n            aware = self._assign_tzname(aware, res.tzname)\n\n            # This is mostly relevant for winter GMT zones parsed in the UK\n            if (aware.tzname() != res.tzname and\n                    res.tzname in self.info.UTCZONE):\n                aware = aware.replace(tzinfo=tz.UTC)\n\n        elif res.tzoffset == 0:\n            aware = naive.replace(tzinfo=tz.UTC)\n\n        elif res.tzoffset:\n            aware = naive.replace(tzinfo=tz.tzoffset(res.tzname, res.tzoffset))\n\n        elif not res.tzname and not res.tzoffset:\n            # i.e. no timezone information was found.\n            aware = naive\n\n        elif res.tzname:\n            # tz-like string was parsed but we don't know what to do\n            # with it\n            warnings.warn(\"tzname {tzname} identified but not understood.  \"\n                          \"Pass `tzinfos` argument in order to correctly \"\n                          \"return a timezone-aware datetime.  In a future \"\n                          \"version, this will raise an \"\n                          \"exception.\".format(tzname=res.tzname),\n                          category=UnknownTimezoneWarning)\n            aware = naive\n\n        return aware\n\n    def _build_naive(self, res, default):\n        repl = {}\n        for attr in (\"year\", \"month\", \"day\", \"hour\",\n                     \"minute\", \"second\", \"microsecond\"):\n            value = getattr(res, attr)\n            if value is not None:\n                repl[attr] = value\n\n        if 'day' not in repl:\n            # If the default day exceeds the last day of the month, fall back\n            # to the end of the month.\n            cyear = default.year if res.year is None else res.year\n            cmonth = default.month if res.month is None else res.month\n            cday = default.day if res.day is None else res.day\n\n            if cday > monthrange(cyear, cmonth)[1]:\n                repl['day'] = monthrange(cyear, cmonth)[1]\n\n        naive = default.replace(**repl)\n\n        if res.weekday is not None and not res.day:\n            naive = naive + relativedelta.relativedelta(weekday=res.weekday)\n\n        return naive\n\n    def _assign_tzname(self, dt, tzname):\n        if dt.tzname() != tzname:\n            new_dt = tz.enfold(dt, fold=1)\n            if new_dt.tzname() == tzname:\n                return new_dt\n\n        return dt\n\n    def _recombine_skipped(self, tokens, skipped_idxs):\n        \"\"\"\n        >>> tokens = [\"foo\", \" \", \"bar\", \" \", \"19June2000\", \"baz\"]\n        >>> skipped_idxs = [0, 1, 2, 5]\n        >>> _recombine_skipped(tokens, skipped_idxs)\n        [\"foo bar\", \"baz\"]\n        \"\"\"\n        skipped_tokens = []\n        for i, idx in enumerate(sorted(skipped_idxs)):\n            if i > 0 and idx - 1 == skipped_idxs[i - 1]:\n                skipped_tokens[-1] = skipped_tokens[-1] + tokens[idx]\n            else:\n                skipped_tokens.append(tokens[idx])\n\n        return skipped_tokens\n\n\nDEFAULTPARSER = parser()\n\n\ndef parse(timestr, parserinfo=None, **kwargs):\n    \"\"\"\n\n    Parse a string in one of the supported formats, using the\n    ``parserinfo`` parameters.\n\n    :param timestr:\n        A string containing a date/time stamp.\n\n    :param parserinfo:\n        A :class:`parserinfo` object containing parameters for the parser.\n        If ``None``, the default arguments to the :class:`parserinfo`\n        constructor are used.\n\n    The ``**kwargs`` parameter takes the following keyword arguments:\n\n    :param default:\n        The default datetime object, if this is a datetime object and not\n        ``None``, elements specified in ``timestr`` replace elements in the\n        default object.\n\n    :param ignoretz:\n        If set ``True``, time zones in parsed strings are ignored and a naive\n        :class:`datetime` object is returned.\n\n    :param tzinfos:\n        Additional time zone names / aliases which may be present in the\n        string. This argument maps time zone names (and optionally offsets\n        from those time zones) to time zones. This parameter can be a\n        dictionary with timezone aliases mapping time zone names to time\n        zones or a function taking two parameters (``tzname`` and\n        ``tzoffset``) and returning a time zone.\n\n        The timezones to which the names are mapped can be an integer\n        offset from UTC in seconds or a :class:`tzinfo` object.\n\n        .. doctest::\n           :options: +NORMALIZE_WHITESPACE\n\n            >>> from dateutil.parser import parse\n            >>> from dateutil.tz import gettz\n            >>> tzinfos = {\"BRST\": -7200, \"CST\": gettz(\"America/Chicago\")}\n            >>> parse(\"2012-01-19 17:21:00 BRST\", tzinfos=tzinfos)\n            datetime.datetime(2012, 1, 19, 17, 21, tzinfo=tzoffset(u'BRST', -7200))\n            >>> parse(\"2012-01-19 17:21:00 CST\", tzinfos=tzinfos)\n            datetime.datetime(2012, 1, 19, 17, 21,\n                              tzinfo=tzfile('/usr/share/zoneinfo/America/Chicago'))\n\n        This parameter is ignored if ``ignoretz`` is set.\n\n    :param dayfirst:\n        Whether to interpret the first value in an ambiguous 3-integer date\n        (e.g. 01/05/09) as the day (``True``) or month (``False``). If\n        ``yearfirst`` is set to ``True``, this distinguishes between YDM and\n        YMD. If set to ``None``, this value is retrieved from the current\n        :class:`parserinfo` object (which itself defaults to ``False``).\n\n    :param yearfirst:\n        Whether to interpret the first value in an ambiguous 3-integer date\n        (e.g. 01/05/09) as the year. If ``True``, the first number is taken to\n        be the year, otherwise the last number is taken to be the year. If\n        this is set to ``None``, the value is retrieved from the current\n        :class:`parserinfo` object (which itself defaults to ``False``).\n\n    :param fuzzy:\n        Whether to allow fuzzy parsing, allowing for string like \"Today is\n        January 1, 2047 at 8:21:00AM\".\n\n    :param fuzzy_with_tokens:\n        If ``True``, ``fuzzy`` is automatically set to True, and the parser\n        will return a tuple where the first element is the parsed\n        :class:`datetime.datetime` datetimestamp and the second element is\n        a tuple containing the portions of the string which were ignored:\n\n        .. doctest::\n\n            >>> from dateutil.parser import parse\n            >>> parse(\"Today is January 1, 2047 at 8:21:00AM\", fuzzy_with_tokens=True)\n            (datetime.datetime(2047, 1, 1, 8, 21), (u'Today is ', u' ', u'at '))\n\n    :return:\n        Returns a :class:`datetime.datetime` object or, if the\n        ``fuzzy_with_tokens`` option is ``True``, returns a tuple, the\n        first element being a :class:`datetime.datetime` object, the second\n        a tuple containing the fuzzy tokens.\n\n    :raises ParserError:\n        Raised for invalid or unknown string formats, if the provided\n        :class:`tzinfo` is not in a valid format, or if an invalid date would\n        be created.\n\n    :raises OverflowError:\n        Raised if the parsed date exceeds the largest valid C integer on\n        your system.\n    \"\"\"\n    if parserinfo:\n        return parser(parserinfo).parse(timestr, **kwargs)\n    else:\n        return DEFAULTPARSER.parse(timestr, **kwargs)\n\n\nclass _tzparser(object):\n\n    class _result(_resultbase):\n\n        __slots__ = [\"stdabbr\", \"stdoffset\", \"dstabbr\", \"dstoffset\",\n                     \"start\", \"end\"]\n\n        class _attr(_resultbase):\n            __slots__ = [\"month\", \"week\", \"weekday\",\n                         \"yday\", \"jyday\", \"day\", \"time\"]\n\n        def __repr__(self):\n            return self._repr(\"\")\n\n        def __init__(self):\n            _resultbase.__init__(self)\n            self.start = self._attr()\n            self.end = self._attr()\n\n    def parse(self, tzstr):\n        res = self._result()\n        l = [x for x in re.split(r'([,:.]|[a-zA-Z]+|[0-9]+)',tzstr) if x]\n        used_idxs = list()\n        try:\n\n            len_l = len(l)\n\n            i = 0\n            while i < len_l:\n                # BRST+3[BRDT[+2]]\n                j = i\n                while j < len_l and not [x for x in l[j]\n                                         if x in \"0123456789:,-+\"]:\n                    j += 1\n                if j != i:\n                    if not res.stdabbr:\n                        offattr = \"stdoffset\"\n                        res.stdabbr = \"\".join(l[i:j])\n                    else:\n                        offattr = \"dstoffset\"\n                        res.dstabbr = \"\".join(l[i:j])\n\n                    for ii in range(j):\n                        used_idxs.append(ii)\n                    i = j\n                    if (i < len_l and (l[i] in ('+', '-') or l[i][0] in\n                                       \"0123456789\")):\n                        if l[i] in ('+', '-'):\n                            # Yes, that's right.  See the TZ variable\n                            # documentation.\n                            signal = (1, -1)[l[i] == '+']\n                            used_idxs.append(i)\n                            i += 1\n                        else:\n                            signal = -1\n                        len_li = len(l[i])\n                        if len_li == 4:\n                            # -0300\n                            setattr(res, offattr, (int(l[i][:2]) * 3600 +\n                                                   int(l[i][2:]) * 60) * signal)\n                        elif i + 1 < len_l and l[i + 1] == ':':\n                            # -03:00\n                            setattr(res, offattr,\n                                    (int(l[i]) * 3600 +\n                                     int(l[i + 2]) * 60) * signal)\n                            used_idxs.append(i)\n                            i += 2\n                        elif len_li <= 2:\n                            # -[0]3\n                            setattr(res, offattr,\n                                    int(l[i][:2]) * 3600 * signal)\n                        else:\n                            return None\n                        used_idxs.append(i)\n                        i += 1\n                    if res.dstabbr:\n                        break\n                else:\n                    break\n\n\n            if i < len_l:\n                for j in range(i, len_l):\n                    if l[j] == ';':\n                        l[j] = ','\n\n                assert l[i] == ','\n\n                i += 1\n\n            if i >= len_l:\n                pass\n            elif (8 <= l.count(',') <= 9 and\n                  not [y for x in l[i:] if x != ','\n                       for y in x if y not in \"0123456789+-\"]):\n                # GMT0BST,3,0,30,3600,10,0,26,7200[,3600]\n                for x in (res.start, res.end):\n                    x.month = int(l[i])\n                    used_idxs.append(i)\n                    i += 2\n                    if l[i] == '-':\n                        value = int(l[i + 1]) * -1\n                        used_idxs.append(i)\n                        i += 1\n                    else:\n                        value = int(l[i])\n                    used_idxs.append(i)\n                    i += 2\n                    if value:\n                        x.week = value\n                        x.weekday = (int(l[i]) - 1) % 7\n                    else:\n                        x.day = int(l[i])\n                    used_idxs.append(i)\n                    i += 2\n                    x.time = int(l[i])\n                    used_idxs.append(i)\n                    i += 2\n                if i < len_l:\n                    if l[i] in ('-', '+'):\n                        signal = (-1, 1)[l[i] == \"+\"]\n                        used_idxs.append(i)\n                        i += 1\n                    else:\n                        signal = 1\n                    used_idxs.append(i)\n                    res.dstoffset = (res.stdoffset + int(l[i]) * signal)\n\n                # This was a made-up format that is not in normal use\n                warn(('Parsed time zone \"%s\"' % tzstr) +\n                     'is in a non-standard dateutil-specific format, which ' +\n                     'is now deprecated; support for parsing this format ' +\n                     'will be removed in future versions. It is recommended ' +\n                     'that you switch to a standard format like the GNU ' +\n                     'TZ variable format.', tz.DeprecatedTzFormatWarning)\n            elif (l.count(',') == 2 and l[i:].count('/') <= 2 and\n                  not [y for x in l[i:] if x not in (',', '/', 'J', 'M',\n                                                     '.', '-', ':')\n                       for y in x if y not in \"0123456789\"]):\n                for x in (res.start, res.end):\n                    if l[i] == 'J':\n                        # non-leap year day (1 based)\n                        used_idxs.append(i)\n                        i += 1\n                        x.jyday = int(l[i])\n                    elif l[i] == 'M':\n                        # month[-.]week[-.]weekday\n                        used_idxs.append(i)\n                        i += 1\n                        x.month = int(l[i])\n                        used_idxs.append(i)\n                        i += 1\n                        assert l[i] in ('-', '.')\n                        used_idxs.append(i)\n                        i += 1\n                        x.week = int(l[i])\n                        if x.week == 5:\n                            x.week = -1\n                        used_idxs.append(i)\n                        i += 1\n                        assert l[i] in ('-', '.')\n                        used_idxs.append(i)\n                        i += 1\n                        x.weekday = (int(l[i]) - 1) % 7\n                    else:\n                        # year day (zero based)\n                        x.yday = int(l[i]) + 1\n\n                    used_idxs.append(i)\n                    i += 1\n\n                    if i < len_l and l[i] == '/':\n                        used_idxs.append(i)\n                        i += 1\n                        # start time\n                        len_li = len(l[i])\n                        if len_li == 4:\n                            # -0300\n                            x.time = (int(l[i][:2]) * 3600 +\n                                      int(l[i][2:]) * 60)\n                        elif i + 1 < len_l and l[i + 1] == ':':\n                            # -03:00\n                            x.time = int(l[i]) * 3600 + int(l[i + 2]) * 60\n                            used_idxs.append(i)\n                            i += 2\n                            if i + 1 < len_l and l[i + 1] == ':':\n                                used_idxs.append(i)\n                                i += 2\n                                x.time += int(l[i])\n                        elif len_li <= 2:\n                            # -[0]3\n                            x.time = (int(l[i][:2]) * 3600)\n                        else:\n                            return None\n                        used_idxs.append(i)\n                        i += 1\n\n                    assert i == len_l or l[i] == ','\n\n                    i += 1\n\n                assert i >= len_l\n\n        except (IndexError, ValueError, AssertionError):\n            return None\n\n        unused_idxs = set(range(len_l)).difference(used_idxs)\n        res.any_unused_tokens = not {l[n] for n in unused_idxs}.issubset({\",\",\":\"})\n        return res\n\n\nDEFAULTTZPARSER = _tzparser()\n\n\ndef _parsetz(tzstr):\n    return DEFAULTTZPARSER.parse(tzstr)\n\n\nclass ParserError(ValueError):\n    \"\"\"Exception subclass used for any failure to parse a datetime string.\n\n    This is a subclass of :py:exc:`ValueError`, and should be raised any time\n    earlier versions of ``dateutil`` would have raised ``ValueError``.\n\n    .. versionadded:: 2.8.1\n    \"\"\"\n    def __str__(self):\n        try:\n            return self.args[0] % self.args[1:]\n        except (TypeError, IndexError):\n            return super(ParserError, self).__str__()\n\n    def __repr__(self):\n        args = \", \".join(\"'%s'\" % arg for arg in self.args)\n        return \"%s(%s)\" % (self.__class__.__name__, args)\n\n\nclass UnknownTimezoneWarning(RuntimeWarning):\n    \"\"\"Raised when the parser finds a timezone it cannot parse into a tzinfo.\n\n    .. versionadded:: 2.7.0\n    \"\"\"\n# vim:ts=4:sw=4:et\n", "src/dateutil/parser/__init__.py": "# -*- coding: utf-8 -*-\nfrom ._parser import parse, parser, parserinfo, ParserError\nfrom ._parser import DEFAULTPARSER, DEFAULTTZPARSER\nfrom ._parser import UnknownTimezoneWarning\n\nfrom ._parser import __doc__\n\nfrom .isoparser import isoparser, isoparse\n\n__all__ = ['parse', 'parser', 'parserinfo',\n           'isoparse', 'isoparser',\n           'ParserError',\n           'UnknownTimezoneWarning']\n\n\n###\n# Deprecate portions of the private interface so that downstream code that\n# is improperly relying on it is given *some* notice.\n\n\ndef __deprecated_private_func(f):\n    from functools import wraps\n    import warnings\n\n    msg = ('{name} is a private function and may break without warning, '\n           'it will be moved and or renamed in future versions.')\n    msg = msg.format(name=f.__name__)\n\n    @wraps(f)\n    def deprecated_func(*args, **kwargs):\n        warnings.warn(msg, DeprecationWarning)\n        return f(*args, **kwargs)\n\n    return deprecated_func\n\ndef __deprecate_private_class(c):\n    import warnings\n\n    msg = ('{name} is a private class and may break without warning, '\n           'it will be moved and or renamed in future versions.')\n    msg = msg.format(name=c.__name__)\n\n    class private_class(c):\n        __doc__ = c.__doc__\n\n        def __init__(self, *args, **kwargs):\n            warnings.warn(msg, DeprecationWarning)\n            super(private_class, self).__init__(*args, **kwargs)\n\n    private_class.__name__ = c.__name__\n\n    return private_class\n\n\nfrom ._parser import _timelex, _resultbase\nfrom ._parser import _tzparser, _parsetz\n\n_timelex = __deprecate_private_class(_timelex)\n_tzparser = __deprecate_private_class(_tzparser)\n_resultbase = __deprecate_private_class(_resultbase)\n_parsetz = __deprecated_private_func(_parsetz)\n", "src/dateutil/parser/isoparser.py": "# -*- coding: utf-8 -*-\n\"\"\"\nThis module offers a parser for ISO-8601 strings\n\nIt is intended to support all valid date, time and datetime formats per the\nISO-8601 specification.\n\n..versionadded:: 2.7.0\n\"\"\"\nfrom datetime import datetime, timedelta, time, date\nimport calendar\nfrom dateutil import tz\n\nfrom functools import wraps\n\nimport re\nimport six\n\n__all__ = [\"isoparse\", \"isoparser\"]\n\n\ndef _takes_ascii(f):\n    @wraps(f)\n    def func(self, str_in, *args, **kwargs):\n        # If it's a stream, read the whole thing\n        str_in = getattr(str_in, 'read', lambda: str_in)()\n\n        # If it's unicode, turn it into bytes, since ISO-8601 only covers ASCII\n        if isinstance(str_in, six.text_type):\n            # ASCII is the same in UTF-8\n            try:\n                str_in = str_in.encode('ascii')\n            except UnicodeEncodeError as e:\n                msg = 'ISO-8601 strings should contain only ASCII characters'\n                six.raise_from(ValueError(msg), e)\n\n        return f(self, str_in, *args, **kwargs)\n\n    return func\n\n\nclass isoparser(object):\n    def __init__(self, sep=None):\n        \"\"\"\n        :param sep:\n            A single character that separates date and time portions. If\n            ``None``, the parser will accept any single character.\n            For strict ISO-8601 adherence, pass ``'T'``.\n        \"\"\"\n        if sep is not None:\n            if (len(sep) != 1 or ord(sep) >= 128 or sep in '0123456789'):\n                raise ValueError('Separator must be a single, non-numeric ' +\n                                 'ASCII character')\n\n            sep = sep.encode('ascii')\n\n        self._sep = sep\n\n    @_takes_ascii\n    def isoparse(self, dt_str):\n        \"\"\"\n        Parse an ISO-8601 datetime string into a :class:`datetime.datetime`.\n\n        An ISO-8601 datetime string consists of a date portion, followed\n        optionally by a time portion - the date and time portions are separated\n        by a single character separator, which is ``T`` in the official\n        standard. Incomplete date formats (such as ``YYYY-MM``) may *not* be\n        combined with a time portion.\n\n        Supported date formats are:\n\n        Common:\n\n        - ``YYYY``\n        - ``YYYY-MM``\n        - ``YYYY-MM-DD`` or ``YYYYMMDD``\n\n        Uncommon:\n\n        - ``YYYY-Www`` or ``YYYYWww`` - ISO week (day defaults to 0)\n        - ``YYYY-Www-D`` or ``YYYYWwwD`` - ISO week and day\n\n        The ISO week and day numbering follows the same logic as\n        :func:`datetime.date.isocalendar`.\n\n        Supported time formats are:\n\n        - ``hh``\n        - ``hh:mm`` or ``hhmm``\n        - ``hh:mm:ss`` or ``hhmmss``\n        - ``hh:mm:ss.ssssss`` (Up to 6 sub-second digits)\n\n        Midnight is a special case for `hh`, as the standard supports both\n        00:00 and 24:00 as a representation. The decimal separator can be\n        either a dot or a comma.\n\n\n        .. caution::\n\n            Support for fractional components other than seconds is part of the\n            ISO-8601 standard, but is not currently implemented in this parser.\n\n        Supported time zone offset formats are:\n\n        - `Z` (UTC)\n        - `\u00b1HH:MM`\n        - `\u00b1HHMM`\n        - `\u00b1HH`\n\n        Offsets will be represented as :class:`dateutil.tz.tzoffset` objects,\n        with the exception of UTC, which will be represented as\n        :class:`dateutil.tz.tzutc`. Time zone offsets equivalent to UTC (such\n        as `+00:00`) will also be represented as :class:`dateutil.tz.tzutc`.\n\n        :param dt_str:\n            A string or stream containing only an ISO-8601 datetime string\n\n        :return:\n            Returns a :class:`datetime.datetime` representing the string.\n            Unspecified components default to their lowest value.\n\n        .. warning::\n\n            As of version 2.7.0, the strictness of the parser should not be\n            considered a stable part of the contract. Any valid ISO-8601 string\n            that parses correctly with the default settings will continue to\n            parse correctly in future versions, but invalid strings that\n            currently fail (e.g. ``2017-01-01T00:00+00:00:00``) are not\n            guaranteed to continue failing in future versions if they encode\n            a valid date.\n\n        .. versionadded:: 2.7.0\n        \"\"\"\n        components, pos = self._parse_isodate(dt_str)\n\n        if len(dt_str) > pos:\n            if self._sep is None or dt_str[pos:pos + 1] == self._sep:\n                components += self._parse_isotime(dt_str[pos + 1:])\n            else:\n                raise ValueError('String contains unknown ISO components')\n\n        if len(components) > 3 and components[3] == 24:\n            components[3] = 0\n            return datetime(*components) + timedelta(days=1)\n\n        return datetime(*components)\n\n    @_takes_ascii\n    def parse_isodate(self, datestr):\n        \"\"\"\n        Parse the date portion of an ISO string.\n\n        :param datestr:\n            The string portion of an ISO string, without a separator\n\n        :return:\n            Returns a :class:`datetime.date` object\n        \"\"\"\n        components, pos = self._parse_isodate(datestr)\n        if pos < len(datestr):\n            raise ValueError('String contains unknown ISO ' +\n                             'components: {!r}'.format(datestr.decode('ascii')))\n        return date(*components)\n\n    @_takes_ascii\n    def parse_isotime(self, timestr):\n        \"\"\"\n        Parse the time portion of an ISO string.\n\n        :param timestr:\n            The time portion of an ISO string, without a separator\n\n        :return:\n            Returns a :class:`datetime.time` object\n        \"\"\"\n        components = self._parse_isotime(timestr)\n        if components[0] == 24:\n            components[0] = 0\n        return time(*components)\n\n    @_takes_ascii\n    def parse_tzstr(self, tzstr, zero_as_utc=True):\n        \"\"\"\n        Parse a valid ISO time zone string.\n\n        See :func:`isoparser.isoparse` for details on supported formats.\n\n        :param tzstr:\n            A string representing an ISO time zone offset\n\n        :param zero_as_utc:\n            Whether to return :class:`dateutil.tz.tzutc` for zero-offset zones\n\n        :return:\n            Returns :class:`dateutil.tz.tzoffset` for offsets and\n            :class:`dateutil.tz.tzutc` for ``Z`` and (if ``zero_as_utc`` is\n            specified) offsets equivalent to UTC.\n        \"\"\"\n        return self._parse_tzstr(tzstr, zero_as_utc=zero_as_utc)\n\n    # Constants\n    _DATE_SEP = b'-'\n    _TIME_SEP = b':'\n    _FRACTION_REGEX = re.compile(b'[\\\\.,]([0-9]+)')\n\n    def _parse_isodate(self, dt_str):\n        try:\n            return self._parse_isodate_common(dt_str)\n        except ValueError:\n            return self._parse_isodate_uncommon(dt_str)\n\n    def _parse_isodate_common(self, dt_str):\n        len_str = len(dt_str)\n        components = [1, 1, 1]\n\n        if len_str < 4:\n            raise ValueError('ISO string too short')\n\n        # Year\n        components[0] = int(dt_str[0:4])\n        pos = 4\n        if pos >= len_str:\n            return components, pos\n\n        has_sep = dt_str[pos:pos + 1] == self._DATE_SEP\n        if has_sep:\n            pos += 1\n\n        # Month\n        if len_str - pos < 2:\n            raise ValueError('Invalid common month')\n\n        components[1] = int(dt_str[pos:pos + 2])\n        pos += 2\n\n        if pos >= len_str:\n            if has_sep:\n                return components, pos\n            else:\n                raise ValueError('Invalid ISO format')\n\n        if has_sep:\n            if dt_str[pos:pos + 1] != self._DATE_SEP:\n                raise ValueError('Invalid separator in ISO string')\n            pos += 1\n\n        # Day\n        if len_str - pos < 2:\n            raise ValueError('Invalid common day')\n        components[2] = int(dt_str[pos:pos + 2])\n        return components, pos + 2\n\n    def _parse_isodate_uncommon(self, dt_str):\n        if len(dt_str) < 4:\n            raise ValueError('ISO string too short')\n\n        # All ISO formats start with the year\n        year = int(dt_str[0:4])\n\n        has_sep = dt_str[4:5] == self._DATE_SEP\n\n        pos = 4 + has_sep       # Skip '-' if it's there\n        if dt_str[pos:pos + 1] == b'W':\n            # YYYY-?Www-?D?\n            pos += 1\n            weekno = int(dt_str[pos:pos + 2])\n            pos += 2\n\n            dayno = 1\n            if len(dt_str) > pos:\n                if (dt_str[pos:pos + 1] == self._DATE_SEP) != has_sep:\n                    raise ValueError('Inconsistent use of dash separator')\n\n                pos += has_sep\n\n                dayno = int(dt_str[pos:pos + 1])\n                pos += 1\n\n            base_date = self._calculate_weekdate(year, weekno, dayno)\n        else:\n            # YYYYDDD or YYYY-DDD\n            if len(dt_str) - pos < 3:\n                raise ValueError('Invalid ordinal day')\n\n            ordinal_day = int(dt_str[pos:pos + 3])\n            pos += 3\n\n            if ordinal_day < 1 or ordinal_day > (365 + calendar.isleap(year)):\n                raise ValueError('Invalid ordinal day' +\n                                 ' {} for year {}'.format(ordinal_day, year))\n\n            base_date = date(year, 1, 1) + timedelta(days=ordinal_day - 1)\n\n        components = [base_date.year, base_date.month, base_date.day]\n        return components, pos\n\n    def _calculate_weekdate(self, year, week, day):\n        \"\"\"\n        Calculate the day of corresponding to the ISO year-week-day calendar.\n\n        This function is effectively the inverse of\n        :func:`datetime.date.isocalendar`.\n\n        :param year:\n            The year in the ISO calendar\n\n        :param week:\n            The week in the ISO calendar - range is [1, 53]\n\n        :param day:\n            The day in the ISO calendar - range is [1 (MON), 7 (SUN)]\n\n        :return:\n            Returns a :class:`datetime.date`\n        \"\"\"\n        if not 0 < week < 54:\n            raise ValueError('Invalid week: {}'.format(week))\n\n        if not 0 < day < 8:     # Range is 1-7\n            raise ValueError('Invalid weekday: {}'.format(day))\n\n        # Get week 1 for the specific year:\n        jan_4 = date(year, 1, 4)   # Week 1 always has January 4th in it\n        week_1 = jan_4 - timedelta(days=jan_4.isocalendar()[2] - 1)\n\n        # Now add the specific number of weeks and days to get what we want\n        week_offset = (week - 1) * 7 + (day - 1)\n        return week_1 + timedelta(days=week_offset)\n\n    def _parse_isotime(self, timestr):\n        len_str = len(timestr)\n        components = [0, 0, 0, 0, None]\n        pos = 0\n        comp = -1\n\n        if len_str < 2:\n            raise ValueError('ISO time too short')\n\n        has_sep = False\n\n        while pos < len_str and comp < 5:\n            comp += 1\n\n            if timestr[pos:pos + 1] in b'-+Zz':\n                # Detect time zone boundary\n                components[-1] = self._parse_tzstr(timestr[pos:])\n                pos = len_str\n                break\n\n            if comp == 1 and timestr[pos:pos+1] == self._TIME_SEP:\n                has_sep = True\n                pos += 1\n            elif comp == 2 and has_sep:\n                if timestr[pos:pos+1] != self._TIME_SEP:\n                    raise ValueError('Inconsistent use of colon separator')\n                pos += 1\n\n            if comp < 3:\n                # Hour, minute, second\n                components[comp] = int(timestr[pos:pos + 2])\n                pos += 2\n\n            if comp == 3:\n                # Fraction of a second\n                frac = self._FRACTION_REGEX.match(timestr[pos:])\n                if not frac:\n                    continue\n\n                us_str = frac.group(1)[:6]  # Truncate to microseconds\n                components[comp] = int(us_str) * 10**(6 - len(us_str))\n                pos += len(frac.group())\n\n        if pos < len_str:\n            raise ValueError('Unused components in ISO string')\n\n        if components[0] == 24:\n            # Standard supports 00:00 and 24:00 as representations of midnight\n            if any(component != 0 for component in components[1:4]):\n                raise ValueError('Hour may only be 24 at 24:00:00.000')\n\n        return components\n\n    def _parse_tzstr(self, tzstr, zero_as_utc=True):\n        if tzstr == b'Z' or tzstr == b'z':\n            return tz.UTC\n\n        if len(tzstr) not in {3, 5, 6}:\n            raise ValueError('Time zone offset must be 1, 3, 5 or 6 characters')\n\n        if tzstr[0:1] == b'-':\n            mult = -1\n        elif tzstr[0:1] == b'+':\n            mult = 1\n        else:\n            raise ValueError('Time zone offset requires sign')\n\n        hours = int(tzstr[1:3])\n        if len(tzstr) == 3:\n            minutes = 0\n        else:\n            minutes = int(tzstr[(4 if tzstr[3:4] == self._TIME_SEP else 3):])\n\n        if zero_as_utc and hours == 0 and minutes == 0:\n            return tz.UTC\n        else:\n            if minutes > 59:\n                raise ValueError('Invalid minutes in time zone offset')\n\n            if hours > 23:\n                raise ValueError('Invalid hours in time zone offset')\n\n            return tz.tzoffset(None, mult * (hours * 60 + minutes) * 60)\n\n\nDEFAULT_ISOPARSER = isoparser()\nisoparse = DEFAULT_ISOPARSER.isoparse\n", "src/dateutil/tz/_common.py": "from six import PY2\n\nfrom functools import wraps\n\nfrom datetime import datetime, timedelta, tzinfo\n\n\nZERO = timedelta(0)\n\n__all__ = ['tzname_in_python2', 'enfold']\n\n\ndef tzname_in_python2(namefunc):\n    \"\"\"Change unicode output into bytestrings in Python 2\n\n    tzname() API changed in Python 3. It used to return bytes, but was changed\n    to unicode strings\n    \"\"\"\n    if PY2:\n        @wraps(namefunc)\n        def adjust_encoding(*args, **kwargs):\n            name = namefunc(*args, **kwargs)\n            if name is not None:\n                name = name.encode()\n\n            return name\n\n        return adjust_encoding\n    else:\n        return namefunc\n\n\n# The following is adapted from Alexander Belopolsky's tz library\n# https://github.com/abalkin/tz\nif hasattr(datetime, 'fold'):\n    # This is the pre-python 3.6 fold situation\n    def enfold(dt, fold=1):\n        \"\"\"\n        Provides a unified interface for assigning the ``fold`` attribute to\n        datetimes both before and after the implementation of PEP-495.\n\n        :param fold:\n            The value for the ``fold`` attribute in the returned datetime. This\n            should be either 0 or 1.\n\n        :return:\n            Returns an object for which ``getattr(dt, 'fold', 0)`` returns\n            ``fold`` for all versions of Python. In versions prior to\n            Python 3.6, this is a ``_DatetimeWithFold`` object, which is a\n            subclass of :py:class:`datetime.datetime` with the ``fold``\n            attribute added, if ``fold`` is 1.\n\n        .. versionadded:: 2.6.0\n        \"\"\"\n        return dt.replace(fold=fold)\n\nelse:\n    class _DatetimeWithFold(datetime):\n        \"\"\"\n        This is a class designed to provide a PEP 495-compliant interface for\n        Python versions before 3.6. It is used only for dates in a fold, so\n        the ``fold`` attribute is fixed at ``1``.\n\n        .. versionadded:: 2.6.0\n        \"\"\"\n        __slots__ = ()\n\n        def replace(self, *args, **kwargs):\n            \"\"\"\n            Return a datetime with the same attributes, except for those\n            attributes given new values by whichever keyword arguments are\n            specified. Note that tzinfo=None can be specified to create a naive\n            datetime from an aware datetime with no conversion of date and time\n            data.\n\n            This is reimplemented in ``_DatetimeWithFold`` because pypy3 will\n            return a ``datetime.datetime`` even if ``fold`` is unchanged.\n            \"\"\"\n            argnames = (\n                'year', 'month', 'day', 'hour', 'minute', 'second',\n                'microsecond', 'tzinfo'\n            )\n\n            for arg, argname in zip(args, argnames):\n                if argname in kwargs:\n                    raise TypeError('Duplicate argument: {}'.format(argname))\n\n                kwargs[argname] = arg\n\n            for argname in argnames:\n                if argname not in kwargs:\n                    kwargs[argname] = getattr(self, argname)\n\n            dt_class = self.__class__ if kwargs.get('fold', 1) else datetime\n\n            return dt_class(**kwargs)\n\n        @property\n        def fold(self):\n            return 1\n\n    def enfold(dt, fold=1):\n        \"\"\"\n        Provides a unified interface for assigning the ``fold`` attribute to\n        datetimes both before and after the implementation of PEP-495.\n\n        :param fold:\n            The value for the ``fold`` attribute in the returned datetime. This\n            should be either 0 or 1.\n\n        :return:\n            Returns an object for which ``getattr(dt, 'fold', 0)`` returns\n            ``fold`` for all versions of Python. In versions prior to\n            Python 3.6, this is a ``_DatetimeWithFold`` object, which is a\n            subclass of :py:class:`datetime.datetime` with the ``fold``\n            attribute added, if ``fold`` is 1.\n\n        .. versionadded:: 2.6.0\n        \"\"\"\n        if getattr(dt, 'fold', 0) == fold:\n            return dt\n\n        args = dt.timetuple()[:6]\n        args += (dt.microsecond, dt.tzinfo)\n\n        if fold:\n            return _DatetimeWithFold(*args)\n        else:\n            return datetime(*args)\n\n\ndef _validate_fromutc_inputs(f):\n    \"\"\"\n    The CPython version of ``fromutc`` checks that the input is a ``datetime``\n    object and that ``self`` is attached as its ``tzinfo``.\n    \"\"\"\n    @wraps(f)\n    def fromutc(self, dt):\n        if not isinstance(dt, datetime):\n            raise TypeError(\"fromutc() requires a datetime argument\")\n        if dt.tzinfo is not self:\n            raise ValueError(\"dt.tzinfo is not self\")\n\n        return f(self, dt)\n\n    return fromutc\n\n\nclass _tzinfo(tzinfo):\n    \"\"\"\n    Base class for all ``dateutil`` ``tzinfo`` objects.\n    \"\"\"\n\n    def is_ambiguous(self, dt):\n        \"\"\"\n        Whether or not the \"wall time\" of a given datetime is ambiguous in this\n        zone.\n\n        :param dt:\n            A :py:class:`datetime.datetime`, naive or time zone aware.\n\n\n        :return:\n            Returns ``True`` if ambiguous, ``False`` otherwise.\n\n        .. versionadded:: 2.6.0\n        \"\"\"\n\n        dt = dt.replace(tzinfo=self)\n\n        wall_0 = enfold(dt, fold=0)\n        wall_1 = enfold(dt, fold=1)\n\n        same_offset = wall_0.utcoffset() == wall_1.utcoffset()\n        same_dt = wall_0.replace(tzinfo=None) == wall_1.replace(tzinfo=None)\n\n        return same_dt and not same_offset\n\n    def _fold_status(self, dt_utc, dt_wall):\n        \"\"\"\n        Determine the fold status of a \"wall\" datetime, given a representation\n        of the same datetime as a (naive) UTC datetime. This is calculated based\n        on the assumption that ``dt.utcoffset() - dt.dst()`` is constant for all\n        datetimes, and that this offset is the actual number of hours separating\n        ``dt_utc`` and ``dt_wall``.\n\n        :param dt_utc:\n            Representation of the datetime as UTC\n\n        :param dt_wall:\n            Representation of the datetime as \"wall time\". This parameter must\n            either have a `fold` attribute or have a fold-naive\n            :class:`datetime.tzinfo` attached, otherwise the calculation may\n            fail.\n        \"\"\"\n        if self.is_ambiguous(dt_wall):\n            delta_wall = dt_wall - dt_utc\n            _fold = int(delta_wall == (dt_utc.utcoffset() - dt_utc.dst()))\n        else:\n            _fold = 0\n\n        return _fold\n\n    def _fold(self, dt):\n        return getattr(dt, 'fold', 0)\n\n    def _fromutc(self, dt):\n        \"\"\"\n        Given a timezone-aware datetime in a given timezone, calculates a\n        timezone-aware datetime in a new timezone.\n\n        Since this is the one time that we *know* we have an unambiguous\n        datetime object, we take this opportunity to determine whether the\n        datetime is ambiguous and in a \"fold\" state (e.g. if it's the first\n        occurrence, chronologically, of the ambiguous datetime).\n\n        :param dt:\n            A timezone-aware :class:`datetime.datetime` object.\n        \"\"\"\n\n        # Re-implement the algorithm from Python's datetime.py\n        dtoff = dt.utcoffset()\n        if dtoff is None:\n            raise ValueError(\"fromutc() requires a non-None utcoffset() \"\n                             \"result\")\n\n        # The original datetime.py code assumes that `dst()` defaults to\n        # zero during ambiguous times. PEP 495 inverts this presumption, so\n        # for pre-PEP 495 versions of python, we need to tweak the algorithm.\n        dtdst = dt.dst()\n        if dtdst is None:\n            raise ValueError(\"fromutc() requires a non-None dst() result\")\n        delta = dtoff - dtdst\n\n        dt += delta\n        # Set fold=1 so we can default to being in the fold for\n        # ambiguous dates.\n        dtdst = enfold(dt, fold=1).dst()\n        if dtdst is None:\n            raise ValueError(\"fromutc(): dt.dst gave inconsistent \"\n                             \"results; cannot convert\")\n        return dt + dtdst\n\n    @_validate_fromutc_inputs\n    def fromutc(self, dt):\n        \"\"\"\n        Given a timezone-aware datetime in a given timezone, calculates a\n        timezone-aware datetime in a new timezone.\n\n        Since this is the one time that we *know* we have an unambiguous\n        datetime object, we take this opportunity to determine whether the\n        datetime is ambiguous and in a \"fold\" state (e.g. if it's the first\n        occurrence, chronologically, of the ambiguous datetime).\n\n        :param dt:\n            A timezone-aware :class:`datetime.datetime` object.\n        \"\"\"\n        dt_wall = self._fromutc(dt)\n\n        # Calculate the fold status given the two datetimes.\n        _fold = self._fold_status(dt, dt_wall)\n\n        # Set the default fold value for ambiguous dates\n        return enfold(dt_wall, fold=_fold)\n\n\nclass tzrangebase(_tzinfo):\n    \"\"\"\n    This is an abstract base class for time zones represented by an annual\n    transition into and out of DST. Child classes should implement the following\n    methods:\n\n        * ``__init__(self, *args, **kwargs)``\n        * ``transitions(self, year)`` - this is expected to return a tuple of\n          datetimes representing the DST on and off transitions in standard\n          time.\n\n    A fully initialized ``tzrangebase`` subclass should also provide the\n    following attributes:\n        * ``hasdst``: Boolean whether or not the zone uses DST.\n        * ``_dst_offset`` / ``_std_offset``: :class:`datetime.timedelta` objects\n          representing the respective UTC offsets.\n        * ``_dst_abbr`` / ``_std_abbr``: Strings representing the timezone short\n          abbreviations in DST and STD, respectively.\n        * ``_hasdst``: Whether or not the zone has DST.\n\n    .. versionadded:: 2.6.0\n    \"\"\"\n    def __init__(self):\n        raise NotImplementedError('tzrangebase is an abstract base class')\n\n    def utcoffset(self, dt):\n        isdst = self._isdst(dt)\n\n        if isdst is None:\n            return None\n        elif isdst:\n            return self._dst_offset\n        else:\n            return self._std_offset\n\n    def dst(self, dt):\n        isdst = self._isdst(dt)\n\n        if isdst is None:\n            return None\n        elif isdst:\n            return self._dst_base_offset\n        else:\n            return ZERO\n\n    @tzname_in_python2\n    def tzname(self, dt):\n        if self._isdst(dt):\n            return self._dst_abbr\n        else:\n            return self._std_abbr\n\n    def fromutc(self, dt):\n        \"\"\" Given a datetime in UTC, return local time \"\"\"\n        if not isinstance(dt, datetime):\n            raise TypeError(\"fromutc() requires a datetime argument\")\n\n        if dt.tzinfo is not self:\n            raise ValueError(\"dt.tzinfo is not self\")\n\n        # Get transitions - if there are none, fixed offset\n        transitions = self.transitions(dt.year)\n        if transitions is None:\n            return dt + self.utcoffset(dt)\n\n        # Get the transition times in UTC\n        dston, dstoff = transitions\n\n        dston -= self._std_offset\n        dstoff -= self._std_offset\n\n        utc_transitions = (dston, dstoff)\n        dt_utc = dt.replace(tzinfo=None)\n\n        isdst = self._naive_isdst(dt_utc, utc_transitions)\n\n        if isdst:\n            dt_wall = dt + self._dst_offset\n        else:\n            dt_wall = dt + self._std_offset\n\n        _fold = int(not isdst and self.is_ambiguous(dt_wall))\n\n        return enfold(dt_wall, fold=_fold)\n\n    def is_ambiguous(self, dt):\n        \"\"\"\n        Whether or not the \"wall time\" of a given datetime is ambiguous in this\n        zone.\n\n        :param dt:\n            A :py:class:`datetime.datetime`, naive or time zone aware.\n\n\n        :return:\n            Returns ``True`` if ambiguous, ``False`` otherwise.\n\n        .. versionadded:: 2.6.0\n        \"\"\"\n        if not self.hasdst:\n            return False\n\n        start, end = self.transitions(dt.year)\n\n        dt = dt.replace(tzinfo=None)\n        return (end <= dt < end + self._dst_base_offset)\n\n    def _isdst(self, dt):\n        if not self.hasdst:\n            return False\n        elif dt is None:\n            return None\n\n        transitions = self.transitions(dt.year)\n\n        if transitions is None:\n            return False\n\n        dt = dt.replace(tzinfo=None)\n\n        isdst = self._naive_isdst(dt, transitions)\n\n        # Handle ambiguous dates\n        if not isdst and self.is_ambiguous(dt):\n            return not self._fold(dt)\n        else:\n            return isdst\n\n    def _naive_isdst(self, dt, transitions):\n        dston, dstoff = transitions\n\n        dt = dt.replace(tzinfo=None)\n\n        if dston < dstoff:\n            isdst = dston <= dt < dstoff\n        else:\n            isdst = not dstoff <= dt < dston\n\n        return isdst\n\n    @property\n    def _dst_base_offset(self):\n        return self._dst_offset - self._std_offset\n\n    __hash__ = None\n\n    def __ne__(self, other):\n        return not (self == other)\n\n    def __repr__(self):\n        return \"%s(...)\" % self.__class__.__name__\n\n    __reduce__ = object.__reduce__\n", "src/dateutil/tz/tz.py": "# -*- coding: utf-8 -*-\n\"\"\"\nThis module offers timezone implementations subclassing the abstract\n:py:class:`datetime.tzinfo` type. There are classes to handle tzfile format\nfiles (usually are in :file:`/etc/localtime`, :file:`/usr/share/zoneinfo`,\netc), TZ environment string (in all known formats), given ranges (with help\nfrom relative deltas), local machine timezone, fixed offset timezone, and UTC\ntimezone.\n\"\"\"\nimport datetime\nimport struct\nimport time\nimport sys\nimport os\nimport bisect\nimport weakref\nfrom collections import OrderedDict\n\nimport six\nfrom six import string_types\nfrom six.moves import _thread\nfrom ._common import tzname_in_python2, _tzinfo\nfrom ._common import tzrangebase, enfold\nfrom ._common import _validate_fromutc_inputs\n\nfrom ._factories import _TzSingleton, _TzOffsetFactory\nfrom ._factories import _TzStrFactory\ntry:\n    from .win import tzwin, tzwinlocal\nexcept ImportError:\n    tzwin = tzwinlocal = None\n\n# For warning about rounding tzinfo\nfrom warnings import warn\n\nZERO = datetime.timedelta(0)\nEPOCH = datetime.datetime(1970, 1, 1, 0, 0)\nEPOCHORDINAL = EPOCH.toordinal()\n\n\n@six.add_metaclass(_TzSingleton)\nclass tzutc(datetime.tzinfo):\n    \"\"\"\n    This is a tzinfo object that represents the UTC time zone.\n\n    **Examples:**\n\n    .. doctest::\n\n        >>> from datetime import *\n        >>> from dateutil.tz import *\n\n        >>> datetime.now()\n        datetime.datetime(2003, 9, 27, 9, 40, 1, 521290)\n\n        >>> datetime.now(tzutc())\n        datetime.datetime(2003, 9, 27, 12, 40, 12, 156379, tzinfo=tzutc())\n\n        >>> datetime.now(tzutc()).tzname()\n        'UTC'\n\n    .. versionchanged:: 2.7.0\n        ``tzutc()`` is now a singleton, so the result of ``tzutc()`` will\n        always return the same object.\n\n        .. doctest::\n\n            >>> from dateutil.tz import tzutc, UTC\n            >>> tzutc() is tzutc()\n            True\n            >>> tzutc() is UTC\n            True\n    \"\"\"\n    def utcoffset(self, dt):\n        return ZERO\n\n    def dst(self, dt):\n        return ZERO\n\n    @tzname_in_python2\n    def tzname(self, dt):\n        return \"UTC\"\n\n    def is_ambiguous(self, dt):\n        \"\"\"\n        Whether or not the \"wall time\" of a given datetime is ambiguous in this\n        zone.\n\n        :param dt:\n            A :py:class:`datetime.datetime`, naive or time zone aware.\n\n\n        :return:\n            Returns ``True`` if ambiguous, ``False`` otherwise.\n\n        .. versionadded:: 2.6.0\n        \"\"\"\n        return False\n\n    @_validate_fromutc_inputs\n    def fromutc(self, dt):\n        \"\"\"\n        Fast track version of fromutc() returns the original ``dt`` object for\n        any valid :py:class:`datetime.datetime` object.\n        \"\"\"\n        return dt\n\n    def __eq__(self, other):\n        if not isinstance(other, (tzutc, tzoffset)):\n            return NotImplemented\n\n        return (isinstance(other, tzutc) or\n                (isinstance(other, tzoffset) and other._offset == ZERO))\n\n    __hash__ = None\n\n    def __ne__(self, other):\n        return not (self == other)\n\n    def __repr__(self):\n        return \"%s()\" % self.__class__.__name__\n\n    __reduce__ = object.__reduce__\n\n\n#: Convenience constant providing a :class:`tzutc()` instance\n#:\n#: .. versionadded:: 2.7.0\nUTC = tzutc()\n\n\n@six.add_metaclass(_TzOffsetFactory)\nclass tzoffset(datetime.tzinfo):\n    \"\"\"\n    A simple class for representing a fixed offset from UTC.\n\n    :param name:\n        The timezone name, to be returned when ``tzname()`` is called.\n    :param offset:\n        The time zone offset in seconds, or (since version 2.6.0, represented\n        as a :py:class:`datetime.timedelta` object).\n    \"\"\"\n    def __init__(self, name, offset):\n        self._name = name\n\n        try:\n            # Allow a timedelta\n            offset = offset.total_seconds()\n        except (TypeError, AttributeError):\n            pass\n\n        self._offset = datetime.timedelta(seconds=_get_supported_offset(offset))\n\n    def utcoffset(self, dt):\n        return self._offset\n\n    def dst(self, dt):\n        return ZERO\n\n    @tzname_in_python2\n    def tzname(self, dt):\n        return self._name\n\n    @_validate_fromutc_inputs\n    def fromutc(self, dt):\n        return dt + self._offset\n\n    def is_ambiguous(self, dt):\n        \"\"\"\n        Whether or not the \"wall time\" of a given datetime is ambiguous in this\n        zone.\n\n        :param dt:\n            A :py:class:`datetime.datetime`, naive or time zone aware.\n        :return:\n            Returns ``True`` if ambiguous, ``False`` otherwise.\n\n        .. versionadded:: 2.6.0\n        \"\"\"\n        return False\n\n    def __eq__(self, other):\n        if not isinstance(other, tzoffset):\n            return NotImplemented\n\n        return self._offset == other._offset\n\n    __hash__ = None\n\n    def __ne__(self, other):\n        return not (self == other)\n\n    def __repr__(self):\n        return \"%s(%s, %s)\" % (self.__class__.__name__,\n                               repr(self._name),\n                               int(self._offset.total_seconds()))\n\n    __reduce__ = object.__reduce__\n\n\nclass tzlocal(_tzinfo):\n    \"\"\"\n    A :class:`tzinfo` subclass built around the ``time`` timezone functions.\n    \"\"\"\n    def __init__(self):\n        super(tzlocal, self).__init__()\n\n        self._std_offset = datetime.timedelta(seconds=-time.timezone)\n        if time.daylight:\n            self._dst_offset = datetime.timedelta(seconds=-time.altzone)\n        else:\n            self._dst_offset = self._std_offset\n\n        self._dst_saved = self._dst_offset - self._std_offset\n        self._hasdst = bool(self._dst_saved)\n        self._tznames = tuple(time.tzname)\n\n    def utcoffset(self, dt):\n        if dt is None and self._hasdst:\n            return None\n\n        if self._isdst(dt):\n            return self._dst_offset\n        else:\n            return self._std_offset\n\n    def dst(self, dt):\n        if dt is None and self._hasdst:\n            return None\n\n        if self._isdst(dt):\n            return self._dst_offset - self._std_offset\n        else:\n            return ZERO\n\n    @tzname_in_python2\n    def tzname(self, dt):\n        return self._tznames[self._isdst(dt)]\n\n    def is_ambiguous(self, dt):\n        \"\"\"\n        Whether or not the \"wall time\" of a given datetime is ambiguous in this\n        zone.\n\n        :param dt:\n            A :py:class:`datetime.datetime`, naive or time zone aware.\n\n\n        :return:\n            Returns ``True`` if ambiguous, ``False`` otherwise.\n\n        .. versionadded:: 2.6.0\n        \"\"\"\n        naive_dst = self._naive_is_dst(dt)\n        return (not naive_dst and\n                (naive_dst != self._naive_is_dst(dt - self._dst_saved)))\n\n    def _naive_is_dst(self, dt):\n        timestamp = _datetime_to_timestamp(dt)\n        return time.localtime(timestamp + time.timezone).tm_isdst\n\n    def _isdst(self, dt, fold_naive=True):\n        # We can't use mktime here. It is unstable when deciding if\n        # the hour near to a change is DST or not.\n        #\n        # timestamp = time.mktime((dt.year, dt.month, dt.day, dt.hour,\n        #                         dt.minute, dt.second, dt.weekday(), 0, -1))\n        # return time.localtime(timestamp).tm_isdst\n        #\n        # The code above yields the following result:\n        #\n        # >>> import tz, datetime\n        # >>> t = tz.tzlocal()\n        # >>> datetime.datetime(2003,2,15,23,tzinfo=t).tzname()\n        # 'BRDT'\n        # >>> datetime.datetime(2003,2,16,0,tzinfo=t).tzname()\n        # 'BRST'\n        # >>> datetime.datetime(2003,2,15,23,tzinfo=t).tzname()\n        # 'BRST'\n        # >>> datetime.datetime(2003,2,15,22,tzinfo=t).tzname()\n        # 'BRDT'\n        # >>> datetime.datetime(2003,2,15,23,tzinfo=t).tzname()\n        # 'BRDT'\n        #\n        # Here is a more stable implementation:\n        #\n        if not self._hasdst:\n            return False\n\n        # Check for ambiguous times:\n        dstval = self._naive_is_dst(dt)\n        fold = getattr(dt, 'fold', None)\n\n        if self.is_ambiguous(dt):\n            if fold is not None:\n                return not self._fold(dt)\n            else:\n                return True\n\n        return dstval\n\n    def __eq__(self, other):\n        if isinstance(other, tzlocal):\n            return (self._std_offset == other._std_offset and\n                    self._dst_offset == other._dst_offset)\n        elif isinstance(other, tzutc):\n            return (not self._hasdst and\n                    self._tznames[0] in {'UTC', 'GMT'} and\n                    self._std_offset == ZERO)\n        elif isinstance(other, tzoffset):\n            return (not self._hasdst and\n                    self._tznames[0] == other._name and\n                    self._std_offset == other._offset)\n        else:\n            return NotImplemented\n\n    __hash__ = None\n\n    def __ne__(self, other):\n        return not (self == other)\n\n    def __repr__(self):\n        return \"%s()\" % self.__class__.__name__\n\n    __reduce__ = object.__reduce__\n\n\nclass _ttinfo(object):\n    __slots__ = [\"offset\", \"delta\", \"isdst\", \"abbr\",\n                 \"isstd\", \"isgmt\", \"dstoffset\"]\n\n    def __init__(self):\n        for attr in self.__slots__:\n            setattr(self, attr, None)\n\n    def __repr__(self):\n        l = []\n        for attr in self.__slots__:\n            value = getattr(self, attr)\n            if value is not None:\n                l.append(\"%s=%s\" % (attr, repr(value)))\n        return \"%s(%s)\" % (self.__class__.__name__, \", \".join(l))\n\n    def __eq__(self, other):\n        if not isinstance(other, _ttinfo):\n            return NotImplemented\n\n        return (self.offset == other.offset and\n                self.delta == other.delta and\n                self.isdst == other.isdst and\n                self.abbr == other.abbr and\n                self.isstd == other.isstd and\n                self.isgmt == other.isgmt and\n                self.dstoffset == other.dstoffset)\n\n    __hash__ = None\n\n    def __ne__(self, other):\n        return not (self == other)\n\n    def __getstate__(self):\n        state = {}\n        for name in self.__slots__:\n            state[name] = getattr(self, name, None)\n        return state\n\n    def __setstate__(self, state):\n        for name in self.__slots__:\n            if name in state:\n                setattr(self, name, state[name])\n\n\nclass _tzfile(object):\n    \"\"\"\n    Lightweight class for holding the relevant transition and time zone\n    information read from binary tzfiles.\n    \"\"\"\n    attrs = ['trans_list', 'trans_list_utc', 'trans_idx', 'ttinfo_list',\n             'ttinfo_std', 'ttinfo_dst', 'ttinfo_before', 'ttinfo_first']\n\n    def __init__(self, **kwargs):\n        for attr in self.attrs:\n            setattr(self, attr, kwargs.get(attr, None))\n\n\nclass tzfile(_tzinfo):\n    \"\"\"\n    This is a ``tzinfo`` subclass that allows one to use the ``tzfile(5)``\n    format timezone files to extract current and historical zone information.\n\n    :param fileobj:\n        This can be an opened file stream or a file name that the time zone\n        information can be read from.\n\n    :param filename:\n        This is an optional parameter specifying the source of the time zone\n        information in the event that ``fileobj`` is a file object. If omitted\n        and ``fileobj`` is a file stream, this parameter will be set either to\n        ``fileobj``'s ``name`` attribute or to ``repr(fileobj)``.\n\n    See `Sources for Time Zone and Daylight Saving Time Data\n    <https://data.iana.org/time-zones/tz-link.html>`_ for more information.\n    Time zone files can be compiled from the `IANA Time Zone database files\n    <https://www.iana.org/time-zones>`_ with the `zic time zone compiler\n    <https://www.freebsd.org/cgi/man.cgi?query=zic&sektion=8>`_\n\n    .. note::\n\n        Only construct a ``tzfile`` directly if you have a specific timezone\n        file on disk that you want to read into a Python ``tzinfo`` object.\n        If you want to get a ``tzfile`` representing a specific IANA zone,\n        (e.g. ``'America/New_York'``), you should call\n        :func:`dateutil.tz.gettz` with the zone identifier.\n\n\n    **Examples:**\n\n    Using the US Eastern time zone as an example, we can see that a ``tzfile``\n    provides time zone information for the standard Daylight Saving offsets:\n\n    .. testsetup:: tzfile\n\n        from dateutil.tz import gettz\n        from datetime import datetime\n\n    .. doctest:: tzfile\n\n        >>> NYC = gettz('America/New_York')\n        >>> NYC\n        tzfile('/usr/share/zoneinfo/America/New_York')\n\n        >>> print(datetime(2016, 1, 3, tzinfo=NYC))     # EST\n        2016-01-03 00:00:00-05:00\n\n        >>> print(datetime(2016, 7, 7, tzinfo=NYC))     # EDT\n        2016-07-07 00:00:00-04:00\n\n\n    The ``tzfile`` structure contains a fully history of the time zone,\n    so historical dates will also have the right offsets. For example, before\n    the adoption of the UTC standards, New York used local solar  mean time:\n\n    .. doctest:: tzfile\n\n       >>> print(datetime(1901, 4, 12, tzinfo=NYC))    # LMT\n       1901-04-12 00:00:00-04:56\n\n    And during World War II, New York was on \"Eastern War Time\", which was a\n    state of permanent daylight saving time:\n\n    .. doctest:: tzfile\n\n        >>> print(datetime(1944, 2, 7, tzinfo=NYC))    # EWT\n        1944-02-07 00:00:00-04:00\n\n    \"\"\"\n\n    def __init__(self, fileobj, filename=None):\n        super(tzfile, self).__init__()\n\n        file_opened_here = False\n        if isinstance(fileobj, string_types):\n            self._filename = fileobj\n            fileobj = open(fileobj, 'rb')\n            file_opened_here = True\n        elif filename is not None:\n            self._filename = filename\n        elif hasattr(fileobj, \"name\"):\n            self._filename = fileobj.name\n        else:\n            self._filename = repr(fileobj)\n\n        if fileobj is not None:\n            if not file_opened_here:\n                fileobj = _nullcontext(fileobj)\n\n            with fileobj as file_stream:\n                tzobj = self._read_tzfile(file_stream)\n\n            self._set_tzdata(tzobj)\n\n    def _set_tzdata(self, tzobj):\n        \"\"\" Set the time zone data of this object from a _tzfile object \"\"\"\n        # Copy the relevant attributes over as private attributes\n        for attr in _tzfile.attrs:\n            setattr(self, '_' + attr, getattr(tzobj, attr))\n\n    def _read_tzfile(self, fileobj):\n        out = _tzfile()\n\n        # From tzfile(5):\n        #\n        # The time zone information files used by tzset(3)\n        # begin with the magic characters \"TZif\" to identify\n        # them as time zone information files, followed by\n        # sixteen bytes reserved for future use, followed by\n        # six four-byte values of type long, written in a\n        # ``standard'' byte order (the high-order  byte\n        # of the value is written first).\n        if fileobj.read(4).decode() != \"TZif\":\n            raise ValueError(\"magic not found\")\n\n        fileobj.read(16)\n\n        (\n            # The number of UTC/local indicators stored in the file.\n            ttisgmtcnt,\n\n            # The number of standard/wall indicators stored in the file.\n            ttisstdcnt,\n\n            # The number of leap seconds for which data is\n            # stored in the file.\n            leapcnt,\n\n            # The number of \"transition times\" for which data\n            # is stored in the file.\n            timecnt,\n\n            # The number of \"local time types\" for which data\n            # is stored in the file (must not be zero).\n            typecnt,\n\n            # The  number  of  characters  of \"time zone\n            # abbreviation strings\" stored in the file.\n            charcnt,\n\n        ) = struct.unpack(\">6l\", fileobj.read(24))\n\n        # The above header is followed by tzh_timecnt four-byte\n        # values  of  type long,  sorted  in ascending order.\n        # These values are written in ``standard'' byte order.\n        # Each is used as a transition time (as  returned  by\n        # time(2)) at which the rules for computing local time\n        # change.\n\n        if timecnt:\n            out.trans_list_utc = list(struct.unpack(\">%dl\" % timecnt,\n                                                    fileobj.read(timecnt*4)))\n        else:\n            out.trans_list_utc = []\n\n        # Next come tzh_timecnt one-byte values of type unsigned\n        # char; each one tells which of the different types of\n        # ``local time'' types described in the file is associated\n        # with the same-indexed transition time. These values\n        # serve as indices into an array of ttinfo structures that\n        # appears next in the file.\n\n        if timecnt:\n            out.trans_idx = struct.unpack(\">%dB\" % timecnt,\n                                          fileobj.read(timecnt))\n        else:\n            out.trans_idx = []\n\n        # Each ttinfo structure is written as a four-byte value\n        # for tt_gmtoff  of  type long,  in  a  standard  byte\n        # order, followed  by a one-byte value for tt_isdst\n        # and a one-byte  value  for  tt_abbrind.   In  each\n        # structure, tt_gmtoff  gives  the  number  of\n        # seconds to be added to UTC, tt_isdst tells whether\n        # tm_isdst should be set by  localtime(3),  and\n        # tt_abbrind serves  as an index into the array of\n        # time zone abbreviation characters that follow the\n        # ttinfo structure(s) in the file.\n\n        ttinfo = []\n\n        for i in range(typecnt):\n            ttinfo.append(struct.unpack(\">lbb\", fileobj.read(6)))\n\n        abbr = fileobj.read(charcnt).decode()\n\n        # Then there are tzh_leapcnt pairs of four-byte\n        # values, written in  standard byte  order;  the\n        # first  value  of  each pair gives the time (as\n        # returned by time(2)) at which a leap second\n        # occurs;  the  second  gives the  total  number of\n        # leap seconds to be applied after the given time.\n        # The pairs of values are sorted in ascending order\n        # by time.\n\n        # Not used, for now (but seek for correct file position)\n        if leapcnt:\n            fileobj.seek(leapcnt * 8, os.SEEK_CUR)\n\n        # Then there are tzh_ttisstdcnt standard/wall\n        # indicators, each stored as a one-byte value;\n        # they tell whether the transition times associated\n        # with local time types were specified as standard\n        # time or wall clock time, and are used when\n        # a time zone file is used in handling POSIX-style\n        # time zone environment variables.\n\n        if ttisstdcnt:\n            isstd = struct.unpack(\">%db\" % ttisstdcnt,\n                                  fileobj.read(ttisstdcnt))\n\n        # Finally, there are tzh_ttisgmtcnt UTC/local\n        # indicators, each stored as a one-byte value;\n        # they tell whether the transition times associated\n        # with local time types were specified as UTC or\n        # local time, and are used when a time zone file\n        # is used in handling POSIX-style time zone envi-\n        # ronment variables.\n\n        if ttisgmtcnt:\n            isgmt = struct.unpack(\">%db\" % ttisgmtcnt,\n                                  fileobj.read(ttisgmtcnt))\n\n        # Build ttinfo list\n        out.ttinfo_list = []\n        for i in range(typecnt):\n            gmtoff, isdst, abbrind = ttinfo[i]\n            gmtoff = _get_supported_offset(gmtoff)\n            tti = _ttinfo()\n            tti.offset = gmtoff\n            tti.dstoffset = datetime.timedelta(0)\n            tti.delta = datetime.timedelta(seconds=gmtoff)\n            tti.isdst = isdst\n            tti.abbr = abbr[abbrind:abbr.find('\\x00', abbrind)]\n            tti.isstd = (ttisstdcnt > i and isstd[i] != 0)\n            tti.isgmt = (ttisgmtcnt > i and isgmt[i] != 0)\n            out.ttinfo_list.append(tti)\n\n        # Replace ttinfo indexes for ttinfo objects.\n        out.trans_idx = [out.ttinfo_list[idx] for idx in out.trans_idx]\n\n        # Set standard, dst, and before ttinfos. before will be\n        # used when a given time is before any transitions,\n        # and will be set to the first non-dst ttinfo, or to\n        # the first dst, if all of them are dst.\n        out.ttinfo_std = None\n        out.ttinfo_dst = None\n        out.ttinfo_before = None\n        if out.ttinfo_list:\n            if not out.trans_list_utc:\n                out.ttinfo_std = out.ttinfo_first = out.ttinfo_list[0]\n            else:\n                for i in range(timecnt-1, -1, -1):\n                    tti = out.trans_idx[i]\n                    if not out.ttinfo_std and not tti.isdst:\n                        out.ttinfo_std = tti\n                    elif not out.ttinfo_dst and tti.isdst:\n                        out.ttinfo_dst = tti\n\n                    if out.ttinfo_std and out.ttinfo_dst:\n                        break\n                else:\n                    if out.ttinfo_dst and not out.ttinfo_std:\n                        out.ttinfo_std = out.ttinfo_dst\n\n                for tti in out.ttinfo_list:\n                    if not tti.isdst:\n                        out.ttinfo_before = tti\n                        break\n                else:\n                    out.ttinfo_before = out.ttinfo_list[0]\n\n        # Now fix transition times to become relative to wall time.\n        #\n        # I'm not sure about this. In my tests, the tz source file\n        # is setup to wall time, and in the binary file isstd and\n        # isgmt are off, so it should be in wall time. OTOH, it's\n        # always in gmt time. Let me know if you have comments\n        # about this.\n        lastdst = None\n        lastoffset = None\n        lastdstoffset = None\n        lastbaseoffset = None\n        out.trans_list = []\n\n        for i, tti in enumerate(out.trans_idx):\n            offset = tti.offset\n            dstoffset = 0\n\n            if lastdst is not None:\n                if tti.isdst:\n                    if not lastdst:\n                        dstoffset = offset - lastoffset\n\n                    if not dstoffset and lastdstoffset:\n                        dstoffset = lastdstoffset\n\n                    tti.dstoffset = datetime.timedelta(seconds=dstoffset)\n                    lastdstoffset = dstoffset\n\n            # If a time zone changes its base offset during a DST transition,\n            # then you need to adjust by the previous base offset to get the\n            # transition time in local time. Otherwise you use the current\n            # base offset. Ideally, I would have some mathematical proof of\n            # why this is true, but I haven't really thought about it enough.\n            baseoffset = offset - dstoffset\n            adjustment = baseoffset\n            if (lastbaseoffset is not None and baseoffset != lastbaseoffset\n                    and tti.isdst != lastdst):\n                # The base DST has changed\n                adjustment = lastbaseoffset\n\n            lastdst = tti.isdst\n            lastoffset = offset\n            lastbaseoffset = baseoffset\n\n            out.trans_list.append(out.trans_list_utc[i] + adjustment)\n\n        out.trans_idx = tuple(out.trans_idx)\n        out.trans_list = tuple(out.trans_list)\n        out.trans_list_utc = tuple(out.trans_list_utc)\n\n        return out\n\n    def _find_last_transition(self, dt, in_utc=False):\n        # If there's no list, there are no transitions to find\n        if not self._trans_list:\n            return None\n\n        timestamp = _datetime_to_timestamp(dt)\n\n        # Find where the timestamp fits in the transition list - if the\n        # timestamp is a transition time, it's part of the \"after\" period.\n        trans_list = self._trans_list_utc if in_utc else self._trans_list\n        idx = bisect.bisect_right(trans_list, timestamp)\n\n        # We want to know when the previous transition was, so subtract off 1\n        return idx - 1\n\n    def _get_ttinfo(self, idx):\n        # For no list or after the last transition, default to _ttinfo_std\n        if idx is None or (idx + 1) >= len(self._trans_list):\n            return self._ttinfo_std\n\n        # If there is a list and the time is before it, return _ttinfo_before\n        if idx < 0:\n            return self._ttinfo_before\n\n        return self._trans_idx[idx]\n\n    def _find_ttinfo(self, dt):\n        idx = self._resolve_ambiguous_time(dt)\n\n        return self._get_ttinfo(idx)\n\n    def fromutc(self, dt):\n        \"\"\"\n        The ``tzfile`` implementation of :py:func:`datetime.tzinfo.fromutc`.\n\n        :param dt:\n            A :py:class:`datetime.datetime` object.\n\n        :raises TypeError:\n            Raised if ``dt`` is not a :py:class:`datetime.datetime` object.\n\n        :raises ValueError:\n            Raised if this is called with a ``dt`` which does not have this\n            ``tzinfo`` attached.\n\n        :return:\n            Returns a :py:class:`datetime.datetime` object representing the\n            wall time in ``self``'s time zone.\n        \"\"\"\n        # These isinstance checks are in datetime.tzinfo, so we'll preserve\n        # them, even if we don't care about duck typing.\n        if not isinstance(dt, datetime.datetime):\n            raise TypeError(\"fromutc() requires a datetime argument\")\n\n        if dt.tzinfo is not self:\n            raise ValueError(\"dt.tzinfo is not self\")\n\n        # First treat UTC as wall time and get the transition we're in.\n        idx = self._find_last_transition(dt, in_utc=True)\n        tti = self._get_ttinfo(idx)\n\n        dt_out = dt + datetime.timedelta(seconds=tti.offset)\n\n        fold = self.is_ambiguous(dt_out, idx=idx)\n\n        return enfold(dt_out, fold=int(fold))\n\n    def is_ambiguous(self, dt, idx=None):\n        \"\"\"\n        Whether or not the \"wall time\" of a given datetime is ambiguous in this\n        zone.\n\n        :param dt:\n            A :py:class:`datetime.datetime`, naive or time zone aware.\n\n\n        :return:\n            Returns ``True`` if ambiguous, ``False`` otherwise.\n\n        .. versionadded:: 2.6.0\n        \"\"\"\n        if idx is None:\n            idx = self._find_last_transition(dt)\n\n        # Calculate the difference in offsets from current to previous\n        timestamp = _datetime_to_timestamp(dt)\n        tti = self._get_ttinfo(idx)\n\n        if idx is None or idx <= 0:\n            return False\n\n        od = self._get_ttinfo(idx - 1).offset - tti.offset\n        tt = self._trans_list[idx]          # Transition time\n\n        return timestamp < tt + od\n\n    def _resolve_ambiguous_time(self, dt):\n        idx = self._find_last_transition(dt)\n\n        # If we have no transitions, return the index\n        _fold = self._fold(dt)\n        if idx is None or idx == 0:\n            return idx\n\n        # If it's ambiguous and we're in a fold, shift to a different index.\n        idx_offset = int(not _fold and self.is_ambiguous(dt, idx))\n\n        return idx - idx_offset\n\n    def utcoffset(self, dt):\n        if dt is None:\n            return None\n\n        if not self._ttinfo_std:\n            return ZERO\n\n        return self._find_ttinfo(dt).delta\n\n    def dst(self, dt):\n        if dt is None:\n            return None\n\n        if not self._ttinfo_dst:\n            return ZERO\n\n        tti = self._find_ttinfo(dt)\n\n        if not tti.isdst:\n            return ZERO\n\n        # The documentation says that utcoffset()-dst() must\n        # be constant for every dt.\n        return tti.dstoffset\n\n    @tzname_in_python2\n    def tzname(self, dt):\n        if not self._ttinfo_std or dt is None:\n            return None\n        return self._find_ttinfo(dt).abbr\n\n    def __eq__(self, other):\n        if not isinstance(other, tzfile):\n            return NotImplemented\n        return (self._trans_list == other._trans_list and\n                self._trans_idx == other._trans_idx and\n                self._ttinfo_list == other._ttinfo_list)\n\n    __hash__ = None\n\n    def __ne__(self, other):\n        return not (self == other)\n\n    def __repr__(self):\n        return \"%s(%s)\" % (self.__class__.__name__, repr(self._filename))\n\n    def __reduce__(self):\n        return self.__reduce_ex__(None)\n\n    def __reduce_ex__(self, protocol):\n        return (self.__class__, (None, self._filename), self.__dict__)\n\n\nclass tzrange(tzrangebase):\n    \"\"\"\n    The ``tzrange`` object is a time zone specified by a set of offsets and\n    abbreviations, equivalent to the way the ``TZ`` variable can be specified\n    in POSIX-like systems, but using Python delta objects to specify DST\n    start, end and offsets.\n\n    :param stdabbr:\n        The abbreviation for standard time (e.g. ``'EST'``).\n\n    :param stdoffset:\n        An integer or :class:`datetime.timedelta` object or equivalent\n        specifying the base offset from UTC.\n\n        If unspecified, +00:00 is used.\n\n    :param dstabbr:\n        The abbreviation for DST / \"Summer\" time (e.g. ``'EDT'``).\n\n        If specified, with no other DST information, DST is assumed to occur\n        and the default behavior or ``dstoffset``, ``start`` and ``end`` is\n        used. If unspecified and no other DST information is specified, it\n        is assumed that this zone has no DST.\n\n        If this is unspecified and other DST information is *is* specified,\n        DST occurs in the zone but the time zone abbreviation is left\n        unchanged.\n\n    :param dstoffset:\n        A an integer or :class:`datetime.timedelta` object or equivalent\n        specifying the UTC offset during DST. If unspecified and any other DST\n        information is specified, it is assumed to be the STD offset +1 hour.\n\n    :param start:\n        A :class:`relativedelta.relativedelta` object or equivalent specifying\n        the time and time of year that daylight savings time starts. To\n        specify, for example, that DST starts at 2AM on the 2nd Sunday in\n        March, pass:\n\n            ``relativedelta(hours=2, month=3, day=1, weekday=SU(+2))``\n\n        If unspecified and any other DST information is specified, the default\n        value is 2 AM on the first Sunday in April.\n\n    :param end:\n        A :class:`relativedelta.relativedelta` object or equivalent\n        representing the time and time of year that daylight savings time\n        ends, with the same specification method as in ``start``. One note is\n        that this should point to the first time in the *standard* zone, so if\n        a transition occurs at 2AM in the DST zone and the clocks are set back\n        1 hour to 1AM, set the ``hours`` parameter to +1.\n\n\n    **Examples:**\n\n    .. testsetup:: tzrange\n\n        from dateutil.tz import tzrange, tzstr\n\n    .. doctest:: tzrange\n\n        >>> tzstr('EST5EDT') == tzrange(\"EST\", -18000, \"EDT\")\n        True\n\n        >>> from dateutil.relativedelta import *\n        >>> range1 = tzrange(\"EST\", -18000, \"EDT\")\n        >>> range2 = tzrange(\"EST\", -18000, \"EDT\", -14400,\n        ...                  relativedelta(hours=+2, month=4, day=1,\n        ...                                weekday=SU(+1)),\n        ...                  relativedelta(hours=+1, month=10, day=31,\n        ...                                weekday=SU(-1)))\n        >>> tzstr('EST5EDT') == range1 == range2\n        True\n\n    \"\"\"\n    def __init__(self, stdabbr, stdoffset=None,\n                 dstabbr=None, dstoffset=None,\n                 start=None, end=None):\n\n        global relativedelta\n        from dateutil import relativedelta\n\n        self._std_abbr = stdabbr\n        self._dst_abbr = dstabbr\n\n        try:\n            stdoffset = stdoffset.total_seconds()\n        except (TypeError, AttributeError):\n            pass\n\n        try:\n            dstoffset = dstoffset.total_seconds()\n        except (TypeError, AttributeError):\n            pass\n\n        if stdoffset is not None:\n            self._std_offset = datetime.timedelta(seconds=stdoffset)\n        else:\n            self._std_offset = ZERO\n\n        if dstoffset is not None:\n            self._dst_offset = datetime.timedelta(seconds=dstoffset)\n        elif dstabbr and stdoffset is not None:\n            self._dst_offset = self._std_offset + datetime.timedelta(hours=+1)\n        else:\n            self._dst_offset = ZERO\n\n        if dstabbr and start is None:\n            self._start_delta = relativedelta.relativedelta(\n                hours=+2, month=4, day=1, weekday=relativedelta.SU(+1))\n        else:\n            self._start_delta = start\n\n        if dstabbr and end is None:\n            self._end_delta = relativedelta.relativedelta(\n                hours=+1, month=10, day=31, weekday=relativedelta.SU(-1))\n        else:\n            self._end_delta = end\n\n        self._dst_base_offset_ = self._dst_offset - self._std_offset\n        self.hasdst = bool(self._start_delta)\n\n    def transitions(self, year):\n        \"\"\"\n        For a given year, get the DST on and off transition times, expressed\n        always on the standard time side. For zones with no transitions, this\n        function returns ``None``.\n\n        :param year:\n            The year whose transitions you would like to query.\n\n        :return:\n            Returns a :class:`tuple` of :class:`datetime.datetime` objects,\n            ``(dston, dstoff)`` for zones with an annual DST transition, or\n            ``None`` for fixed offset zones.\n        \"\"\"\n        if not self.hasdst:\n            return None\n\n        base_year = datetime.datetime(year, 1, 1)\n\n        start = base_year + self._start_delta\n        end = base_year + self._end_delta\n\n        return (start, end)\n\n    def __eq__(self, other):\n        if not isinstance(other, tzrange):\n            return NotImplemented\n\n        return (self._std_abbr == other._std_abbr and\n                self._dst_abbr == other._dst_abbr and\n                self._std_offset == other._std_offset and\n                self._dst_offset == other._dst_offset and\n                self._start_delta == other._start_delta and\n                self._end_delta == other._end_delta)\n\n    @property\n    def _dst_base_offset(self):\n        return self._dst_base_offset_\n\n\n@six.add_metaclass(_TzStrFactory)\nclass tzstr(tzrange):\n    \"\"\"\n    ``tzstr`` objects are time zone objects specified by a time-zone string as\n    it would be passed to a ``TZ`` variable on POSIX-style systems (see\n    the `GNU C Library: TZ Variable`_ for more details).\n\n    There is one notable exception, which is that POSIX-style time zones use an\n    inverted offset format, so normally ``GMT+3`` would be parsed as an offset\n    3 hours *behind* GMT. The ``tzstr`` time zone object will parse this as an\n    offset 3 hours *ahead* of GMT. If you would like to maintain the POSIX\n    behavior, pass a ``True`` value to ``posix_offset``.\n\n    The :class:`tzrange` object provides the same functionality, but is\n    specified using :class:`relativedelta.relativedelta` objects. rather than\n    strings.\n\n    :param s:\n        A time zone string in ``TZ`` variable format. This can be a\n        :class:`bytes` (2.x: :class:`str`), :class:`str` (2.x:\n        :class:`unicode`) or a stream emitting unicode characters\n        (e.g. :class:`StringIO`).\n\n    :param posix_offset:\n        Optional. If set to ``True``, interpret strings such as ``GMT+3`` or\n        ``UTC+3`` as being 3 hours *behind* UTC rather than ahead, per the\n        POSIX standard.\n\n    .. caution::\n\n        Prior to version 2.7.0, this function also supported time zones\n        in the format:\n\n            * ``EST5EDT,4,0,6,7200,10,0,26,7200,3600``\n            * ``EST5EDT,4,1,0,7200,10,-1,0,7200,3600``\n\n        This format is non-standard and has been deprecated; this function\n        will raise a :class:`DeprecatedTZFormatWarning` until\n        support is removed in a future version.\n\n    .. _`GNU C Library: TZ Variable`:\n        https://www.gnu.org/software/libc/manual/html_node/TZ-Variable.html\n    \"\"\"\n    def __init__(self, s, posix_offset=False):\n        global parser\n        from dateutil.parser import _parser as parser\n\n        self._s = s\n\n        res = parser._parsetz(s)\n        if res is None or res.any_unused_tokens:\n            raise ValueError(\"unknown string format\")\n\n        # Here we break the compatibility with the TZ variable handling.\n        # GMT-3 actually *means* the timezone -3.\n        if res.stdabbr in (\"GMT\", \"UTC\") and not posix_offset:\n            res.stdoffset *= -1\n\n        # We must initialize it first, since _delta() needs\n        # _std_offset and _dst_offset set. Use False in start/end\n        # to avoid building it two times.\n        tzrange.__init__(self, res.stdabbr, res.stdoffset,\n                         res.dstabbr, res.dstoffset,\n                         start=False, end=False)\n\n        if not res.dstabbr:\n            self._start_delta = None\n            self._end_delta = None\n        else:\n            self._start_delta = self._delta(res.start)\n            if self._start_delta:\n                self._end_delta = self._delta(res.end, isend=1)\n\n        self.hasdst = bool(self._start_delta)\n\n    def _delta(self, x, isend=0):\n        from dateutil import relativedelta\n        kwargs = {}\n        if x.month is not None:\n            kwargs[\"month\"] = x.month\n            if x.weekday is not None:\n                kwargs[\"weekday\"] = relativedelta.weekday(x.weekday, x.week)\n                if x.week > 0:\n                    kwargs[\"day\"] = 1\n                else:\n                    kwargs[\"day\"] = 31\n            elif x.day:\n                kwargs[\"day\"] = x.day\n        elif x.yday is not None:\n            kwargs[\"yearday\"] = x.yday\n        elif x.jyday is not None:\n            kwargs[\"nlyearday\"] = x.jyday\n        if not kwargs:\n            # Default is to start on first sunday of april, and end\n            # on last sunday of october.\n            if not isend:\n                kwargs[\"month\"] = 4\n                kwargs[\"day\"] = 1\n                kwargs[\"weekday\"] = relativedelta.SU(+1)\n            else:\n                kwargs[\"month\"] = 10\n                kwargs[\"day\"] = 31\n                kwargs[\"weekday\"] = relativedelta.SU(-1)\n        if x.time is not None:\n            kwargs[\"seconds\"] = x.time\n        else:\n            # Default is 2AM.\n            kwargs[\"seconds\"] = 7200\n        if isend:\n            # Convert to standard time, to follow the documented way\n            # of working with the extra hour. See the documentation\n            # of the tzinfo class.\n            delta = self._dst_offset - self._std_offset\n            kwargs[\"seconds\"] -= delta.seconds + delta.days * 86400\n        return relativedelta.relativedelta(**kwargs)\n\n    def __repr__(self):\n        return \"%s(%s)\" % (self.__class__.__name__, repr(self._s))\n\n\nclass _tzicalvtzcomp(object):\n    def __init__(self, tzoffsetfrom, tzoffsetto, isdst,\n                 tzname=None, rrule=None):\n        self.tzoffsetfrom = datetime.timedelta(seconds=tzoffsetfrom)\n        self.tzoffsetto = datetime.timedelta(seconds=tzoffsetto)\n        self.tzoffsetdiff = self.tzoffsetto - self.tzoffsetfrom\n        self.isdst = isdst\n        self.tzname = tzname\n        self.rrule = rrule\n\n\nclass _tzicalvtz(_tzinfo):\n    def __init__(self, tzid, comps=[]):\n        super(_tzicalvtz, self).__init__()\n\n        self._tzid = tzid\n        self._comps = comps\n        self._cachedate = []\n        self._cachecomp = []\n        self._cache_lock = _thread.allocate_lock()\n\n    def _find_comp(self, dt):\n        if len(self._comps) == 1:\n            return self._comps[0]\n\n        dt = dt.replace(tzinfo=None)\n\n        try:\n            with self._cache_lock:\n                return self._cachecomp[self._cachedate.index(\n                    (dt, self._fold(dt)))]\n        except ValueError:\n            pass\n\n        lastcompdt = None\n        lastcomp = None\n\n        for comp in self._comps:\n            compdt = self._find_compdt(comp, dt)\n\n            if compdt and (not lastcompdt or lastcompdt < compdt):\n                lastcompdt = compdt\n                lastcomp = comp\n\n        if not lastcomp:\n            # RFC says nothing about what to do when a given\n            # time is before the first onset date. We'll look for the\n            # first standard component, or the first component, if\n            # none is found.\n            for comp in self._comps:\n                if not comp.isdst:\n                    lastcomp = comp\n                    break\n            else:\n                lastcomp = comp[0]\n\n        with self._cache_lock:\n            self._cachedate.insert(0, (dt, self._fold(dt)))\n            self._cachecomp.insert(0, lastcomp)\n\n            if len(self._cachedate) > 10:\n                self._cachedate.pop()\n                self._cachecomp.pop()\n\n        return lastcomp\n\n    def _find_compdt(self, comp, dt):\n        if comp.tzoffsetdiff < ZERO and self._fold(dt):\n            dt -= comp.tzoffsetdiff\n\n        compdt = comp.rrule.before(dt, inc=True)\n\n        return compdt\n\n    def utcoffset(self, dt):\n        if dt is None:\n            return None\n\n        return self._find_comp(dt).tzoffsetto\n\n    def dst(self, dt):\n        comp = self._find_comp(dt)\n        if comp.isdst:\n            return comp.tzoffsetdiff\n        else:\n            return ZERO\n\n    @tzname_in_python2\n    def tzname(self, dt):\n        return self._find_comp(dt).tzname\n\n    def __repr__(self):\n        return \"<tzicalvtz %s>\" % repr(self._tzid)\n\n    __reduce__ = object.__reduce__\n\n\nclass tzical(object):\n    \"\"\"\n    This object is designed to parse an iCalendar-style ``VTIMEZONE`` structure\n    as set out in `RFC 5545`_ Section 4.6.5 into one or more `tzinfo` objects.\n\n    :param `fileobj`:\n        A file or stream in iCalendar format, which should be UTF-8 encoded\n        with CRLF endings.\n\n    .. _`RFC 5545`: https://tools.ietf.org/html/rfc5545\n    \"\"\"\n    def __init__(self, fileobj):\n        global rrule\n        from dateutil import rrule\n\n        if isinstance(fileobj, string_types):\n            self._s = fileobj\n            # ical should be encoded in UTF-8 with CRLF\n            fileobj = open(fileobj, 'r')\n        else:\n            self._s = getattr(fileobj, 'name', repr(fileobj))\n            fileobj = _nullcontext(fileobj)\n\n        self._vtz = {}\n\n        with fileobj as fobj:\n            self._parse_rfc(fobj.read())\n\n    def keys(self):\n        \"\"\"\n        Retrieves the available time zones as a list.\n        \"\"\"\n        return list(self._vtz.keys())\n\n    def get(self, tzid=None):\n        \"\"\"\n        Retrieve a :py:class:`datetime.tzinfo` object by its ``tzid``.\n\n        :param tzid:\n            If there is exactly one time zone available, omitting ``tzid``\n            or passing :py:const:`None` value returns it. Otherwise a valid\n            key (which can be retrieved from :func:`keys`) is required.\n\n        :raises ValueError:\n            Raised if ``tzid`` is not specified but there are either more\n            or fewer than 1 zone defined.\n\n        :returns:\n            Returns either a :py:class:`datetime.tzinfo` object representing\n            the relevant time zone or :py:const:`None` if the ``tzid`` was\n            not found.\n        \"\"\"\n        if tzid is None:\n            if len(self._vtz) == 0:\n                raise ValueError(\"no timezones defined\")\n            elif len(self._vtz) > 1:\n                raise ValueError(\"more than one timezone available\")\n            tzid = next(iter(self._vtz))\n\n        return self._vtz.get(tzid)\n\n    def _parse_offset(self, s):\n        s = s.strip()\n        if not s:\n            raise ValueError(\"empty offset\")\n        if s[0] in ('+', '-'):\n            signal = (-1, +1)[s[0] == '+']\n            s = s[1:]\n        else:\n            signal = +1\n        if len(s) == 4:\n            return (int(s[:2]) * 3600 + int(s[2:]) * 60) * signal\n        elif len(s) == 6:\n            return (int(s[:2]) * 3600 + int(s[2:4]) * 60 + int(s[4:])) * signal\n        else:\n            raise ValueError(\"invalid offset: \" + s)\n\n    def _parse_rfc(self, s):\n        lines = s.splitlines()\n        if not lines:\n            raise ValueError(\"empty string\")\n\n        # Unfold\n        i = 0\n        while i < len(lines):\n            line = lines[i].rstrip()\n            if not line:\n                del lines[i]\n            elif i > 0 and line[0] == \" \":\n                lines[i-1] += line[1:]\n                del lines[i]\n            else:\n                i += 1\n\n        tzid = None\n        comps = []\n        invtz = False\n        comptype = None\n        for line in lines:\n            if not line:\n                continue\n            name, value = line.split(':', 1)\n            parms = name.split(';')\n            if not parms:\n                raise ValueError(\"empty property name\")\n            name = parms[0].upper()\n            parms = parms[1:]\n            if invtz:\n                if name == \"BEGIN\":\n                    if value in (\"STANDARD\", \"DAYLIGHT\"):\n                        # Process component\n                        pass\n                    else:\n                        raise ValueError(\"unknown component: \"+value)\n                    comptype = value\n                    founddtstart = False\n                    tzoffsetfrom = None\n                    tzoffsetto = None\n                    rrulelines = []\n                    tzname = None\n                elif name == \"END\":\n                    if value == \"VTIMEZONE\":\n                        if comptype:\n                            raise ValueError(\"component not closed: \"+comptype)\n                        if not tzid:\n                            raise ValueError(\"mandatory TZID not found\")\n                        if not comps:\n                            raise ValueError(\n                                \"at least one component is needed\")\n                        # Process vtimezone\n                        self._vtz[tzid] = _tzicalvtz(tzid, comps)\n                        invtz = False\n                    elif value == comptype:\n                        if not founddtstart:\n                            raise ValueError(\"mandatory DTSTART not found\")\n                        if tzoffsetfrom is None:\n                            raise ValueError(\n                                \"mandatory TZOFFSETFROM not found\")\n                        if tzoffsetto is None:\n                            raise ValueError(\n                                \"mandatory TZOFFSETFROM not found\")\n                        # Process component\n                        rr = None\n                        if rrulelines:\n                            rr = rrule.rrulestr(\"\\n\".join(rrulelines),\n                                                compatible=True,\n                                                ignoretz=True,\n                                                cache=True)\n                        comp = _tzicalvtzcomp(tzoffsetfrom, tzoffsetto,\n                                              (comptype == \"DAYLIGHT\"),\n                                              tzname, rr)\n                        comps.append(comp)\n                        comptype = None\n                    else:\n                        raise ValueError(\"invalid component end: \"+value)\n                elif comptype:\n                    if name == \"DTSTART\":\n                        # DTSTART in VTIMEZONE takes a subset of valid RRULE\n                        # values under RFC 5545.\n                        for parm in parms:\n                            if parm != 'VALUE=DATE-TIME':\n                                msg = ('Unsupported DTSTART param in ' +\n                                       'VTIMEZONE: ' + parm)\n                                raise ValueError(msg)\n                        rrulelines.append(line)\n                        founddtstart = True\n                    elif name in (\"RRULE\", \"RDATE\", \"EXRULE\", \"EXDATE\"):\n                        rrulelines.append(line)\n                    elif name == \"TZOFFSETFROM\":\n                        if parms:\n                            raise ValueError(\n                                \"unsupported %s parm: %s \" % (name, parms[0]))\n                        tzoffsetfrom = self._parse_offset(value)\n                    elif name == \"TZOFFSETTO\":\n                        if parms:\n                            raise ValueError(\n                                \"unsupported TZOFFSETTO parm: \"+parms[0])\n                        tzoffsetto = self._parse_offset(value)\n                    elif name == \"TZNAME\":\n                        if parms:\n                            raise ValueError(\n                                \"unsupported TZNAME parm: \"+parms[0])\n                        tzname = value\n                    elif name == \"COMMENT\":\n                        pass\n                    else:\n                        raise ValueError(\"unsupported property: \"+name)\n                else:\n                    if name == \"TZID\":\n                        if parms:\n                            raise ValueError(\n                                \"unsupported TZID parm: \"+parms[0])\n                        tzid = value\n                    elif name in (\"TZURL\", \"LAST-MODIFIED\", \"COMMENT\"):\n                        pass\n                    else:\n                        raise ValueError(\"unsupported property: \"+name)\n            elif name == \"BEGIN\" and value == \"VTIMEZONE\":\n                tzid = None\n                comps = []\n                invtz = True\n\n    def __repr__(self):\n        return \"%s(%s)\" % (self.__class__.__name__, repr(self._s))\n\n\nif sys.platform != \"win32\":\n    TZFILES = [\"/etc/localtime\", \"localtime\"]\n    TZPATHS = [\"/usr/share/zoneinfo\",\n               \"/usr/lib/zoneinfo\",\n               \"/usr/share/lib/zoneinfo\",\n               \"/etc/zoneinfo\"]\nelse:\n    TZFILES = []\n    TZPATHS = []\n\n\ndef __get_gettz():\n    tzlocal_classes = (tzlocal,)\n    if tzwinlocal is not None:\n        tzlocal_classes += (tzwinlocal,)\n\n    class GettzFunc(object):\n        \"\"\"\n        Retrieve a time zone object from a string representation\n\n        This function is intended to retrieve the :py:class:`tzinfo` subclass\n        that best represents the time zone that would be used if a POSIX\n        `TZ variable`_ were set to the same value.\n\n        If no argument or an empty string is passed to ``gettz``, local time\n        is returned:\n\n        .. code-block:: python3\n\n            >>> gettz()\n            tzfile('/etc/localtime')\n\n        This function is also the preferred way to map IANA tz database keys\n        to :class:`tzfile` objects:\n\n        .. code-block:: python3\n\n            >>> gettz('Pacific/Kiritimati')\n            tzfile('/usr/share/zoneinfo/Pacific/Kiritimati')\n\n        On Windows, the standard is extended to include the Windows-specific\n        zone names provided by the operating system:\n\n        .. code-block:: python3\n\n            >>> gettz('Egypt Standard Time')\n            tzwin('Egypt Standard Time')\n\n        Passing a GNU ``TZ`` style string time zone specification returns a\n        :class:`tzstr` object:\n\n        .. code-block:: python3\n\n            >>> gettz('AEST-10AEDT-11,M10.1.0/2,M4.1.0/3')\n            tzstr('AEST-10AEDT-11,M10.1.0/2,M4.1.0/3')\n\n        :param name:\n            A time zone name (IANA, or, on Windows, Windows keys), location of\n            a ``tzfile(5)`` zoneinfo file or ``TZ`` variable style time zone\n            specifier. An empty string, no argument or ``None`` is interpreted\n            as local time.\n\n        :return:\n            Returns an instance of one of ``dateutil``'s :py:class:`tzinfo`\n            subclasses.\n\n        .. versionchanged:: 2.7.0\n\n            After version 2.7.0, any two calls to ``gettz`` using the same\n            input strings will return the same object:\n\n            .. code-block:: python3\n\n                >>> tz.gettz('America/Chicago') is tz.gettz('America/Chicago')\n                True\n\n            In addition to improving performance, this ensures that\n            `\"same zone\" semantics`_ are used for datetimes in the same zone.\n\n\n        .. _`TZ variable`:\n            https://www.gnu.org/software/libc/manual/html_node/TZ-Variable.html\n\n        .. _`\"same zone\" semantics`:\n            https://blog.ganssle.io/articles/2018/02/aware-datetime-arithmetic.html\n        \"\"\"\n        def __init__(self):\n\n            self.__instances = weakref.WeakValueDictionary()\n            self.__strong_cache_size = 8\n            self.__strong_cache = OrderedDict()\n            self._cache_lock = _thread.allocate_lock()\n\n        def __call__(self, name=None):\n            with self._cache_lock:\n                rv = self.__instances.get(name, None)\n\n                if rv is None:\n                    rv = self.nocache(name=name)\n                    if not (name is None\n                            or isinstance(rv, tzlocal_classes)\n                            or rv is None):\n                        # tzlocal is slightly more complicated than the other\n                        # time zone providers because it depends on environment\n                        # at construction time, so don't cache that.\n                        #\n                        # We also cannot store weak references to None, so we\n                        # will also not store that.\n                        self.__instances[name] = rv\n                    else:\n                        # No need for strong caching, return immediately\n                        return rv\n\n                self.__strong_cache[name] = self.__strong_cache.pop(name, rv)\n\n                if len(self.__strong_cache) > self.__strong_cache_size:\n                    self.__strong_cache.popitem(last=False)\n\n            return rv\n\n        def set_cache_size(self, size):\n            with self._cache_lock:\n                self.__strong_cache_size = size\n                while len(self.__strong_cache) > size:\n                    self.__strong_cache.popitem(last=False)\n\n        def cache_clear(self):\n            with self._cache_lock:\n                self.__instances = weakref.WeakValueDictionary()\n                self.__strong_cache.clear()\n\n        @staticmethod\n        def nocache(name=None):\n            \"\"\"A non-cached version of gettz\"\"\"\n            tz = None\n            if not name:\n                try:\n                    name = os.environ[\"TZ\"]\n                except KeyError:\n                    pass\n            if name is None or name in (\"\", \":\"):\n                for filepath in TZFILES:\n                    if not os.path.isabs(filepath):\n                        filename = filepath\n                        for path in TZPATHS:\n                            filepath = os.path.join(path, filename)\n                            if os.path.isfile(filepath):\n                                break\n                        else:\n                            continue\n                    if os.path.isfile(filepath):\n                        try:\n                            tz = tzfile(filepath)\n                            break\n                        except (IOError, OSError, ValueError):\n                            pass\n                else:\n                    tz = tzlocal()\n            else:\n                try:\n                    if name.startswith(\":\"):\n                        name = name[1:]\n                except TypeError as e:\n                    if isinstance(name, bytes):\n                        new_msg = \"gettz argument should be str, not bytes\"\n                        six.raise_from(TypeError(new_msg), e)\n                    else:\n                        raise\n                if os.path.isabs(name):\n                    if os.path.isfile(name):\n                        tz = tzfile(name)\n                    else:\n                        tz = None\n                else:\n                    for path in TZPATHS:\n                        filepath = os.path.join(path, name)\n                        if not os.path.isfile(filepath):\n                            filepath = filepath.replace(' ', '_')\n                            if not os.path.isfile(filepath):\n                                continue\n                        try:\n                            tz = tzfile(filepath)\n                            break\n                        except (IOError, OSError, ValueError):\n                            pass\n                    else:\n                        tz = None\n                        if tzwin is not None:\n                            try:\n                                tz = tzwin(name)\n                            except (WindowsError, UnicodeEncodeError):\n                                # UnicodeEncodeError is for Python 2.7 compat\n                                tz = None\n\n                        if not tz:\n                            from dateutil.zoneinfo import get_zonefile_instance\n                            tz = get_zonefile_instance().get(name)\n\n                        if not tz:\n                            for c in name:\n                                # name is not a tzstr unless it has at least\n                                # one offset. For short values of \"name\", an\n                                # explicit for loop seems to be the fastest way\n                                # To determine if a string contains a digit\n                                if c in \"0123456789\":\n                                    try:\n                                        tz = tzstr(name)\n                                    except ValueError:\n                                        pass\n                                    break\n                            else:\n                                if name in (\"GMT\", \"UTC\"):\n                                    tz = UTC\n                                elif name in time.tzname:\n                                    tz = tzlocal()\n            return tz\n\n    return GettzFunc()\n\n\ngettz = __get_gettz()\ndel __get_gettz\n\n\ndef datetime_exists(dt, tz=None):\n    \"\"\"\n    Given a datetime and a time zone, determine whether or not a given datetime\n    would fall in a gap.\n\n    :param dt:\n        A :class:`datetime.datetime` (whose time zone will be ignored if ``tz``\n        is provided.)\n\n    :param tz:\n        A :class:`datetime.tzinfo` with support for the ``fold`` attribute. If\n        ``None`` or not provided, the datetime's own time zone will be used.\n\n    :return:\n        Returns a boolean value whether or not the \"wall time\" exists in\n        ``tz``.\n\n    .. versionadded:: 2.7.0\n    \"\"\"\n    if tz is None:\n        if dt.tzinfo is None:\n            raise ValueError('Datetime is naive and no time zone provided.')\n        tz = dt.tzinfo\n\n    dt = dt.replace(tzinfo=None)\n\n    # This is essentially a test of whether or not the datetime can survive\n    # a round trip to UTC.\n    dt_rt = dt.replace(tzinfo=tz).astimezone(UTC).astimezone(tz)\n    dt_rt = dt_rt.replace(tzinfo=None)\n\n    return dt == dt_rt\n\n\ndef datetime_ambiguous(dt, tz=None):\n    \"\"\"\n    Given a datetime and a time zone, determine whether or not a given datetime\n    is ambiguous (i.e if there are two times differentiated only by their DST\n    status).\n\n    :param dt:\n        A :class:`datetime.datetime` (whose time zone will be ignored if ``tz``\n        is provided.)\n\n    :param tz:\n        A :class:`datetime.tzinfo` with support for the ``fold`` attribute. If\n        ``None`` or not provided, the datetime's own time zone will be used.\n\n    :return:\n        Returns a boolean value whether or not the \"wall time\" is ambiguous in\n        ``tz``.\n\n    .. versionadded:: 2.6.0\n    \"\"\"\n    if tz is None:\n        if dt.tzinfo is None:\n            raise ValueError('Datetime is naive and no time zone provided.')\n\n        tz = dt.tzinfo\n\n    # If a time zone defines its own \"is_ambiguous\" function, we'll use that.\n    is_ambiguous_fn = getattr(tz, 'is_ambiguous', None)\n    if is_ambiguous_fn is not None:\n        try:\n            return tz.is_ambiguous(dt)\n        except Exception:\n            pass\n\n    # If it doesn't come out and tell us it's ambiguous, we'll just check if\n    # the fold attribute has any effect on this particular date and time.\n    dt = dt.replace(tzinfo=tz)\n    wall_0 = enfold(dt, fold=0)\n    wall_1 = enfold(dt, fold=1)\n\n    same_offset = wall_0.utcoffset() == wall_1.utcoffset()\n    same_dst = wall_0.dst() == wall_1.dst()\n\n    return not (same_offset and same_dst)\n\n\ndef resolve_imaginary(dt):\n    \"\"\"\n    Given a datetime that may be imaginary, return an existing datetime.\n\n    This function assumes that an imaginary datetime represents what the\n    wall time would be in a zone had the offset transition not occurred, so\n    it will always fall forward by the transition's change in offset.\n\n    .. doctest::\n\n        >>> from dateutil import tz\n        >>> from datetime import datetime\n        >>> NYC = tz.gettz('America/New_York')\n        >>> print(tz.resolve_imaginary(datetime(2017, 3, 12, 2, 30, tzinfo=NYC)))\n        2017-03-12 03:30:00-04:00\n\n        >>> KIR = tz.gettz('Pacific/Kiritimati')\n        >>> print(tz.resolve_imaginary(datetime(1995, 1, 1, 12, 30, tzinfo=KIR)))\n        1995-01-02 12:30:00+14:00\n\n    As a note, :func:`datetime.astimezone` is guaranteed to produce a valid,\n    existing datetime, so a round-trip to and from UTC is sufficient to get\n    an extant datetime, however, this generally \"falls back\" to an earlier time\n    rather than falling forward to the STD side (though no guarantees are made\n    about this behavior).\n\n    :param dt:\n        A :class:`datetime.datetime` which may or may not exist.\n\n    :return:\n        Returns an existing :class:`datetime.datetime`. If ``dt`` was not\n        imaginary, the datetime returned is guaranteed to be the same object\n        passed to the function.\n\n    .. versionadded:: 2.7.0\n    \"\"\"\n    if dt.tzinfo is not None and not datetime_exists(dt):\n\n        curr_offset = (dt + datetime.timedelta(hours=24)).utcoffset()\n        old_offset = (dt - datetime.timedelta(hours=24)).utcoffset()\n\n        dt += curr_offset - old_offset\n\n    return dt\n\n\ndef _datetime_to_timestamp(dt):\n    \"\"\"\n    Convert a :class:`datetime.datetime` object to an epoch timestamp in\n    seconds since January 1, 1970, ignoring the time zone.\n    \"\"\"\n    return (dt.replace(tzinfo=None) - EPOCH).total_seconds()\n\n\nif sys.version_info >= (3, 6):\n    def _get_supported_offset(second_offset):\n        return second_offset\nelse:\n    def _get_supported_offset(second_offset):\n        # For python pre-3.6, round to full-minutes if that's not the case.\n        # Python's datetime doesn't accept sub-minute timezones. Check\n        # http://python.org/sf/1447945 or https://bugs.python.org/issue5288\n        # for some information.\n        old_offset = second_offset\n        calculated_offset = 60 * ((second_offset + 30) // 60)\n        return calculated_offset\n\n\ntry:\n    # Python 3.7 feature\n    from contextlib import nullcontext as _nullcontext\nexcept ImportError:\n    class _nullcontext(object):\n        \"\"\"\n        Class for wrapping contexts so that they are passed through in a\n        with statement.\n        \"\"\"\n        def __init__(self, context):\n            self.context = context\n\n        def __enter__(self):\n            return self.context\n\n        def __exit__(*args, **kwargs):\n            pass\n\n# vim:ts=4:sw=4:et\n", "src/dateutil/tz/win.py": "# -*- coding: utf-8 -*-\n\"\"\"\nThis module provides an interface to the native time zone data on Windows,\nincluding :py:class:`datetime.tzinfo` implementations.\n\nAttempting to import this module on a non-Windows platform will raise an\n:py:obj:`ImportError`.\n\"\"\"\n# This code was originally contributed by Jeffrey Harris.\nimport datetime\nimport struct\n\nfrom six.moves import winreg\nfrom six import text_type\n\ntry:\n    import ctypes\n    from ctypes import wintypes\nexcept ValueError:\n    # ValueError is raised on non-Windows systems for some horrible reason.\n    raise ImportError(\"Running tzwin on non-Windows system\")\n\nfrom ._common import tzrangebase\n\n__all__ = [\"tzwin\", \"tzwinlocal\", \"tzres\"]\n\nONEWEEK = datetime.timedelta(7)\n\nTZKEYNAMENT = r\"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones\"\nTZKEYNAME9X = r\"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Time Zones\"\nTZLOCALKEYNAME = r\"SYSTEM\\CurrentControlSet\\Control\\TimeZoneInformation\"\n\n\ndef _settzkeyname():\n    handle = winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE)\n    try:\n        winreg.OpenKey(handle, TZKEYNAMENT).Close()\n        TZKEYNAME = TZKEYNAMENT\n    except WindowsError:\n        TZKEYNAME = TZKEYNAME9X\n    handle.Close()\n    return TZKEYNAME\n\n\nTZKEYNAME = _settzkeyname()\n\n\nclass tzres(object):\n    \"\"\"\n    Class for accessing ``tzres.dll``, which contains timezone name related\n    resources.\n\n    .. versionadded:: 2.5.0\n    \"\"\"\n    p_wchar = ctypes.POINTER(wintypes.WCHAR)        # Pointer to a wide char\n\n    def __init__(self, tzres_loc='tzres.dll'):\n        # Load the user32 DLL so we can load strings from tzres\n        user32 = ctypes.WinDLL('user32')\n\n        # Specify the LoadStringW function\n        user32.LoadStringW.argtypes = (wintypes.HINSTANCE,\n                                       wintypes.UINT,\n                                       wintypes.LPWSTR,\n                                       ctypes.c_int)\n\n        self.LoadStringW = user32.LoadStringW\n        self._tzres = ctypes.WinDLL(tzres_loc)\n        self.tzres_loc = tzres_loc\n\n    def load_name(self, offset):\n        \"\"\"\n        Load a timezone name from a DLL offset (integer).\n\n        >>> from dateutil.tzwin import tzres\n        >>> tzr = tzres()\n        >>> print(tzr.load_name(112))\n        'Eastern Standard Time'\n\n        :param offset:\n            A positive integer value referring to a string from the tzres dll.\n\n        .. note::\n\n            Offsets found in the registry are generally of the form\n            ``@tzres.dll,-114``. The offset in this case is 114, not -114.\n\n        \"\"\"\n        resource = self.p_wchar()\n        lpBuffer = ctypes.cast(ctypes.byref(resource), wintypes.LPWSTR)\n        nchar = self.LoadStringW(self._tzres._handle, offset, lpBuffer, 0)\n        return resource[:nchar]\n\n    def name_from_string(self, tzname_str):\n        \"\"\"\n        Parse strings as returned from the Windows registry into the time zone\n        name as defined in the registry.\n\n        >>> from dateutil.tzwin import tzres\n        >>> tzr = tzres()\n        >>> print(tzr.name_from_string('@tzres.dll,-251'))\n        'Dateline Daylight Time'\n        >>> print(tzr.name_from_string('Eastern Standard Time'))\n        'Eastern Standard Time'\n\n        :param tzname_str:\n            A timezone name string as returned from a Windows registry key.\n\n        :return:\n            Returns the localized timezone string from tzres.dll if the string\n            is of the form `@tzres.dll,-offset`, else returns the input string.\n        \"\"\"\n        if not tzname_str.startswith('@'):\n            return tzname_str\n\n        name_splt = tzname_str.split(',-')\n        try:\n            offset = int(name_splt[1])\n        except:\n            raise ValueError(\"Malformed timezone string.\")\n\n        return self.load_name(offset)\n\n\nclass tzwinbase(tzrangebase):\n    \"\"\"tzinfo class based on win32's timezones available in the registry.\"\"\"\n    def __init__(self):\n        raise NotImplementedError('tzwinbase is an abstract base class')\n\n    def __eq__(self, other):\n        # Compare on all relevant dimensions, including name.\n        if not isinstance(other, tzwinbase):\n            return NotImplemented\n\n        return  (self._std_offset == other._std_offset and\n                 self._dst_offset == other._dst_offset and\n                 self._stddayofweek == other._stddayofweek and\n                 self._dstdayofweek == other._dstdayofweek and\n                 self._stdweeknumber == other._stdweeknumber and\n                 self._dstweeknumber == other._dstweeknumber and\n                 self._stdhour == other._stdhour and\n                 self._dsthour == other._dsthour and\n                 self._stdminute == other._stdminute and\n                 self._dstminute == other._dstminute and\n                 self._std_abbr == other._std_abbr and\n                 self._dst_abbr == other._dst_abbr)\n\n    @staticmethod\n    def list():\n        \"\"\"Return a list of all time zones known to the system.\"\"\"\n        with winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE) as handle:\n            with winreg.OpenKey(handle, TZKEYNAME) as tzkey:\n                result = [winreg.EnumKey(tzkey, i)\n                          for i in range(winreg.QueryInfoKey(tzkey)[0])]\n        return result\n\n    def display(self):\n        \"\"\"\n        Return the display name of the time zone.\n        \"\"\"\n        return self._display\n\n    def transitions(self, year):\n        \"\"\"\n        For a given year, get the DST on and off transition times, expressed\n        always on the standard time side. For zones with no transitions, this\n        function returns ``None``.\n\n        :param year:\n            The year whose transitions you would like to query.\n\n        :return:\n            Returns a :class:`tuple` of :class:`datetime.datetime` objects,\n            ``(dston, dstoff)`` for zones with an annual DST transition, or\n            ``None`` for fixed offset zones.\n        \"\"\"\n\n        if not self.hasdst:\n            return None\n\n        dston = picknthweekday(year, self._dstmonth, self._dstdayofweek,\n                               self._dsthour, self._dstminute,\n                               self._dstweeknumber)\n\n        dstoff = picknthweekday(year, self._stdmonth, self._stddayofweek,\n                                self._stdhour, self._stdminute,\n                                self._stdweeknumber)\n\n        # Ambiguous dates default to the STD side\n        dstoff -= self._dst_base_offset\n\n        return dston, dstoff\n\n    def _get_hasdst(self):\n        return self._dstmonth != 0\n\n    @property\n    def _dst_base_offset(self):\n        return self._dst_base_offset_\n\n\nclass tzwin(tzwinbase):\n    \"\"\"\n    Time zone object created from the zone info in the Windows registry\n\n    These are similar to :py:class:`dateutil.tz.tzrange` objects in that\n    the time zone data is provided in the format of a single offset rule\n    for either 0 or 2 time zone transitions per year.\n\n    :param: name\n        The name of a Windows time zone key, e.g. \"Eastern Standard Time\".\n        The full list of keys can be retrieved with :func:`tzwin.list`.\n    \"\"\"\n\n    def __init__(self, name):\n        self._name = name\n\n        with winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE) as handle:\n            tzkeyname = text_type(\"{kn}\\\\{name}\").format(kn=TZKEYNAME, name=name)\n            with winreg.OpenKey(handle, tzkeyname) as tzkey:\n                keydict = valuestodict(tzkey)\n\n        self._std_abbr = keydict[\"Std\"]\n        self._dst_abbr = keydict[\"Dlt\"]\n\n        self._display = keydict[\"Display\"]\n\n        # See http://ww_winreg.jsiinc.com/SUBA/tip0300/rh0398.htm\n        tup = struct.unpack(\"=3l16h\", keydict[\"TZI\"])\n        stdoffset = -tup[0]-tup[1]          # Bias + StandardBias * -1\n        dstoffset = stdoffset-tup[2]        # + DaylightBias * -1\n        self._std_offset = datetime.timedelta(minutes=stdoffset)\n        self._dst_offset = datetime.timedelta(minutes=dstoffset)\n\n        # for the meaning see the win32 TIME_ZONE_INFORMATION structure docs\n        # http://msdn.microsoft.com/en-us/library/windows/desktop/ms725481(v=vs.85).aspx\n        (self._stdmonth,\n         self._stddayofweek,   # Sunday = 0\n         self._stdweeknumber,  # Last = 5\n         self._stdhour,\n         self._stdminute) = tup[4:9]\n\n        (self._dstmonth,\n         self._dstdayofweek,   # Sunday = 0\n         self._dstweeknumber,  # Last = 5\n         self._dsthour,\n         self._dstminute) = tup[12:17]\n\n        self._dst_base_offset_ = self._dst_offset - self._std_offset\n        self.hasdst = self._get_hasdst()\n\n    def __repr__(self):\n        return \"tzwin(%s)\" % repr(self._name)\n\n    def __reduce__(self):\n        return (self.__class__, (self._name,))\n\n\nclass tzwinlocal(tzwinbase):\n    \"\"\"\n    Class representing the local time zone information in the Windows registry\n\n    While :class:`dateutil.tz.tzlocal` makes system calls (via the :mod:`time`\n    module) to retrieve time zone information, ``tzwinlocal`` retrieves the\n    rules directly from the Windows registry and creates an object like\n    :class:`dateutil.tz.tzwin`.\n\n    Because Windows does not have an equivalent of :func:`time.tzset`, on\n    Windows, :class:`dateutil.tz.tzlocal` instances will always reflect the\n    time zone settings *at the time that the process was started*, meaning\n    changes to the machine's time zone settings during the run of a program\n    on Windows will **not** be reflected by :class:`dateutil.tz.tzlocal`.\n    Because ``tzwinlocal`` reads the registry directly, it is unaffected by\n    this issue.\n    \"\"\"\n    def __init__(self):\n        with winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE) as handle:\n            with winreg.OpenKey(handle, TZLOCALKEYNAME) as tzlocalkey:\n                keydict = valuestodict(tzlocalkey)\n\n            self._std_abbr = keydict[\"StandardName\"]\n            self._dst_abbr = keydict[\"DaylightName\"]\n\n            try:\n                tzkeyname = text_type('{kn}\\\\{sn}').format(kn=TZKEYNAME,\n                                                          sn=self._std_abbr)\n                with winreg.OpenKey(handle, tzkeyname) as tzkey:\n                    _keydict = valuestodict(tzkey)\n                    self._display = _keydict[\"Display\"]\n            except OSError:\n                self._display = None\n\n        stdoffset = -keydict[\"Bias\"]-keydict[\"StandardBias\"]\n        dstoffset = stdoffset-keydict[\"DaylightBias\"]\n\n        self._std_offset = datetime.timedelta(minutes=stdoffset)\n        self._dst_offset = datetime.timedelta(minutes=dstoffset)\n\n        # For reasons unclear, in this particular key, the day of week has been\n        # moved to the END of the SYSTEMTIME structure.\n        tup = struct.unpack(\"=8h\", keydict[\"StandardStart\"])\n\n        (self._stdmonth,\n         self._stdweeknumber,  # Last = 5\n         self._stdhour,\n         self._stdminute) = tup[1:5]\n\n        self._stddayofweek = tup[7]\n\n        tup = struct.unpack(\"=8h\", keydict[\"DaylightStart\"])\n\n        (self._dstmonth,\n         self._dstweeknumber,  # Last = 5\n         self._dsthour,\n         self._dstminute) = tup[1:5]\n\n        self._dstdayofweek = tup[7]\n\n        self._dst_base_offset_ = self._dst_offset - self._std_offset\n        self.hasdst = self._get_hasdst()\n\n    def __repr__(self):\n        return \"tzwinlocal()\"\n\n    def __str__(self):\n        # str will return the standard name, not the daylight name.\n        return \"tzwinlocal(%s)\" % repr(self._std_abbr)\n\n    def __reduce__(self):\n        return (self.__class__, ())\n\n\ndef picknthweekday(year, month, dayofweek, hour, minute, whichweek):\n    \"\"\" dayofweek == 0 means Sunday, whichweek 5 means last instance \"\"\"\n    first = datetime.datetime(year, month, 1, hour, minute)\n\n    # This will work if dayofweek is ISO weekday (1-7) or Microsoft-style (0-6),\n    # Because 7 % 7 = 0\n    weekdayone = first.replace(day=((dayofweek - first.isoweekday()) % 7) + 1)\n    wd = weekdayone + ((whichweek - 1) * ONEWEEK)\n    if (wd.month != month):\n        wd -= ONEWEEK\n\n    return wd\n\n\ndef valuestodict(key):\n    \"\"\"Convert a registry key's values to a dictionary.\"\"\"\n    dout = {}\n    size = winreg.QueryInfoKey(key)[1]\n    tz_res = None\n\n    for i in range(size):\n        key_name, value, dtype = winreg.EnumValue(key, i)\n        if dtype == winreg.REG_DWORD or dtype == winreg.REG_DWORD_LITTLE_ENDIAN:\n            # If it's a DWORD (32-bit integer), it's stored as unsigned - convert\n            # that to a proper signed integer\n            if value & (1 << 31):\n                value = value - (1 << 32)\n        elif dtype == winreg.REG_SZ:\n            # If it's a reference to the tzres DLL, load the actual string\n            if value.startswith('@tzres'):\n                tz_res = tz_res or tzres()\n                value = tz_res.name_from_string(value)\n\n            value = value.rstrip('\\x00')    # Remove trailing nulls\n\n        dout[key_name] = value\n\n    return dout\n", "src/dateutil/tz/_factories.py": "from datetime import timedelta\nimport weakref\nfrom collections import OrderedDict\n\nfrom six.moves import _thread\n\n\nclass _TzSingleton(type):\n    def __init__(cls, *args, **kwargs):\n        cls.__instance = None\n        super(_TzSingleton, cls).__init__(*args, **kwargs)\n\n    def __call__(cls):\n        if cls.__instance is None:\n            cls.__instance = super(_TzSingleton, cls).__call__()\n        return cls.__instance\n\n\nclass _TzFactory(type):\n    def instance(cls, *args, **kwargs):\n        \"\"\"Alternate constructor that returns a fresh instance\"\"\"\n        return type.__call__(cls, *args, **kwargs)\n\n\nclass _TzOffsetFactory(_TzFactory):\n    def __init__(cls, *args, **kwargs):\n        cls.__instances = weakref.WeakValueDictionary()\n        cls.__strong_cache = OrderedDict()\n        cls.__strong_cache_size = 8\n\n        cls._cache_lock = _thread.allocate_lock()\n\n    def __call__(cls, name, offset):\n        if isinstance(offset, timedelta):\n            key = (name, offset.total_seconds())\n        else:\n            key = (name, offset)\n\n        instance = cls.__instances.get(key, None)\n        if instance is None:\n            instance = cls.__instances.setdefault(key,\n                                                  cls.instance(name, offset))\n\n        # This lock may not be necessary in Python 3. See GH issue #901\n        with cls._cache_lock:\n            cls.__strong_cache[key] = cls.__strong_cache.pop(key, instance)\n\n            # Remove an item if the strong cache is overpopulated\n            if len(cls.__strong_cache) > cls.__strong_cache_size:\n                cls.__strong_cache.popitem(last=False)\n\n        return instance\n\n\nclass _TzStrFactory(_TzFactory):\n    def __init__(cls, *args, **kwargs):\n        cls.__instances = weakref.WeakValueDictionary()\n        cls.__strong_cache = OrderedDict()\n        cls.__strong_cache_size = 8\n\n        cls.__cache_lock = _thread.allocate_lock()\n\n    def __call__(cls, s, posix_offset=False):\n        key = (s, posix_offset)\n        instance = cls.__instances.get(key, None)\n\n        if instance is None:\n            instance = cls.__instances.setdefault(key,\n                cls.instance(s, posix_offset))\n\n        # This lock may not be necessary in Python 3. See GH issue #901\n        with cls.__cache_lock:\n            cls.__strong_cache[key] = cls.__strong_cache.pop(key, instance)\n\n            # Remove an item if the strong cache is overpopulated\n            if len(cls.__strong_cache) > cls.__strong_cache_size:\n                cls.__strong_cache.popitem(last=False)\n\n        return instance\n\n", "src/dateutil/tz/__init__.py": "# -*- coding: utf-8 -*-\nfrom .tz import *\nfrom .tz import __doc__\n\n__all__ = [\"tzutc\", \"tzoffset\", \"tzlocal\", \"tzfile\", \"tzrange\",\n           \"tzstr\", \"tzical\", \"tzwin\", \"tzwinlocal\", \"gettz\",\n           \"enfold\", \"datetime_ambiguous\", \"datetime_exists\",\n           \"resolve_imaginary\", \"UTC\", \"DeprecatedTzFormatWarning\"]\n\n\nclass DeprecatedTzFormatWarning(Warning):\n    \"\"\"Warning raised when time zones are parsed from deprecated formats.\"\"\"\n", "src/dateutil/zoneinfo/rebuild.py": "import logging\nimport os\nimport tempfile\nimport shutil\nimport json\nfrom subprocess import check_call, check_output\nfrom tarfile import TarFile\n\nfrom dateutil.zoneinfo import METADATA_FN, ZONEFILENAME\n\n\ndef rebuild(filename, tag=None, format=\"gz\", zonegroups=[], metadata=None):\n    \"\"\"Rebuild the internal timezone info in dateutil/zoneinfo/zoneinfo*tar*\n\n    filename is the timezone tarball from ``ftp.iana.org/tz``.\n\n    \"\"\"\n    tmpdir = tempfile.mkdtemp()\n    zonedir = os.path.join(tmpdir, \"zoneinfo\")\n    moduledir = os.path.dirname(__file__)\n    try:\n        with TarFile.open(filename) as tf:\n            for name in zonegroups:\n                tf.extract(name, tmpdir)\n            filepaths = [os.path.join(tmpdir, n) for n in zonegroups]\n\n            _run_zic(zonedir, filepaths)\n\n        # write metadata file\n        with open(os.path.join(zonedir, METADATA_FN), 'w') as f:\n            json.dump(metadata, f, indent=4, sort_keys=True)\n        target = os.path.join(moduledir, ZONEFILENAME)\n        with TarFile.open(target, \"w:%s\" % format) as tf:\n            for entry in os.listdir(zonedir):\n                entrypath = os.path.join(zonedir, entry)\n                tf.add(entrypath, entry)\n    finally:\n        shutil.rmtree(tmpdir)\n\n\ndef _run_zic(zonedir, filepaths):\n    \"\"\"Calls the ``zic`` compiler in a compatible way to get a \"fat\" binary.\n\n    Recent versions of ``zic`` default to ``-b slim``, while older versions\n    don't even have the ``-b`` option (but default to \"fat\" binaries). The\n    current version of dateutil does not support Version 2+ TZif files, which\n    causes problems when used in conjunction with \"slim\" binaries, so this\n    function is used to ensure that we always get a \"fat\" binary.\n    \"\"\"\n\n    try:\n        help_text = check_output([\"zic\", \"--help\"])\n    except OSError as e:\n        _print_on_nosuchfile(e)\n        raise\n\n    if b\"-b \" in help_text:\n        bloat_args = [\"-b\", \"fat\"]\n    else:\n        bloat_args = []\n\n    check_call([\"zic\"] + bloat_args + [\"-d\", zonedir] + filepaths)\n\n\ndef _print_on_nosuchfile(e):\n    \"\"\"Print helpful troubleshooting message\n\n    e is an exception raised by subprocess.check_call()\n\n    \"\"\"\n    if e.errno == 2:\n        logging.error(\n            \"Could not find zic. Perhaps you need to install \"\n            \"libc-bin or some other package that provides it, \"\n            \"or it's not in your PATH?\")\n", "src/dateutil/zoneinfo/__init__.py": "# -*- coding: utf-8 -*-\nimport warnings\nimport json\n\nfrom tarfile import TarFile\nfrom pkgutil import get_data\nfrom io import BytesIO\n\nfrom dateutil.tz import tzfile as _tzfile\n\n__all__ = [\"get_zonefile_instance\", \"gettz\", \"gettz_db_metadata\"]\n\nZONEFILENAME = \"dateutil-zoneinfo.tar.gz\"\nMETADATA_FN = 'METADATA'\n\n\nclass tzfile(_tzfile):\n    def __reduce__(self):\n        return (gettz, (self._filename,))\n\n\ndef getzoneinfofile_stream():\n    try:\n        return BytesIO(get_data(__name__, ZONEFILENAME))\n    except IOError as e:  # TODO  switch to FileNotFoundError?\n        warnings.warn(\"I/O error({0}): {1}\".format(e.errno, e.strerror))\n        return None\n\n\nclass ZoneInfoFile(object):\n    def __init__(self, zonefile_stream=None):\n        if zonefile_stream is not None:\n            with TarFile.open(fileobj=zonefile_stream) as tf:\n                self.zones = {zf.name: tzfile(tf.extractfile(zf), filename=zf.name)\n                              for zf in tf.getmembers()\n                              if zf.isfile() and zf.name != METADATA_FN}\n                # deal with links: They'll point to their parent object. Less\n                # waste of memory\n                links = {zl.name: self.zones[zl.linkname]\n                         for zl in tf.getmembers() if\n                         zl.islnk() or zl.issym()}\n                self.zones.update(links)\n                try:\n                    metadata_json = tf.extractfile(tf.getmember(METADATA_FN))\n                    metadata_str = metadata_json.read().decode('UTF-8')\n                    self.metadata = json.loads(metadata_str)\n                except KeyError:\n                    # no metadata in tar file\n                    self.metadata = None\n        else:\n            self.zones = {}\n            self.metadata = None\n\n    def get(self, name, default=None):\n        \"\"\"\n        Wrapper for :func:`ZoneInfoFile.zones.get`. This is a convenience method\n        for retrieving zones from the zone dictionary.\n\n        :param name:\n            The name of the zone to retrieve. (Generally IANA zone names)\n\n        :param default:\n            The value to return in the event of a missing key.\n\n        .. versionadded:: 2.6.0\n\n        \"\"\"\n        return self.zones.get(name, default)\n\n\n# The current API has gettz as a module function, although in fact it taps into\n# a stateful class. So as a workaround for now, without changing the API, we\n# will create a new \"global\" class instance the first time a user requests a\n# timezone. Ugly, but adheres to the api.\n#\n# TODO: Remove after deprecation period.\n_CLASS_ZONE_INSTANCE = []\n\n\ndef get_zonefile_instance(new_instance=False):\n    \"\"\"\n    This is a convenience function which provides a :class:`ZoneInfoFile`\n    instance using the data provided by the ``dateutil`` package. By default, it\n    caches a single instance of the ZoneInfoFile object and returns that.\n\n    :param new_instance:\n        If ``True``, a new instance of :class:`ZoneInfoFile` is instantiated and\n        used as the cached instance for the next call. Otherwise, new instances\n        are created only as necessary.\n\n    :return:\n        Returns a :class:`ZoneInfoFile` object.\n\n    .. versionadded:: 2.6\n    \"\"\"\n    if new_instance:\n        zif = None\n    else:\n        zif = getattr(get_zonefile_instance, '_cached_instance', None)\n\n    if zif is None:\n        zif = ZoneInfoFile(getzoneinfofile_stream())\n\n        get_zonefile_instance._cached_instance = zif\n\n    return zif\n\n\ndef gettz(name):\n    \"\"\"\n    This retrieves a time zone from the local zoneinfo tarball that is packaged\n    with dateutil.\n\n    :param name:\n        An IANA-style time zone name, as found in the zoneinfo file.\n\n    :return:\n        Returns a :class:`dateutil.tz.tzfile` time zone object.\n\n    .. warning::\n        It is generally inadvisable to use this function, and it is only\n        provided for API compatibility with earlier versions. This is *not*\n        equivalent to ``dateutil.tz.gettz()``, which selects an appropriate\n        time zone based on the inputs, favoring system zoneinfo. This is ONLY\n        for accessing the dateutil-specific zoneinfo (which may be out of\n        date compared to the system zoneinfo).\n\n    .. deprecated:: 2.6\n        If you need to use a specific zoneinfofile over the system zoneinfo,\n        instantiate a :class:`dateutil.zoneinfo.ZoneInfoFile` object and call\n        :func:`dateutil.zoneinfo.ZoneInfoFile.get(name)` instead.\n\n        Use :func:`get_zonefile_instance` to retrieve an instance of the\n        dateutil-provided zoneinfo.\n    \"\"\"\n    warnings.warn(\"zoneinfo.gettz() will be removed in future versions, \"\n                  \"to use the dateutil-provided zoneinfo files, instantiate a \"\n                  \"ZoneInfoFile object and use ZoneInfoFile.zones.get() \"\n                  \"instead. See the documentation for details.\",\n                  DeprecationWarning)\n\n    if len(_CLASS_ZONE_INSTANCE) == 0:\n        _CLASS_ZONE_INSTANCE.append(ZoneInfoFile(getzoneinfofile_stream()))\n    return _CLASS_ZONE_INSTANCE[0].zones.get(name)\n\n\ndef gettz_db_metadata():\n    \"\"\" Get the zonefile metadata\n\n    See `zonefile_metadata`_\n\n    :returns:\n        A dictionary with the database metadata\n\n    .. deprecated:: 2.6\n        See deprecation warning in :func:`zoneinfo.gettz`. To get metadata,\n        query the attribute ``zoneinfo.ZoneInfoFile.metadata``.\n    \"\"\"\n    warnings.warn(\"zoneinfo.gettz_db_metadata() will be removed in future \"\n                  \"versions, to use the dateutil-provided zoneinfo files, \"\n                  \"ZoneInfoFile object and query the 'metadata' attribute \"\n                  \"instead. See the documentation for details.\",\n                  DeprecationWarning)\n\n    if len(_CLASS_ZONE_INSTANCE) == 0:\n        _CLASS_ZONE_INSTANCE.append(ZoneInfoFile(getzoneinfofile_stream()))\n    return _CLASS_ZONE_INSTANCE[0].metadata\n"}