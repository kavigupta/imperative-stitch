{"noxfile.py": "from pathlib import Path\nfrom tempfile import TemporaryDirectory\nimport os\n\nimport nox\n\nROOT = Path(__file__).parent\nPYPROJECT = ROOT / \"pyproject.toml\"\nDOCS = ROOT / \"docs\"\nREFERENCING = ROOT / \"referencing\"\n\nREQUIREMENTS = dict(\n    docs=DOCS / \"requirements.txt\",\n    tests=ROOT / \"test-requirements.txt\",\n)\nREQUIREMENTS_IN = [  # this is actually ordered, as files depend on each other\n    (path.parent / f\"{path.stem}.in\", path) for path in REQUIREMENTS.values()\n]\n\nSUPPORTED = [\"3.8\", \"3.9\", \"3.10\", \"pypy3.10\", \"3.11\", \"3.12\"]\nLATEST = SUPPORTED[-1]\n\nnox.options.default_venv_backend = \"uv|virtualenv\"\nnox.options.sessions = []\n\n\ndef session(default=True, python=LATEST, **kwargs):  # noqa: D103\n    def _session(fn):\n        if default:\n            nox.options.sessions.append(kwargs.get(\"name\", fn.__name__))\n        return nox.session(python=python, **kwargs)(fn)\n\n    return _session\n\n\n@session(python=SUPPORTED)\ndef tests(session):\n    \"\"\"\n    Run the test suite with a corresponding Python version.\n    \"\"\"\n    session.install(\"-r\", REQUIREMENTS[\"tests\"])\n\n    if session.posargs and session.posargs[0] == \"coverage\":\n        if len(session.posargs) > 1 and session.posargs[1] == \"github\":\n            github = Path(os.environ[\"GITHUB_STEP_SUMMARY\"])\n        else:\n            github = None\n\n        session.install(\"coverage[toml]\")\n        session.run(\"coverage\", \"run\", \"-m\", \"pytest\", REFERENCING)\n        if github is None:\n            session.run(\"coverage\", \"report\")\n        else:\n            with github.open(\"a\") as summary:\n                summary.write(\"### Coverage\\n\\n\")\n                summary.flush()  # without a flush, output seems out of order.\n                session.run(\n                    \"coverage\",\n                    \"report\",\n                    \"--format=markdown\",\n                    stdout=summary,\n                )\n    else:\n        session.run(\"pytest\", *session.posargs, REFERENCING)\n\n\n@session()\ndef audit(session):\n    \"\"\"\n    Audit dependencies for vulnerabilities.\n    \"\"\"\n    session.install(\"pip-audit\", ROOT)\n    session.run(\"python\", \"-m\", \"pip_audit\")\n\n\n@session(tags=[\"build\"])\ndef build(session):\n    \"\"\"\n    Build a distribution suitable for PyPI and check its validity.\n    \"\"\"\n    session.install(\"build\", \"twine\")\n    with TemporaryDirectory() as tmpdir:\n        session.run(\"python\", \"-m\", \"build\", ROOT, \"--outdir\", tmpdir)\n        session.run(\"twine\", \"check\", \"--strict\", tmpdir + \"/*\")\n\n\n@session(tags=[\"style\"])\ndef style(session):\n    \"\"\"\n    Check Python code style.\n    \"\"\"\n    session.install(\"ruff\")\n    session.run(\"ruff\", \"check\", ROOT, __file__)\n\n\n@session()\ndef typing(session):\n    \"\"\"\n    Check static typing.\n    \"\"\"\n    session.install(\"pyright<1.1.354\", ROOT)\n    session.run(\"pyright\", *session.posargs, REFERENCING)\n\n\n@session()\ndef mypy(session):\n    \"\"\"\n    Check that mypy runs with no blocking errors.\n    \"\"\"\n    session.install(\"mypy\", ROOT)\n    session.run(\"mypy\", REFERENCING)\n\n\n@session(tags=[\"docs\"])\n@nox.parametrize(\n    \"builder\",\n    [\n        nox.param(name, id=name)\n        for name in [\n            \"dirhtml\",\n            \"doctest\",\n            \"linkcheck\",\n            \"man\",\n            \"spelling\",\n        ]\n    ],\n)\ndef docs(session, builder):\n    \"\"\"\n    Build the documentation using a specific Sphinx builder.\n    \"\"\"\n    session.install(\"-r\", REQUIREMENTS[\"docs\"])\n    with TemporaryDirectory() as tmpdir_str:\n        tmpdir = Path(tmpdir_str)\n        argv = [\"-n\", \"-T\", \"-W\"]\n        if builder != \"spelling\":\n            argv += [\"-q\"]\n        posargs = session.posargs or [tmpdir / builder]\n        session.run(\n            \"python\",\n            \"-m\",\n            \"sphinx\",\n            \"-b\",\n            builder,\n            DOCS,\n            *argv,\n            *posargs,\n        )\n\n\n@session(tags=[\"docs\", \"style\"], name=\"docs(style)\")\ndef docs_style(session):\n    \"\"\"\n    Check the documentation style.\n    \"\"\"\n    session.install(\n        \"doc8\",\n        \"pygments\",\n        \"pygments-github-lexers\",\n    )\n    session.run(\"python\", \"-m\", \"doc8\", \"--config\", PYPROJECT, DOCS)\n\n\n@session(default=False)\ndef requirements(session):\n    \"\"\"\n    Update the project's pinned requirements.\n\n    You should commit the result afterwards.\n    \"\"\"\n    if session.venv_backend == \"uv\":\n        cmd = [\"uv\", \"pip\", \"compile\"]\n    else:\n        session.install(\"pip-tools\")\n        cmd = [\"pip-compile\", \"--resolver\", \"backtracking\", \"--strip-extras\"]\n\n    for each, out in REQUIREMENTS_IN:\n        # otherwise output files end up with silly absolute path comments...\n        relative = each.relative_to(ROOT)\n        session.run(*cmd, \"--upgrade\", \"--output-file\", out, relative)\n", "referencing/exceptions.py": "\"\"\"\nErrors, oh no!\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING, Any\n\nimport attrs\n\nfrom referencing._attrs import frozen\n\nif TYPE_CHECKING:\n    from referencing import Resource\n    from referencing.typing import URI\n\n\n@frozen\nclass NoSuchResource(KeyError):\n    \"\"\"\n    The given URI is not present in a registry.\n\n    Unlike most exceptions, this class *is* intended to be publicly\n    instantiable and *is* part of the public API of the package.\n    \"\"\"\n\n    ref: URI\n\n    def __eq__(self, other: object) -> bool:\n        if self.__class__ is not other.__class__:\n            return NotImplemented\n        return attrs.astuple(self) == attrs.astuple(other)\n\n    def __hash__(self) -> int:\n        return hash(attrs.astuple(self))\n\n\n@frozen\nclass NoInternalID(Exception):\n    \"\"\"\n    A resource has no internal ID, but one is needed.\n\n    E.g. in modern JSON Schema drafts, this is the :kw:`$id` keyword.\n\n    One might be needed if a resource was to-be added to a registry but no\n    other URI is available, and the resource doesn't declare its canonical URI.\n    \"\"\"\n\n    resource: Resource[Any]\n\n    def __eq__(self, other: object) -> bool:\n        if self.__class__ is not other.__class__:\n            return NotImplemented\n        return attrs.astuple(self) == attrs.astuple(other)\n\n    def __hash__(self) -> int:\n        return hash(attrs.astuple(self))\n\n\n@frozen\nclass Unretrievable(KeyError):\n    \"\"\"\n    The given URI is not present in a registry, and retrieving it failed.\n    \"\"\"\n\n    ref: URI\n\n    def __eq__(self, other: object) -> bool:\n        if self.__class__ is not other.__class__:\n            return NotImplemented\n        return attrs.astuple(self) == attrs.astuple(other)\n\n    def __hash__(self) -> int:\n        return hash(attrs.astuple(self))\n\n\n@frozen\nclass CannotDetermineSpecification(Exception):\n    \"\"\"\n    Attempting to detect the appropriate `Specification` failed.\n\n    This happens if no discernible information is found in the contents of the\n    new resource which would help identify it.\n    \"\"\"\n\n    contents: Any\n\n    def __eq__(self, other: object) -> bool:\n        if self.__class__ is not other.__class__:\n            return NotImplemented\n        return attrs.astuple(self) == attrs.astuple(other)\n\n    def __hash__(self) -> int:\n        return hash(attrs.astuple(self))\n\n\n@attrs.frozen  # Because here we allow subclassing below.\nclass Unresolvable(Exception):\n    \"\"\"\n    A reference was unresolvable.\n    \"\"\"\n\n    ref: URI\n\n    def __eq__(self, other: object) -> bool:\n        if self.__class__ is not other.__class__:\n            return NotImplemented\n        return attrs.astuple(self) == attrs.astuple(other)\n\n    def __hash__(self) -> int:\n        return hash(attrs.astuple(self))\n\n\n@frozen\nclass PointerToNowhere(Unresolvable):\n    \"\"\"\n    A JSON Pointer leads to a part of a document that does not exist.\n    \"\"\"\n\n    resource: Resource[Any]\n\n    def __str__(self) -> str:\n        msg = f\"{self.ref!r} does not exist within {self.resource.contents!r}\"\n        if self.ref == \"/\":\n            msg += (\n                \". The pointer '/' is a valid JSON Pointer but it points to \"\n                \"an empty string property ''. If you intended to point \"\n                \"to the entire resource, you should use '#'.\"\n            )\n        return msg\n\n\n@frozen\nclass NoSuchAnchor(Unresolvable):\n    \"\"\"\n    An anchor does not exist within a particular resource.\n    \"\"\"\n\n    resource: Resource[Any]\n    anchor: str\n\n    def __str__(self) -> str:\n        return (\n            f\"{self.anchor!r} does not exist within {self.resource.contents!r}\"\n        )\n\n\n@frozen\nclass InvalidAnchor(Unresolvable):\n    \"\"\"\n    An anchor which could never exist in a resource was dereferenced.\n\n    It is somehow syntactically invalid.\n    \"\"\"\n\n    resource: Resource[Any]\n    anchor: str\n\n    def __str__(self) -> str:\n        return (\n            f\"'#{self.anchor}' is not a valid anchor, neither as a \"\n            \"plain name anchor nor as a JSON Pointer. You may have intended \"\n            f\"to use '#/{self.anchor}', as the slash is required *before each \"\n            \"segment* of a JSON pointer.\"\n        )\n", "referencing/typing.py": "\"\"\"\nType-annotation related support for the referencing library.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING, Protocol, TypeVar\n\ntry:\n    from collections.abc import Mapping as Mapping\n\n    Mapping[str, str]\nexcept TypeError:  # pragma: no cover\n    from typing import Mapping as Mapping\n\n\nif TYPE_CHECKING:\n    from referencing._core import Resolved, Resolver, Resource\n\n#: A URI which identifies a `Resource`.\nURI = str\n\n#: The type of documents within a registry.\nD = TypeVar(\"D\")\n\n\nclass Retrieve(Protocol[D]):\n    \"\"\"\n    A retrieval callable, usable within a `Registry` for resource retrieval.\n\n    Does not make assumptions about where the resource might be coming from.\n    \"\"\"\n\n    def __call__(self, uri: URI) -> Resource[D]:\n        \"\"\"\n        Retrieve the resource with the given URI.\n\n        Raise `referencing.exceptions.NoSuchResource` if you wish to indicate\n        the retriever cannot lookup the given URI.\n        \"\"\"\n        ...\n\n\nclass Anchor(Protocol[D]):\n    \"\"\"\n    An anchor within a `Resource`.\n\n    Beyond \"simple\" anchors, some specifications like JSON Schema's 2020\n    version have dynamic anchors.\n    \"\"\"\n\n    @property\n    def name(self) -> str:\n        \"\"\"\n        Return the name of this anchor.\n        \"\"\"\n        ...\n\n    def resolve(self, resolver: Resolver[D]) -> Resolved[D]:\n        \"\"\"\n        Return the resource for this anchor.\n        \"\"\"\n        ...\n", "referencing/retrieval.py": "\"\"\"\nHelpers related to (dynamic) resource retrieval.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom functools import lru_cache\nfrom typing import TYPE_CHECKING, Callable, TypeVar\nimport json\n\nfrom referencing import Resource\n\nif TYPE_CHECKING:\n    from referencing.typing import URI, D, Retrieve\n\n#: A serialized document (e.g. a JSON string)\n_T = TypeVar(\"_T\")\n\n\ndef to_cached_resource(\n    cache: Callable[[Retrieve[D]], Retrieve[D]] | None = None,\n    loads: Callable[[_T], D] = json.loads,\n    from_contents: Callable[[D], Resource[D]] = Resource.from_contents,\n) -> Callable[[Callable[[URI], _T]], Retrieve[D]]:\n    \"\"\"\n    Create a retriever which caches its return values from a simpler callable.\n\n    Takes a function which returns things like serialized JSON (strings) and\n    returns something suitable for passing to `Registry` as a retrieve\n    function.\n\n    This decorator both reduces a small bit of boilerplate for a common case\n    (deserializing JSON from strings and creating `Resource` objects from the\n    result) as well as makes the probable need for caching a bit easier.\n    Retrievers which otherwise do expensive operations (like hitting the\n    network) might otherwise be called repeatedly.\n\n    Examples\n    --------\n\n    .. testcode::\n\n        from referencing import Registry\n        from referencing.typing import URI\n        import referencing.retrieval\n\n\n        @referencing.retrieval.to_cached_resource()\n        def retrieve(uri: URI):\n            print(f\"Retrieved {uri}\")\n\n            # Normally, go get some expensive JSON from the network, a file ...\n            return '''\n                {\n                    \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n                    \"foo\": \"bar\"\n                }\n            '''\n\n        one = Registry(retrieve=retrieve).get_or_retrieve(\"urn:example:foo\")\n        print(one.value.contents[\"foo\"])\n\n        # Retrieving the same URI again reuses the same value (and thus doesn't\n        # print another retrieval message here)\n        two = Registry(retrieve=retrieve).get_or_retrieve(\"urn:example:foo\")\n        print(two.value.contents[\"foo\"])\n\n    .. testoutput::\n\n        Retrieved urn:example:foo\n        bar\n        bar\n\n    \"\"\"\n    if cache is None:\n        cache = lru_cache(maxsize=None)\n\n    def decorator(retrieve: Callable[[URI], _T]):\n        @cache\n        def cached_retrieve(uri: URI):\n            response = retrieve(uri)\n            contents = loads(response)\n            return from_contents(contents)\n\n        return cached_retrieve\n\n    return decorator\n", "referencing/_attrs.py": "from __future__ import annotations\n\nfrom typing import NoReturn, TypeVar\n\nfrom attrs import define as _define, frozen as _frozen\n\n_T = TypeVar(\"_T\")\n\n\ndef define(cls: type[_T]) -> type[_T]:  # pragma: no cover\n    cls.__init_subclass__ = _do_not_subclass\n    return _define(cls)\n\n\ndef frozen(cls: type[_T]) -> type[_T]:\n    cls.__init_subclass__ = _do_not_subclass\n    return _frozen(cls)\n\n\nclass UnsupportedSubclassing(Exception):\n    def __str__(self):\n        return (\n            \"Subclassing is not part of referencing's public API. \"\n            \"If no other suitable API exists for what you're trying to do, \"\n            \"feel free to file an issue asking for one.\"\n        )\n\n\n@staticmethod\ndef _do_not_subclass() -> NoReturn:  # pragma: no cover\n    raise UnsupportedSubclassing()\n", "referencing/jsonschema.py": "\"\"\"\nReferencing implementations for JSON Schema specs (historic & current).\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom collections.abc import Sequence, Set\nfrom typing import Any, Iterable, Union\n\nfrom referencing import Anchor, Registry, Resource, Specification, exceptions\nfrom referencing._attrs import frozen\nfrom referencing._core import (\n    _UNSET,  # type: ignore[reportPrivateUsage]\n    Resolved as _Resolved,\n    Resolver as _Resolver,\n    _Unset,  # type: ignore[reportPrivateUsage]\n)\nfrom referencing.typing import URI, Anchor as AnchorType, Mapping\n\n#: A JSON Schema which is a JSON object\nObjectSchema = Mapping[str, Any]\n\n#: A JSON Schema of any kind\nSchema = Union[bool, ObjectSchema]\n\n#: A Resource whose contents are JSON Schemas\nSchemaResource = Resource[Schema]\n\n#: A JSON Schema Registry\nSchemaRegistry = Registry[Schema]\n\n#: The empty JSON Schema Registry\nEMPTY_REGISTRY: SchemaRegistry = Registry()\n\n\n@frozen\nclass UnknownDialect(Exception):\n    \"\"\"\n    A dialect identifier was found for a dialect unknown by this library.\n\n    If it's a custom (\"unofficial\") dialect, be sure you've registered it.\n    \"\"\"\n\n    uri: URI\n\n\ndef _dollar_id(contents: Schema) -> URI | None:\n    if isinstance(contents, bool):\n        return\n    return contents.get(\"$id\")\n\n\ndef _legacy_dollar_id(contents: Schema) -> URI | None:\n    if isinstance(contents, bool) or \"$ref\" in contents:\n        return\n    id = contents.get(\"$id\")\n    if id is not None and not id.startswith(\"#\"):\n        return id\n\n\ndef _legacy_id(contents: ObjectSchema) -> URI | None:\n    if \"$ref\" in contents:\n        return\n    id = contents.get(\"id\")\n    if id is not None and not id.startswith(\"#\"):\n        return id\n\n\ndef _anchor(\n    specification: Specification[Schema],\n    contents: Schema,\n) -> Iterable[AnchorType[Schema]]:\n    if isinstance(contents, bool):\n        return\n    anchor = contents.get(\"$anchor\")\n    if anchor is not None:\n        yield Anchor(\n            name=anchor,\n            resource=specification.create_resource(contents),\n        )\n\n    dynamic_anchor = contents.get(\"$dynamicAnchor\")\n    if dynamic_anchor is not None:\n        yield DynamicAnchor(\n            name=dynamic_anchor,\n            resource=specification.create_resource(contents),\n        )\n\n\ndef _anchor_2019(\n    specification: Specification[Schema],\n    contents: Schema,\n) -> Iterable[Anchor[Schema]]:\n    if isinstance(contents, bool):\n        return []\n    anchor = contents.get(\"$anchor\")\n    if anchor is None:\n        return []\n    return [\n        Anchor(\n            name=anchor,\n            resource=specification.create_resource(contents),\n        ),\n    ]\n\n\ndef _legacy_anchor_in_dollar_id(\n    specification: Specification[Schema],\n    contents: Schema,\n) -> Iterable[Anchor[Schema]]:\n    if isinstance(contents, bool):\n        return []\n    id = contents.get(\"$id\", \"\")\n    if not id.startswith(\"#\"):\n        return []\n    return [\n        Anchor(\n            name=id[1:],\n            resource=specification.create_resource(contents),\n        ),\n    ]\n\n\ndef _legacy_anchor_in_id(\n    specification: Specification[ObjectSchema],\n    contents: ObjectSchema,\n) -> Iterable[Anchor[ObjectSchema]]:\n    id = contents.get(\"id\", \"\")\n    if not id.startswith(\"#\"):\n        return []\n    return [\n        Anchor(\n            name=id[1:],\n            resource=specification.create_resource(contents),\n        ),\n    ]\n\n\ndef _subresources_of(\n    in_value: Set[str] = frozenset(),\n    in_subvalues: Set[str] = frozenset(),\n    in_subarray: Set[str] = frozenset(),\n):\n    \"\"\"\n    Create a callable returning JSON Schema specification-style subschemas.\n\n    Relies on specifying the set of keywords containing subschemas in their\n    values, in a subobject's values, or in a subarray.\n    \"\"\"\n\n    def subresources_of(contents: Schema) -> Iterable[ObjectSchema]:\n        if isinstance(contents, bool):\n            return\n        for each in in_value:\n            if each in contents:\n                yield contents[each]\n        for each in in_subarray:\n            if each in contents:\n                yield from contents[each]\n        for each in in_subvalues:\n            if each in contents:\n                yield from contents[each].values()\n\n    return subresources_of\n\n\ndef _subresources_of_with_crazy_items(\n    in_value: Set[str] = frozenset(),\n    in_subvalues: Set[str] = frozenset(),\n    in_subarray: Set[str] = frozenset(),\n):\n    \"\"\"\n    Specifically handle older drafts where there are some funky keywords.\n    \"\"\"\n\n    def subresources_of(contents: Schema) -> Iterable[ObjectSchema]:\n        if isinstance(contents, bool):\n            return\n        for each in in_value:\n            if each in contents:\n                yield contents[each]\n        for each in in_subarray:\n            if each in contents:\n                yield from contents[each]\n        for each in in_subvalues:\n            if each in contents:\n                yield from contents[each].values()\n\n        items = contents.get(\"items\")\n        if items is not None:\n            if isinstance(items, Sequence):\n                yield from items\n            else:\n                yield items\n\n    return subresources_of\n\n\ndef _subresources_of_with_crazy_items_dependencies(\n    in_value: Set[str] = frozenset(),\n    in_subvalues: Set[str] = frozenset(),\n    in_subarray: Set[str] = frozenset(),\n):\n    \"\"\"\n    Specifically handle older drafts where there are some funky keywords.\n    \"\"\"\n\n    def subresources_of(contents: Schema) -> Iterable[ObjectSchema]:\n        if isinstance(contents, bool):\n            return\n        for each in in_value:\n            if each in contents:\n                yield contents[each]\n        for each in in_subarray:\n            if each in contents:\n                yield from contents[each]\n        for each in in_subvalues:\n            if each in contents:\n                yield from contents[each].values()\n\n        items = contents.get(\"items\")\n        if items is not None:\n            if isinstance(items, Sequence):\n                yield from items\n            else:\n                yield items\n        dependencies = contents.get(\"dependencies\")\n        if dependencies is not None:\n            values = iter(dependencies.values())\n            value = next(values, None)\n            if isinstance(value, Mapping):\n                yield value\n                yield from values\n\n    return subresources_of\n\n\ndef _subresources_of_with_crazy_aP_items_dependencies(\n    in_value: Set[str] = frozenset(),\n    in_subvalues: Set[str] = frozenset(),\n    in_subarray: Set[str] = frozenset(),\n):\n    \"\"\"\n    Specifically handle even older drafts where there are some funky keywords.\n    \"\"\"\n\n    def subresources_of(contents: ObjectSchema) -> Iterable[ObjectSchema]:\n        for each in in_value:\n            if each in contents:\n                yield contents[each]\n        for each in in_subarray:\n            if each in contents:\n                yield from contents[each]\n        for each in in_subvalues:\n            if each in contents:\n                yield from contents[each].values()\n\n        items = contents.get(\"items\")\n        if items is not None:\n            if isinstance(items, Sequence):\n                yield from items\n            else:\n                yield items\n        dependencies = contents.get(\"dependencies\")\n        if dependencies is not None:\n            values = iter(dependencies.values())\n            value = next(values, None)\n            if isinstance(value, Mapping):\n                yield value\n                yield from values\n\n        for each in \"additionalItems\", \"additionalProperties\":\n            value = contents.get(each)\n            if isinstance(value, Mapping):\n                yield value\n\n    return subresources_of\n\n\ndef _maybe_in_subresource(\n    in_value: Set[str] = frozenset(),\n    in_subvalues: Set[str] = frozenset(),\n    in_subarray: Set[str] = frozenset(),\n):\n    in_child = in_subvalues | in_subarray\n\n    def maybe_in_subresource(\n        segments: Sequence[int | str],\n        resolver: _Resolver[Any],\n        subresource: Resource[Any],\n    ) -> _Resolver[Any]:\n        _segments = iter(segments)\n        for segment in _segments:\n            if segment not in in_value and (\n                segment not in in_child or next(_segments, None) is None\n            ):\n                return resolver\n        return resolver.in_subresource(subresource)\n\n    return maybe_in_subresource\n\n\ndef _maybe_in_subresource_crazy_items(\n    in_value: Set[str] = frozenset(),\n    in_subvalues: Set[str] = frozenset(),\n    in_subarray: Set[str] = frozenset(),\n):\n    in_child = in_subvalues | in_subarray\n\n    def maybe_in_subresource(\n        segments: Sequence[int | str],\n        resolver: _Resolver[Any],\n        subresource: Resource[Any],\n    ) -> _Resolver[Any]:\n        _segments = iter(segments)\n        for segment in _segments:\n            if segment == \"items\" and isinstance(\n                subresource.contents,\n                Mapping,\n            ):\n                return resolver.in_subresource(subresource)\n            if segment not in in_value and (\n                segment not in in_child or next(_segments, None) is None\n            ):\n                return resolver\n        return resolver.in_subresource(subresource)\n\n    return maybe_in_subresource\n\n\ndef _maybe_in_subresource_crazy_items_dependencies(\n    in_value: Set[str] = frozenset(),\n    in_subvalues: Set[str] = frozenset(),\n    in_subarray: Set[str] = frozenset(),\n):\n    in_child = in_subvalues | in_subarray\n\n    def maybe_in_subresource(\n        segments: Sequence[int | str],\n        resolver: _Resolver[Any],\n        subresource: Resource[Any],\n    ) -> _Resolver[Any]:\n        _segments = iter(segments)\n        for segment in _segments:\n            if segment in {\"items\", \"dependencies\"} and isinstance(\n                subresource.contents,\n                Mapping,\n            ):\n                return resolver.in_subresource(subresource)\n            if segment not in in_value and (\n                segment not in in_child or next(_segments, None) is None\n            ):\n                return resolver\n        return resolver.in_subresource(subresource)\n\n    return maybe_in_subresource\n\n\n#: JSON Schema draft 2020-12\nDRAFT202012 = Specification(\n    name=\"draft2020-12\",\n    id_of=_dollar_id,\n    subresources_of=_subresources_of(\n        in_value={\n            \"additionalProperties\",\n            \"contains\",\n            \"contentSchema\",\n            \"else\",\n            \"if\",\n            \"items\",\n            \"not\",\n            \"propertyNames\",\n            \"then\",\n            \"unevaluatedItems\",\n            \"unevaluatedProperties\",\n        },\n        in_subarray={\"allOf\", \"anyOf\", \"oneOf\", \"prefixItems\"},\n        in_subvalues={\n            \"$defs\",\n            \"definitions\",\n            \"dependentSchemas\",\n            \"patternProperties\",\n            \"properties\",\n        },\n    ),\n    anchors_in=_anchor,\n    maybe_in_subresource=_maybe_in_subresource(\n        in_value={\n            \"additionalProperties\",\n            \"contains\",\n            \"contentSchema\",\n            \"else\",\n            \"if\",\n            \"items\",\n            \"not\",\n            \"propertyNames\",\n            \"then\",\n            \"unevaluatedItems\",\n            \"unevaluatedProperties\",\n        },\n        in_subarray={\"allOf\", \"anyOf\", \"oneOf\", \"prefixItems\"},\n        in_subvalues={\n            \"$defs\",\n            \"definitions\",\n            \"dependentSchemas\",\n            \"patternProperties\",\n            \"properties\",\n        },\n    ),\n)\n#: JSON Schema draft 2019-09\nDRAFT201909 = Specification(\n    name=\"draft2019-09\",\n    id_of=_dollar_id,\n    subresources_of=_subresources_of_with_crazy_items(\n        in_value={\n            \"additionalItems\",\n            \"additionalProperties\",\n            \"contains\",\n            \"contentSchema\",\n            \"else\",\n            \"if\",\n            \"not\",\n            \"propertyNames\",\n            \"then\",\n            \"unevaluatedItems\",\n            \"unevaluatedProperties\",\n        },\n        in_subarray={\"allOf\", \"anyOf\", \"oneOf\"},\n        in_subvalues={\n            \"$defs\",\n            \"definitions\",\n            \"dependentSchemas\",\n            \"patternProperties\",\n            \"properties\",\n        },\n    ),\n    anchors_in=_anchor_2019,  # type: ignore[reportGeneralTypeIssues]  # TODO: check whether this is real\n    maybe_in_subresource=_maybe_in_subresource_crazy_items(\n        in_value={\n            \"additionalItems\",\n            \"additionalProperties\",\n            \"contains\",\n            \"contentSchema\",\n            \"else\",\n            \"if\",\n            \"not\",\n            \"propertyNames\",\n            \"then\",\n            \"unevaluatedItems\",\n            \"unevaluatedProperties\",\n        },\n        in_subarray={\"allOf\", \"anyOf\", \"oneOf\"},\n        in_subvalues={\n            \"$defs\",\n            \"definitions\",\n            \"dependentSchemas\",\n            \"patternProperties\",\n            \"properties\",\n        },\n    ),\n)\n#: JSON Schema draft 7\nDRAFT7 = Specification(\n    name=\"draft-07\",\n    id_of=_legacy_dollar_id,\n    subresources_of=_subresources_of_with_crazy_items_dependencies(\n        in_value={\n            \"additionalItems\",\n            \"additionalProperties\",\n            \"contains\",\n            \"else\",\n            \"if\",\n            \"not\",\n            \"propertyNames\",\n            \"then\",\n        },\n        in_subarray={\"allOf\", \"anyOf\", \"oneOf\"},\n        in_subvalues={\"definitions\", \"patternProperties\", \"properties\"},\n    ),\n    anchors_in=_legacy_anchor_in_dollar_id,  # type: ignore[reportGeneralTypeIssues]  # TODO: check whether this is real\n    maybe_in_subresource=_maybe_in_subresource_crazy_items_dependencies(\n        in_value={\n            \"additionalItems\",\n            \"additionalProperties\",\n            \"contains\",\n            \"else\",\n            \"if\",\n            \"not\",\n            \"propertyNames\",\n            \"then\",\n        },\n        in_subarray={\"allOf\", \"anyOf\", \"oneOf\"},\n        in_subvalues={\"definitions\", \"patternProperties\", \"properties\"},\n    ),\n)\n#: JSON Schema draft 6\nDRAFT6 = Specification(\n    name=\"draft-06\",\n    id_of=_legacy_dollar_id,\n    subresources_of=_subresources_of_with_crazy_items_dependencies(\n        in_value={\n            \"additionalItems\",\n            \"additionalProperties\",\n            \"contains\",\n            \"not\",\n            \"propertyNames\",\n        },\n        in_subarray={\"allOf\", \"anyOf\", \"oneOf\"},\n        in_subvalues={\"definitions\", \"patternProperties\", \"properties\"},\n    ),\n    anchors_in=_legacy_anchor_in_dollar_id,  # type: ignore[reportGeneralTypeIssues]  # TODO: check whether this is real\n    maybe_in_subresource=_maybe_in_subresource_crazy_items_dependencies(\n        in_value={\n            \"additionalItems\",\n            \"additionalProperties\",\n            \"contains\",\n            \"not\",\n            \"propertyNames\",\n        },\n        in_subarray={\"allOf\", \"anyOf\", \"oneOf\"},\n        in_subvalues={\"definitions\", \"patternProperties\", \"properties\"},\n    ),\n)\n#: JSON Schema draft 4\nDRAFT4 = Specification(\n    name=\"draft-04\",\n    id_of=_legacy_id,\n    subresources_of=_subresources_of_with_crazy_aP_items_dependencies(\n        in_value={\"not\"},\n        in_subarray={\"allOf\", \"anyOf\", \"oneOf\"},\n        in_subvalues={\"definitions\", \"patternProperties\", \"properties\"},\n    ),\n    anchors_in=_legacy_anchor_in_id,\n    maybe_in_subresource=_maybe_in_subresource_crazy_items_dependencies(\n        in_value={\"additionalItems\", \"additionalProperties\", \"not\"},\n        in_subarray={\"allOf\", \"anyOf\", \"oneOf\"},\n        in_subvalues={\"definitions\", \"patternProperties\", \"properties\"},\n    ),\n)\n#: JSON Schema draft 3\nDRAFT3 = Specification(\n    name=\"draft-03\",\n    id_of=_legacy_id,\n    subresources_of=_subresources_of_with_crazy_aP_items_dependencies(\n        in_subarray={\"extends\"},\n        in_subvalues={\"definitions\", \"patternProperties\", \"properties\"},\n    ),\n    anchors_in=_legacy_anchor_in_id,\n    maybe_in_subresource=_maybe_in_subresource_crazy_items_dependencies(\n        in_value={\"additionalItems\", \"additionalProperties\"},\n        in_subarray={\"extends\"},\n        in_subvalues={\"definitions\", \"patternProperties\", \"properties\"},\n    ),\n)\n\n\n_SPECIFICATIONS: Registry[Specification[Schema]] = Registry(\n    {  # type: ignore[reportGeneralTypeIssues]  # :/ internal vs external types\n        dialect_id: Resource.opaque(specification)\n        for dialect_id, specification in [\n            (\"https://json-schema.org/draft/2020-12/schema\", DRAFT202012),\n            (\"https://json-schema.org/draft/2019-09/schema\", DRAFT201909),\n            (\"http://json-schema.org/draft-07/schema\", DRAFT7),\n            (\"http://json-schema.org/draft-06/schema\", DRAFT6),\n            (\"http://json-schema.org/draft-04/schema\", DRAFT4),\n            (\"http://json-schema.org/draft-03/schema\", DRAFT3),\n        ]\n    },\n)\n\n\ndef specification_with(\n    dialect_id: URI,\n    default: Specification[Any] | _Unset = _UNSET,\n) -> Specification[Any]:\n    \"\"\"\n    Retrieve the `Specification` with the given dialect identifier.\n\n    Raises:\n\n        `UnknownDialect`\n\n            if the given ``dialect_id`` isn't known\n\n    \"\"\"\n    resource = _SPECIFICATIONS.get(dialect_id.rstrip(\"#\"))\n    if resource is not None:\n        return resource.contents\n    if default is _UNSET:\n        raise UnknownDialect(dialect_id)\n    return default\n\n\n@frozen\nclass DynamicAnchor:\n    \"\"\"\n    Dynamic anchors, introduced in draft 2020.\n    \"\"\"\n\n    name: str\n    resource: SchemaResource\n\n    def resolve(self, resolver: _Resolver[Schema]) -> _Resolved[Schema]:\n        \"\"\"\n        Resolve this anchor dynamically.\n        \"\"\"\n        last = self.resource\n        for uri, registry in resolver.dynamic_scope():\n            try:\n                anchor = registry.anchor(uri, self.name).value\n            except exceptions.NoSuchAnchor:\n                continue\n            if isinstance(anchor, DynamicAnchor):\n                last = anchor.resource\n        return _Resolved(\n            contents=last.contents,\n            resolver=resolver.in_subresource(last),\n        )\n\n\ndef lookup_recursive_ref(resolver: _Resolver[Schema]) -> _Resolved[Schema]:\n    \"\"\"\n    Recursive references (via recursive anchors), present only in draft 2019.\n\n    As per the 2019 specification (\u00a7 8.2.4.2.1), only the ``#`` recursive\n    reference is supported (and is therefore assumed to be the relevant\n    reference).\n    \"\"\"\n    resolved = resolver.lookup(\"#\")\n    if isinstance(resolved.contents, Mapping) and resolved.contents.get(\n        \"$recursiveAnchor\",\n    ):\n        for uri, _ in resolver.dynamic_scope():\n            next_resolved = resolver.lookup(uri)\n            if not isinstance(\n                next_resolved.contents,\n                Mapping,\n            ) or not next_resolved.contents.get(\"$recursiveAnchor\"):\n                break\n            resolved = next_resolved\n    return resolved\n", "referencing/__init__.py": "\"\"\"\nCross-specification, implementation-agnostic JSON referencing.\n\"\"\"\n\nfrom referencing._core import Anchor, Registry, Resource, Specification\n\n__all__ = [\"Anchor\", \"Registry\", \"Resource\", \"Specification\"]\n", "referencing/_core.py": "from __future__ import annotations\n\nfrom collections.abc import Iterable, Iterator, Sequence\nfrom enum import Enum\nfrom typing import Any, Callable, ClassVar, Generic, Protocol, TypeVar\nfrom urllib.parse import unquote, urldefrag, urljoin\n\nfrom attrs import evolve, field\nfrom rpds import HashTrieMap, HashTrieSet, List\n\nfrom referencing import exceptions\nfrom referencing._attrs import frozen\nfrom referencing.typing import URI, Anchor as AnchorType, D, Mapping, Retrieve\n\nEMPTY_UNCRAWLED: HashTrieSet[URI] = HashTrieSet()\nEMPTY_PREVIOUS_RESOLVERS: List[URI] = List()\n\n\nclass _Unset(Enum):\n    \"\"\"\n    What sillyness...\n    \"\"\"\n\n    SENTINEL = 1\n\n\n_UNSET = _Unset.SENTINEL\n\n\nclass _MaybeInSubresource(Protocol[D]):\n    def __call__(\n        self,\n        segments: Sequence[int | str],\n        resolver: Resolver[D],\n        subresource: Resource[D],\n    ) -> Resolver[D]: ...\n\n\ndef _detect_or_error(contents: D) -> Specification[D]:\n    if not isinstance(contents, Mapping):\n        raise exceptions.CannotDetermineSpecification(contents)\n\n    jsonschema_dialect_id = contents.get(\"$schema\")  # type: ignore[reportUnknownMemberType]\n    if not isinstance(jsonschema_dialect_id, str):\n        raise exceptions.CannotDetermineSpecification(contents)\n\n    from referencing.jsonschema import specification_with\n\n    return specification_with(jsonschema_dialect_id)\n\n\ndef _detect_or_default(\n    default: Specification[D],\n) -> Callable[[D], Specification[D]]:\n    def _detect(contents: D) -> Specification[D]:\n        if not isinstance(contents, Mapping):\n            return default\n\n        jsonschema_dialect_id = contents.get(\"$schema\")  # type: ignore[reportUnknownMemberType]\n        if jsonschema_dialect_id is None:\n            return default\n\n        from referencing.jsonschema import specification_with\n\n        return specification_with(\n            jsonschema_dialect_id,  # type: ignore[reportUnknownArgumentType]\n            default=default,\n        )\n\n    return _detect\n\n\nclass _SpecificationDetector:\n    def __get__(\n        self,\n        instance: Specification[D] | None,\n        cls: type[Specification[D]],\n    ) -> Callable[[D], Specification[D]]:\n        if instance is None:\n            return _detect_or_error\n        else:\n            return _detect_or_default(instance)\n\n\n@frozen\nclass Specification(Generic[D]):\n    \"\"\"\n    A specification which defines referencing behavior.\n\n    The various methods of a `Specification` allow for varying referencing\n    behavior across JSON Schema specification versions, etc.\n    \"\"\"\n\n    #: A short human-readable name for the specification, used for debugging.\n    name: str\n\n    #: Find the ID of a given document.\n    id_of: Callable[[D], URI | None]\n\n    #: Retrieve the subresources of the given document (without traversing into\n    #: the subresources themselves).\n    subresources_of: Callable[[D], Iterable[D]]\n\n    #: While resolving a JSON pointer, conditionally enter a subresource\n    #: (if e.g. we have just entered a keyword whose value is a subresource)\n    maybe_in_subresource: _MaybeInSubresource[D]\n\n    #: Retrieve the anchors contained in the given document.\n    _anchors_in: Callable[\n        [Specification[D], D],\n        Iterable[AnchorType[D]],\n    ] = field(alias=\"anchors_in\")\n\n    #: An opaque specification where resources have no subresources\n    #: nor internal identifiers.\n    OPAQUE: ClassVar[Specification[Any]]\n\n    #: Attempt to discern which specification applies to the given contents.\n    #:\n    #: May be called either as an instance method or as a class method, with\n    #: slightly different behavior in the following case:\n    #:\n    #: Recall that not all contents contains enough internal information about\n    #: which specification it is written for -- the JSON Schema ``{}``,\n    #: for instance, is valid under many different dialects and may be\n    #: interpreted as any one of them.\n    #:\n    #: When this method is used as an instance method (i.e. called on a\n    #: specific specification), that specification is used as the default\n    #: if the given contents are unidentifiable.\n    #:\n    #: On the other hand when called as a class method, an error is raised.\n    #:\n    #: To reiterate, ``DRAFT202012.detect({})`` will return ``DRAFT202012``\n    #: whereas the class method ``Specification.detect({})`` will raise an\n    #: error.\n    #:\n    #: (Note that of course ``DRAFT202012.detect(...)`` may return some other\n    #: specification when given a schema which *does* identify as being for\n    #: another version).\n    #:\n    #: Raises:\n    #:\n    #:     `CannotDetermineSpecification`\n    #:\n    #:         if the given contents don't have any discernible\n    #:         information which could be used to guess which\n    #:         specification they identify as\n    detect = _SpecificationDetector()\n\n    def __repr__(self) -> str:\n        return f\"<Specification name={self.name!r}>\"\n\n    def anchors_in(self, contents: D):\n        \"\"\"\n        Retrieve the anchors contained in the given document.\n        \"\"\"\n        return self._anchors_in(self, contents)\n\n    def create_resource(self, contents: D) -> Resource[D]:\n        \"\"\"\n        Create a resource which is interpreted using this specification.\n        \"\"\"\n        return Resource(contents=contents, specification=self)\n\n\nSpecification.OPAQUE = Specification(\n    name=\"opaque\",\n    id_of=lambda contents: None,\n    subresources_of=lambda contents: [],\n    anchors_in=lambda specification, contents: [],\n    maybe_in_subresource=lambda segments, resolver, subresource: resolver,\n)\n\n\n@frozen\nclass Resource(Generic[D]):\n    r\"\"\"\n    A document (deserialized JSON) with a concrete interpretation under a spec.\n\n    In other words, a Python object, along with an instance of `Specification`\n    which describes how the document interacts with referencing -- both\n    internally (how it refers to other `Resource`\\ s) and externally (how it\n    should be identified such that it is referenceable by other documents).\n    \"\"\"\n\n    contents: D\n    _specification: Specification[D] = field(alias=\"specification\")\n\n    @classmethod\n    def from_contents(\n        cls,\n        contents: D,\n        default_specification: (\n            type[Specification[D]] | Specification[D]\n        ) = Specification,\n    ) -> Resource[D]:\n        \"\"\"\n        Create a resource guessing which specification applies to the contents.\n\n        Raises:\n\n            `CannotDetermineSpecification`\n\n                if the given contents don't have any discernible\n                information which could be used to guess which\n                specification they identify as\n\n        \"\"\"\n        specification = default_specification.detect(contents)\n        return specification.create_resource(contents=contents)\n\n    @classmethod\n    def opaque(cls, contents: D) -> Resource[D]:\n        \"\"\"\n        Create an opaque `Resource` -- i.e. one with opaque specification.\n\n        See `Specification.OPAQUE` for details.\n        \"\"\"\n        return Specification.OPAQUE.create_resource(contents=contents)\n\n    def id(self) -> URI | None:\n        \"\"\"\n        Retrieve this resource's (specification-specific) identifier.\n        \"\"\"\n        id = self._specification.id_of(self.contents)\n        if id is None:\n            return\n        return id.rstrip(\"#\")\n\n    def subresources(self) -> Iterable[Resource[D]]:\n        \"\"\"\n        Retrieve this resource's subresources.\n        \"\"\"\n        return (\n            Resource.from_contents(\n                each,\n                default_specification=self._specification,\n            )\n            for each in self._specification.subresources_of(self.contents)\n        )\n\n    def anchors(self) -> Iterable[AnchorType[D]]:\n        \"\"\"\n        Retrieve this resource's (specification-specific) identifier.\n        \"\"\"\n        return self._specification.anchors_in(self.contents)\n\n    def pointer(self, pointer: str, resolver: Resolver[D]) -> Resolved[D]:\n        \"\"\"\n        Resolve the given JSON pointer.\n\n        Raises:\n\n            `exceptions.PointerToNowhere`\n\n                if the pointer points to a location not present in the document\n\n        \"\"\"\n        if not pointer:\n            return Resolved(contents=self.contents, resolver=resolver)\n\n        contents = self.contents\n        segments: list[int | str] = []\n        for segment in unquote(pointer[1:]).split(\"/\"):\n            if isinstance(contents, Sequence):\n                segment = int(segment)\n            else:\n                segment = segment.replace(\"~1\", \"/\").replace(\"~0\", \"~\")\n            try:\n                contents = contents[segment]  # type: ignore[reportUnknownArgumentType]\n            except LookupError as lookup_error:\n                error = exceptions.PointerToNowhere(ref=pointer, resource=self)\n                raise error from lookup_error\n\n            segments.append(segment)\n            last = resolver\n            resolver = self._specification.maybe_in_subresource(\n                segments=segments,\n                resolver=resolver,\n                subresource=self._specification.create_resource(contents),\n            )\n            if resolver is not last:\n                segments = []\n        return Resolved(contents=contents, resolver=resolver)  # type: ignore[reportUnknownArgumentType]\n\n\ndef _fail_to_retrieve(uri: URI):\n    raise exceptions.NoSuchResource(ref=uri)\n\n\n@frozen\nclass Registry(Mapping[URI, Resource[D]]):\n    r\"\"\"\n    A registry of `Resource`\\ s, each identified by their canonical URIs.\n\n    Registries store a collection of in-memory resources, and optionally\n    enable additional resources which may be stored elsewhere (e.g. in a\n    database, a separate set of files, over the network, etc.).\n\n    They also lazily walk their known resources, looking for subresources\n    within them. In other words, subresources contained within any added\n    resources will be retrievable via their own IDs (though this discovery of\n    subresources will be delayed until necessary).\n\n    Registries are immutable, and their methods return new instances of the\n    registry with the additional resources added to them.\n\n    The ``retrieve`` argument can be used to configure retrieval of resources\n    dynamically, either over the network, from a database, or the like.\n    Pass it a callable which will be called if any URI not present in the\n    registry is accessed. It must either return a `Resource` or else raise a\n    `NoSuchResource` exception indicating that the resource does not exist\n    even according to the retrieval logic.\n    \"\"\"\n\n    _resources: HashTrieMap[URI, Resource[D]] = field(\n        default=HashTrieMap(),\n        converter=HashTrieMap.convert,  # type: ignore[reportGeneralTypeIssues]\n        alias=\"resources\",\n    )\n    _anchors: HashTrieMap[tuple[URI, str], AnchorType[D]] = HashTrieMap()\n    _uncrawled: HashTrieSet[URI] = EMPTY_UNCRAWLED\n    _retrieve: Retrieve[D] = field(default=_fail_to_retrieve, alias=\"retrieve\")\n\n    def __getitem__(self, uri: URI) -> Resource[D]:\n        \"\"\"\n        Return the (already crawled) `Resource` identified by the given URI.\n        \"\"\"\n        try:\n            return self._resources[uri.rstrip(\"#\")]\n        except KeyError:\n            raise exceptions.NoSuchResource(ref=uri) from None\n\n    def __iter__(self) -> Iterator[URI]:\n        \"\"\"\n        Iterate over all crawled URIs in the registry.\n        \"\"\"\n        return iter(self._resources)\n\n    def __len__(self) -> int:\n        \"\"\"\n        Count the total number of fully crawled resources in this registry.\n        \"\"\"\n        return len(self._resources)\n\n    def __rmatmul__(\n        self,\n        new: Resource[D] | Iterable[Resource[D]],\n    ) -> Registry[D]:\n        \"\"\"\n        Create a new registry with resource(s) added using their internal IDs.\n\n        Resources must have a internal IDs (e.g. the :kw:`$id` keyword in\n        modern JSON Schema versions), otherwise an error will be raised.\n\n        Both a single resource as well as an iterable of resources works, i.e.:\n\n            * ``resource @ registry`` or\n\n            * ``[iterable, of, multiple, resources] @ registry``\n\n        which -- again, assuming the resources have internal IDs -- is\n        equivalent to calling `Registry.with_resources` as such:\n\n        .. code:: python\n\n            registry.with_resources(\n                (resource.id(), resource) for resource in new_resources\n            )\n\n        Raises:\n\n            `NoInternalID`\n\n                if the resource(s) in fact do not have IDs\n\n        \"\"\"\n        if isinstance(new, Resource):\n            new = (new,)\n\n        resources = self._resources\n        uncrawled = self._uncrawled\n        for resource in new:\n            id = resource.id()\n            if id is None:\n                raise exceptions.NoInternalID(resource=resource)\n            uncrawled = uncrawled.insert(id)\n            resources = resources.insert(id, resource)\n        return evolve(self, resources=resources, uncrawled=uncrawled)\n\n    def __repr__(self) -> str:\n        size = len(self)\n        pluralized = \"resource\" if size == 1 else \"resources\"\n        if self._uncrawled:\n            uncrawled = len(self._uncrawled)\n            if uncrawled == size:\n                summary = f\"uncrawled {pluralized}\"\n            else:\n                summary = f\"{pluralized}, {uncrawled} uncrawled\"\n        else:\n            summary = f\"{pluralized}\"\n        return f\"<Registry ({size} {summary})>\"\n\n    def get_or_retrieve(self, uri: URI) -> Retrieved[D, Resource[D]]:\n        \"\"\"\n        Get a resource from the registry, crawling or retrieving if necessary.\n\n        May involve crawling to find the given URI if it is not already known,\n        so the returned object is a `Retrieved` object which contains both the\n        resource value as well as the registry which ultimately contained it.\n        \"\"\"\n        resource = self._resources.get(uri)\n        if resource is not None:\n            return Retrieved(registry=self, value=resource)\n\n        registry = self.crawl()\n        resource = registry._resources.get(uri)\n        if resource is not None:\n            return Retrieved(registry=registry, value=resource)\n\n        try:\n            resource = registry._retrieve(uri)\n        except (\n            exceptions.CannotDetermineSpecification,\n            exceptions.NoSuchResource,\n        ):\n            raise\n        except Exception as error:\n            raise exceptions.Unretrievable(ref=uri) from error\n        else:\n            registry = registry.with_resource(uri, resource)\n            return Retrieved(registry=registry, value=resource)\n\n    def remove(self, uri: URI):\n        \"\"\"\n        Return a registry with the resource identified by a given URI removed.\n        \"\"\"\n        if uri not in self._resources:\n            raise exceptions.NoSuchResource(ref=uri)\n\n        return evolve(\n            self,\n            resources=self._resources.remove(uri),\n            uncrawled=self._uncrawled.discard(uri),\n            anchors=HashTrieMap(\n                (k, v) for k, v in self._anchors.items() if k[0] != uri\n            ),\n        )\n\n    def anchor(self, uri: URI, name: str):\n        \"\"\"\n        Retrieve a given anchor from a resource which must already be crawled.\n        \"\"\"\n        value = self._anchors.get((uri, name))\n        if value is not None:\n            return Retrieved(value=value, registry=self)\n\n        registry = self.crawl()\n        value = registry._anchors.get((uri, name))\n        if value is not None:\n            return Retrieved(value=value, registry=registry)\n\n        resource = self[uri]\n        canonical_uri = resource.id()\n        if canonical_uri is not None:\n            value = registry._anchors.get((canonical_uri, name))\n            if value is not None:\n                return Retrieved(value=value, registry=registry)\n\n        if \"/\" in name:\n            raise exceptions.InvalidAnchor(\n                ref=uri,\n                resource=resource,\n                anchor=name,\n            )\n        raise exceptions.NoSuchAnchor(ref=uri, resource=resource, anchor=name)\n\n    def contents(self, uri: URI) -> D:\n        \"\"\"\n        Retrieve the (already crawled) contents identified by the given URI.\n        \"\"\"\n        return self[uri].contents\n\n    def crawl(self) -> Registry[D]:\n        \"\"\"\n        Crawl all added resources, discovering subresources.\n        \"\"\"\n        resources = self._resources\n        anchors = self._anchors\n        uncrawled = [(uri, resources[uri]) for uri in self._uncrawled]\n        while uncrawled:\n            uri, resource = uncrawled.pop()\n\n            id = resource.id()\n            if id is not None:\n                uri = urljoin(uri, id)\n                resources = resources.insert(uri, resource)\n            for each in resource.anchors():\n                anchors = anchors.insert((uri, each.name), each)\n            uncrawled.extend((uri, each) for each in resource.subresources())\n        return evolve(\n            self,\n            resources=resources,\n            anchors=anchors,\n            uncrawled=EMPTY_UNCRAWLED,\n        )\n\n    def with_resource(self, uri: URI, resource: Resource[D]):\n        \"\"\"\n        Add the given `Resource` to the registry, without crawling it.\n        \"\"\"\n        return self.with_resources([(uri, resource)])\n\n    def with_resources(\n        self,\n        pairs: Iterable[tuple[URI, Resource[D]]],\n    ) -> Registry[D]:\n        r\"\"\"\n        Add the given `Resource`\\ s to the registry, without crawling them.\n        \"\"\"\n        resources = self._resources\n        uncrawled = self._uncrawled\n        for uri, resource in pairs:\n            # Empty fragment URIs are equivalent to URIs without the fragment.\n            # TODO: Is this true for non JSON Schema resources? Probably not.\n            uri = uri.rstrip(\"#\")\n            uncrawled = uncrawled.insert(uri)\n            resources = resources.insert(uri, resource)\n        return evolve(self, resources=resources, uncrawled=uncrawled)\n\n    def with_contents(\n        self,\n        pairs: Iterable[tuple[URI, D]],\n        **kwargs: Any,\n    ) -> Registry[D]:\n        r\"\"\"\n        Add the given contents to the registry, autodetecting when necessary.\n        \"\"\"\n        return self.with_resources(\n            (uri, Resource.from_contents(each, **kwargs))\n            for uri, each in pairs\n        )\n\n    def combine(self, *registries: Registry[D]) -> Registry[D]:\n        \"\"\"\n        Combine together one or more other registries, producing a unified one.\n        \"\"\"\n        if registries == (self,):\n            return self\n        resources = self._resources\n        anchors = self._anchors\n        uncrawled = self._uncrawled\n        retrieve = self._retrieve\n        for registry in registries:\n            resources = resources.update(registry._resources)\n            anchors = anchors.update(registry._anchors)\n            uncrawled = uncrawled.update(registry._uncrawled)\n\n            if registry._retrieve is not _fail_to_retrieve:\n                if registry._retrieve is not retrieve is not _fail_to_retrieve:\n                    raise ValueError(  # noqa: TRY003\n                        \"Cannot combine registries with conflicting retrieval \"\n                        \"functions.\",\n                    )\n                retrieve = registry._retrieve\n        return evolve(\n            self,\n            anchors=anchors,\n            resources=resources,\n            uncrawled=uncrawled,\n            retrieve=retrieve,\n        )\n\n    def resolver(self, base_uri: URI = \"\") -> Resolver[D]:\n        \"\"\"\n        Return a `Resolver` which resolves references against this registry.\n        \"\"\"\n        return Resolver(base_uri=base_uri, registry=self)\n\n    def resolver_with_root(self, resource: Resource[D]) -> Resolver[D]:\n        \"\"\"\n        Return a `Resolver` with a specific root resource.\n        \"\"\"\n        uri = resource.id() or \"\"\n        return Resolver(\n            base_uri=uri,\n            registry=self.with_resource(uri, resource),\n        )\n\n\n#: An anchor or resource.\nAnchorOrResource = TypeVar(\"AnchorOrResource\", AnchorType[Any], Resource[Any])\n\n\n@frozen\nclass Retrieved(Generic[D, AnchorOrResource]):\n    \"\"\"\n    A value retrieved from a `Registry`.\n    \"\"\"\n\n    value: AnchorOrResource\n    registry: Registry[D]\n\n\n@frozen\nclass Resolved(Generic[D]):\n    \"\"\"\n    A reference resolved to its contents by a `Resolver`.\n    \"\"\"\n\n    contents: D\n    resolver: Resolver[D]\n\n\n@frozen\nclass Resolver(Generic[D]):\n    \"\"\"\n    A reference resolver.\n\n    Resolvers help resolve references (including relative ones) by\n    pairing a fixed base URI with a `Registry`.\n\n    This object, under normal circumstances, is expected to be used by\n    *implementers of libraries* built on top of `referencing` (e.g. JSON Schema\n    implementations or other libraries resolving JSON references),\n    not directly by end-users populating registries or while writing\n    schemas or other resources.\n\n    References are resolved against the base URI, and the combined URI\n    is then looked up within the registry.\n\n    The process of resolving a reference may itself involve calculating\n    a *new* base URI for future reference resolution (e.g. if an\n    intermediate resource sets a new base URI), or may involve encountering\n    additional subresources and adding them to a new registry.\n    \"\"\"\n\n    _base_uri: URI = field(alias=\"base_uri\")\n    _registry: Registry[D] = field(alias=\"registry\")\n    _previous: List[URI] = field(default=List(), repr=False, alias=\"previous\")\n\n    def lookup(self, ref: URI) -> Resolved[D]:\n        \"\"\"\n        Resolve the given reference to the resource it points to.\n\n        Raises:\n\n            `exceptions.Unresolvable`\n\n                or a subclass thereof (see below) if the reference isn't\n                resolvable\n\n            `exceptions.NoSuchAnchor`\n\n                if the reference is to a URI where a resource exists but\n                contains a plain name fragment which does not exist within\n                the resource\n\n            `exceptions.PointerToNowhere`\n\n                if the reference is to a URI where a resource exists but\n                contains a JSON pointer to a location within the resource\n                that does not exist\n\n        \"\"\"\n        if ref.startswith(\"#\"):\n            uri, fragment = self._base_uri, ref[1:]\n        else:\n            uri, fragment = urldefrag(urljoin(self._base_uri, ref))\n        try:\n            retrieved = self._registry.get_or_retrieve(uri)\n        except exceptions.NoSuchResource:\n            raise exceptions.Unresolvable(ref=ref) from None\n        except exceptions.Unretrievable as error:\n            raise exceptions.Unresolvable(ref=ref) from error\n\n        if fragment.startswith(\"/\"):\n            resolver = self._evolve(registry=retrieved.registry, base_uri=uri)\n            return retrieved.value.pointer(pointer=fragment, resolver=resolver)\n\n        if fragment:\n            retrieved = retrieved.registry.anchor(uri, fragment)\n            resolver = self._evolve(registry=retrieved.registry, base_uri=uri)\n            return retrieved.value.resolve(resolver=resolver)\n\n        resolver = self._evolve(registry=retrieved.registry, base_uri=uri)\n        return Resolved(contents=retrieved.value.contents, resolver=resolver)\n\n    def in_subresource(self, subresource: Resource[D]) -> Resolver[D]:\n        \"\"\"\n        Create a resolver for a subresource (which may have a new base URI).\n        \"\"\"\n        id = subresource.id()\n        if id is None:\n            return self\n        return evolve(self, base_uri=urljoin(self._base_uri, id))\n\n    def dynamic_scope(self) -> Iterable[tuple[URI, Registry[D]]]:\n        \"\"\"\n        In specs with such a notion, return the URIs in the dynamic scope.\n        \"\"\"\n        for uri in self._previous:\n            yield uri, self._registry\n\n    def _evolve(self, base_uri: URI, **kwargs: Any):\n        \"\"\"\n        Evolve, appending to the dynamic scope.\n        \"\"\"\n        previous = self._previous\n        if self._base_uri and (not previous or base_uri != self._base_uri):\n            previous = previous.push_front(self._base_uri)\n        return evolve(self, base_uri=base_uri, previous=previous, **kwargs)\n\n\n@frozen\nclass Anchor(Generic[D]):\n    \"\"\"\n    A simple anchor in a `Resource`.\n    \"\"\"\n\n    name: str\n    resource: Resource[D]\n\n    def resolve(self, resolver: Resolver[D]):\n        \"\"\"\n        Return the resource for this anchor.\n        \"\"\"\n        return Resolved(contents=self.resource.contents, resolver=resolver)\n"}