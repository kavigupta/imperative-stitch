{"noxfile.py": "from pathlib import Path\nfrom tempfile import TemporaryDirectory\nimport os\n\nimport nox\n\nROOT = Path(__file__).parent\nPYPROJECT = ROOT / \"pyproject.toml\"\nDOCS = ROOT / \"docs\"\nREFERENCING = ROOT / \"referencing\"\n\nREQUIREMENTS = dict(\n    docs=DOCS / \"requirements.txt\",\n    tests=ROOT / \"test-requirements.txt\",\n)\nREQUIREMENTS_IN = [  # this is actually ordered, as files depend on each other\n    (path.parent / f\"{path.stem}.in\", path) for path in REQUIREMENTS.values()\n]\n\nSUPPORTED = [\"3.8\", \"3.9\", \"3.10\", \"pypy3.10\", \"3.11\", \"3.12\"]\nLATEST = SUPPORTED[-1]\n\nnox.options.default_venv_backend = \"uv|virtualenv\"\nnox.options.sessions = []\n\n\ndef session(default=True, python=LATEST, **kwargs):  # noqa: D103\n    def _session(fn):\n        if default:\n            nox.options.sessions.append(kwargs.get(\"name\", fn.__name__))\n        return nox.session(python=python, **kwargs)(fn)\n\n    return _session\n\n\n@session(python=SUPPORTED)\ndef tests(session):\n    \"\"\"\n    Run the test suite with a corresponding Python version.\n    \"\"\"\n    session.install(\"-r\", REQUIREMENTS[\"tests\"])\n\n    if session.posargs and session.posargs[0] == \"coverage\":\n        if len(session.posargs) > 1 and session.posargs[1] == \"github\":\n            github = Path(os.environ[\"GITHUB_STEP_SUMMARY\"])\n        else:\n            github = None\n\n        session.install(\"coverage[toml]\")\n        session.run(\"coverage\", \"run\", \"-m\", \"pytest\", REFERENCING)\n        if github is None:\n            session.run(\"coverage\", \"report\")\n        else:\n            with github.open(\"a\") as summary:\n                summary.write(\"### Coverage\\n\\n\")\n                summary.flush()  # without a flush, output seems out of order.\n                session.run(\n                    \"coverage\",\n                    \"report\",\n                    \"--format=markdown\",\n                    stdout=summary,\n                )\n    else:\n        session.run(\"pytest\", *session.posargs, REFERENCING)\n\n\n@session()\ndef audit(session):\n    \"\"\"\n    Audit dependencies for vulnerabilities.\n    \"\"\"\n    session.install(\"pip-audit\", ROOT)\n    session.run(\"python\", \"-m\", \"pip_audit\")\n\n\n@session(tags=[\"build\"])\ndef build(session):\n    \"\"\"\n    Build a distribution suitable for PyPI and check its validity.\n    \"\"\"\n    session.install(\"build\", \"twine\")\n    with TemporaryDirectory() as tmpdir:\n        session.run(\"python\", \"-m\", \"build\", ROOT, \"--outdir\", tmpdir)\n        session.run(\"twine\", \"check\", \"--strict\", tmpdir + \"/*\")\n\n\n@session(tags=[\"style\"])\ndef style(session):\n    \"\"\"\n    Check Python code style.\n    \"\"\"\n    session.install(\"ruff\")\n    session.run(\"ruff\", \"check\", ROOT, __file__)\n\n\n@session()\ndef typing(session):\n    \"\"\"\n    Check static typing.\n    \"\"\"\n    session.install(\"pyright<1.1.354\", ROOT)\n    session.run(\"pyright\", *session.posargs, REFERENCING)\n\n\n@session()\ndef mypy(session):\n    \"\"\"\n    Check that mypy runs with no blocking errors.\n    \"\"\"\n    session.install(\"mypy\", ROOT)\n    session.run(\"mypy\", REFERENCING)\n\n\n@session(tags=[\"docs\"])\n@nox.parametrize(\n    \"builder\",\n    [\n        nox.param(name, id=name)\n        for name in [\n            \"dirhtml\",\n            \"doctest\",\n            \"linkcheck\",\n            \"man\",\n            \"spelling\",\n        ]\n    ],\n)\ndef docs(session, builder):\n    \"\"\"\n    Build the documentation using a specific Sphinx builder.\n    \"\"\"\n    session.install(\"-r\", REQUIREMENTS[\"docs\"])\n    with TemporaryDirectory() as tmpdir_str:\n        tmpdir = Path(tmpdir_str)\n        argv = [\"-n\", \"-T\", \"-W\"]\n        if builder != \"spelling\":\n            argv += [\"-q\"]\n        posargs = session.posargs or [tmpdir / builder]\n        session.run(\n            \"python\",\n            \"-m\",\n            \"sphinx\",\n            \"-b\",\n            builder,\n            DOCS,\n            *argv,\n            *posargs,\n        )\n\n\n@session(tags=[\"docs\", \"style\"], name=\"docs(style)\")\ndef docs_style(session):\n    \"\"\"\n    Check the documentation style.\n    \"\"\"\n    session.install(\n        \"doc8\",\n        \"pygments\",\n        \"pygments-github-lexers\",\n    )\n    session.run(\"python\", \"-m\", \"doc8\", \"--config\", PYPROJECT, DOCS)\n\n\n@session(default=False)\ndef requirements(session):\n    \"\"\"\n    Update the project's pinned requirements.\n\n    You should commit the result afterwards.\n    \"\"\"\n    if session.venv_backend == \"uv\":\n        cmd = [\"uv\", \"pip\", \"compile\"]\n    else:\n        session.install(\"pip-tools\")\n        cmd = [\"pip-compile\", \"--resolver\", \"backtracking\", \"--strip-extras\"]\n\n    for each, out in REQUIREMENTS_IN:\n        # otherwise output files end up with silly absolute path comments...\n        relative = each.relative_to(ROOT)\n        session.run(*cmd, \"--upgrade\", \"--output-file\", out, relative)\n", "docs/conf.py": "import importlib.metadata\nimport re\n\nfrom url import URL\n\nGITHUB = URL.parse(\"https://github.com/\")\nHOMEPAGE = GITHUB / \"python-jsonschema/referencing\"\n\nproject = \"referencing\"\nauthor = \"Julian Berman\"\ncopyright = f\"2022, {author}\"\n\nrelease = importlib.metadata.version(\"referencing\")\nversion = release.partition(\"-\")[0]\n\nlanguage = \"en\"\ndefault_role = \"any\"\n\nextensions = [\n    \"sphinx.ext.autodoc\",\n    \"sphinx.ext.autosectionlabel\",\n    \"sphinx.ext.coverage\",\n    \"sphinx.ext.doctest\",\n    \"sphinx.ext.extlinks\",\n    \"sphinx.ext.intersphinx\",\n    \"sphinx.ext.napoleon\",\n    \"sphinx.ext.todo\",\n    \"sphinx.ext.viewcode\",\n    \"sphinx_copybutton\",\n    \"sphinx_json_schema_spec\",\n    \"sphinxcontrib.spelling\",\n    \"sphinxext.opengraph\",\n]\n\npygments_style = \"lovelace\"\npygments_dark_style = \"one-dark\"\n\nhtml_theme = \"furo\"\n\n# See sphinx-doc/sphinx#10785\n_TYPE_ALIASES = dict(\n    AnchorType=(\"class\", \"Anchor\"),\n    D=(\"data\", \"D\"),\n    ObjectSchema=(\"data\", \"ObjectSchema\"),\n    Schema=(\"data\", \"Schema\"),\n    URI=(\"attr\", \"URI\"),  # ?!?!?! Sphinx...\n)\n\n\ndef _resolve_broken_refs(app, env, node, contnode):\n    if node[\"refdomain\"] != \"py\":\n        return\n\n    if node[\"reftarget\"].startswith(\"referencing.typing.\"):\n        kind, target = \"data\", node[\"reftarget\"]\n    else:\n        kind, target = _TYPE_ALIASES.get(node[\"reftarget\"], (None, None))\n    if kind is not None:\n        return app.env.get_domain(\"py\").resolve_xref(\n            env,\n            node[\"refdoc\"],\n            app.builder,\n            kind,\n            target,\n            node,\n            contnode,\n        )\n\n\ndef setup(app):\n    app.connect(\"missing-reference\", _resolve_broken_refs)\n\n\ndef entire_domain(host):\n    return r\"http.?://\" + re.escape(host) + r\"($|/.*)\"\n\n\nlinkcheck_ignore = [\n    entire_domain(\"img.shields.io\"),\n    f\"{GITHUB}.*#.*\",\n    str(HOMEPAGE / \"actions\"),\n    str(HOMEPAGE / \"workflows/CI/badge.svg\"),\n]\n\n# = Extensions =\n\n# -- autodoc --\n\nautodoc_default_options = {\n    \"members\": True,\n    \"member-order\": \"bysource\",\n}\n\n# -- autosectionlabel --\n\nautosectionlabel_prefix_document = True\n\n# -- intersphinx --\n\nintersphinx_mapping = {\n    \"hatch\": (\"https://hatch.pypa.io/latest/\", None),\n    \"jsonschema-specifications\": (\n        \"https://jsonschema-specifications.readthedocs.io/en/stable/\",\n        None,\n    ),\n    \"regret\": (\"https://regret.readthedocs.io/en/stable/\", None),\n    \"python\": (\"https://docs.python.org/\", None),\n    \"setuptools\": (\"https://setuptools.pypa.io/en/stable/\", None),\n}\n\n# -- extlinks --\n\nextlinks = {\n    \"gh\": (str(HOMEPAGE) + \"/%s\", None),\n    \"github\": (str(GITHUB) + \"/%s\", None),\n    \"hatch\": (\"https://hatch.pypa.io/latest/%s\", None),\n    \"httpx\": (\"https://www.python-httpx.org/%s\", None),\n}\nextlinks_detect_hardcoded_links = True\n\n# -- sphinx-copybutton --\n\ncopybutton_prompt_text = r\">>> |\\.\\.\\. |\\$\"\ncopybutton_prompt_is_regexp = True\n\n# -- sphinxcontrib-spelling --\n\nspelling_word_list_filename = \"spelling-wordlist.txt\"\nspelling_show_suggestions = True\n", "referencing/exceptions.py": "\"\"\"\nErrors, oh no!\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING, Any\n\nimport attrs\n\nfrom referencing._attrs import frozen\n\nif TYPE_CHECKING:\n    from referencing import Resource\n    from referencing.typing import URI\n\n\n@frozen\nclass NoSuchResource(KeyError):\n    \"\"\"\n    The given URI is not present in a registry.\n\n    Unlike most exceptions, this class *is* intended to be publicly\n    instantiable and *is* part of the public API of the package.\n    \"\"\"\n\n    ref: URI\n\n    def __eq__(self, other: object) -> bool:\n        if self.__class__ is not other.__class__:\n            return NotImplemented\n        return attrs.astuple(self) == attrs.astuple(other)\n\n    def __hash__(self) -> int:\n        return hash(attrs.astuple(self))\n\n\n@frozen\nclass NoInternalID(Exception):\n    \"\"\"\n    A resource has no internal ID, but one is needed.\n\n    E.g. in modern JSON Schema drafts, this is the :kw:`$id` keyword.\n\n    One might be needed if a resource was to-be added to a registry but no\n    other URI is available, and the resource doesn't declare its canonical URI.\n    \"\"\"\n\n    resource: Resource[Any]\n\n    def __eq__(self, other: object) -> bool:\n        if self.__class__ is not other.__class__:\n            return NotImplemented\n        return attrs.astuple(self) == attrs.astuple(other)\n\n    def __hash__(self) -> int:\n        return hash(attrs.astuple(self))\n\n\n@frozen\nclass Unretrievable(KeyError):\n    \"\"\"\n    The given URI is not present in a registry, and retrieving it failed.\n    \"\"\"\n\n    ref: URI\n\n    def __eq__(self, other: object) -> bool:\n        if self.__class__ is not other.__class__:\n            return NotImplemented\n        return attrs.astuple(self) == attrs.astuple(other)\n\n    def __hash__(self) -> int:\n        return hash(attrs.astuple(self))\n\n\n@frozen\nclass CannotDetermineSpecification(Exception):\n    \"\"\"\n    Attempting to detect the appropriate `Specification` failed.\n\n    This happens if no discernible information is found in the contents of the\n    new resource which would help identify it.\n    \"\"\"\n\n    contents: Any\n\n    def __eq__(self, other: object) -> bool:\n        if self.__class__ is not other.__class__:\n            return NotImplemented\n        return attrs.astuple(self) == attrs.astuple(other)\n\n    def __hash__(self) -> int:\n        return hash(attrs.astuple(self))\n\n\n@attrs.frozen  # Because here we allow subclassing below.\nclass Unresolvable(Exception):\n    \"\"\"\n    A reference was unresolvable.\n    \"\"\"\n\n    ref: URI\n\n    def __eq__(self, other: object) -> bool:\n        if self.__class__ is not other.__class__:\n            return NotImplemented\n        return attrs.astuple(self) == attrs.astuple(other)\n\n    def __hash__(self) -> int:\n        return hash(attrs.astuple(self))\n\n\n@frozen\nclass PointerToNowhere(Unresolvable):\n    \"\"\"\n    A JSON Pointer leads to a part of a document that does not exist.\n    \"\"\"\n\n    resource: Resource[Any]\n\n    def __str__(self) -> str:\n        msg = f\"{self.ref!r} does not exist within {self.resource.contents!r}\"\n        if self.ref == \"/\":\n            msg += (\n                \". The pointer '/' is a valid JSON Pointer but it points to \"\n                \"an empty string property ''. If you intended to point \"\n                \"to the entire resource, you should use '#'.\"\n            )\n        return msg\n\n\n@frozen\nclass NoSuchAnchor(Unresolvable):\n    \"\"\"\n    An anchor does not exist within a particular resource.\n    \"\"\"\n\n    resource: Resource[Any]\n    anchor: str\n\n    def __str__(self) -> str:\n        return (\n            f\"{self.anchor!r} does not exist within {self.resource.contents!r}\"\n        )\n\n\n@frozen\nclass InvalidAnchor(Unresolvable):\n    \"\"\"\n    An anchor which could never exist in a resource was dereferenced.\n\n    It is somehow syntactically invalid.\n    \"\"\"\n\n    resource: Resource[Any]\n    anchor: str\n\n    def __str__(self) -> str:\n        return (\n            f\"'#{self.anchor}' is not a valid anchor, neither as a \"\n            \"plain name anchor nor as a JSON Pointer. You may have intended \"\n            f\"to use '#/{self.anchor}', as the slash is required *before each \"\n            \"segment* of a JSON pointer.\"\n        )\n", "referencing/typing.py": "\"\"\"\nType-annotation related support for the referencing library.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING, Protocol, TypeVar\n\ntry:\n    from collections.abc import Mapping as Mapping\n\n    Mapping[str, str]\nexcept TypeError:  # pragma: no cover\n    from typing import Mapping as Mapping\n\n\nif TYPE_CHECKING:\n    from referencing._core import Resolved, Resolver, Resource\n\n#: A URI which identifies a `Resource`.\nURI = str\n\n#: The type of documents within a registry.\nD = TypeVar(\"D\")\n\n\nclass Retrieve(Protocol[D]):\n    \"\"\"\n    A retrieval callable, usable within a `Registry` for resource retrieval.\n\n    Does not make assumptions about where the resource might be coming from.\n    \"\"\"\n\n    def __call__(self, uri: URI) -> Resource[D]:\n        \"\"\"\n        Retrieve the resource with the given URI.\n\n        Raise `referencing.exceptions.NoSuchResource` if you wish to indicate\n        the retriever cannot lookup the given URI.\n        \"\"\"\n        ...\n\n\nclass Anchor(Protocol[D]):\n    \"\"\"\n    An anchor within a `Resource`.\n\n    Beyond \"simple\" anchors, some specifications like JSON Schema's 2020\n    version have dynamic anchors.\n    \"\"\"\n\n    @property\n    def name(self) -> str:\n        \"\"\"\n        Return the name of this anchor.\n        \"\"\"\n        ...\n\n    def resolve(self, resolver: Resolver[D]) -> Resolved[D]:\n        \"\"\"\n        Return the resource for this anchor.\n        \"\"\"\n        ...\n", "referencing/retrieval.py": "\"\"\"\nHelpers related to (dynamic) resource retrieval.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom functools import lru_cache\nfrom typing import TYPE_CHECKING, Callable, TypeVar\nimport json\n\nfrom referencing import Resource\n\nif TYPE_CHECKING:\n    from referencing.typing import URI, D, Retrieve\n\n#: A serialized document (e.g. a JSON string)\n_T = TypeVar(\"_T\")\n\n\ndef to_cached_resource(\n    cache: Callable[[Retrieve[D]], Retrieve[D]] | None = None,\n    loads: Callable[[_T], D] = json.loads,\n    from_contents: Callable[[D], Resource[D]] = Resource.from_contents,\n) -> Callable[[Callable[[URI], _T]], Retrieve[D]]:\n    \"\"\"\n    Create a retriever which caches its return values from a simpler callable.\n\n    Takes a function which returns things like serialized JSON (strings) and\n    returns something suitable for passing to `Registry` as a retrieve\n    function.\n\n    This decorator both reduces a small bit of boilerplate for a common case\n    (deserializing JSON from strings and creating `Resource` objects from the\n    result) as well as makes the probable need for caching a bit easier.\n    Retrievers which otherwise do expensive operations (like hitting the\n    network) might otherwise be called repeatedly.\n\n    Examples\n    --------\n\n    .. testcode::\n\n        from referencing import Registry\n        from referencing.typing import URI\n        import referencing.retrieval\n\n\n        @referencing.retrieval.to_cached_resource()\n        def retrieve(uri: URI):\n            print(f\"Retrieved {uri}\")\n\n            # Normally, go get some expensive JSON from the network, a file ...\n            return '''\n                {\n                    \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n                    \"foo\": \"bar\"\n                }\n            '''\n\n        one = Registry(retrieve=retrieve).get_or_retrieve(\"urn:example:foo\")\n        print(one.value.contents[\"foo\"])\n\n        # Retrieving the same URI again reuses the same value (and thus doesn't\n        # print another retrieval message here)\n        two = Registry(retrieve=retrieve).get_or_retrieve(\"urn:example:foo\")\n        print(two.value.contents[\"foo\"])\n\n    .. testoutput::\n\n        Retrieved urn:example:foo\n        bar\n        bar\n\n    \"\"\"\n    if cache is None:\n        cache = lru_cache(maxsize=None)\n\n    def decorator(retrieve: Callable[[URI], _T]):\n        @cache\n        def cached_retrieve(uri: URI):\n            response = retrieve(uri)\n            contents = loads(response)\n            return from_contents(contents)\n\n        return cached_retrieve\n\n    return decorator\n", "referencing/_attrs.py": "from __future__ import annotations\n\nfrom typing import NoReturn, TypeVar\n\nfrom attrs import define as _define, frozen as _frozen\n\n_T = TypeVar(\"_T\")\n\n\ndef define(cls: type[_T]) -> type[_T]:  # pragma: no cover\n    cls.__init_subclass__ = _do_not_subclass\n    return _define(cls)\n\n\ndef frozen(cls: type[_T]) -> type[_T]:\n    cls.__init_subclass__ = _do_not_subclass\n    return _frozen(cls)\n\n\nclass UnsupportedSubclassing(Exception):\n    def __str__(self):\n        return (\n            \"Subclassing is not part of referencing's public API. \"\n            \"If no other suitable API exists for what you're trying to do, \"\n            \"feel free to file an issue asking for one.\"\n        )\n\n\n@staticmethod\ndef _do_not_subclass() -> NoReturn:  # pragma: no cover\n    raise UnsupportedSubclassing()\n", "referencing/jsonschema.py": "\"\"\"\nReferencing implementations for JSON Schema specs (historic & current).\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom collections.abc import Sequence, Set\nfrom typing import Any, Iterable, Union\n\nfrom referencing import Anchor, Registry, Resource, Specification, exceptions\nfrom referencing._attrs import frozen\nfrom referencing._core import (\n    _UNSET,  # type: ignore[reportPrivateUsage]\n    Resolved as _Resolved,\n    Resolver as _Resolver,\n    _Unset,  # type: ignore[reportPrivateUsage]\n)\nfrom referencing.typing import URI, Anchor as AnchorType, Mapping\n\n#: A JSON Schema which is a JSON object\nObjectSchema = Mapping[str, Any]\n\n#: A JSON Schema of any kind\nSchema = Union[bool, ObjectSchema]\n\n#: A Resource whose contents are JSON Schemas\nSchemaResource = Resource[Schema]\n\n#: A JSON Schema Registry\nSchemaRegistry = Registry[Schema]\n\n#: The empty JSON Schema Registry\nEMPTY_REGISTRY: SchemaRegistry = Registry()\n\n\n@frozen\nclass UnknownDialect(Exception):\n    \"\"\"\n    A dialect identifier was found for a dialect unknown by this library.\n\n    If it's a custom (\"unofficial\") dialect, be sure you've registered it.\n    \"\"\"\n\n    uri: URI\n\n\ndef _dollar_id(contents: Schema) -> URI | None:\n    if isinstance(contents, bool):\n        return\n    return contents.get(\"$id\")\n\n\ndef _legacy_dollar_id(contents: Schema) -> URI | None:\n    if isinstance(contents, bool) or \"$ref\" in contents:\n        return\n    id = contents.get(\"$id\")\n    if id is not None and not id.startswith(\"#\"):\n        return id\n\n\ndef _legacy_id(contents: ObjectSchema) -> URI | None:\n    if \"$ref\" in contents:\n        return\n    id = contents.get(\"id\")\n    if id is not None and not id.startswith(\"#\"):\n        return id\n\n\ndef _anchor(\n    specification: Specification[Schema],\n    contents: Schema,\n) -> Iterable[AnchorType[Schema]]:\n    if isinstance(contents, bool):\n        return\n    anchor = contents.get(\"$anchor\")\n    if anchor is not None:\n        yield Anchor(\n            name=anchor,\n            resource=specification.create_resource(contents),\n        )\n\n    dynamic_anchor = contents.get(\"$dynamicAnchor\")\n    if dynamic_anchor is not None:\n        yield DynamicAnchor(\n            name=dynamic_anchor,\n            resource=specification.create_resource(contents),\n        )\n\n\ndef _anchor_2019(\n    specification: Specification[Schema],\n    contents: Schema,\n) -> Iterable[Anchor[Schema]]:\n    if isinstance(contents, bool):\n        return []\n    anchor = contents.get(\"$anchor\")\n    if anchor is None:\n        return []\n    return [\n        Anchor(\n            name=anchor,\n            resource=specification.create_resource(contents),\n        ),\n    ]\n\n\ndef _legacy_anchor_in_dollar_id(\n    specification: Specification[Schema],\n    contents: Schema,\n) -> Iterable[Anchor[Schema]]:\n    if isinstance(contents, bool):\n        return []\n    id = contents.get(\"$id\", \"\")\n    if not id.startswith(\"#\"):\n        return []\n    return [\n        Anchor(\n            name=id[1:],\n            resource=specification.create_resource(contents),\n        ),\n    ]\n\n\ndef _legacy_anchor_in_id(\n    specification: Specification[ObjectSchema],\n    contents: ObjectSchema,\n) -> Iterable[Anchor[ObjectSchema]]:\n    id = contents.get(\"id\", \"\")\n    if not id.startswith(\"#\"):\n        return []\n    return [\n        Anchor(\n            name=id[1:],\n            resource=specification.create_resource(contents),\n        ),\n    ]\n\n\ndef _subresources_of(\n    in_value: Set[str] = frozenset(),\n    in_subvalues: Set[str] = frozenset(),\n    in_subarray: Set[str] = frozenset(),\n):\n    \"\"\"\n    Create a callable returning JSON Schema specification-style subschemas.\n\n    Relies on specifying the set of keywords containing subschemas in their\n    values, in a subobject's values, or in a subarray.\n    \"\"\"\n\n    def subresources_of(contents: Schema) -> Iterable[ObjectSchema]:\n        if isinstance(contents, bool):\n            return\n        for each in in_value:\n            if each in contents:\n                yield contents[each]\n        for each in in_subarray:\n            if each in contents:\n                yield from contents[each]\n        for each in in_subvalues:\n            if each in contents:\n                yield from contents[each].values()\n\n    return subresources_of\n\n\ndef _subresources_of_with_crazy_items(\n    in_value: Set[str] = frozenset(),\n    in_subvalues: Set[str] = frozenset(),\n    in_subarray: Set[str] = frozenset(),\n):\n    \"\"\"\n    Specifically handle older drafts where there are some funky keywords.\n    \"\"\"\n\n    def subresources_of(contents: Schema) -> Iterable[ObjectSchema]:\n        if isinstance(contents, bool):\n            return\n        for each in in_value:\n            if each in contents:\n                yield contents[each]\n        for each in in_subarray:\n            if each in contents:\n                yield from contents[each]\n        for each in in_subvalues:\n            if each in contents:\n                yield from contents[each].values()\n\n        items = contents.get(\"items\")\n        if items is not None:\n            if isinstance(items, Sequence):\n                yield from items\n            else:\n                yield items\n\n    return subresources_of\n\n\ndef _subresources_of_with_crazy_items_dependencies(\n    in_value: Set[str] = frozenset(),\n    in_subvalues: Set[str] = frozenset(),\n    in_subarray: Set[str] = frozenset(),\n):\n    \"\"\"\n    Specifically handle older drafts where there are some funky keywords.\n    \"\"\"\n\n    def subresources_of(contents: Schema) -> Iterable[ObjectSchema]:\n        if isinstance(contents, bool):\n            return\n        for each in in_value:\n            if each in contents:\n                yield contents[each]\n        for each in in_subarray:\n            if each in contents:\n                yield from contents[each]\n        for each in in_subvalues:\n            if each in contents:\n                yield from contents[each].values()\n\n        items = contents.get(\"items\")\n        if items is not None:\n            if isinstance(items, Sequence):\n                yield from items\n            else:\n                yield items\n        dependencies = contents.get(\"dependencies\")\n        if dependencies is not None:\n            values = iter(dependencies.values())\n            value = next(values, None)\n            if isinstance(value, Mapping):\n                yield value\n                yield from values\n\n    return subresources_of\n\n\ndef _subresources_of_with_crazy_aP_items_dependencies(\n    in_value: Set[str] = frozenset(),\n    in_subvalues: Set[str] = frozenset(),\n    in_subarray: Set[str] = frozenset(),\n):\n    \"\"\"\n    Specifically handle even older drafts where there are some funky keywords.\n    \"\"\"\n\n    def subresources_of(contents: ObjectSchema) -> Iterable[ObjectSchema]:\n        for each in in_value:\n            if each in contents:\n                yield contents[each]\n        for each in in_subarray:\n            if each in contents:\n                yield from contents[each]\n        for each in in_subvalues:\n            if each in contents:\n                yield from contents[each].values()\n\n        items = contents.get(\"items\")\n        if items is not None:\n            if isinstance(items, Sequence):\n                yield from items\n            else:\n                yield items\n        dependencies = contents.get(\"dependencies\")\n        if dependencies is not None:\n            values = iter(dependencies.values())\n            value = next(values, None)\n            if isinstance(value, Mapping):\n                yield value\n                yield from values\n\n        for each in \"additionalItems\", \"additionalProperties\":\n            value = contents.get(each)\n            if isinstance(value, Mapping):\n                yield value\n\n    return subresources_of\n\n\ndef _maybe_in_subresource(\n    in_value: Set[str] = frozenset(),\n    in_subvalues: Set[str] = frozenset(),\n    in_subarray: Set[str] = frozenset(),\n):\n    in_child = in_subvalues | in_subarray\n\n    def maybe_in_subresource(\n        segments: Sequence[int | str],\n        resolver: _Resolver[Any],\n        subresource: Resource[Any],\n    ) -> _Resolver[Any]:\n        _segments = iter(segments)\n        for segment in _segments:\n            if segment not in in_value and (\n                segment not in in_child or next(_segments, None) is None\n            ):\n                return resolver\n        return resolver.in_subresource(subresource)\n\n    return maybe_in_subresource\n\n\ndef _maybe_in_subresource_crazy_items(\n    in_value: Set[str] = frozenset(),\n    in_subvalues: Set[str] = frozenset(),\n    in_subarray: Set[str] = frozenset(),\n):\n    in_child = in_subvalues | in_subarray\n\n    def maybe_in_subresource(\n        segments: Sequence[int | str],\n        resolver: _Resolver[Any],\n        subresource: Resource[Any],\n    ) -> _Resolver[Any]:\n        _segments = iter(segments)\n        for segment in _segments:\n            if segment == \"items\" and isinstance(\n                subresource.contents,\n                Mapping,\n            ):\n                return resolver.in_subresource(subresource)\n            if segment not in in_value and (\n                segment not in in_child or next(_segments, None) is None\n            ):\n                return resolver\n        return resolver.in_subresource(subresource)\n\n    return maybe_in_subresource\n\n\ndef _maybe_in_subresource_crazy_items_dependencies(\n    in_value: Set[str] = frozenset(),\n    in_subvalues: Set[str] = frozenset(),\n    in_subarray: Set[str] = frozenset(),\n):\n    in_child = in_subvalues | in_subarray\n\n    def maybe_in_subresource(\n        segments: Sequence[int | str],\n        resolver: _Resolver[Any],\n        subresource: Resource[Any],\n    ) -> _Resolver[Any]:\n        _segments = iter(segments)\n        for segment in _segments:\n            if segment in {\"items\", \"dependencies\"} and isinstance(\n                subresource.contents,\n                Mapping,\n            ):\n                return resolver.in_subresource(subresource)\n            if segment not in in_value and (\n                segment not in in_child or next(_segments, None) is None\n            ):\n                return resolver\n        return resolver.in_subresource(subresource)\n\n    return maybe_in_subresource\n\n\n#: JSON Schema draft 2020-12\nDRAFT202012 = Specification(\n    name=\"draft2020-12\",\n    id_of=_dollar_id,\n    subresources_of=_subresources_of(\n        in_value={\n            \"additionalProperties\",\n            \"contains\",\n            \"contentSchema\",\n            \"else\",\n            \"if\",\n            \"items\",\n            \"not\",\n            \"propertyNames\",\n            \"then\",\n            \"unevaluatedItems\",\n            \"unevaluatedProperties\",\n        },\n        in_subarray={\"allOf\", \"anyOf\", \"oneOf\", \"prefixItems\"},\n        in_subvalues={\n            \"$defs\",\n            \"definitions\",\n            \"dependentSchemas\",\n            \"patternProperties\",\n            \"properties\",\n        },\n    ),\n    anchors_in=_anchor,\n    maybe_in_subresource=_maybe_in_subresource(\n        in_value={\n            \"additionalProperties\",\n            \"contains\",\n            \"contentSchema\",\n            \"else\",\n            \"if\",\n            \"items\",\n            \"not\",\n            \"propertyNames\",\n            \"then\",\n            \"unevaluatedItems\",\n            \"unevaluatedProperties\",\n        },\n        in_subarray={\"allOf\", \"anyOf\", \"oneOf\", \"prefixItems\"},\n        in_subvalues={\n            \"$defs\",\n            \"definitions\",\n            \"dependentSchemas\",\n            \"patternProperties\",\n            \"properties\",\n        },\n    ),\n)\n#: JSON Schema draft 2019-09\nDRAFT201909 = Specification(\n    name=\"draft2019-09\",\n    id_of=_dollar_id,\n    subresources_of=_subresources_of_with_crazy_items(\n        in_value={\n            \"additionalItems\",\n            \"additionalProperties\",\n            \"contains\",\n            \"contentSchema\",\n            \"else\",\n            \"if\",\n            \"not\",\n            \"propertyNames\",\n            \"then\",\n            \"unevaluatedItems\",\n            \"unevaluatedProperties\",\n        },\n        in_subarray={\"allOf\", \"anyOf\", \"oneOf\"},\n        in_subvalues={\n            \"$defs\",\n            \"definitions\",\n            \"dependentSchemas\",\n            \"patternProperties\",\n            \"properties\",\n        },\n    ),\n    anchors_in=_anchor_2019,  # type: ignore[reportGeneralTypeIssues]  # TODO: check whether this is real\n    maybe_in_subresource=_maybe_in_subresource_crazy_items(\n        in_value={\n            \"additionalItems\",\n            \"additionalProperties\",\n            \"contains\",\n            \"contentSchema\",\n            \"else\",\n            \"if\",\n            \"not\",\n            \"propertyNames\",\n            \"then\",\n            \"unevaluatedItems\",\n            \"unevaluatedProperties\",\n        },\n        in_subarray={\"allOf\", \"anyOf\", \"oneOf\"},\n        in_subvalues={\n            \"$defs\",\n            \"definitions\",\n            \"dependentSchemas\",\n            \"patternProperties\",\n            \"properties\",\n        },\n    ),\n)\n#: JSON Schema draft 7\nDRAFT7 = Specification(\n    name=\"draft-07\",\n    id_of=_legacy_dollar_id,\n    subresources_of=_subresources_of_with_crazy_items_dependencies(\n        in_value={\n            \"additionalItems\",\n            \"additionalProperties\",\n            \"contains\",\n            \"else\",\n            \"if\",\n            \"not\",\n            \"propertyNames\",\n            \"then\",\n        },\n        in_subarray={\"allOf\", \"anyOf\", \"oneOf\"},\n        in_subvalues={\"definitions\", \"patternProperties\", \"properties\"},\n    ),\n    anchors_in=_legacy_anchor_in_dollar_id,  # type: ignore[reportGeneralTypeIssues]  # TODO: check whether this is real\n    maybe_in_subresource=_maybe_in_subresource_crazy_items_dependencies(\n        in_value={\n            \"additionalItems\",\n            \"additionalProperties\",\n            \"contains\",\n            \"else\",\n            \"if\",\n            \"not\",\n            \"propertyNames\",\n            \"then\",\n        },\n        in_subarray={\"allOf\", \"anyOf\", \"oneOf\"},\n        in_subvalues={\"definitions\", \"patternProperties\", \"properties\"},\n    ),\n)\n#: JSON Schema draft 6\nDRAFT6 = Specification(\n    name=\"draft-06\",\n    id_of=_legacy_dollar_id,\n    subresources_of=_subresources_of_with_crazy_items_dependencies(\n        in_value={\n            \"additionalItems\",\n            \"additionalProperties\",\n            \"contains\",\n            \"not\",\n            \"propertyNames\",\n        },\n        in_subarray={\"allOf\", \"anyOf\", \"oneOf\"},\n        in_subvalues={\"definitions\", \"patternProperties\", \"properties\"},\n    ),\n    anchors_in=_legacy_anchor_in_dollar_id,  # type: ignore[reportGeneralTypeIssues]  # TODO: check whether this is real\n    maybe_in_subresource=_maybe_in_subresource_crazy_items_dependencies(\n        in_value={\n            \"additionalItems\",\n            \"additionalProperties\",\n            \"contains\",\n            \"not\",\n            \"propertyNames\",\n        },\n        in_subarray={\"allOf\", \"anyOf\", \"oneOf\"},\n        in_subvalues={\"definitions\", \"patternProperties\", \"properties\"},\n    ),\n)\n#: JSON Schema draft 4\nDRAFT4 = Specification(\n    name=\"draft-04\",\n    id_of=_legacy_id,\n    subresources_of=_subresources_of_with_crazy_aP_items_dependencies(\n        in_value={\"not\"},\n        in_subarray={\"allOf\", \"anyOf\", \"oneOf\"},\n        in_subvalues={\"definitions\", \"patternProperties\", \"properties\"},\n    ),\n    anchors_in=_legacy_anchor_in_id,\n    maybe_in_subresource=_maybe_in_subresource_crazy_items_dependencies(\n        in_value={\"additionalItems\", \"additionalProperties\", \"not\"},\n        in_subarray={\"allOf\", \"anyOf\", \"oneOf\"},\n        in_subvalues={\"definitions\", \"patternProperties\", \"properties\"},\n    ),\n)\n#: JSON Schema draft 3\nDRAFT3 = Specification(\n    name=\"draft-03\",\n    id_of=_legacy_id,\n    subresources_of=_subresources_of_with_crazy_aP_items_dependencies(\n        in_subarray={\"extends\"},\n        in_subvalues={\"definitions\", \"patternProperties\", \"properties\"},\n    ),\n    anchors_in=_legacy_anchor_in_id,\n    maybe_in_subresource=_maybe_in_subresource_crazy_items_dependencies(\n        in_value={\"additionalItems\", \"additionalProperties\"},\n        in_subarray={\"extends\"},\n        in_subvalues={\"definitions\", \"patternProperties\", \"properties\"},\n    ),\n)\n\n\n_SPECIFICATIONS: Registry[Specification[Schema]] = Registry(\n    {  # type: ignore[reportGeneralTypeIssues]  # :/ internal vs external types\n        dialect_id: Resource.opaque(specification)\n        for dialect_id, specification in [\n            (\"https://json-schema.org/draft/2020-12/schema\", DRAFT202012),\n            (\"https://json-schema.org/draft/2019-09/schema\", DRAFT201909),\n            (\"http://json-schema.org/draft-07/schema\", DRAFT7),\n            (\"http://json-schema.org/draft-06/schema\", DRAFT6),\n            (\"http://json-schema.org/draft-04/schema\", DRAFT4),\n            (\"http://json-schema.org/draft-03/schema\", DRAFT3),\n        ]\n    },\n)\n\n\ndef specification_with(\n    dialect_id: URI,\n    default: Specification[Any] | _Unset = _UNSET,\n) -> Specification[Any]:\n    \"\"\"\n    Retrieve the `Specification` with the given dialect identifier.\n\n    Raises:\n\n        `UnknownDialect`\n\n            if the given ``dialect_id`` isn't known\n\n    \"\"\"\n    resource = _SPECIFICATIONS.get(dialect_id.rstrip(\"#\"))\n    if resource is not None:\n        return resource.contents\n    if default is _UNSET:\n        raise UnknownDialect(dialect_id)\n    return default\n\n\n@frozen\nclass DynamicAnchor:\n    \"\"\"\n    Dynamic anchors, introduced in draft 2020.\n    \"\"\"\n\n    name: str\n    resource: SchemaResource\n\n    def resolve(self, resolver: _Resolver[Schema]) -> _Resolved[Schema]:\n        \"\"\"\n        Resolve this anchor dynamically.\n        \"\"\"\n        last = self.resource\n        for uri, registry in resolver.dynamic_scope():\n            try:\n                anchor = registry.anchor(uri, self.name).value\n            except exceptions.NoSuchAnchor:\n                continue\n            if isinstance(anchor, DynamicAnchor):\n                last = anchor.resource\n        return _Resolved(\n            contents=last.contents,\n            resolver=resolver.in_subresource(last),\n        )\n\n\ndef lookup_recursive_ref(resolver: _Resolver[Schema]) -> _Resolved[Schema]:\n    \"\"\"\n    Recursive references (via recursive anchors), present only in draft 2019.\n\n    As per the 2019 specification (\u00a7 8.2.4.2.1), only the ``#`` recursive\n    reference is supported (and is therefore assumed to be the relevant\n    reference).\n    \"\"\"\n    resolved = resolver.lookup(\"#\")\n    if isinstance(resolved.contents, Mapping) and resolved.contents.get(\n        \"$recursiveAnchor\",\n    ):\n        for uri, _ in resolver.dynamic_scope():\n            next_resolved = resolver.lookup(uri)\n            if not isinstance(\n                next_resolved.contents,\n                Mapping,\n            ) or not next_resolved.contents.get(\"$recursiveAnchor\"):\n                break\n            resolved = next_resolved\n    return resolved\n", "referencing/__init__.py": "\"\"\"\nCross-specification, implementation-agnostic JSON referencing.\n\"\"\"\n\nfrom referencing._core import Anchor, Registry, Resource, Specification\n\n__all__ = [\"Anchor\", \"Registry\", \"Resource\", \"Specification\"]\n", "referencing/_core.py": "from __future__ import annotations\n\nfrom collections.abc import Iterable, Iterator, Sequence\nfrom enum import Enum\nfrom typing import Any, Callable, ClassVar, Generic, Protocol, TypeVar\nfrom urllib.parse import unquote, urldefrag, urljoin\n\nfrom attrs import evolve, field\nfrom rpds import HashTrieMap, HashTrieSet, List\n\nfrom referencing import exceptions\nfrom referencing._attrs import frozen\nfrom referencing.typing import URI, Anchor as AnchorType, D, Mapping, Retrieve\n\nEMPTY_UNCRAWLED: HashTrieSet[URI] = HashTrieSet()\nEMPTY_PREVIOUS_RESOLVERS: List[URI] = List()\n\n\nclass _Unset(Enum):\n    \"\"\"\n    What sillyness...\n    \"\"\"\n\n    SENTINEL = 1\n\n\n_UNSET = _Unset.SENTINEL\n\n\nclass _MaybeInSubresource(Protocol[D]):\n    def __call__(\n        self,\n        segments: Sequence[int | str],\n        resolver: Resolver[D],\n        subresource: Resource[D],\n    ) -> Resolver[D]: ...\n\n\ndef _detect_or_error(contents: D) -> Specification[D]:\n    if not isinstance(contents, Mapping):\n        raise exceptions.CannotDetermineSpecification(contents)\n\n    jsonschema_dialect_id = contents.get(\"$schema\")  # type: ignore[reportUnknownMemberType]\n    if not isinstance(jsonschema_dialect_id, str):\n        raise exceptions.CannotDetermineSpecification(contents)\n\n    from referencing.jsonschema import specification_with\n\n    return specification_with(jsonschema_dialect_id)\n\n\ndef _detect_or_default(\n    default: Specification[D],\n) -> Callable[[D], Specification[D]]:\n    def _detect(contents: D) -> Specification[D]:\n        if not isinstance(contents, Mapping):\n            return default\n\n        jsonschema_dialect_id = contents.get(\"$schema\")  # type: ignore[reportUnknownMemberType]\n        if jsonschema_dialect_id is None:\n            return default\n\n        from referencing.jsonschema import specification_with\n\n        return specification_with(\n            jsonschema_dialect_id,  # type: ignore[reportUnknownArgumentType]\n            default=default,\n        )\n\n    return _detect\n\n\nclass _SpecificationDetector:\n    def __get__(\n        self,\n        instance: Specification[D] | None,\n        cls: type[Specification[D]],\n    ) -> Callable[[D], Specification[D]]:\n        if instance is None:\n            return _detect_or_error\n        else:\n            return _detect_or_default(instance)\n\n\n@frozen\nclass Specification(Generic[D]):\n    \"\"\"\n    A specification which defines referencing behavior.\n\n    The various methods of a `Specification` allow for varying referencing\n    behavior across JSON Schema specification versions, etc.\n    \"\"\"\n\n    #: A short human-readable name for the specification, used for debugging.\n    name: str\n\n    #: Find the ID of a given document.\n    id_of: Callable[[D], URI | None]\n\n    #: Retrieve the subresources of the given document (without traversing into\n    #: the subresources themselves).\n    subresources_of: Callable[[D], Iterable[D]]\n\n    #: While resolving a JSON pointer, conditionally enter a subresource\n    #: (if e.g. we have just entered a keyword whose value is a subresource)\n    maybe_in_subresource: _MaybeInSubresource[D]\n\n    #: Retrieve the anchors contained in the given document.\n    _anchors_in: Callable[\n        [Specification[D], D],\n        Iterable[AnchorType[D]],\n    ] = field(alias=\"anchors_in\")\n\n    #: An opaque specification where resources have no subresources\n    #: nor internal identifiers.\n    OPAQUE: ClassVar[Specification[Any]]\n\n    #: Attempt to discern which specification applies to the given contents.\n    #:\n    #: May be called either as an instance method or as a class method, with\n    #: slightly different behavior in the following case:\n    #:\n    #: Recall that not all contents contains enough internal information about\n    #: which specification it is written for -- the JSON Schema ``{}``,\n    #: for instance, is valid under many different dialects and may be\n    #: interpreted as any one of them.\n    #:\n    #: When this method is used as an instance method (i.e. called on a\n    #: specific specification), that specification is used as the default\n    #: if the given contents are unidentifiable.\n    #:\n    #: On the other hand when called as a class method, an error is raised.\n    #:\n    #: To reiterate, ``DRAFT202012.detect({})`` will return ``DRAFT202012``\n    #: whereas the class method ``Specification.detect({})`` will raise an\n    #: error.\n    #:\n    #: (Note that of course ``DRAFT202012.detect(...)`` may return some other\n    #: specification when given a schema which *does* identify as being for\n    #: another version).\n    #:\n    #: Raises:\n    #:\n    #:     `CannotDetermineSpecification`\n    #:\n    #:         if the given contents don't have any discernible\n    #:         information which could be used to guess which\n    #:         specification they identify as\n    detect = _SpecificationDetector()\n\n    def __repr__(self) -> str:\n        return f\"<Specification name={self.name!r}>\"\n\n    def anchors_in(self, contents: D):\n        \"\"\"\n        Retrieve the anchors contained in the given document.\n        \"\"\"\n        return self._anchors_in(self, contents)\n\n    def create_resource(self, contents: D) -> Resource[D]:\n        \"\"\"\n        Create a resource which is interpreted using this specification.\n        \"\"\"\n        return Resource(contents=contents, specification=self)\n\n\nSpecification.OPAQUE = Specification(\n    name=\"opaque\",\n    id_of=lambda contents: None,\n    subresources_of=lambda contents: [],\n    anchors_in=lambda specification, contents: [],\n    maybe_in_subresource=lambda segments, resolver, subresource: resolver,\n)\n\n\n@frozen\nclass Resource(Generic[D]):\n    r\"\"\"\n    A document (deserialized JSON) with a concrete interpretation under a spec.\n\n    In other words, a Python object, along with an instance of `Specification`\n    which describes how the document interacts with referencing -- both\n    internally (how it refers to other `Resource`\\ s) and externally (how it\n    should be identified such that it is referenceable by other documents).\n    \"\"\"\n\n    contents: D\n    _specification: Specification[D] = field(alias=\"specification\")\n\n    @classmethod\n    def from_contents(\n        cls,\n        contents: D,\n        default_specification: (\n            type[Specification[D]] | Specification[D]\n        ) = Specification,\n    ) -> Resource[D]:\n        \"\"\"\n        Create a resource guessing which specification applies to the contents.\n\n        Raises:\n\n            `CannotDetermineSpecification`\n\n                if the given contents don't have any discernible\n                information which could be used to guess which\n                specification they identify as\n\n        \"\"\"\n        specification = default_specification.detect(contents)\n        return specification.create_resource(contents=contents)\n\n    @classmethod\n    def opaque(cls, contents: D) -> Resource[D]:\n        \"\"\"\n        Create an opaque `Resource` -- i.e. one with opaque specification.\n\n        See `Specification.OPAQUE` for details.\n        \"\"\"\n        return Specification.OPAQUE.create_resource(contents=contents)\n\n    def id(self) -> URI | None:\n        \"\"\"\n        Retrieve this resource's (specification-specific) identifier.\n        \"\"\"\n        id = self._specification.id_of(self.contents)\n        if id is None:\n            return\n        return id.rstrip(\"#\")\n\n    def subresources(self) -> Iterable[Resource[D]]:\n        \"\"\"\n        Retrieve this resource's subresources.\n        \"\"\"\n        return (\n            Resource.from_contents(\n                each,\n                default_specification=self._specification,\n            )\n            for each in self._specification.subresources_of(self.contents)\n        )\n\n    def anchors(self) -> Iterable[AnchorType[D]]:\n        \"\"\"\n        Retrieve this resource's (specification-specific) identifier.\n        \"\"\"\n        return self._specification.anchors_in(self.contents)\n\n    def pointer(self, pointer: str, resolver: Resolver[D]) -> Resolved[D]:\n        \"\"\"\n        Resolve the given JSON pointer.\n\n        Raises:\n\n            `exceptions.PointerToNowhere`\n\n                if the pointer points to a location not present in the document\n\n        \"\"\"\n        if not pointer:\n            return Resolved(contents=self.contents, resolver=resolver)\n\n        contents = self.contents\n        segments: list[int | str] = []\n        for segment in unquote(pointer[1:]).split(\"/\"):\n            if isinstance(contents, Sequence):\n                segment = int(segment)\n            else:\n                segment = segment.replace(\"~1\", \"/\").replace(\"~0\", \"~\")\n            try:\n                contents = contents[segment]  # type: ignore[reportUnknownArgumentType]\n            except LookupError as lookup_error:\n                error = exceptions.PointerToNowhere(ref=pointer, resource=self)\n                raise error from lookup_error\n\n            segments.append(segment)\n            last = resolver\n            resolver = self._specification.maybe_in_subresource(\n                segments=segments,\n                resolver=resolver,\n                subresource=self._specification.create_resource(contents),\n            )\n            if resolver is not last:\n                segments = []\n        return Resolved(contents=contents, resolver=resolver)  # type: ignore[reportUnknownArgumentType]\n\n\ndef _fail_to_retrieve(uri: URI):\n    raise exceptions.NoSuchResource(ref=uri)\n\n\n@frozen\nclass Registry(Mapping[URI, Resource[D]]):\n    r\"\"\"\n    A registry of `Resource`\\ s, each identified by their canonical URIs.\n\n    Registries store a collection of in-memory resources, and optionally\n    enable additional resources which may be stored elsewhere (e.g. in a\n    database, a separate set of files, over the network, etc.).\n\n    They also lazily walk their known resources, looking for subresources\n    within them. In other words, subresources contained within any added\n    resources will be retrievable via their own IDs (though this discovery of\n    subresources will be delayed until necessary).\n\n    Registries are immutable, and their methods return new instances of the\n    registry with the additional resources added to them.\n\n    The ``retrieve`` argument can be used to configure retrieval of resources\n    dynamically, either over the network, from a database, or the like.\n    Pass it a callable which will be called if any URI not present in the\n    registry is accessed. It must either return a `Resource` or else raise a\n    `NoSuchResource` exception indicating that the resource does not exist\n    even according to the retrieval logic.\n    \"\"\"\n\n    _resources: HashTrieMap[URI, Resource[D]] = field(\n        default=HashTrieMap(),\n        converter=HashTrieMap.convert,  # type: ignore[reportGeneralTypeIssues]\n        alias=\"resources\",\n    )\n    _anchors: HashTrieMap[tuple[URI, str], AnchorType[D]] = HashTrieMap()\n    _uncrawled: HashTrieSet[URI] = EMPTY_UNCRAWLED\n    _retrieve: Retrieve[D] = field(default=_fail_to_retrieve, alias=\"retrieve\")\n\n    def __getitem__(self, uri: URI) -> Resource[D]:\n        \"\"\"\n        Return the (already crawled) `Resource` identified by the given URI.\n        \"\"\"\n        try:\n            return self._resources[uri.rstrip(\"#\")]\n        except KeyError:\n            raise exceptions.NoSuchResource(ref=uri) from None\n\n    def __iter__(self) -> Iterator[URI]:\n        \"\"\"\n        Iterate over all crawled URIs in the registry.\n        \"\"\"\n        return iter(self._resources)\n\n    def __len__(self) -> int:\n        \"\"\"\n        Count the total number of fully crawled resources in this registry.\n        \"\"\"\n        return len(self._resources)\n\n    def __rmatmul__(\n        self,\n        new: Resource[D] | Iterable[Resource[D]],\n    ) -> Registry[D]:\n        \"\"\"\n        Create a new registry with resource(s) added using their internal IDs.\n\n        Resources must have a internal IDs (e.g. the :kw:`$id` keyword in\n        modern JSON Schema versions), otherwise an error will be raised.\n\n        Both a single resource as well as an iterable of resources works, i.e.:\n\n            * ``resource @ registry`` or\n\n            * ``[iterable, of, multiple, resources] @ registry``\n\n        which -- again, assuming the resources have internal IDs -- is\n        equivalent to calling `Registry.with_resources` as such:\n\n        .. code:: python\n\n            registry.with_resources(\n                (resource.id(), resource) for resource in new_resources\n            )\n\n        Raises:\n\n            `NoInternalID`\n\n                if the resource(s) in fact do not have IDs\n\n        \"\"\"\n        if isinstance(new, Resource):\n            new = (new,)\n\n        resources = self._resources\n        uncrawled = self._uncrawled\n        for resource in new:\n            id = resource.id()\n            if id is None:\n                raise exceptions.NoInternalID(resource=resource)\n            uncrawled = uncrawled.insert(id)\n            resources = resources.insert(id, resource)\n        return evolve(self, resources=resources, uncrawled=uncrawled)\n\n    def __repr__(self) -> str:\n        size = len(self)\n        pluralized = \"resource\" if size == 1 else \"resources\"\n        if self._uncrawled:\n            uncrawled = len(self._uncrawled)\n            if uncrawled == size:\n                summary = f\"uncrawled {pluralized}\"\n            else:\n                summary = f\"{pluralized}, {uncrawled} uncrawled\"\n        else:\n            summary = f\"{pluralized}\"\n        return f\"<Registry ({size} {summary})>\"\n\n    def get_or_retrieve(self, uri: URI) -> Retrieved[D, Resource[D]]:\n        \"\"\"\n        Get a resource from the registry, crawling or retrieving if necessary.\n\n        May involve crawling to find the given URI if it is not already known,\n        so the returned object is a `Retrieved` object which contains both the\n        resource value as well as the registry which ultimately contained it.\n        \"\"\"\n        resource = self._resources.get(uri)\n        if resource is not None:\n            return Retrieved(registry=self, value=resource)\n\n        registry = self.crawl()\n        resource = registry._resources.get(uri)\n        if resource is not None:\n            return Retrieved(registry=registry, value=resource)\n\n        try:\n            resource = registry._retrieve(uri)\n        except (\n            exceptions.CannotDetermineSpecification,\n            exceptions.NoSuchResource,\n        ):\n            raise\n        except Exception as error:\n            raise exceptions.Unretrievable(ref=uri) from error\n        else:\n            registry = registry.with_resource(uri, resource)\n            return Retrieved(registry=registry, value=resource)\n\n    def remove(self, uri: URI):\n        \"\"\"\n        Return a registry with the resource identified by a given URI removed.\n        \"\"\"\n        if uri not in self._resources:\n            raise exceptions.NoSuchResource(ref=uri)\n\n        return evolve(\n            self,\n            resources=self._resources.remove(uri),\n            uncrawled=self._uncrawled.discard(uri),\n            anchors=HashTrieMap(\n                (k, v) for k, v in self._anchors.items() if k[0] != uri\n            ),\n        )\n\n    def anchor(self, uri: URI, name: str):\n        \"\"\"\n        Retrieve a given anchor from a resource which must already be crawled.\n        \"\"\"\n        value = self._anchors.get((uri, name))\n        if value is not None:\n            return Retrieved(value=value, registry=self)\n\n        registry = self.crawl()\n        value = registry._anchors.get((uri, name))\n        if value is not None:\n            return Retrieved(value=value, registry=registry)\n\n        resource = self[uri]\n        canonical_uri = resource.id()\n        if canonical_uri is not None:\n            value = registry._anchors.get((canonical_uri, name))\n            if value is not None:\n                return Retrieved(value=value, registry=registry)\n\n        if \"/\" in name:\n            raise exceptions.InvalidAnchor(\n                ref=uri,\n                resource=resource,\n                anchor=name,\n            )\n        raise exceptions.NoSuchAnchor(ref=uri, resource=resource, anchor=name)\n\n    def contents(self, uri: URI) -> D:\n        \"\"\"\n        Retrieve the (already crawled) contents identified by the given URI.\n        \"\"\"\n        return self[uri].contents\n\n    def crawl(self) -> Registry[D]:\n        \"\"\"\n        Crawl all added resources, discovering subresources.\n        \"\"\"\n        resources = self._resources\n        anchors = self._anchors\n        uncrawled = [(uri, resources[uri]) for uri in self._uncrawled]\n        while uncrawled:\n            uri, resource = uncrawled.pop()\n\n            id = resource.id()\n            if id is not None:\n                uri = urljoin(uri, id)\n                resources = resources.insert(uri, resource)\n            for each in resource.anchors():\n                anchors = anchors.insert((uri, each.name), each)\n            uncrawled.extend((uri, each) for each in resource.subresources())\n        return evolve(\n            self,\n            resources=resources,\n            anchors=anchors,\n            uncrawled=EMPTY_UNCRAWLED,\n        )\n\n    def with_resource(self, uri: URI, resource: Resource[D]):\n        \"\"\"\n        Add the given `Resource` to the registry, without crawling it.\n        \"\"\"\n        return self.with_resources([(uri, resource)])\n\n    def with_resources(\n        self,\n        pairs: Iterable[tuple[URI, Resource[D]]],\n    ) -> Registry[D]:\n        r\"\"\"\n        Add the given `Resource`\\ s to the registry, without crawling them.\n        \"\"\"\n        resources = self._resources\n        uncrawled = self._uncrawled\n        for uri, resource in pairs:\n            # Empty fragment URIs are equivalent to URIs without the fragment.\n            # TODO: Is this true for non JSON Schema resources? Probably not.\n            uri = uri.rstrip(\"#\")\n            uncrawled = uncrawled.insert(uri)\n            resources = resources.insert(uri, resource)\n        return evolve(self, resources=resources, uncrawled=uncrawled)\n\n    def with_contents(\n        self,\n        pairs: Iterable[tuple[URI, D]],\n        **kwargs: Any,\n    ) -> Registry[D]:\n        r\"\"\"\n        Add the given contents to the registry, autodetecting when necessary.\n        \"\"\"\n        return self.with_resources(\n            (uri, Resource.from_contents(each, **kwargs))\n            for uri, each in pairs\n        )\n\n    def combine(self, *registries: Registry[D]) -> Registry[D]:\n        \"\"\"\n        Combine together one or more other registries, producing a unified one.\n        \"\"\"\n        if registries == (self,):\n            return self\n        resources = self._resources\n        anchors = self._anchors\n        uncrawled = self._uncrawled\n        retrieve = self._retrieve\n        for registry in registries:\n            resources = resources.update(registry._resources)\n            anchors = anchors.update(registry._anchors)\n            uncrawled = uncrawled.update(registry._uncrawled)\n\n            if registry._retrieve is not _fail_to_retrieve:\n                if registry._retrieve is not retrieve is not _fail_to_retrieve:\n                    raise ValueError(  # noqa: TRY003\n                        \"Cannot combine registries with conflicting retrieval \"\n                        \"functions.\",\n                    )\n                retrieve = registry._retrieve\n        return evolve(\n            self,\n            anchors=anchors,\n            resources=resources,\n            uncrawled=uncrawled,\n            retrieve=retrieve,\n        )\n\n    def resolver(self, base_uri: URI = \"\") -> Resolver[D]:\n        \"\"\"\n        Return a `Resolver` which resolves references against this registry.\n        \"\"\"\n        return Resolver(base_uri=base_uri, registry=self)\n\n    def resolver_with_root(self, resource: Resource[D]) -> Resolver[D]:\n        \"\"\"\n        Return a `Resolver` with a specific root resource.\n        \"\"\"\n        uri = resource.id() or \"\"\n        return Resolver(\n            base_uri=uri,\n            registry=self.with_resource(uri, resource),\n        )\n\n\n#: An anchor or resource.\nAnchorOrResource = TypeVar(\"AnchorOrResource\", AnchorType[Any], Resource[Any])\n\n\n@frozen\nclass Retrieved(Generic[D, AnchorOrResource]):\n    \"\"\"\n    A value retrieved from a `Registry`.\n    \"\"\"\n\n    value: AnchorOrResource\n    registry: Registry[D]\n\n\n@frozen\nclass Resolved(Generic[D]):\n    \"\"\"\n    A reference resolved to its contents by a `Resolver`.\n    \"\"\"\n\n    contents: D\n    resolver: Resolver[D]\n\n\n@frozen\nclass Resolver(Generic[D]):\n    \"\"\"\n    A reference resolver.\n\n    Resolvers help resolve references (including relative ones) by\n    pairing a fixed base URI with a `Registry`.\n\n    This object, under normal circumstances, is expected to be used by\n    *implementers of libraries* built on top of `referencing` (e.g. JSON Schema\n    implementations or other libraries resolving JSON references),\n    not directly by end-users populating registries or while writing\n    schemas or other resources.\n\n    References are resolved against the base URI, and the combined URI\n    is then looked up within the registry.\n\n    The process of resolving a reference may itself involve calculating\n    a *new* base URI for future reference resolution (e.g. if an\n    intermediate resource sets a new base URI), or may involve encountering\n    additional subresources and adding them to a new registry.\n    \"\"\"\n\n    _base_uri: URI = field(alias=\"base_uri\")\n    _registry: Registry[D] = field(alias=\"registry\")\n    _previous: List[URI] = field(default=List(), repr=False, alias=\"previous\")\n\n    def lookup(self, ref: URI) -> Resolved[D]:\n        \"\"\"\n        Resolve the given reference to the resource it points to.\n\n        Raises:\n\n            `exceptions.Unresolvable`\n\n                or a subclass thereof (see below) if the reference isn't\n                resolvable\n\n            `exceptions.NoSuchAnchor`\n\n                if the reference is to a URI where a resource exists but\n                contains a plain name fragment which does not exist within\n                the resource\n\n            `exceptions.PointerToNowhere`\n\n                if the reference is to a URI where a resource exists but\n                contains a JSON pointer to a location within the resource\n                that does not exist\n\n        \"\"\"\n        if ref.startswith(\"#\"):\n            uri, fragment = self._base_uri, ref[1:]\n        else:\n            uri, fragment = urldefrag(urljoin(self._base_uri, ref))\n        try:\n            retrieved = self._registry.get_or_retrieve(uri)\n        except exceptions.NoSuchResource:\n            raise exceptions.Unresolvable(ref=ref) from None\n        except exceptions.Unretrievable as error:\n            raise exceptions.Unresolvable(ref=ref) from error\n\n        if fragment.startswith(\"/\"):\n            resolver = self._evolve(registry=retrieved.registry, base_uri=uri)\n            return retrieved.value.pointer(pointer=fragment, resolver=resolver)\n\n        if fragment:\n            retrieved = retrieved.registry.anchor(uri, fragment)\n            resolver = self._evolve(registry=retrieved.registry, base_uri=uri)\n            return retrieved.value.resolve(resolver=resolver)\n\n        resolver = self._evolve(registry=retrieved.registry, base_uri=uri)\n        return Resolved(contents=retrieved.value.contents, resolver=resolver)\n\n    def in_subresource(self, subresource: Resource[D]) -> Resolver[D]:\n        \"\"\"\n        Create a resolver for a subresource (which may have a new base URI).\n        \"\"\"\n        id = subresource.id()\n        if id is None:\n            return self\n        return evolve(self, base_uri=urljoin(self._base_uri, id))\n\n    def dynamic_scope(self) -> Iterable[tuple[URI, Registry[D]]]:\n        \"\"\"\n        In specs with such a notion, return the URIs in the dynamic scope.\n        \"\"\"\n        for uri in self._previous:\n            yield uri, self._registry\n\n    def _evolve(self, base_uri: URI, **kwargs: Any):\n        \"\"\"\n        Evolve, appending to the dynamic scope.\n        \"\"\"\n        previous = self._previous\n        if self._base_uri and (not previous or base_uri != self._base_uri):\n            previous = previous.push_front(self._base_uri)\n        return evolve(self, base_uri=base_uri, previous=previous, **kwargs)\n\n\n@frozen\nclass Anchor(Generic[D]):\n    \"\"\"\n    A simple anchor in a `Resource`.\n    \"\"\"\n\n    name: str\n    resource: Resource[D]\n\n    def resolve(self, resolver: Resolver[D]):\n        \"\"\"\n        Return the resource for this anchor.\n        \"\"\"\n        return Resolved(contents=self.resource.contents, resolver=resolver)\n", "referencing/tests/test_referencing_suite.py": "from pathlib import Path\nimport json\nimport os\n\nimport pytest\n\nfrom referencing import Registry\nfrom referencing.exceptions import Unresolvable\nimport referencing.jsonschema\n\n\nclass SuiteNotFound(Exception):\n    def __str__(self):  # pragma: no cover\n        return (\n            \"Cannot find the referencing suite. \"\n            \"Set the REFERENCING_SUITE environment variable to the path to \"\n            \"the suite, or run the test suite from alongside a full checkout \"\n            \"of the git repository.\"\n        )\n\n\nif \"REFERENCING_SUITE\" in os.environ:  # pragma: no cover\n    SUITE = Path(os.environ[\"REFERENCING_SUITE\"]) / \"tests\"\nelse:\n    SUITE = Path(__file__).parent.parent.parent / \"suite/tests\"\nif not SUITE.is_dir():  # pragma: no cover\n    raise SuiteNotFound()\nDIALECT_IDS = json.loads(SUITE.joinpath(\"specifications.json\").read_text())\n\n\n@pytest.mark.parametrize(\n    \"test_path\",\n    [\n        pytest.param(each, id=f\"{each.parent.name}-{each.stem}\")\n        for each in SUITE.glob(\"*/**/*.json\")\n    ],\n)\ndef test_referencing_suite(test_path, subtests):\n    dialect_id = DIALECT_IDS[test_path.relative_to(SUITE).parts[0]]\n    specification = referencing.jsonschema.specification_with(dialect_id)\n    loaded = json.loads(test_path.read_text())\n    registry = loaded[\"registry\"]\n    registry = Registry().with_resources(\n        (uri, specification.create_resource(contents))\n        for uri, contents in loaded[\"registry\"].items()\n    )\n    for test in loaded[\"tests\"]:\n        with subtests.test(test=test):\n            if \"normalization\" in test_path.stem:\n                pytest.xfail(\"APIs need to change for proper URL support.\")\n\n            resolver = registry.resolver(base_uri=test.get(\"base_uri\", \"\"))\n\n            if test.get(\"error\"):\n                with pytest.raises(Unresolvable):\n                    resolver.lookup(test[\"ref\"])\n            else:\n                resolved = resolver.lookup(test[\"ref\"])\n                assert resolved.contents == test[\"target\"]\n\n                then = test.get(\"then\")\n                while then:  # pragma: no cover\n                    with subtests.test(test=test, then=then):\n                        resolved = resolved.resolver.lookup(then[\"ref\"])\n                        assert resolved.contents == then[\"target\"]\n                    then = then.get(\"then\")\n", "referencing/tests/test_jsonschema.py": "import pytest\n\nfrom referencing import Registry, Resource, Specification\nimport referencing.jsonschema\n\n\n@pytest.mark.parametrize(\n    \"uri, expected\",\n    [\n        (\n            \"https://json-schema.org/draft/2020-12/schema\",\n            referencing.jsonschema.DRAFT202012,\n        ),\n        (\n            \"https://json-schema.org/draft/2019-09/schema\",\n            referencing.jsonschema.DRAFT201909,\n        ),\n        (\n            \"http://json-schema.org/draft-07/schema#\",\n            referencing.jsonschema.DRAFT7,\n        ),\n        (\n            \"http://json-schema.org/draft-06/schema#\",\n            referencing.jsonschema.DRAFT6,\n        ),\n        (\n            \"http://json-schema.org/draft-04/schema#\",\n            referencing.jsonschema.DRAFT4,\n        ),\n        (\n            \"http://json-schema.org/draft-03/schema#\",\n            referencing.jsonschema.DRAFT3,\n        ),\n    ],\n)\ndef test_schemas_with_explicit_schema_keywords_are_detected(uri, expected):\n    \"\"\"\n    The $schema keyword in JSON Schema is a dialect identifier.\n    \"\"\"\n    contents = {\"$schema\": uri}\n    resource = Resource.from_contents(contents)\n    assert resource == Resource(contents=contents, specification=expected)\n\n\ndef test_unknown_dialect():\n    dialect_id = \"http://example.com/unknown-json-schema-dialect-id\"\n    with pytest.raises(referencing.jsonschema.UnknownDialect) as excinfo:\n        Resource.from_contents({\"$schema\": dialect_id})\n    assert excinfo.value.uri == dialect_id\n\n\n@pytest.mark.parametrize(\n    \"id, specification\",\n    [\n        (\"$id\", referencing.jsonschema.DRAFT202012),\n        (\"$id\", referencing.jsonschema.DRAFT201909),\n        (\"$id\", referencing.jsonschema.DRAFT7),\n        (\"$id\", referencing.jsonschema.DRAFT6),\n        (\"id\", referencing.jsonschema.DRAFT4),\n        (\"id\", referencing.jsonschema.DRAFT3),\n    ],\n)\ndef test_id_of_mapping(id, specification):\n    uri = \"http://example.com/some-schema\"\n    assert specification.id_of({id: uri}) == uri\n\n\n@pytest.mark.parametrize(\n    \"specification\",\n    [\n        referencing.jsonschema.DRAFT202012,\n        referencing.jsonschema.DRAFT201909,\n        referencing.jsonschema.DRAFT7,\n        referencing.jsonschema.DRAFT6,\n    ],\n)\n@pytest.mark.parametrize(\"value\", [True, False])\ndef test_id_of_bool(specification, value):\n    assert specification.id_of(value) is None\n\n\n@pytest.mark.parametrize(\n    \"specification\",\n    [\n        referencing.jsonschema.DRAFT202012,\n        referencing.jsonschema.DRAFT201909,\n        referencing.jsonschema.DRAFT7,\n        referencing.jsonschema.DRAFT6,\n    ],\n)\n@pytest.mark.parametrize(\"value\", [True, False])\ndef test_anchors_in_bool(specification, value):\n    assert list(specification.anchors_in(value)) == []\n\n\n@pytest.mark.parametrize(\n    \"specification\",\n    [\n        referencing.jsonschema.DRAFT202012,\n        referencing.jsonschema.DRAFT201909,\n        referencing.jsonschema.DRAFT7,\n        referencing.jsonschema.DRAFT6,\n    ],\n)\n@pytest.mark.parametrize(\"value\", [True, False])\ndef test_subresources_of_bool(specification, value):\n    assert list(specification.subresources_of(value)) == []\n\n\n@pytest.mark.parametrize(\n    \"uri, expected\",\n    [\n        (\n            \"https://json-schema.org/draft/2020-12/schema\",\n            referencing.jsonschema.DRAFT202012,\n        ),\n        (\n            \"https://json-schema.org/draft/2019-09/schema\",\n            referencing.jsonschema.DRAFT201909,\n        ),\n        (\n            \"http://json-schema.org/draft-07/schema#\",\n            referencing.jsonschema.DRAFT7,\n        ),\n        (\n            \"http://json-schema.org/draft-06/schema#\",\n            referencing.jsonschema.DRAFT6,\n        ),\n        (\n            \"http://json-schema.org/draft-04/schema#\",\n            referencing.jsonschema.DRAFT4,\n        ),\n        (\n            \"http://json-schema.org/draft-03/schema#\",\n            referencing.jsonschema.DRAFT3,\n        ),\n    ],\n)\ndef test_specification_with(uri, expected):\n    assert referencing.jsonschema.specification_with(uri) == expected\n\n\n@pytest.mark.parametrize(\n    \"uri, expected\",\n    [\n        (\n            \"http://json-schema.org/draft-07/schema\",\n            referencing.jsonschema.DRAFT7,\n        ),\n        (\n            \"http://json-schema.org/draft-06/schema\",\n            referencing.jsonschema.DRAFT6,\n        ),\n        (\n            \"http://json-schema.org/draft-04/schema\",\n            referencing.jsonschema.DRAFT4,\n        ),\n        (\n            \"http://json-schema.org/draft-03/schema\",\n            referencing.jsonschema.DRAFT3,\n        ),\n    ],\n)\ndef test_specification_with_no_empty_fragment(uri, expected):\n    assert referencing.jsonschema.specification_with(uri) == expected\n\n\ndef test_specification_with_unknown_dialect():\n    dialect_id = \"http://example.com/unknown-json-schema-dialect-id\"\n    with pytest.raises(referencing.jsonschema.UnknownDialect) as excinfo:\n        referencing.jsonschema.specification_with(dialect_id)\n    assert excinfo.value.uri == dialect_id\n\n\ndef test_specification_with_default():\n    dialect_id = \"http://example.com/unknown-json-schema-dialect-id\"\n    specification = referencing.jsonschema.specification_with(\n        dialect_id,\n        default=Specification.OPAQUE,\n    )\n    assert specification is Specification.OPAQUE\n\n\n# FIXME: The tests below should move to the referencing suite but I haven't yet\n#        figured out how to represent dynamic (& recursive) ref lookups in it.\ndef test_lookup_trivial_dynamic_ref():\n    one = referencing.jsonschema.DRAFT202012.create_resource(\n        {\"$dynamicAnchor\": \"foo\"},\n    )\n    resolver = Registry().with_resource(\"http://example.com\", one).resolver()\n    resolved = resolver.lookup(\"http://example.com#foo\")\n    assert resolved.contents == one.contents\n\n\ndef test_multiple_lookup_trivial_dynamic_ref():\n    TRUE = referencing.jsonschema.DRAFT202012.create_resource(True)\n    root = referencing.jsonschema.DRAFT202012.create_resource(\n        {\n            \"$id\": \"http://example.com\",\n            \"$dynamicAnchor\": \"fooAnchor\",\n            \"$defs\": {\n                \"foo\": {\n                    \"$id\": \"foo\",\n                    \"$dynamicAnchor\": \"fooAnchor\",\n                    \"$defs\": {\n                        \"bar\": True,\n                        \"baz\": {\n                            \"$dynamicAnchor\": \"fooAnchor\",\n                        },\n                    },\n                },\n            },\n        },\n    )\n    resolver = (\n        Registry()\n        .with_resources(\n            [\n                (\"http://example.com\", root),\n                (\"http://example.com/foo/\", TRUE),\n                (\"http://example.com/foo/bar\", root),\n            ],\n        )\n        .resolver()\n    )\n\n    first = resolver.lookup(\"http://example.com\")\n    second = first.resolver.lookup(\"foo/\")\n    resolver = second.resolver.lookup(\"bar\").resolver\n    fourth = resolver.lookup(\"#fooAnchor\")\n    assert fourth.contents == root.contents\n\n\ndef test_multiple_lookup_dynamic_ref_to_nondynamic_ref():\n    one = referencing.jsonschema.DRAFT202012.create_resource(\n        {\"$anchor\": \"fooAnchor\"},\n    )\n    two = referencing.jsonschema.DRAFT202012.create_resource(\n        {\n            \"$id\": \"http://example.com\",\n            \"$dynamicAnchor\": \"fooAnchor\",\n            \"$defs\": {\n                \"foo\": {\n                    \"$id\": \"foo\",\n                    \"$dynamicAnchor\": \"fooAnchor\",\n                    \"$defs\": {\n                        \"bar\": True,\n                        \"baz\": {\n                            \"$dynamicAnchor\": \"fooAnchor\",\n                        },\n                    },\n                },\n            },\n        },\n    )\n    resolver = (\n        Registry()\n        .with_resources(\n            [\n                (\"http://example.com\", two),\n                (\"http://example.com/foo/\", one),\n                (\"http://example.com/foo/bar\", two),\n            ],\n        )\n        .resolver()\n    )\n\n    first = resolver.lookup(\"http://example.com\")\n    second = first.resolver.lookup(\"foo/\")\n    resolver = second.resolver.lookup(\"bar\").resolver\n    fourth = resolver.lookup(\"#fooAnchor\")\n    assert fourth.contents == two.contents\n\n\ndef test_lookup_trivial_recursive_ref():\n    one = referencing.jsonschema.DRAFT201909.create_resource(\n        {\"$recursiveAnchor\": True},\n    )\n    resolver = Registry().with_resource(\"http://example.com\", one).resolver()\n    first = resolver.lookup(\"http://example.com\")\n    resolved = referencing.jsonschema.lookup_recursive_ref(\n        resolver=first.resolver,\n    )\n    assert resolved.contents == one.contents\n\n\ndef test_lookup_recursive_ref_to_bool():\n    TRUE = referencing.jsonschema.DRAFT201909.create_resource(True)\n    registry = Registry({\"http://example.com\": TRUE})\n    resolved = referencing.jsonschema.lookup_recursive_ref(\n        resolver=registry.resolver(base_uri=\"http://example.com\"),\n    )\n    assert resolved.contents == TRUE.contents\n\n\ndef test_multiple_lookup_recursive_ref_to_bool():\n    TRUE = referencing.jsonschema.DRAFT201909.create_resource(True)\n    root = referencing.jsonschema.DRAFT201909.create_resource(\n        {\n            \"$id\": \"http://example.com\",\n            \"$recursiveAnchor\": True,\n            \"$defs\": {\n                \"foo\": {\n                    \"$id\": \"foo\",\n                    \"$recursiveAnchor\": True,\n                    \"$defs\": {\n                        \"bar\": True,\n                        \"baz\": {\n                            \"$recursiveAnchor\": True,\n                            \"$anchor\": \"fooAnchor\",\n                        },\n                    },\n                },\n            },\n        },\n    )\n    resolver = (\n        Registry()\n        .with_resources(\n            [\n                (\"http://example.com\", root),\n                (\"http://example.com/foo/\", TRUE),\n                (\"http://example.com/foo/bar\", root),\n            ],\n        )\n        .resolver()\n    )\n\n    first = resolver.lookup(\"http://example.com\")\n    second = first.resolver.lookup(\"foo/\")\n    resolver = second.resolver.lookup(\"bar\").resolver\n    fourth = referencing.jsonschema.lookup_recursive_ref(resolver=resolver)\n    assert fourth.contents == root.contents\n\n\ndef test_multiple_lookup_recursive_ref_with_nonrecursive_ref():\n    one = referencing.jsonschema.DRAFT201909.create_resource(\n        {\"$recursiveAnchor\": True},\n    )\n    two = referencing.jsonschema.DRAFT201909.create_resource(\n        {\n            \"$id\": \"http://example.com\",\n            \"$recursiveAnchor\": True,\n            \"$defs\": {\n                \"foo\": {\n                    \"$id\": \"foo\",\n                    \"$recursiveAnchor\": True,\n                    \"$defs\": {\n                        \"bar\": True,\n                        \"baz\": {\n                            \"$recursiveAnchor\": True,\n                            \"$anchor\": \"fooAnchor\",\n                        },\n                    },\n                },\n            },\n        },\n    )\n    three = referencing.jsonschema.DRAFT201909.create_resource(\n        {\"$recursiveAnchor\": False},\n    )\n    resolver = (\n        Registry()\n        .with_resources(\n            [\n                (\"http://example.com\", three),\n                (\"http://example.com/foo/\", two),\n                (\"http://example.com/foo/bar\", one),\n            ],\n        )\n        .resolver()\n    )\n\n    first = resolver.lookup(\"http://example.com\")\n    second = first.resolver.lookup(\"foo/\")\n    resolver = second.resolver.lookup(\"bar\").resolver\n    fourth = referencing.jsonschema.lookup_recursive_ref(resolver=resolver)\n    assert fourth.contents == two.contents\n\n\ndef test_empty_registry():\n    assert referencing.jsonschema.EMPTY_REGISTRY == Registry()\n", "referencing/tests/test_retrieval.py": "from functools import lru_cache\nimport json\n\nimport pytest\n\nfrom referencing import Registry, Resource, exceptions\nfrom referencing.jsonschema import DRAFT202012\nfrom referencing.retrieval import to_cached_resource\n\n\nclass TestToCachedResource:\n    def test_it_caches_retrieved_resources(self):\n        contents = {\"$schema\": \"https://json-schema.org/draft/2020-12/schema\"}\n        stack = [json.dumps(contents)]\n\n        @to_cached_resource()\n        def retrieve(uri):\n            return stack.pop()\n\n        registry = Registry(retrieve=retrieve)\n\n        expected = Resource.from_contents(contents)\n\n        got = registry.get_or_retrieve(\"urn:example:schema\")\n        assert got.value == expected\n\n        # And a second time we get the same value.\n        again = registry.get_or_retrieve(\"urn:example:schema\")\n        assert again.value is got.value\n\n    def test_custom_loader(self):\n        contents = {\"$schema\": \"https://json-schema.org/draft/2020-12/schema\"}\n        stack = [json.dumps(contents)[::-1]]\n\n        @to_cached_resource(loads=lambda s: json.loads(s[::-1]))\n        def retrieve(uri):\n            return stack.pop()\n\n        registry = Registry(retrieve=retrieve)\n\n        expected = Resource.from_contents(contents)\n\n        got = registry.get_or_retrieve(\"urn:example:schema\")\n        assert got.value == expected\n\n        # And a second time we get the same value.\n        again = registry.get_or_retrieve(\"urn:example:schema\")\n        assert again.value is got.value\n\n    def test_custom_from_contents(self):\n        contents = {}\n        stack = [json.dumps(contents)]\n\n        @to_cached_resource(from_contents=DRAFT202012.create_resource)\n        def retrieve(uri):\n            return stack.pop()\n\n        registry = Registry(retrieve=retrieve)\n\n        expected = DRAFT202012.create_resource(contents)\n\n        got = registry.get_or_retrieve(\"urn:example:schema\")\n        assert got.value == expected\n\n        # And a second time we get the same value.\n        again = registry.get_or_retrieve(\"urn:example:schema\")\n        assert again.value is got.value\n\n    def test_custom_cache(self):\n        schema = {\"$schema\": \"https://json-schema.org/draft/2020-12/schema\"}\n        mapping = {\n            \"urn:example:1\": dict(schema, foo=1),\n            \"urn:example:2\": dict(schema, foo=2),\n            \"urn:example:3\": dict(schema, foo=3),\n        }\n\n        resources = {\n            uri: Resource.from_contents(contents)\n            for uri, contents in mapping.items()\n        }\n\n        @to_cached_resource(cache=lru_cache(maxsize=2))\n        def retrieve(uri):\n            return json.dumps(mapping.pop(uri))\n\n        registry = Registry(retrieve=retrieve)\n\n        got = registry.get_or_retrieve(\"urn:example:1\")\n        assert got.value == resources[\"urn:example:1\"]\n        assert registry.get_or_retrieve(\"urn:example:1\").value is got.value\n        assert registry.get_or_retrieve(\"urn:example:1\").value is got.value\n\n        got = registry.get_or_retrieve(\"urn:example:2\")\n        assert got.value == resources[\"urn:example:2\"]\n        assert registry.get_or_retrieve(\"urn:example:2\").value is got.value\n        assert registry.get_or_retrieve(\"urn:example:2\").value is got.value\n\n        # This still succeeds, but evicts the first URI\n        got = registry.get_or_retrieve(\"urn:example:3\")\n        assert got.value == resources[\"urn:example:3\"]\n        assert registry.get_or_retrieve(\"urn:example:3\").value is got.value\n        assert registry.get_or_retrieve(\"urn:example:3\").value is got.value\n\n        # And now this fails (as we popped the value out of `mapping`)\n        with pytest.raises(exceptions.Unretrievable):\n            registry.get_or_retrieve(\"urn:example:1\")\n", "referencing/tests/test_exceptions.py": "import itertools\n\nimport pytest\n\nfrom referencing import Resource, exceptions\n\n\ndef pairs(choices):\n    return itertools.combinations(choices, 2)\n\n\nTRUE = Resource.opaque(True)\n\n\nthunks = (\n    lambda: exceptions.CannotDetermineSpecification(TRUE),\n    lambda: exceptions.NoSuchResource(\"urn:example:foo\"),\n    lambda: exceptions.NoInternalID(TRUE),\n    lambda: exceptions.InvalidAnchor(resource=TRUE, anchor=\"foo\", ref=\"a#b\"),\n    lambda: exceptions.NoSuchAnchor(resource=TRUE, anchor=\"foo\", ref=\"a#b\"),\n    lambda: exceptions.PointerToNowhere(resource=TRUE, ref=\"urn:example:foo\"),\n    lambda: exceptions.Unresolvable(\"urn:example:foo\"),\n    lambda: exceptions.Unretrievable(\"urn:example:foo\"),\n)\n\n\n@pytest.mark.parametrize(\"one, two\", pairs(each() for each in thunks))\ndef test_eq_incompatible_types(one, two):\n    assert one != two\n\n\n@pytest.mark.parametrize(\"thunk\", thunks)\ndef test_hash(thunk):\n    assert thunk() in {thunk()}\n", "referencing/tests/test_core.py": "from rpds import HashTrieMap\nimport pytest\n\nfrom referencing import Anchor, Registry, Resource, Specification, exceptions\nfrom referencing.jsonschema import DRAFT202012\n\nID_AND_CHILDREN = Specification(\n    name=\"id-and-children\",\n    id_of=lambda contents: contents.get(\"ID\"),\n    subresources_of=lambda contents: contents.get(\"children\", []),\n    anchors_in=lambda specification, contents: [\n        Anchor(\n            name=name,\n            resource=specification.create_resource(contents=each),\n        )\n        for name, each in contents.get(\"anchors\", {}).items()\n    ],\n    maybe_in_subresource=lambda segments, resolver, subresource: (\n        resolver.in_subresource(subresource)\n        if not len(segments) % 2\n        and all(each == \"children\" for each in segments[::2])\n        else resolver\n    ),\n)\n\n\ndef blow_up(uri):  # pragma: no cover\n    \"\"\"\n    A retriever suitable for use in tests which expect it never to be used.\n    \"\"\"\n    raise RuntimeError(\"This retrieve function expects to never be called!\")\n\n\nclass TestRegistry:\n    def test_with_resource(self):\n        \"\"\"\n        Adding a resource to the registry then allows re-retrieving it.\n        \"\"\"\n\n        resource = Resource.opaque(contents={\"foo\": \"bar\"})\n        uri = \"urn:example\"\n        registry = Registry().with_resource(uri=uri, resource=resource)\n        assert registry[uri] is resource\n\n    def test_with_resources(self):\n        \"\"\"\n        Adding multiple resources to the registry is like adding each one.\n        \"\"\"\n\n        one = Resource.opaque(contents={})\n        two = Resource(contents={\"foo\": \"bar\"}, specification=ID_AND_CHILDREN)\n        registry = Registry().with_resources(\n            [\n                (\"http://example.com/1\", one),\n                (\"http://example.com/foo/bar\", two),\n            ],\n        )\n        assert registry == Registry().with_resource(\n            uri=\"http://example.com/1\",\n            resource=one,\n        ).with_resource(\n            uri=\"http://example.com/foo/bar\",\n            resource=two,\n        )\n\n    def test_matmul_resource(self):\n        uri = \"urn:example:resource\"\n        resource = ID_AND_CHILDREN.create_resource({\"ID\": uri, \"foo\": 12})\n        registry = resource @ Registry()\n        assert registry == Registry().with_resource(uri, resource)\n\n    def test_matmul_many_resources(self):\n        one_uri = \"urn:example:one\"\n        one = ID_AND_CHILDREN.create_resource({\"ID\": one_uri, \"foo\": 12})\n\n        two_uri = \"urn:example:two\"\n        two = ID_AND_CHILDREN.create_resource({\"ID\": two_uri, \"foo\": 12})\n\n        registry = [one, two] @ Registry()\n        assert registry == Registry().with_resources(\n            [(one_uri, one), (two_uri, two)],\n        )\n\n    def test_matmul_resource_without_id(self):\n        resource = Resource.opaque(contents={\"foo\": \"bar\"})\n        with pytest.raises(exceptions.NoInternalID) as e:\n            resource @ Registry()\n        assert e.value == exceptions.NoInternalID(resource=resource)\n\n    def test_with_contents_from_json_schema(self):\n        uri = \"urn:example\"\n        schema = {\"$schema\": \"https://json-schema.org/draft/2020-12/schema\"}\n        registry = Registry().with_contents([(uri, schema)])\n\n        expected = Resource(contents=schema, specification=DRAFT202012)\n        assert registry[uri] == expected\n\n    def test_with_contents_and_default_specification(self):\n        uri = \"urn:example\"\n        registry = Registry().with_contents(\n            [(uri, {\"foo\": \"bar\"})],\n            default_specification=Specification.OPAQUE,\n        )\n        assert registry[uri] == Resource.opaque({\"foo\": \"bar\"})\n\n    def test_len(self):\n        total = 5\n        registry = Registry().with_contents(\n            [(str(i), {\"foo\": \"bar\"}) for i in range(total)],\n            default_specification=Specification.OPAQUE,\n        )\n        assert len(registry) == total\n\n    def test_bool_empty(self):\n        assert not Registry()\n\n    def test_bool_not_empty(self):\n        registry = Registry().with_contents(\n            [(str(i), {\"foo\": \"bar\"}) for i in range(3)],\n            default_specification=Specification.OPAQUE,\n        )\n        assert registry\n\n    def test_iter(self):\n        registry = Registry().with_contents(\n            [(str(i), {\"foo\": \"bar\"}) for i in range(8)],\n            default_specification=Specification.OPAQUE,\n        )\n        assert set(registry) == {str(i) for i in range(8)}\n\n    def test_crawl_still_has_top_level_resource(self):\n        resource = Resource.opaque({\"foo\": \"bar\"})\n        uri = \"urn:example\"\n        registry = Registry({uri: resource}).crawl()\n        assert registry[uri] is resource\n\n    def test_crawl_finds_a_subresource(self):\n        child_id = \"urn:child\"\n        root = ID_AND_CHILDREN.create_resource(\n            {\"ID\": \"urn:root\", \"children\": [{\"ID\": child_id, \"foo\": 12}]},\n        )\n        registry = root @ Registry()\n        with pytest.raises(LookupError):\n            registry[child_id]\n\n        expected = ID_AND_CHILDREN.create_resource({\"ID\": child_id, \"foo\": 12})\n        assert registry.crawl()[child_id] == expected\n\n    def test_crawl_finds_anchors_with_id(self):\n        resource = ID_AND_CHILDREN.create_resource(\n            {\"ID\": \"urn:bar\", \"anchors\": {\"foo\": 12}},\n        )\n        registry = resource @ Registry()\n\n        assert registry.crawl().anchor(resource.id(), \"foo\").value == Anchor(\n            name=\"foo\",\n            resource=ID_AND_CHILDREN.create_resource(12),\n        )\n\n    def test_crawl_finds_anchors_no_id(self):\n        resource = ID_AND_CHILDREN.create_resource({\"anchors\": {\"foo\": 12}})\n        registry = Registry().with_resource(\"urn:root\", resource)\n\n        assert registry.crawl().anchor(\"urn:root\", \"foo\").value == Anchor(\n            name=\"foo\",\n            resource=ID_AND_CHILDREN.create_resource(12),\n        )\n\n    def test_contents(self):\n        resource = Resource.opaque({\"foo\": \"bar\"})\n        uri = \"urn:example\"\n        registry = Registry().with_resource(uri, resource)\n        assert registry.contents(uri) == {\"foo\": \"bar\"}\n\n    def test_getitem_strips_empty_fragments(self):\n        uri = \"http://example.com/\"\n        resource = ID_AND_CHILDREN.create_resource({\"ID\": uri + \"#\"})\n        registry = resource @ Registry()\n        assert registry[uri] == registry[uri + \"#\"] == resource\n\n    def test_contents_strips_empty_fragments(self):\n        uri = \"http://example.com/\"\n        resource = ID_AND_CHILDREN.create_resource({\"ID\": uri + \"#\"})\n        registry = resource @ Registry()\n        assert (\n            registry.contents(uri)\n            == registry.contents(uri + \"#\")\n            == {\"ID\": uri + \"#\"}\n        )\n\n    def test_contents_nonexistent_resource(self):\n        registry = Registry()\n        with pytest.raises(exceptions.NoSuchResource) as e:\n            registry.contents(\"urn:example\")\n        assert e.value == exceptions.NoSuchResource(ref=\"urn:example\")\n\n    def test_crawled_anchor(self):\n        resource = ID_AND_CHILDREN.create_resource({\"anchors\": {\"foo\": \"bar\"}})\n        registry = Registry().with_resource(\"urn:example\", resource)\n        retrieved = registry.anchor(\"urn:example\", \"foo\")\n        assert retrieved.value == Anchor(\n            name=\"foo\",\n            resource=ID_AND_CHILDREN.create_resource(\"bar\"),\n        )\n        assert retrieved.registry == registry.crawl()\n\n    def test_anchor_in_nonexistent_resource(self):\n        registry = Registry()\n        with pytest.raises(exceptions.NoSuchResource) as e:\n            registry.anchor(\"urn:example\", \"foo\")\n        assert e.value == exceptions.NoSuchResource(ref=\"urn:example\")\n\n    def test_init(self):\n        one = Resource.opaque(contents={})\n        two = ID_AND_CHILDREN.create_resource({\"foo\": \"bar\"})\n        registry = Registry(\n            {\n                \"http://example.com/1\": one,\n                \"http://example.com/foo/bar\": two,\n            },\n        )\n        assert (\n            registry\n            == Registry()\n            .with_resources(\n                [\n                    (\"http://example.com/1\", one),\n                    (\"http://example.com/foo/bar\", two),\n                ],\n            )\n            .crawl()\n        )\n\n    def test_dict_conversion(self):\n        \"\"\"\n        Passing a `dict` to `Registry` gets converted to a `HashTrieMap`.\n\n        So continuing to use the registry works.\n        \"\"\"\n\n        one = Resource.opaque(contents={})\n        two = ID_AND_CHILDREN.create_resource({\"foo\": \"bar\"})\n        registry = Registry(\n            {\"http://example.com/1\": one},\n        ).with_resource(\"http://example.com/foo/bar\", two)\n        assert (\n            registry.crawl()\n            == Registry()\n            .with_resources(\n                [\n                    (\"http://example.com/1\", one),\n                    (\"http://example.com/foo/bar\", two),\n                ],\n            )\n            .crawl()\n        )\n\n    def test_no_such_resource(self):\n        registry = Registry()\n        with pytest.raises(exceptions.NoSuchResource) as e:\n            registry[\"urn:bigboom\"]\n        assert e.value == exceptions.NoSuchResource(ref=\"urn:bigboom\")\n\n    def test_combine(self):\n        one = Resource.opaque(contents={})\n        two = ID_AND_CHILDREN.create_resource({\"foo\": \"bar\"})\n        three = ID_AND_CHILDREN.create_resource({\"baz\": \"quux\"})\n        four = ID_AND_CHILDREN.create_resource({\"anchors\": {\"foo\": 12}})\n\n        first = Registry({\"http://example.com/1\": one})\n        second = Registry().with_resource(\"http://example.com/foo/bar\", two)\n        third = Registry(\n            {\n                \"http://example.com/1\": one,\n                \"http://example.com/baz\": three,\n            },\n        )\n        fourth = (\n            Registry()\n            .with_resource(\n                \"http://example.com/foo/quux\",\n                four,\n            )\n            .crawl()\n        )\n        assert first.combine(second, third, fourth) == Registry(\n            [\n                (\"http://example.com/1\", one),\n                (\"http://example.com/baz\", three),\n                (\"http://example.com/foo/quux\", four),\n            ],\n            anchors=HashTrieMap(\n                {\n                    (\"http://example.com/foo/quux\", \"foo\"): Anchor(\n                        name=\"foo\",\n                        resource=ID_AND_CHILDREN.create_resource(12),\n                    ),\n                },\n            ),\n        ).with_resource(\"http://example.com/foo/bar\", two)\n\n    def test_combine_self(self):\n        \"\"\"\n        Combining a registry with itself short-circuits.\n\n        This is a performance optimization -- otherwise we do lots more work\n        (in jsonschema this seems to correspond to making the test suite take\n         *3x* longer).\n        \"\"\"\n\n        registry = Registry({\"urn:foo\": \"bar\"})\n        assert registry.combine(registry) is registry\n\n    def test_combine_with_uncrawled_resources(self):\n        one = Resource.opaque(contents={})\n        two = ID_AND_CHILDREN.create_resource({\"foo\": \"bar\"})\n        three = ID_AND_CHILDREN.create_resource({\"baz\": \"quux\"})\n\n        first = Registry().with_resource(\"http://example.com/1\", one)\n        second = Registry().with_resource(\"http://example.com/foo/bar\", two)\n        third = Registry(\n            {\n                \"http://example.com/1\": one,\n                \"http://example.com/baz\": three,\n            },\n        )\n        expected = Registry(\n            [\n                (\"http://example.com/1\", one),\n                (\"http://example.com/foo/bar\", two),\n                (\"http://example.com/baz\", three),\n            ],\n        )\n        combined = first.combine(second, third)\n        assert combined != expected\n        assert combined.crawl() == expected\n\n    def test_combine_with_single_retrieve(self):\n        one = Resource.opaque(contents={})\n        two = ID_AND_CHILDREN.create_resource({\"foo\": \"bar\"})\n        three = ID_AND_CHILDREN.create_resource({\"baz\": \"quux\"})\n\n        def retrieve(uri):  # pragma: no cover\n            pass\n\n        first = Registry().with_resource(\"http://example.com/1\", one)\n        second = Registry(\n            retrieve=retrieve,\n        ).with_resource(\"http://example.com/2\", two)\n        third = Registry().with_resource(\"http://example.com/3\", three)\n\n        assert first.combine(second, third) == Registry(\n            retrieve=retrieve,\n        ).with_resources(\n            [\n                (\"http://example.com/1\", one),\n                (\"http://example.com/2\", two),\n                (\"http://example.com/3\", three),\n            ],\n        )\n        assert second.combine(first, third) == Registry(\n            retrieve=retrieve,\n        ).with_resources(\n            [\n                (\"http://example.com/1\", one),\n                (\"http://example.com/2\", two),\n                (\"http://example.com/3\", three),\n            ],\n        )\n\n    def test_combine_with_common_retrieve(self):\n        one = Resource.opaque(contents={})\n        two = ID_AND_CHILDREN.create_resource({\"foo\": \"bar\"})\n        three = ID_AND_CHILDREN.create_resource({\"baz\": \"quux\"})\n\n        def retrieve(uri):  # pragma: no cover\n            pass\n\n        first = Registry(retrieve=retrieve).with_resource(\n            \"http://example.com/1\",\n            one,\n        )\n        second = Registry(\n            retrieve=retrieve,\n        ).with_resource(\"http://example.com/2\", two)\n        third = Registry(retrieve=retrieve).with_resource(\n            \"http://example.com/3\",\n            three,\n        )\n\n        assert first.combine(second, third) == Registry(\n            retrieve=retrieve,\n        ).with_resources(\n            [\n                (\"http://example.com/1\", one),\n                (\"http://example.com/2\", two),\n                (\"http://example.com/3\", three),\n            ],\n        )\n        assert second.combine(first, third) == Registry(\n            retrieve=retrieve,\n        ).with_resources(\n            [\n                (\"http://example.com/1\", one),\n                (\"http://example.com/2\", two),\n                (\"http://example.com/3\", three),\n            ],\n        )\n\n    def test_combine_conflicting_retrieve(self):\n        one = Resource.opaque(contents={})\n        two = ID_AND_CHILDREN.create_resource({\"foo\": \"bar\"})\n        three = ID_AND_CHILDREN.create_resource({\"baz\": \"quux\"})\n\n        def foo_retrieve(uri):  # pragma: no cover\n            pass\n\n        def bar_retrieve(uri):  # pragma: no cover\n            pass\n\n        first = Registry(retrieve=foo_retrieve).with_resource(\n            \"http://example.com/1\",\n            one,\n        )\n        second = Registry().with_resource(\"http://example.com/2\", two)\n        third = Registry(retrieve=bar_retrieve).with_resource(\n            \"http://example.com/3\",\n            three,\n        )\n\n        with pytest.raises(Exception, match=\"conflict.*retriev\"):\n            first.combine(second, third)\n\n    def test_remove(self):\n        one = Resource.opaque(contents={})\n        two = ID_AND_CHILDREN.create_resource({\"foo\": \"bar\"})\n        registry = Registry({\"urn:foo\": one, \"urn:bar\": two})\n        assert registry.remove(\"urn:foo\") == Registry({\"urn:bar\": two})\n\n    def test_remove_uncrawled(self):\n        one = Resource.opaque(contents={})\n        two = ID_AND_CHILDREN.create_resource({\"foo\": \"bar\"})\n        registry = Registry().with_resources(\n            [(\"urn:foo\", one), (\"urn:bar\", two)],\n        )\n        assert registry.remove(\"urn:foo\") == Registry().with_resource(\n            \"urn:bar\",\n            two,\n        )\n\n    def test_remove_with_anchors(self):\n        one = Resource.opaque(contents={})\n        two = ID_AND_CHILDREN.create_resource({\"anchors\": {\"foo\": \"bar\"}})\n        registry = (\n            Registry()\n            .with_resources(\n                [(\"urn:foo\", one), (\"urn:bar\", two)],\n            )\n            .crawl()\n        )\n        assert (\n            registry.remove(\"urn:bar\")\n            == Registry()\n            .with_resource(\n                \"urn:foo\",\n                one,\n            )\n            .crawl()\n        )\n\n    def test_remove_nonexistent_uri(self):\n        with pytest.raises(exceptions.NoSuchResource) as e:\n            Registry().remove(\"urn:doesNotExist\")\n        assert e.value == exceptions.NoSuchResource(ref=\"urn:doesNotExist\")\n\n    def test_retrieve(self):\n        foo = Resource.opaque({\"foo\": \"bar\"})\n        registry = Registry(retrieve=lambda uri: foo)\n        assert registry.get_or_retrieve(\"urn:example\").value == foo\n\n    def test_retrieve_arbitrary_exception(self):\n        foo = Resource.opaque({\"foo\": \"bar\"})\n\n        def retrieve(uri):\n            if uri == \"urn:succeed\":\n                return foo\n            raise Exception(\"Oh no!\")\n\n        registry = Registry(retrieve=retrieve)\n        assert registry.get_or_retrieve(\"urn:succeed\").value == foo\n        with pytest.raises(exceptions.Unretrievable):\n            registry.get_or_retrieve(\"urn:uhoh\")\n\n    def test_retrieve_no_such_resource(self):\n        foo = Resource.opaque({\"foo\": \"bar\"})\n\n        def retrieve(uri):\n            if uri == \"urn:succeed\":\n                return foo\n            raise exceptions.NoSuchResource(ref=uri)\n\n        registry = Registry(retrieve=retrieve)\n        assert registry.get_or_retrieve(\"urn:succeed\").value == foo\n        with pytest.raises(exceptions.NoSuchResource):\n            registry.get_or_retrieve(\"urn:uhoh\")\n\n    def test_retrieve_cannot_determine_specification(self):\n        def retrieve(uri):\n            return Resource.from_contents({})\n\n        registry = Registry(retrieve=retrieve)\n        with pytest.raises(exceptions.CannotDetermineSpecification):\n            registry.get_or_retrieve(\"urn:uhoh\")\n\n    def test_retrieve_already_available_resource(self):\n        foo = Resource.opaque({\"foo\": \"bar\"})\n        registry = Registry({\"urn:example\": foo}, retrieve=blow_up)\n        assert registry[\"urn:example\"] == foo\n        assert registry.get_or_retrieve(\"urn:example\").value == foo\n\n    def test_retrieve_first_checks_crawlable_resource(self):\n        child = ID_AND_CHILDREN.create_resource({\"ID\": \"urn:child\", \"foo\": 12})\n        root = ID_AND_CHILDREN.create_resource({\"children\": [child.contents]})\n        registry = Registry(retrieve=blow_up).with_resource(\"urn:root\", root)\n        assert registry.crawl()[\"urn:child\"] == child\n\n    def test_resolver(self):\n        one = Resource.opaque(contents={})\n        registry = Registry({\"http://example.com\": one})\n        resolver = registry.resolver(base_uri=\"http://example.com\")\n        assert resolver.lookup(\"#\").contents == {}\n\n    def test_resolver_with_root_identified(self):\n        root = ID_AND_CHILDREN.create_resource({\"ID\": \"http://example.com\"})\n        resolver = Registry().resolver_with_root(root)\n        assert resolver.lookup(\"http://example.com\").contents == root.contents\n        assert resolver.lookup(\"#\").contents == root.contents\n\n    def test_resolver_with_root_unidentified(self):\n        root = Resource.opaque(contents={})\n        resolver = Registry().resolver_with_root(root)\n        assert resolver.lookup(\"#\").contents == root.contents\n\n    def test_repr(self):\n        one = Resource.opaque(contents={})\n        two = ID_AND_CHILDREN.create_resource({\"foo\": \"bar\"})\n        registry = Registry().with_resources(\n            [\n                (\"http://example.com/1\", one),\n                (\"http://example.com/foo/bar\", two),\n            ],\n        )\n        assert repr(registry) == \"<Registry (2 uncrawled resources)>\"\n        assert repr(registry.crawl()) == \"<Registry (2 resources)>\"\n\n    def test_repr_mixed_crawled(self):\n        one = Resource.opaque(contents={})\n        two = ID_AND_CHILDREN.create_resource({\"foo\": \"bar\"})\n        registry = (\n            Registry(\n                {\"http://example.com/1\": one},\n            )\n            .crawl()\n            .with_resource(uri=\"http://example.com/foo/bar\", resource=two)\n        )\n        assert repr(registry) == \"<Registry (2 resources, 1 uncrawled)>\"\n\n    def test_repr_one_resource(self):\n        registry = Registry().with_resource(\n            uri=\"http://example.com/1\",\n            resource=Resource.opaque(contents={}),\n        )\n        assert repr(registry) == \"<Registry (1 uncrawled resource)>\"\n\n    def test_repr_empty(self):\n        assert repr(Registry()) == \"<Registry (0 resources)>\"\n\n\nclass TestResource:\n    def test_from_contents_from_json_schema(self):\n        schema = {\"$schema\": \"https://json-schema.org/draft/2020-12/schema\"}\n        resource = Resource.from_contents(schema)\n        assert resource == Resource(contents=schema, specification=DRAFT202012)\n\n    def test_from_contents_with_no_discernible_information(self):\n        \"\"\"\n        Creating a resource with no discernible way to see what\n        specification it belongs to (e.g. no ``$schema`` keyword for JSON\n        Schema) raises an error.\n        \"\"\"\n\n        with pytest.raises(exceptions.CannotDetermineSpecification):\n            Resource.from_contents({\"foo\": \"bar\"})\n\n    def test_from_contents_with_no_discernible_information_and_default(self):\n        resource = Resource.from_contents(\n            {\"foo\": \"bar\"},\n            default_specification=Specification.OPAQUE,\n        )\n        assert resource == Resource.opaque(contents={\"foo\": \"bar\"})\n\n    def test_from_contents_unneeded_default(self):\n        schema = {\"$schema\": \"https://json-schema.org/draft/2020-12/schema\"}\n        resource = Resource.from_contents(\n            schema,\n            default_specification=Specification.OPAQUE,\n        )\n        assert resource == Resource(\n            contents=schema,\n            specification=DRAFT202012,\n        )\n\n    def test_non_mapping_from_contents(self):\n        resource = Resource.from_contents(\n            True,\n            default_specification=ID_AND_CHILDREN,\n        )\n        assert resource == Resource(\n            contents=True,\n            specification=ID_AND_CHILDREN,\n        )\n\n    def test_from_contents_with_fallback(self):\n        resource = Resource.from_contents(\n            {\"foo\": \"bar\"},\n            default_specification=Specification.OPAQUE,\n        )\n        assert resource == Resource.opaque(contents={\"foo\": \"bar\"})\n\n    def test_id_delegates_to_specification(self):\n        specification = Specification(\n            name=\"\",\n            id_of=lambda contents: \"urn:fixedID\",\n            subresources_of=lambda contents: [],\n            anchors_in=lambda specification, contents: [],\n            maybe_in_subresource=(\n                lambda segments, resolver, subresource: resolver\n            ),\n        )\n        resource = Resource(\n            contents={\"foo\": \"baz\"},\n            specification=specification,\n        )\n        assert resource.id() == \"urn:fixedID\"\n\n    def test_id_strips_empty_fragment(self):\n        uri = \"http://example.com/\"\n        root = ID_AND_CHILDREN.create_resource({\"ID\": uri + \"#\"})\n        assert root.id() == uri\n\n    def test_subresources_delegates_to_specification(self):\n        resource = ID_AND_CHILDREN.create_resource({\"children\": [{}, 12]})\n        assert list(resource.subresources()) == [\n            ID_AND_CHILDREN.create_resource(each) for each in [{}, 12]\n        ]\n\n    def test_subresource_with_different_specification(self):\n        schema = {\"$schema\": \"https://json-schema.org/draft/2020-12/schema\"}\n        resource = ID_AND_CHILDREN.create_resource({\"children\": [schema]})\n        assert list(resource.subresources()) == [\n            DRAFT202012.create_resource(schema),\n        ]\n\n    def test_anchors_delegates_to_specification(self):\n        resource = ID_AND_CHILDREN.create_resource(\n            {\"anchors\": {\"foo\": {}, \"bar\": 1, \"baz\": \"\"}},\n        )\n        assert list(resource.anchors()) == [\n            Anchor(name=\"foo\", resource=ID_AND_CHILDREN.create_resource({})),\n            Anchor(name=\"bar\", resource=ID_AND_CHILDREN.create_resource(1)),\n            Anchor(name=\"baz\", resource=ID_AND_CHILDREN.create_resource(\"\")),\n        ]\n\n    def test_pointer_to_mapping(self):\n        resource = Resource.opaque(contents={\"foo\": \"baz\"})\n        resolver = Registry().resolver()\n        assert resource.pointer(\"/foo\", resolver=resolver).contents == \"baz\"\n\n    def test_pointer_to_array(self):\n        resource = Resource.opaque(contents={\"foo\": {\"bar\": [3]}})\n        resolver = Registry().resolver()\n        assert resource.pointer(\"/foo/bar/0\", resolver=resolver).contents == 3\n\n    def test_root_pointer(self):\n        contents = {\"foo\": \"baz\"}\n        resource = Resource.opaque(contents=contents)\n        resolver = Registry().resolver()\n        assert resource.pointer(\"\", resolver=resolver).contents == contents\n\n    def test_opaque(self):\n        contents = {\"foo\": \"bar\"}\n        assert Resource.opaque(contents) == Resource(\n            contents=contents,\n            specification=Specification.OPAQUE,\n        )\n\n\nclass TestResolver:\n    def test_lookup_exact_uri(self):\n        resource = Resource.opaque(contents={\"foo\": \"baz\"})\n        resolver = Registry({\"http://example.com/1\": resource}).resolver()\n        resolved = resolver.lookup(\"http://example.com/1\")\n        assert resolved.contents == resource.contents\n\n    def test_lookup_subresource(self):\n        root = ID_AND_CHILDREN.create_resource(\n            {\n                \"ID\": \"http://example.com/\",\n                \"children\": [\n                    {\"ID\": \"http://example.com/a\", \"foo\": 12},\n                ],\n            },\n        )\n        registry = root @ Registry()\n        resolved = registry.resolver().lookup(\"http://example.com/a\")\n        assert resolved.contents == {\"ID\": \"http://example.com/a\", \"foo\": 12}\n\n    def test_lookup_anchor_with_id(self):\n        root = ID_AND_CHILDREN.create_resource(\n            {\n                \"ID\": \"http://example.com/\",\n                \"anchors\": {\"foo\": 12},\n            },\n        )\n        registry = root @ Registry()\n        resolved = registry.resolver().lookup(\"http://example.com/#foo\")\n        assert resolved.contents == 12\n\n    def test_lookup_anchor_without_id(self):\n        root = ID_AND_CHILDREN.create_resource({\"anchors\": {\"foo\": 12}})\n        resolver = Registry().with_resource(\"urn:example\", root).resolver()\n        resolved = resolver.lookup(\"urn:example#foo\")\n        assert resolved.contents == 12\n\n    def test_lookup_unknown_reference(self):\n        resolver = Registry().resolver()\n        ref = \"http://example.com/does/not/exist\"\n        with pytest.raises(exceptions.Unresolvable) as e:\n            resolver.lookup(ref)\n        assert e.value == exceptions.Unresolvable(ref=ref)\n\n    def test_lookup_non_existent_pointer(self):\n        resource = Resource.opaque({\"foo\": {}})\n        resolver = Registry({\"http://example.com/1\": resource}).resolver()\n        ref = \"http://example.com/1#/foo/bar\"\n        with pytest.raises(exceptions.Unresolvable) as e:\n            resolver.lookup(ref)\n        assert e.value == exceptions.PointerToNowhere(\n            ref=\"/foo/bar\",\n            resource=resource,\n        )\n        assert str(e.value) == \"'/foo/bar' does not exist within {'foo': {}}\"\n\n    def test_lookup_non_existent_pointer_to_array_index(self):\n        resource = Resource.opaque([1, 2, 4, 8])\n        resolver = Registry({\"http://example.com/1\": resource}).resolver()\n        ref = \"http://example.com/1#/10\"\n        with pytest.raises(exceptions.Unresolvable) as e:\n            resolver.lookup(ref)\n        assert e.value == exceptions.PointerToNowhere(\n            ref=\"/10\",\n            resource=resource,\n        )\n\n    def test_lookup_pointer_to_empty_string(self):\n        resolver = Registry().resolver_with_root(Resource.opaque({\"\": {}}))\n        assert resolver.lookup(\"#/\").contents == {}\n\n    def test_lookup_non_existent_pointer_to_empty_string(self):\n        resource = Resource.opaque({\"foo\": {}})\n        resolver = Registry().resolver_with_root(resource)\n        with pytest.raises(\n            exceptions.Unresolvable,\n            match=\"^'/' does not exist within {'foo': {}}.*'#'\",\n        ) as e:\n            resolver.lookup(\"#/\")\n        assert e.value == exceptions.PointerToNowhere(\n            ref=\"/\",\n            resource=resource,\n        )\n\n    def test_lookup_non_existent_anchor(self):\n        root = ID_AND_CHILDREN.create_resource({\"anchors\": {}})\n        resolver = Registry().with_resource(\"urn:example\", root).resolver()\n        resolved = resolver.lookup(\"urn:example\")\n        assert resolved.contents == root.contents\n\n        ref = \"urn:example#noSuchAnchor\"\n        with pytest.raises(exceptions.Unresolvable) as e:\n            resolver.lookup(ref)\n        assert \"'noSuchAnchor' does not exist\" in str(e.value)\n        assert e.value == exceptions.NoSuchAnchor(\n            ref=\"urn:example\",\n            resource=root,\n            anchor=\"noSuchAnchor\",\n        )\n\n    def test_lookup_invalid_JSON_pointerish_anchor(self):\n        resolver = Registry().resolver_with_root(\n            ID_AND_CHILDREN.create_resource(\n                {\n                    \"ID\": \"http://example.com/\",\n                    \"foo\": {\"bar\": 12},\n                },\n            ),\n        )\n\n        valid = resolver.lookup(\"#/foo/bar\")\n        assert valid.contents == 12\n\n        with pytest.raises(exceptions.InvalidAnchor) as e:\n            resolver.lookup(\"#foo/bar\")\n        assert \" '#/foo/bar'\" in str(e.value)\n\n    def test_lookup_retrieved_resource(self):\n        resource = Resource.opaque(contents={\"foo\": \"baz\"})\n        resolver = Registry(retrieve=lambda uri: resource).resolver()\n        resolved = resolver.lookup(\"http://example.com/\")\n        assert resolved.contents == resource.contents\n\n    def test_lookup_failed_retrieved_resource(self):\n        \"\"\"\n        Unretrievable exceptions are also wrapped in Unresolvable.\n        \"\"\"\n\n        uri = \"http://example.com/\"\n\n        registry = Registry(retrieve=blow_up)\n        with pytest.raises(exceptions.Unretrievable):\n            registry.get_or_retrieve(uri)\n\n        resolver = registry.resolver()\n        with pytest.raises(exceptions.Unresolvable):\n            resolver.lookup(uri)\n\n    def test_repeated_lookup_from_retrieved_resource(self):\n        \"\"\"\n        A (custom-)retrieved resource is added to the registry returned by\n        looking it up.\n        \"\"\"\n        resource = Resource.opaque(contents={\"foo\": \"baz\"})\n        once = [resource]\n\n        def retrieve(uri):\n            return once.pop()\n\n        resolver = Registry(retrieve=retrieve).resolver()\n        resolved = resolver.lookup(\"http://example.com/\")\n        assert resolved.contents == resource.contents\n\n        resolved = resolved.resolver.lookup(\"http://example.com/\")\n        assert resolved.contents == resource.contents\n\n    def test_repeated_anchor_lookup_from_retrieved_resource(self):\n        resource = Resource.opaque(contents={\"foo\": \"baz\"})\n        once = [resource]\n\n        def retrieve(uri):\n            return once.pop()\n\n        resolver = Registry(retrieve=retrieve).resolver()\n        resolved = resolver.lookup(\"http://example.com/\")\n        assert resolved.contents == resource.contents\n\n        resolved = resolved.resolver.lookup(\"#\")\n        assert resolved.contents == resource.contents\n\n    # FIXME: The tests below aren't really representable in the current\n    #        suite, though we should probably think of ways to do so.\n\n    def test_in_subresource(self):\n        root = ID_AND_CHILDREN.create_resource(\n            {\n                \"ID\": \"http://example.com/\",\n                \"children\": [\n                    {\n                        \"ID\": \"child/\",\n                        \"children\": [{\"ID\": \"grandchild\"}],\n                    },\n                ],\n            },\n        )\n        registry = root @ Registry()\n\n        resolver = registry.resolver()\n        first = resolver.lookup(\"http://example.com/\")\n        assert first.contents == root.contents\n\n        with pytest.raises(exceptions.Unresolvable):\n            first.resolver.lookup(\"grandchild\")\n\n        sub = first.resolver.in_subresource(\n            ID_AND_CHILDREN.create_resource(first.contents[\"children\"][0]),\n        )\n        second = sub.lookup(\"grandchild\")\n        assert second.contents == {\"ID\": \"grandchild\"}\n\n    def test_in_pointer_subresource(self):\n        root = ID_AND_CHILDREN.create_resource(\n            {\n                \"ID\": \"http://example.com/\",\n                \"children\": [\n                    {\n                        \"ID\": \"child/\",\n                        \"children\": [{\"ID\": \"grandchild\"}],\n                    },\n                ],\n            },\n        )\n        registry = root @ Registry()\n\n        resolver = registry.resolver()\n        first = resolver.lookup(\"http://example.com/\")\n        assert first.contents == root.contents\n\n        with pytest.raises(exceptions.Unresolvable):\n            first.resolver.lookup(\"grandchild\")\n\n        second = first.resolver.lookup(\"#/children/0\")\n        third = second.resolver.lookup(\"grandchild\")\n        assert third.contents == {\"ID\": \"grandchild\"}\n\n    def test_dynamic_scope(self):\n        one = ID_AND_CHILDREN.create_resource(\n            {\n                \"ID\": \"http://example.com/\",\n                \"children\": [\n                    {\n                        \"ID\": \"child/\",\n                        \"children\": [{\"ID\": \"grandchild\"}],\n                    },\n                ],\n            },\n        )\n        two = ID_AND_CHILDREN.create_resource(\n            {\n                \"ID\": \"http://example.com/two\",\n                \"children\": [{\"ID\": \"two-child/\"}],\n            },\n        )\n        registry = [one, two] @ Registry()\n\n        resolver = registry.resolver()\n        first = resolver.lookup(\"http://example.com/\")\n        second = first.resolver.lookup(\"#/children/0\")\n        third = second.resolver.lookup(\"grandchild\")\n        fourth = third.resolver.lookup(\"http://example.com/two\")\n        assert list(fourth.resolver.dynamic_scope()) == [\n            (\"http://example.com/child/grandchild\", fourth.resolver._registry),\n            (\"http://example.com/child/\", fourth.resolver._registry),\n            (\"http://example.com/\", fourth.resolver._registry),\n        ]\n        assert list(third.resolver.dynamic_scope()) == [\n            (\"http://example.com/child/\", third.resolver._registry),\n            (\"http://example.com/\", third.resolver._registry),\n        ]\n        assert list(second.resolver.dynamic_scope()) == [\n            (\"http://example.com/\", second.resolver._registry),\n        ]\n        assert list(first.resolver.dynamic_scope()) == []\n\n\nclass TestSpecification:\n    def test_create_resource(self):\n        specification = Specification(\n            name=\"\",\n            id_of=lambda contents: \"urn:fixedID\",\n            subresources_of=lambda contents: [],\n            anchors_in=lambda specification, contents: [],\n            maybe_in_subresource=(\n                lambda segments, resolver, subresource: resolver\n            ),\n        )\n        resource = specification.create_resource(contents={\"foo\": \"baz\"})\n        assert resource == Resource(\n            contents={\"foo\": \"baz\"},\n            specification=specification,\n        )\n        assert resource.id() == \"urn:fixedID\"\n\n    def test_detect_from_json_schema(self):\n        schema = {\"$schema\": \"https://json-schema.org/draft/2020-12/schema\"}\n        specification = Specification.detect(schema)\n        assert specification == DRAFT202012\n\n    def test_detect_with_no_discernible_information(self):\n        with pytest.raises(exceptions.CannotDetermineSpecification):\n            Specification.detect({\"foo\": \"bar\"})\n\n    def test_detect_with_non_URI_schema(self):\n        with pytest.raises(exceptions.CannotDetermineSpecification):\n            Specification.detect({\"$schema\": 37})\n\n    def test_detect_with_no_discernible_information_and_default(self):\n        specification = Specification.OPAQUE.detect({\"foo\": \"bar\"})\n        assert specification is Specification.OPAQUE\n\n    def test_detect_unneeded_default(self):\n        schema = {\"$schema\": \"https://json-schema.org/draft/2020-12/schema\"}\n        specification = Specification.OPAQUE.detect(schema)\n        assert specification == DRAFT202012\n\n    def test_non_mapping_detect(self):\n        with pytest.raises(exceptions.CannotDetermineSpecification):\n            Specification.detect(True)\n\n    def test_non_mapping_detect_with_default(self):\n        specification = ID_AND_CHILDREN.detect(True)\n        assert specification is ID_AND_CHILDREN\n\n    def test_detect_with_fallback(self):\n        specification = Specification.OPAQUE.detect({\"foo\": \"bar\"})\n        assert specification is Specification.OPAQUE\n\n    def test_repr(self):\n        assert (\n            repr(ID_AND_CHILDREN) == \"<Specification name='id-and-children'>\"\n        )\n\n\nclass TestOpaqueSpecification:\n    THINGS = [{\"foo\": \"bar\"}, True, 37, \"foo\", object()]\n\n    @pytest.mark.parametrize(\"thing\", THINGS)\n    def test_no_id(self, thing):\n        \"\"\"\n        An arbitrary thing has no ID.\n        \"\"\"\n\n        assert Specification.OPAQUE.id_of(thing) is None\n\n    @pytest.mark.parametrize(\"thing\", THINGS)\n    def test_no_subresources(self, thing):\n        \"\"\"\n        An arbitrary thing has no subresources.\n        \"\"\"\n\n        assert list(Specification.OPAQUE.subresources_of(thing)) == []\n\n    @pytest.mark.parametrize(\"thing\", THINGS)\n    def test_no_anchors(self, thing):\n        \"\"\"\n        An arbitrary thing has no anchors.\n        \"\"\"\n\n        assert list(Specification.OPAQUE.anchors_in(thing)) == []\n\n\n@pytest.mark.parametrize(\n    \"cls\",\n    [Anchor, Registry, Resource, Specification, exceptions.PointerToNowhere],\n)\ndef test_nonsubclassable(cls):\n    with pytest.raises(Exception, match=\"(?i)subclassing\"):\n\n        class Boom(cls):  # pragma: no cover\n            pass\n", "referencing/tests/__init__.py": ""}