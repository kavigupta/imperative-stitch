import json
import neurosym as ns

from imperative_stitch.parser import ParsedAST
from imperative_stitch.compress.abstraction import Abstraction
from imperative_stitch.utils.def_use_mask import DefUseChainPreorderMask
from imperative_stitch.utils.export_as_dsl import DSLSubset, create_dsl
from imperative_stitch.utils.def_use_mask.ordering import PythonNodeOrdering

programs = [
    "(Module (/seq (FunctionDef &find_base:0 (arguments nil (list (arg &n:1 None None) (arg &s:1 None None)) None nil nil None nil) (/seq (If (Compare (Name &n:1 Load) (list Eq) (list (Name &s:1 Load))) (/seq (Return (BinOp (Name &n:1 Load) Add (Constant i1 None)))) (/seq)) (/splice (/choiceseq (For (Name &b:1 Store) (fn_1 (Constant i2 None) &n:1) (/seq (Assign (list (Name &m:1 Store)) (Name &n:1 Load) None) (/splice (fn_3 &sum_digits:1 &b:1 &m:1 (/choiceseq (If (Compare (Name &sum_digits:1 Load) (list Gt) (list (Name &s:1 Load))) (/seq Break) (/seq))))) (If (Compare (Name &sum_digits:1 Load) (list Eq) (list (Name &s:1 Load))) (/seq (Return (Name &b:1 Load))) (/seq))) (/seq) None) (For (Name &q:1 Store) (fn_1 (Constant i1 None) &n:1) (/seq (Assign (list (Name &b:1 Store)) (BinOp (BinOp (BinOp (Name &n:1 Load) Sub (Name &s:1 Load)) FloorDiv (Name &q:1 Load)) Add (Constant i1 None)) None) (If (Compare (BinOp (BinOp (Name &b:1 Load) Mult (Name &q:1 Load)) Add (Name &s:1 Load)) (list Eq) (list (Name &n:1 Load))) (/seq (Return (Name &b:1 Load))) (/seq))) (/seq) None))) (Return (UnaryOp USub (Constant i1 None)))) nil None None) (Assign (list (Tuple (list (_starred_content (Name &n:0 Store)) (_starred_content (Name &s:0 Store))) Store)) (Call (Name g_map Load) (list (_starred_content (Name g_int Load)) (_starred_content (Call (Attribute (Call (Name g_input Load) nil nil) s_split Load) nil nil))) nil) None) (Expr (Call (Name g_print Load) (list (_starred_content (Call (Name &find_base:0 Load) (list (_starred_content (Name &n:0 Load)) (_starred_content (Name &s:0 Load))) nil))) nil))) nil)",
    "(Module (/seq (FunctionDef &find_smallest_base:0 (arguments nil (list (arg &n:1 None None) (arg &s:1 None None)) None nil nil None nil) (/seq (If (Compare (Name &n:1 Load) (list Eq) (list (Name &s:1 Load))) (/seq (Return (BinOp (Name &n:1 Load) Add (Constant i1 None)))) (/seq)) (/splice (/choiceseq (For (Name &b:1 Store) (fn_1 (Constant i2 None) &n:1) (/seq (If (Compare (Name &n:1 Load) (list Lt) (list (Name &b:1 Load))) (/seq Break) (/seq)) (Assign (list (Name &temp_n:1 Store)) (Name &n:1 Load) None) (/splice (fn_3 &sum_digits:1 &b:1 &temp_n:1 (/choiceseq))) (If (Compare (Name &sum_digits:1 Load) (list Eq) (list (Name &s:1 Load))) (/seq (Return (Name &b:1 Load))) (/seq))) (/seq) None) (For (Name &d:1 Store) (fn_1 (Constant i1 None) &n:1) (/seq (If (Compare (BinOp (BinOp (Name &n:1 Load) Sub (Name &s:1 Load)) Mod (Name &d:1 Load)) (list Eq) (list (Constant i0 None))) (/seq (Assign (list (Name &b:1 Store)) (BinOp (BinOp (BinOp (Name &n:1 Load) Sub (Name &s:1 Load)) FloorDiv (Name &d:1 Load)) Add (Constant i1 None)) None) (If (BoolOp And (list (Compare (BinOp (BinOp (Name &n:1 Load) Sub (Name &s:1 Load)) FloorDiv (Name &b:1 Load)) (list Eq) (list (Name &d:1 Load))) (Compare (BinOp (Name &n:1 Load) Mod (Name &b:1 Load)) (list Eq) (list (Name &s:1 Load))))) (/seq (Return (Name &b:1 Load))) (/seq))) (/seq))) (/seq) None))) (Return (UnaryOp USub (Constant i1 None)))) nil None None) (Assign (list (Tuple (list (_starred_content (Name &n:0 Store)) (_starred_content (Name &s:0 Store))) Store)) (Call (Name g_map Load) (list (_starred_content (Name g_int Load)) (_starred_content (Call (Attribute (Call (Name g_input Load) nil nil) s_split Load) nil nil))) nil) None) (Expr (Call (Name g_print Load) (list (_starred_content (Call (Name &find_smallest_base:0 Load) (list (_starred_content (Name &n:0 Load)) (_starred_content (Name &s:0 Load))) nil))) nil))) nil)",
    "(Module (/seq (FunctionDef &find_smallest_base:0 (arguments nil (list (arg &n:1 None None) (arg &s:1 None None)) None nil nil None nil) (/seq (If (Compare (Name &n:1 Load) (list Eq) (list (Name &s:1 Load))) (/seq (Return (BinOp (Name &n:1 Load) Add (Constant i1 None)))) (/seq)) (For (Name &b:1 Store) (Call (Name g_range Load) (list (_starred_content (Constant i2 None)) (_starred_content (BinOp (Call (Name g_int Load) (list (_starred_content (BinOp (Name &n:1 Load) Pow (Constant f0.5 None)))) nil) Add (Constant i1 None)))) nil) (/seq (If (Compare (Call (Name &sum_digits:0 Load) (list (_starred_content (Name &n:1 Load)) (_starred_content (Name &b:1 Load))) nil) (list Eq) (list (Name &s:1 Load))) (/seq (Return (Name &b:1 Load))) (/seq))) (/seq) None) (Assign (list (Name &diff:1 Store)) (BinOp (Name &n:1 Load) Sub (Name &s:1 Load)) None) (Assign (list (Name &ans:1 Store)) (Call (Name g_float Load) (list (_starred_content (Constant s_inf None))) nil) None) (For (Name &i:1 Store) (Call (Name g_range Load) (list (_starred_content (Constant i1 None)) (_starred_content (BinOp (Call (Name g_int Load) (list (_starred_content (BinOp (Name &diff:1 Load) Pow (Constant f0.5 None)))) nil) Add (Constant i1 None)))) nil) (/seq (If (Compare (BinOp (Name &diff:1 Load) Mod (Name &i:1 Load)) (list Eq) (list (Constant i0 None))) (/seq (If (BoolOp And (list (Compare (Name &i:1 Load) (list Gt) (list (Constant i1 None))) (Compare (Call (Name &sum_digits:0 Load) (list (_starred_content (Name &n:1 Load)) (_starred_content (Name &i:1 Load))) nil) (list Eq) (list (Name &s:1 Load))))) (/seq (Return (Name &i:1 Load))) (/seq)) (If (BoolOp And (list (Compare (BinOp (Name &diff:1 Load) FloorDiv (Name &i:1 Load)) (list Gt) (list (Constant i1 None))) (Compare (Call (Name &sum_digits:0 Load) (list (_starred_content (Name &n:1 Load)) (_starred_content (BinOp (Name &diff:1 Load) FloorDiv (Name &i:1 Load)))) nil) (list Eq) (list (Name &s:1 Load))))) (/seq (Assign (list (Name &ans:1 Store)) (Call (Name g_min Load) (list (_starred_content (Name &ans:1 Load)) (_starred_content (BinOp (Name &diff:1 Load) FloorDiv (Name &i:1 Load)))) nil) None)) (/seq))) (/seq))) (/seq) None) (Return (IfExp (Compare (Name &ans:1 Load) (list NotEq) (list (Call (Name g_float Load) (list (_starred_content (Constant s_inf None))) nil))) (Name &ans:1 Load) (UnaryOp USub (Constant i1 None))))) nil None None) (FunctionDef &sum_digits:0 (arguments nil (list (arg &n:2 None None) (arg &b:2 None None)) None nil nil None nil) (/seq (/splice (/subseq (Assign (list (Name &total:2 Store)) (Constant i0 None) None) (While (Name &n:2 Load) (/seq (AugAssign (Name &total:2 Store) Add (BinOp (Name &n:2 Load) Mod (Name &b:2 Load))) (AugAssign (Name &n:2 Store) FloorDiv (Name &b:2 Load)) (/splice (/choiceseq))) (/seq)))) (Return (Name &total:2 Load))) nil None None) (Assign (list (Tuple (list (_starred_content (Name &n:0 Store)) (_starred_content (Name &s:0 Store))) Store)) (Call (Name g_map Load) (list (_starred_content (Name g_int Load)) (_starred_content (Call (Attribute (Call (Name g_input Load) nil nil) s_split Load) nil nil))) nil) None) (Expr (Call (Name g_print Load) (list (_starred_content (Call (Name &find_smallest_base:0 Load) (list (_starred_content (Name &n:0 Load)) (_starred_content (Name &s:0 Load))) nil))) nil))) nil)",
]

dfa = {
    "M": {"Module": ["seqS", "[TI]"]},
    "S": {
        "AnnAssign": ["L", "TA", "E", "bool"],
        "Assert": ["E", "E"],
        "Assign": ["[L]", "E", "TC"],
        "AsyncFor": ["L", "E", "seqS", "seqS", "TC"],
        "AsyncFunctionDef": ["Name", "As", "seqS", "[E]", "TA", "TC"],
        "AsyncWith": ["[W]", "seqS", "TC"],
        "AugAssign": ["L", "O", "E"],
        "ClassDef": ["Name", "[E]", "[K]", "seqS", "[E]"],
        "Delete": ["[L]"],
        "Expr": ["E"],
        "For": ["L", "E", "seqS", "seqS", "TC"],
        "FunctionDef": ["Name", "As", "seqS", "[E]", "TA", "TC"],
        "Global": ["[NameStr]"],
        "If": ["E", "seqS", "seqS"],
        "Import": ["[alias]"],
        "ImportFrom": ["NullableNameStr", "[alias]", "int"],
        "Nonlocal": ["[NameStr]"],
        "Raise": ["E", "E"],
        "Return": ["E"],
        "Try": ["seqS", "[EH]", "seqS", "seqS"],
        "While": ["E", "seqS", "seqS"],
        "With": ["[W]", "seqS", "TC"],
        "/splice": ["seqS"],
    },
    "E": {
        "Attribute": ["E", "NameStr", "Ctx"],
        "Await": ["E"],
        "BinOp": ["E", "O", "E"],
        "BoolOp": ["O", "[E]"],
        "Call": ["E", "[StarredRoot]", "[K]"],
        "Compare": ["E", "[O]", "[E]"],
        "Constant": ["Const", "ConstKind"],
        "Dict": ["[E]", "[E]"],
        "DictComp": ["E", "E", "[C]"],
        "GeneratorExp": ["E", "[C]"],
        "IfExp": ["E", "E", "E"],
        "JoinedStr": ["[F]"],
        "Lambda": ["As", "E"],
        "List": ["[StarredRoot]", "Ctx"],
        "ListComp": ["E", "[C]"],
        "Name": ["Name", "Ctx"],
        "NamedExpr": ["L", "E"],
        "Set": ["[StarredRoot]"],
        "SetComp": ["E", "[C]"],
        "Starred": ["E", "Ctx"],
        "Subscript": ["E", "SliceRoot", "Ctx"],
        "Tuple": ["[StarredRoot]", "Ctx"],
        "UnaryOp": ["O", "E"],
        "Yield": ["E"],
        "YieldFrom": ["E"],
        "fn_1": ["E", "Name"],
    },
    "SliceRoot": {
        "_slice_content": ["E"],
        "_slice_slice": ["Slice"],
        "_slice_tuple": ["SliceTuple"],
    },
    "SliceTuple": {"Tuple": ["[SliceRoot]", "Ctx"]},
    "[SliceRoot]": {"list": ["SliceRoot"]},
    "StarredRoot": {"_starred_content": ["E"], "_starred_starred": ["Starred"]},
    "Starred": {"Starred": ["E", "Ctx"]},
    "Slice": {"Slice": ["E", "E", "E"]},
    "As": {"arguments": ["[A]", "[A]", "A", "[A]", "[E]", "A", "[E]"]},
    "A": {"arg": ["Name", "TA", "TC"]},
    "F": {
        "Constant": ["F", "F"],
        "FormattedValue": ["E", "int", "F"],
        "JoinedStr": ["[F]"],
    },
    "C": {"comprehension": ["L", "E", "[E]", "bool"]},
    "K": {"keyword": ["NullableNameStr", "E"]},
    "EH": {"ExceptHandler": ["E", "NullableName", "seqS"]},
    "W": {"withitem": ["E", "L"]},
    "L": {
        "Attribute": ["E", "NameStr", "Ctx"],
        "List": ["[L]", "Ctx"],
        "Name": ["Name", "Ctx"],
        "Starred": ["L", "Ctx"],
        "Subscript": ["E", "SliceRoot", "Ctx"],
        "Tuple": ["[L]", "Ctx"],
        "_starred_content": ["L"],
        "_starred_starred": ["L"],
    },
    "seqS": {
        "/seq": ["S"],
        "/subseq": ["S"],
        "/choiceseq": ["S"],
        "fn_2": ["Name", "Name", "Name", "Name", "Name", "seqS"],
        "fn_3": ["Name", "Name", "Name", "seqS"],
    },
    "[E]": {"list": ["E"]},
    "[StarredRoot]": {"list": ["StarredRoot"]},
    "alias": {"alias": ["NameStr", "NullableNameStr"]},
    "[NameStr]": {"list": ["NameStr"]},
    "TA": {
        "AST": [],
        "Add": [],
        "And": [],
        "AnnAssign": ["TA", "TA", "TA", "TA"],
        "Assert": ["TA", "TA"],
        "Assign": ["TA", "TA", "TA"],
        "AsyncFor": ["TA", "TA", "TA", "TA", "TA"],
        "AsyncFunctionDef": ["TA", "TA", "TA", "TA", "TA", "TA"],
        "AsyncWith": ["TA", "TA", "TA"],
        "Attribute": ["TA", "TA", "TA"],
        "AugAssign": ["TA", "TA", "TA"],
        "AugLoad": [],
        "AugStore": [],
        "Await": ["TA"],
        "BinOp": ["TA", "TA", "TA"],
        "BitAnd": [],
        "BitOr": [],
        "BitXor": [],
        "BoolOp": ["TA", "TA"],
        "Break": [],
        "Bytes": ["TA"],
        "Call": ["TA", "TA", "TA"],
        "ClassDef": ["TA", "TA", "TA", "TA", "TA"],
        "Compare": ["TA", "TA", "TA"],
        "Constant": ["TA", "TA"],
        "Continue": [],
        "Del": [],
        "Delete": ["TA"],
        "Dict": ["TA", "TA"],
        "DictComp": ["TA", "TA", "TA"],
        "Div": [],
        "Ellipsis": [],
        "Eq": [],
        "ExceptHandler": ["TA", "TA", "TA"],
        "Expr": ["TA"],
        "Expression": ["TA"],
        "ExtSlice": [],
        "FloorDiv": [],
        "For": ["TA", "TA", "TA", "TA", "TA"],
        "FormattedValue": ["TA", "TA", "TA"],
        "FunctionDef": ["TA", "TA", "TA", "TA", "TA", "TA"],
        "FunctionType": ["TA", "TA"],
        "GeneratorExp": ["TA", "TA"],
        "Global": ["TA"],
        "Gt": [],
        "GtE": [],
        "If": ["TA", "TA", "TA"],
        "IfExp": ["TA", "TA", "TA"],
        "Import": ["TA"],
        "ImportFrom": ["TA", "TA", "TA"],
        "In": [],
        "Index": [],
        "Interactive": ["TA"],
        "Invert": [],
        "Is": [],
        "IsNot": [],
        "JoinedStr": ["TA"],
        "LShift": [],
        "Lambda": ["TA", "TA"],
        "List": ["TA", "TA"],
        "ListComp": ["TA", "TA"],
        "Load": [],
        "Lt": [],
        "LtE": [],
        "MatMult": [],
        "Mod": [],
        "Module": ["TA", "TA"],
        "Mult": [],
        "Name": ["TA", "TA"],
        "NameConstant": ["TA", "TA"],
        "NamedExpr": ["TA", "TA"],
        "Nonlocal": ["TA"],
        "Not": [],
        "NotEq": [],
        "NotIn": [],
        "Num": ["TA"],
        "Or": [],
        "Param": [],
        "Pass": [],
        "Pow": [],
        "RShift": [],
        "Raise": ["TA", "TA"],
        "Return": ["TA"],
        "Set": ["TA"],
        "SetComp": ["TA", "TA"],
        "Slice": ["TA", "TA", "TA"],
        "Starred": ["TA", "TA"],
        "Store": [],
        "Str": ["TA"],
        "Sub": [],
        "Subscript": ["TA", "TA", "TA"],
        "Suite": [],
        "Try": ["TA", "TA", "TA", "TA"],
        "Tuple": ["TA", "TA"],
        "TypeIgnore": ["TA", "TA"],
        "UAdd": [],
        "USub": [],
        "UnaryOp": ["TA", "TA"],
        "While": ["TA", "TA", "TA"],
        "With": ["TA", "TA", "TA"],
        "Yield": ["TA"],
        "YieldFrom": ["TA"],
        "alias": ["TA", "TA"],
        "arg": ["TA", "TA", "TA"],
        "arguments": ["TA", "TA", "TA", "TA", "TA", "TA", "TA"],
        "boolop": [],
        "cmpop": [],
        "comprehension": ["TA", "TA", "TA", "TA"],
        "excepthandler": [],
        "expr": [],
        "expr_context": [],
        "keyword": ["TA", "TA"],
        "mod": [],
        "operator": [],
        "slice": [],
        "stmt": [],
        "type_ignore": [],
        "unaryop": [],
        "withitem": ["TA", "TA"],
        "_slice_content": ["TA"],
        "_slice_slice": ["TA"],
        "_slice_tuple": ["TA"],
        "_starred_content": ["TA"],
        "_starred_starred": ["TA"],
        "list": ["TA"],
    },
    "[F]": {"list": ["F"]},
    "[A]": {"list": ["A"]},
    "[C]": {"list": ["C"]},
    "[EH]": {"list": ["EH"]},
    "[K]": {"list": ["K"]},
    "[L]": {"list": ["L"]},
    "[O]": {"list": ["O"]},
    "[W]": {"list": ["W"]},
    "[alias]": {"list": ["alias"]},
    "[TI]": {"list": ["TI"]},
}


absts = json.load(open("tmp-abstractions-test-file.json"))
absts = [Abstraction.of(**entry) for entry in absts]

parsed_asts = [ParsedAST.parse_s_expression(p) for p in programs]
programs_to_count = [
    p.to_type_annotated_de_bruijn_ns_s_exp(
        dfa,
        "M",
        de_bruijn_limit=2,
        abstrs=absts,
    )
    for p in parsed_asts
]

dsl = create_dsl(
    dfa,
    DSLSubset.from_program(
        dfa,
        *parsed_asts,
        root="M",
        abstrs=absts,
        to_s_exp=lambda p, dfa, root: p.to_type_annotated_de_bruijn_ns_s_exp(
            dfa,
            root,
            de_bruijn_limit=2,
            abstrs=absts,
        ),
    ),
    "M",
)

fam = ns.BigramProgramDistributionFamily(
    dsl,
    additional_preorder_masks=[
        lambda dist, dsl: DefUseChainPreorderMask(dist, dsl, dfa=dfa, abstrs=absts)
    ],
    include_type_preorder_mask=True,
    node_ordering=lambda dist: PythonNodeOrdering(dist, absts),
)

counts = fam.count_programs([programs_to_count])
print(counts)
